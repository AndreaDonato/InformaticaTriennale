{
	"nodes":[
		{"id":"99a579f63e8ed830","type":"text","text":"# Automa Deterministico a Stati Finiti (DFA)\n\nUn automa deterministico a stati finiti è una quintupla $(Q,\\Sigma,\\delta,q_0,F)$ dove\n\n- $Q$ è l'insieme finito degli ***stati***, ognuno dei quali ha esattamente un arco uscente per ogni simbolo di $\\Sigma$;\n- $\\Sigma$ è l'***alfabeto*** compreso dall'automa;\n- $\\delta:Q\\times \\Sigma\\to Q$ è la ***funzione di transizione degli stati***, in pratica una matrice che associa ogni riga (simbolo dell'alfabeto) ad ogni colonna (stato di partenza), i cui elementi sono gli stati di arrivo.\n\t- Rappresenta la risposta dell'automa che si trova in un determinato stato ad un simbolo in input.\n- $q_0\\in Q$ è lo ***stato iniziale***;\n- $F\\subseteq Q$ è l'insieme degli ***stati accettanti***, ovvero stati in cui l'automa accetta di terminare l'esecuzione.\n\nPosso però dare all'automa una sequenza di simboli di input, ovvero una stringa. In tal caso posso definire ricorsivamente una ***funzione di transizione estesa*** tale che$$\\begin{cases}\n\\delta^*(q,\\varepsilon) = \\delta(q, \\varepsilon) = q\\\\\n\\delta^*(q, aw) = \\delta^*(\\delta(q, a), w) \\quad\\text{dove }a\\in\\Sigma,w\\in\\Sigma^*\n\\end{cases}$$In pratica significa che $\\delta^*$ restituisce lo stato finale a seguito di un input in formato stringa. In generale, ad ogni istante l'automa si trova in una specifica ***configurazione***, identificata dalla coppia $(q,w)$ formata dallo ***stato attuale*** $q$ e dalla ***stringa*** $w$ che deve ancora ***interpretare*** a partire da quello stato.\n\nOgni esecuzione di un singolo simbolo fa effettuare all'automa un singolo ***passo di computazione***. Dato un simbolo $a$ e due stati $p,q\\in Q$, dire che $\\delta(p,a)=q$ è equivalente a dire che $(p, aw) ⊢ (q, w)$. Questo concetto è generalizzabile ad una sequenza di passi. Sono equivalenti le scrittura $\\delta^*(q_i,w)=q_f$ e $q_i,w) ⊢^*(q_f,\\varepsilon)$.\n\nL'automa è detto ***deterministico*** se ad ogni passo di computazione segue una ed un'unica configurazione.\n\nLa stringa $w$ è ***accettata*** $A=(Q,\\Sigma,\\delta,q_0,F)$ se $\\delta^*(q_0, w)\\in F(A)$, ovvero se l'***interpretazione*** di tale stringa fa terminare l'automa su uno stato accettante. Di conseguenza definiamo il ***linguaggio*** di $A$ l'insieme di tutte le stringhe accettate da A o, in modo analogo, diciamo che ***$A$ riconosce $L(A)$***.","x":-360,"y":700,"width":880,"height":747,"color":"4"},
		{"id":"e865a825bb442798","type":"text","text":"# Automa Non-Deterministico a Stati Finiti (NFA)\n\nSe ***la funzione di transizione degli stati non è univoca*** (i.e. alla configurazione $(q,a)$ possono seguire diverse configurazioni), allora l'automa è non-deterministico. Formalmente,$$\\delta: Q\\times\\Sigma_\\varepsilon \\to \\mathcal{P}(Q)$$dove $\\Sigma_\\varepsilon$ è l'***alfabeto epsilon*** associato a $\\Sigma$ (banalmente, $\\Sigma \\cup \\{\\varepsilon\\}$) e $\\mathcal{P}$ rappresenta tutti i possibili sottoinsiemi di $Q$ (***insieme potenza***), intendendo che ogni input può produrre in output un qualsiasi sottoinsieme di stati.\n\nContemporaneamente? Beh no, però a livello teorico posso costruire un albero. L'automa ***si sdoppia***\n\n- ogni volta che c'è ***ambiguità di simbolo*** (e.g. partendo da $q_1$, $1$ porta sia allo stato $q_1$ che allo stato $q_2$);\n- ogni volta che esiste un ***$\\varepsilon$-arco in uscita***: un ramo considera l'attesa del simbolo successivo come \"non fare niente\" (e dunque interpreta $\\varepsilon$, spostandosi lungo l'arco) mentre l'altro resta nello stato corrente.\n\nOgni volta che arrivo in uno stato in cui il simbolo da interpretare non compare su un arco in uscita, ***la computazione termina*** (ogni stato può avere un qualsiasi numero di archi uscenti per ogni simbolo di $\\Sigma$). L'unico stato finale consentito è uno stato accettante in cui non restano ulteriori simboli da interpretare. Se ***almeno un ramo termina su uno stato accettante***, l'NFA ***accetta*** la stringa.","x":680,"y":700,"width":920,"height":491,"color":"4"},
		{"id":"963502012eaccd57","type":"file","file":"Linguaggi Regolari/NonDeterministic.png","x":1708,"y":700,"width":400,"height":108},
		{"id":"9ce2f5e78688648f","type":"file","file":"Linguaggi Regolari/NonDeterministicTree.png","x":1708,"y":934,"width":400,"height":459},
		{"id":"d570218de39c6a66","type":"file","file":"Linguaggi Regolari/Esempi/M3.png","x":-1908,"y":595,"width":400,"height":245},
		{"id":"cb4951b922ab48e7","type":"text","text":"$A = \\{w|w$ la somma dei numeri della stringa è multiplo di 3$\\}$\n\n- $q_0$ è lo stato \"finora la somma modulo $3$ fa $0$ o c'è stato un `RESET`\"\n- $q_1$ è lo stato \"finora la somma modulo $3$ fa $1$\"\n- $q_0$ è lo stato \"finora la somma modulo $3$ fa $2$\"","x":-2008,"y":917,"width":600,"height":146,"color":"4"},
		{"id":"4026031a39513573","type":"file","file":"Linguaggi Regolari/Esempi/M1.png","x":-1908,"y":-346,"width":400,"height":132},
		{"id":"09eeba7d186cc631","type":"text","text":"$A = \\{w|w$ Contiene almeno un $1$ e un numero pari di $0$ segue l'ultimo $1\\}$.\n\n- $q_1$ è lo stato \"non ho ancora letto alcun $1$\";\n- $q_2$ è lo stato che definisce l'alfabeto;\n- $q_3$ è lo stato \"dopo l'ultimo $1$ c'è un numero dispari di $0$\"","x":-2008,"y":-154,"width":600,"height":146,"color":"4"},
		{"id":"202120fe71270d90","type":"file","file":"Linguaggi Regolari/Esempi/M2.png","x":-1909,"y":98,"width":400,"height":263},
		{"id":"9c7bf0e17764ae61","type":"text","text":"$A = \\{w|w$ inizia e finisce con lo stesso simbolo$\\}$\n\n- $q_1$ è lo stato \"la stringa inizia e finisce per $a$\" (analogo $r_1$ con $b$);\n- $q_2$ è lo stato \"la stringa inizia per $a$ ma finisce per $b$\" (analogo $r_2$).","x":-2008,"y":407,"width":600,"height":114,"color":"4"},
		{"id":"a95021f577a47f4e","type":"text","text":"# Progettare Automi\n\nGli automi non hanno memoria e non sanno quanti simboli mancano per finire la stringa. Pertanto, ad ogni simbolo letto devono essere in grado di decidere se la stringa letta ***finora*** fa parte del linguaggio.\n\nLe etichette degli stati sono fondamentali per capire cosa succede.","x":-2860,"y":129,"width":580,"height":201,"color":"4"},
		{"id":"3ce00288d2634111","type":"text","text":"# Esempio di rappresentazione formale\n\nUn automa che accetta stringhe i cui numeri sommati sono multiplo di $i$ non è rappresentabile graficamente, ma posso dire che\n\n- $\\delta_i(q_j,0) = q_j$\n- $\\delta_i(q_j,k) = q_n$, dove $n = (j+k)\\%\\,i$\n- $\\delta_i(q_j,\\langle RESET\\rangle) = q_0$\n- $q_0$ è sia lo stato iniziale che l'unico stato accettante.","x":-1182,"y":575,"width":693,"height":285,"color":"4"},
		{"id":"0d399f2af310e7d9","type":"text","text":"# Equivalenza tra NFA e DFA: Linguaggi Regolari\n\nLa classe dei linguaggi di $\\Sigma$ riconosciuti da un DFA $\\mathcal{L}(DFA)$ e quella dei linguaggi di $\\Sigma$ riconosciuti da un NFA $\\mathcal{L}(NFA)$ coincidono, e sono detti ***linguaggi regolari*** (linguaggio è regolare $\\Leftrightarrow \\exists$ NFA che lo riconosce).\n\nCome conseguenza, dato un NFA è sempre possibile costruire un DFA ad esso equivalente (il contrario è ovvio, perché il DFA è un sotto-caso dell'NFA). Come?\n\n- Identifica tutti i possibili sottoinsiemi di $Q$ (e.g. se $Q=\\{q_1,q_2,q_3\\}$ allora avrò $\\{\\emptyset, q_1, q_2, q_3, q_{12}, q_{13}, q_{23}, q_{123}\\}$). Questi saranno tutti e soli gli stati del DFA equivalente;\n- Definiamo l'***estensione*** di $R\\in Q$ come $E(R)$, intendendo gli stati di $R$ più tutti gli stati raggiungibili da $R$ tramite soli $\\varepsilon$-archi. Lo stato iniziale del DFA è l'estensione dello stato iniziale dell'NFA (e.g. $q_1\\to q_{13}$);\n- Gli stati accettanti sono tutti quelli che hanno almeno uno stato accettante dell'NFA di partenza. In questo caso, $\\{q_1, q_{12}, q_{13}, q_{23}, q_{123}\\}$;\n- A questo punto devo farmi tutte le transizioni per ogni stato e vedere per ognuna l'insieme di stati a cui porta. Con tanto lavoro e tanta fantasia ottengo una roba tipo l'esempio sotto.\n\nDetto questo, i linguaggi regolari godono della proprietà di ***chiusura*** rispetto a tutti gli operatori definiti in precedenza (***concatenazione***, ***complemento***, ***unione***, ***intersezione***, ***potenza***, ***star*** e ***plus***), i.e. se tali operatori prendono in input linguaggi regolari, l'output sarà ancora un linguaggio regolare.","x":680,"y":1260,"width":920,"height":584,"color":"4"},
		{"id":"816848e0c2ad721f","type":"text","text":"# Perché gli NFA?\n\n- Spesso costruire e capire un NFA è più semplice rispetto al suo DFA equivalente;\n\t- Sicuramente in generale un NFA è più piccolo del suo DFA equivalente.\n- Il paradigma di calcolo parallelo si presta a due parallelismi (pun intended):\n\t- Programmazione multi-thread;\n\t- Computazione quantistica.\n- ...","x":700,"y":303,"width":880,"height":272,"color":"3"},
		{"id":"73b289d2ddac85e0","type":"file","file":"Linguaggi Regolari/Esempi/M4-DFA.png","x":1181,"y":-73,"width":399,"height":193},
		{"id":"2154feb042ce2858","type":"text","text":"# Un semplice NFA\n\nCostruire un automa che riconosce le stringhe aventi un $1$ in terzultima posizione è un compito semplice con un NFA. È sufficiente tenere ***traccia dell'$1$ su un singolo ramo*** di computazione che ipotizza di essere a tre step dalla fine (se non lo è, lo stato $q_4$ muore perché non ha archi in uscita).\n\nSi noti che\n\n- con un DFA dovrei considerare tutte le possibili situazioni;\n- con piccole variazioni sull'NFA posso costruire un automa che accetta le stringhe aventi un $1$ in una delle ultime tre posizioni (i.e. aggiungendo $\\varepsilon$ nelle transizioni $q_2\\to q_3$ e $q_3\\to q_4$)","x":700,"y":-380,"width":420,"height":500,"color":"4"},
		{"id":"8bb56d96ae177393","type":"text","text":"# Computazione\n\nEseguire una computazione significa interpretare una sequenza di simboli $\\{w_i\\}$ percorrendo una sequenza di stati $\\{r_i\\}$ tali che\n\n- $r_0 = q_0$, cioè si parte dallo stato iniziale;\n- $r_n = q_F\\in F$, cioè si arriva in uno stato accettante;\n- $\\delta(r_i, w_{i}) = r_{i+1}$, ovvero in un ***DFA*** si passa da un elemento della sequenza al successivo tramite la funzione di transizione degli stati.\n\t- In un ***NFA*** questa definizione va generalizzata: $r_{i+1}\\in\\delta(r_i,w_i)$.","x":-1182,"y":925,"width":693,"height":297,"color":"4"},
		{"id":"1362d388c8714d48","type":"text","text":"# Dimostrare le Chiusure\n\n- ***Unione*** - Date $N_1$ ed $N_2$, basta creare un nuovo stato iniziale che si collega tramite $\\varepsilon$-archi agli stati iniziali delle macchine originali.\n\t- Per l'***intersezione*** non si possono usare gli NFA, bisogna costruire la prova tramite DFA.\n- ***Concatenazione*** - Collego tutti gli stati accettanti di $N_1$ allo stato iniziale di $N_2$ tramite $\\varepsilon$-archi.\n\t- Da questo segue la dimostrazione per la ***potenza***, in quanto sequenza di concatenazioni.\n- ***Star*** - Creo un nuovo stato iniziale che punta con un $\\varepsilon$-arco al vecchio stato iniziale, poi faccio puntare tutti gli stati accettanti al vecchio stato iniziale.\n\t- Questo dimostra anche il ***Plus***, perché $L^+ = L\\,L^*$, che è una concatenazione.","x":-360,"y":1535,"width":880,"height":309,"color":"4"},
		{"id":"4b19755e121bf99d","type":"file","file":"Linguaggi Regolari/RegEx.png","x":1708,"y":2285,"width":400,"height":326},
		{"id":"5bd9813160538beb","type":"text","text":"# Linguaggi ed Espressioni Regolari\n\nI linguaggi regolari sono rappresentabili tramite le ***espressioni regolari*** (***RegEx***, $re(\\Sigma)$). $R$ è una RegEx se è\n\n- $a$, per qualche $a\\in \\Sigma$ (cioè se è costituita da simboli dell'alfabeto);\n- $\\varepsilon$ (la stringa vuota è una RegEx);\n- $\\emptyset$ (l'insieme vuoto è una RegEx);\n- Unione, concatenazione o star di RegEx.\n\n`THM` - **Un linguaggio è regolare se e solo se esiste una RegEx che lo descrive**. Questo si dimostra nei due versi:\n\n- Se $\\mathcal{L}$ è descritto da una RegEx $R$, allora è regolare. Devo costruire un NFA che riconosce $\\mathcal{L}$ a partire da $R$. Posso farlo per ognuno dei punti che definiscono una RegEx.\n\t- $a$ - Un NFA $\\{\\{q_1,q_2\\}, \\Sigma, \\delta, q_1, \\{q_2\\}\\}$ che parte da $q_1$ e che va in $q_2$ accettante tramite $a$ riconosce $\\mathcal{L}(R) = \\{a\\}$\n\t- $\\varepsilon$ - Un NFA $\\{\\{q_1\\}, \\Sigma, \\delta, q_1, \\{q_1\\}\\}$ che parte da uno stato accettante riconosce $\\mathcal{L}(R) = \\{\\varepsilon\\}$;\n\t- $\\emptyset$ - Un NFA $\\{\\{q_1\\}, \\Sigma, \\delta, q_1, \\emptyset\\}$ privo di stati accettanti riconosce $\\mathcal{L}(R) = \\emptyset$;\n\t- Per unione, concatenazione e star: i linguaggi regolari sono chiusi rispetto alle operazioni regolari.\n- Se $\\mathcal{L}$ è regolare, allora esiste una RegEx che lo descrive. O, equivalentemente, devo dimostrare di poter trasformare un generico automa in una RegEx. Questo si può fare con i GNFA, secondo lo schema seguente:\n\t- Posso sempre trasformare un DFA in un GNFA aggiungendo un nuovo stato iniziale che punta con un $\\varepsilon$-arco al vecchio stato iniziale, e in modo analogo un nuovo stato accettante puntato dai vecchi stati accettanti. Inoltre se, ad esempio, tra i nodi $q_i$ e $q_j$ vi sono due archi che vanno nella stessa direzione e con etichette rispettivamente $a$ e $b$, li sostituisco con un unico arco avente etichetta $a\\cup b$;\n\t- Non è restrittivo dimostrare che posso trasformare un GNFA in una RegEx. Come? Riducendo il numero di nodi fino ad ottenerne esattamente due. Posso sempre farlo? Sì, togliendo un nodo alla volta e modificando l'automa in modo che accetti sempre lo stesso linguaggio;\n\t- L'etichetta dell'unico arco che va da $q_i$ a $q_f$ quando il GNFA è ridotto a due nodi è la RegEx cercata.","x":680,"y":1960,"width":920,"height":733,"color":"4"},
		{"id":"5ce0efb2ba6f0a14","type":"text","text":"# NFA Generalizzati (GNFA)\n\nUn GNFA è una quintupla $(Q,\\Sigma,\\delta,q_i,q_f)$ in cui $|Q|\\geq 2$ e la funzione di transizione è definita come$$\\delta:(Q-\\{q_i\\})\\times(Q-\\{q_f\\}) \\to re(\\Sigma)$$ovvero\n- $q_i$ ha solo transizioni uscenti, $q_f$ ha solo transizioni entranti;\n- Ogni transizione tra tutte le possibili coppie di stati è un'***espressione regolare***.\n\nPer costruzione, le stringhe vengono lette a gruppi anziché a simboli. Ad esempio, dando in pasto alla GNFA a fianco la stringa `abbbaaab` si ha che\n\n- Dallo stato iniziale, viene letta la sequenza `abbb` (corrispondente alla regex $ab^*$) finendo in $q_2$;\n- Segue `aaab`. Qui essendo una NFA l'albero si sdoppia, in quanto si potrebbe interpretare\n\t- secondo la regex $a^*$. In questo caso vengono lette tre `a` e si finisce in $q_1$. Rimane solo `b`, che viene interpretata dalla regex $b^*$. Finiamo quindi in $q_{accept}$ come previsto;\n\t- secondo la regex $(aa)^*$. In questo caso vengono lette due `a` e restiamo in $q_2$. Rimane `ab`, che rientra nella regex $ab\\cup ba$, quindi anche qui finiamo in $q_{accept}$.\n\n\nI linguaggi GNFA sono più generali dei linguaggi DFA (e quindi NFA). Si ha infatti che $\\mathcal{L}(DFA)\\subseteq \\mathcal{L}(GNFA)$ (????).","x":1740,"y":1631,"width":880,"height":566,"color":"3"},
		{"id":"58b249e919fb0f61","type":"file","file":"Linguaggi Regolari/DFA_FromNFA.png","x":200,"y":2244,"width":319,"height":173},
		{"id":"043186a341c6fc88","type":"text","text":"# Algoritmo di Riduzione\n\nSia $k$ il numero di stati del GNFA $G$.\n\n```\ndef Convert(G):\n\tSe k = 2:\n\t\tRestituisci la regex;\n\tAltrimenti:\n\t\tScegli un nodo;\n\t\tEliminalo;\n\t\tAggiorna G in G';\n\t\tChiama Convert(G')\n```\n\nQuesto si basa sul fatto (dimostrabile per induzione) che $\\forall\\,G$, `Convert(G)` è equivalente a $G$.","x":130,"y":2780,"width":460,"height":423,"color":"#4545ff"},
		{"id":"2ada182acf4c1e0a","type":"text","text":"# Pumping Lemma per i Linguaggi Regolari\n\nEsistono linguaggi non riconoscibili da automi finiti, quindi non regolari. Ma come faccio a capire se lo sono?\n\nEsiste un teorema, detto ***pumping lemma***, che individua una proprietà unica dei linguaggi regolari.\n\nSe $A$ è un linguaggio regolare, allora $\\exists$ un numero $p>0$ detto ***lunghezza di pumping*** tale che qualsiasi stringa $s\\in A$ di lunghezza $\\geq p$ può essere suddivisa in tre parti $p=xyz$ tali che\n\n1. $\\forall\\,i\\geq0,\\,\\,xy^iz\\in A$;\n2. $|y|>0$ (se così non fosse sarebbe banale);\n3. $|xy|\\leq p$.\n\nQuesta cosa è di facile dimostrazione.\n\n- Se nessuna stringa di $A$ è lunga almeno $p$, il teorema è automaticamente vero;\n- Viceversa, prendiamo un automa $M=(Q,\\Sigma,\\delta,q_1,F)$ con $p$ stati ed una stringa $s$ lunga $n>p$. L'automa attraversa $n+1$ stati, e ovviamente $n+1>p$. Per il principio della piccionaia deve esistere uno stato che si ripete. Questo significa che esistono tre percorsi:\n\t- Da $q_i$ a $q_r$, che chiamiamo $x$;\n\t- Da $q_r$ a $q_r$ stesso, che chiamiamo $y$ (ed è chiaro che posso ripetere $y$ un qualsiasi numero di volte);\n\t- Da $q_r$ a $q_f$, che chiamiamo $z$.\n- È ovvio che $|xy|\\leq p$. La macchina ha $p$ stati. Prima di arrivare a ripetermi (quindi prima della fine di $y$) non posso averli visitati tutti. Anche se mi ripeto la prima volta (arrivando in $q_r$) raggiungo al più $p$, perché non ho ancora raggiunto lo stato accettante (manca $z$).","x":680,"y":2780,"width":920,"height":636,"color":"4"},
		{"id":"99633375e6887712","type":"text","text":"# Applicazioni del Pumping Lemma\n\nPer ***dimostrare che un linguaggio non è regolare*** assumo che lo sia e trovo una stringa che viola il pumping lemma.\n\n- $B=\\{0^n1^n\\,|\\,n>0\\}$. Devo trovare una stringa della forma $xyz\\in B$ tale che $xy^iz\\in B$.\n\t- $y$ non può avere solo simboli uguali a $0$ o uguali a $1$. Se così fosse, si vede subito che $xyyz$ non ha lo stesso numero di $0$ e $1$, quindi $\\notin B$;\n\t- $y$ non può neanche avere entrambi i simboli, poiché in $yy$ non sarebbero nell'ordine corretto.\n\t- $B$ non è regolare perché si viola la condizione `1`.\n- $C=\\{w\\,|\\,w\\text{ ha lo stesso numero di zeri e uni}\\}$. Prendiamo $s=0^p1^p$.\n\t- Dato che per la condizione `3` deve essere $|xy|\\leq p$, se scelgo $x=\\varepsilon$ devo avere che $|y|\\leq p$, ergo è composta di soli zeri. Se itero $y$ ottengo più zeri che uni, da cui $xy^iz\\notin C$;\n\t- Alternativamente, posso notare che se $C$ fosse regolare lo sarebbe anche $C\\cap 0^*1^*$ (perché $0^*1^*$ è regolare e i linguaggi regolari sono chiusi rispetto all'intersezione). Ma $C\\cap 0^*1^* = B$, che non è regolare.\n- $F=\\{ww\\,|\\,w\\in\\{0,1\\}^*\\}$. Prendiamo $s=0^p\\,1\\,0^p\\,1$. Anche qui, basta prendere $x=\\varepsilon$ e notare che $y$ consta di soli $0$ mentre $z=1\\,0^p\\,1$, e che quindi già $xyyz\\notin F$.\n- $E=\\{0^i 1^j\\,|\\,i>j\\}$. In questo caso è utile il fatto che nella condizione `1` sia incluso $i=0$. Se divido $0^{p+1}1^p$ in $x=\\varepsilon$, $y=0^p$ e $z=01^p$, noto che per $i=0$ (ovvero ***cancellando*** $y$) la stringa $xz$ ha più uni che zeri, quindi $\\notin E$. Questa tecnica di cancellazione è detta ***pumping down***.","x":670,"y":3500,"width":940,"height":524,"color":"4"},
		{"id":"f4475828cc860da0","type":"text","text":"# Automi a Stati Finiti\n\nCos'è un computer?\n\nPer automatizzare le operazioni di calcolo è necessario un ***modello di computazione*** che rappresenti schematicamente ciò che deve accadere.\n\nL'***automa a stati finiti*** è il più semplice modello di computazione data poca memoria. Si basa sull'idea di avere ***pochissima memoria***, il che si traduce appunto in \"pochi\" stati esplorabili dal sistema (per capire dove mi trovo in un dato istante, i dati vanno indicizzati. $n$ bit di memoria codificano $2^n$ stati).\n\nL'automa a stati finiti è rappresentabile mediante ***diagramma di stato***. L'insieme $A$ di tutte e sole le stringhe accettate dalla macchina $M$ è detto linguaggio di $M$, e si indica con $L(M) = A$. In tal caso si dice che $M$ ***riconosce*** $A$. Se $M$ non accetta alcuna stringa non vuota accetta il linguaggio vuoto $\\emptyset$.\n\nSe esiste una $M$ che riconosce $A$, allora $A$ è un ***linguaggio regolare***.\n\nA volte è impossibile esibire il diagramma di stato, o perché sarebbe troppo grande o perché dipende da un generico parametro $k$. In tal caso bisogna ricorrere alla definizione formale di computazione.","x":-1275,"y":-154,"width":880,"height":471,"color":"6"},
		{"id":"eb7f2e8ab3192fd4","type":"file","file":"Linguaggi Regolari/PumpingLemmaRegex.png","x":1708,"y":2989,"width":399,"height":218},
		{"id":"15ec29fc11a1ee12","type":"text","text":"# Regex\n\n**Esempi di espressioni regolari:**\n\n1. **Caratteri singoli:**\n    \n    - `a` corrisponde al carattere `a`.\n    - `.` corrisponde a qualsiasi carattere singolo.\n2. **Gruppi e opzioni:**\n    \n    - `[abc]` corrisponde a `a`, `b` o `c`.\n    - `[a-z]` corrisponde a qualsiasi lettera minuscola da `a` a `z`.\n3. **Quantificatori:**\n    \n    - `a*` corrisponde a zero o più `a`.\n    - `a+` corrisponde a una o più `a`.\n    - `a?` corrisponde a zero o una `a`.\n    - `a{3}` corrisponde esattamente a tre `a`.\n    - `a{2,5}` corrisponde a due fino a cinque `a`.\n4. **Ancoraggi:**\n    \n    - `^a` corrisponde a `a` all'inizio di una riga.\n    - `a$` corrisponde a `a` alla fine di una riga.\n5. **Gruppi di cattura:**\n    \n    - `(abc)` corrisponde esattamente alla sequenza `abc` e può essere usato per catturare e riferirsi al contenuto corrispondente.","x":-649,"y":1960,"width":579,"height":709,"color":"1"},
		{"id":"eb6a901325ad751e","type":"text","text":"# Premesse ai Linguaggi\n\nUn ***insieme finito di simboli*** è detto ***alfabeto***. In particolare, $\\Sigma =\\{0, 1\\}$ è l'***alfabeto binario***.\n\nUna qualsiasi sequenza di simboli $\\{w_i\\in \\Sigma\\}$ si definisce ***stringa*** (o ***parola***) di $\\Sigma$. L'insieme (infinito) di tutte le possibili stringhe si indica con $\\Sigma^*$, ergo $w\\in \\Sigma^*$.\n\n- $|w|$ è la ***lunghezza*** di $w$, ovvero il numero di simboli che vi compaiono;\n- Date $x, y\\in\\Sigma^*$ definiamo la ***concatenazione*** come $xy = x_1...x_n\\,y_1...y_n$;\n- $\\varepsilon$ è la ***stringa vuota***, tale che $|\\varepsilon| = 0$, $\\forall w\\in\\Sigma^*$ $w\\varepsilon = \\varepsilon w = w$ e $\\Sigma^*\\neq\\emptyset \\Rightarrow \\varepsilon\\in\\Sigma^*$;\n- Dati $w\\in\\Sigma^*$ e $a\\in\\Sigma$, $|w|_a$ è il ***conteggio*** di $a$ in $w$, ovvero quante volte $a$ compare in $w$;\n- Se inverto la sequenza $a_1...a_n$ in $a_n...a_1$ ottengo la ***stringa rovesciata***;\n- Posso definire l'operazione di ***potenza*** di una stringa come$$w^n=\\begin{cases}\n\\varepsilon\\qquad\\quad\\text{ se }n=0\\\\\nww^{n-1}\\quad\\text{se }n>1\n\\end{cases}$$\n\nUn qualsiasi sottoinsieme di $\\Sigma^*$ si definisce ***linguaggio*** ***L***. Dati due linguaggi $L_1, L_2\\subseteq\\Sigma^*$ definiamo, oltre agli operatori banali di unione e intersezione,\n\n- ***Completamento*** - $\\overline{L} = \\{w ∈ \\Sigma^∗ | w \\notin L\\}$, cioè tutte quelle stringhe che non fanno parte di $L$;\n- ***Concatenazione*** - Una sorta di prodotto cartesiano. $L_1 ◦ L_2 = \\{xy ∈ \\Sigma^* | x ∈ L_1 , y ∈ L_2 \\}$;\n- ***Potenza*** - Tutte le possibili concatenazioni che si ottengono concatenando $n$ volte, ovvero $$L^n=\\begin{cases}\n\\{\\varepsilon\\}\\qquad\\quad\\text{ se }n=0\\\\\nL◦L^{n-1}\\quad\\text{ se }n>1\n\\end{cases}$$\n- ***Star di Kleene*** - $L^*$ restituisce tutte le possibili combinazioni di zero o più stringhe di $L$. Formalmente,$$L^* = \\bigcup_{n\\geq 0}L^n$$\n- ***Plus di Kleene*** - $L^+$ fa praticamente lo stesso lavoro di $L^*$, ma esclude la stringa vuota $\\varepsilon$.\n\nValgono inoltre le leggi di*** De Morgan*** per qualsiasi linguaggio regolare.\n\n- La negazione dell'intersezione è l'unione delle negazioni -  $\\overline{L_1\\cap L_2} = \\overline{L_1}\\cup\\overline{L_2}$\n\t- Riformulabile negando sia a destra che a sinistra - $L_1\\cap L_2 = \\overline{\\overline{L_1}\\cup\\overline{L_2}}$\n- La negazione dell'unione è l'intersezione delle negazioni - $\\overline{L_1\\cup L_2} = \\overline{L_1}\\cap\\overline{L_2}$ \n\t- Riformulabile negando sia a destra che a sinistra - $L_1\\cup L_2 = \\overline{\\overline{L_1}\\cap\\overline{L_2}}$","x":-1275,"y":-2800,"width":880,"height":955,"color":"6"},
		{"id":"2d31e0c1351d0ffb","type":"text","text":"# Linguaggi Regolari\n\nSono linguaggi rappresentabili tramite (e quindi equivalenti ad) ***Automi a Stati Finiti***. Rappresentano il più semplice modello di computazione data una quantità di memoria limitata.","x":-1275,"y":-1120,"width":880,"height":121,"color":"6"},
		{"id":"25cf3ba9630cd073","type":"text","text":"# Linguaggi Context-Free (CFL)\n\nSono linguaggi generati da ***Grammatiche Context-Free*** (***CFG***) e rappresentabili tramite (e quindi equivalenti ad) ***Automi a Pila*** (***PushDown Automata, PDA***).","x":541,"y":-2383,"width":880,"height":121,"color":"6"},
		{"id":"4b1bc6387b1400ff","type":"text","text":"# Esempi di Linguaggi Context-Free\n\n- $G_3 = (\\{S\\}, \\{a,b\\},R,S)$ dove $R=\\{S\\to aSb\\,|\\,SS\\,|\\,\\varepsilon\\}$. Così com'è può non dire nulla, ma se $a=$`(` e $b=$`)` notiamo che $\\mathcal{L}(G_3)$ è il linguaggio delle stringhe di parentesi correttamente annidate.\n- $G_4 = \\{V,\\Sigma,R,\\langle \\mathtt{EXPR}\\rangle\\}$ definisce la corretta sintassi espressioni con sole addizioni e moltiplicazioni.\n\t- $V = \\{\\langle \\mathtt{EXPR}\\rangle\\langle \\mathtt{TERM}\\rangle\\langle \\mathtt{FACTOR}\\rangle\\}$\n\t- $\\Sigma = \\{\\mathtt{a},\\mathtt{+},\\times,\\mathtt{(}, \\mathtt{)}\\}$$$R = \\begin{cases}\\langle \\mathtt{EXPR}\\rangle\\,\\,\\,\\,\\,\\,\\to\\langle \\mathtt{EXPR}\\rangle+\\langle \\mathtt{TERM}\\rangle\\quad\\,|\\,\\langle \\mathtt{TERM}\\rangle\\\\\\langle \\mathtt{TERM}\\rangle\\,\\,\\,\\,\\,\\,\\to\\langle\\mathtt{TERM}\\rangle\\times\\langle \\mathtt{FACTOR}\\rangle\\,|\\,\\langle \\mathtt{FACTOR}\\rangle\\\\\\langle \\mathtt{FACTOR}\\rangle\\to(\\langle \\mathtt{EXPR}\\rangle)\\qquad\\qquad\\,\\,\\,|\\,a\\end{cases}$$\n\t- È, seppur in maniera molto semplificata, il controllo che effettua il ***parser*** del compilatore. Nell'esempio a fianco, la le parentesi devono modificare l'ordine di esecuzione delle operazioni, e infatti l'albero sintattico risultante è completamente diverso.\n- $G_5$ è come $G_4$, ma tutte le regole sono condensate in una sola, della forma$$R = \\langle \\mathtt{EXPR}\\rangle\\to\\langle\\mathtt{EXPR}\\rangle+\\langle \\mathtt{EXPR}\\rangle\\,|\\,\\langle \\mathtt{EXPR}\\rangle\\times\\mathtt{EXPR}\\rangle\\,|\\,(\\langle \\mathtt{EXPR}\\rangle)\\,|\\,a$$Questa grammatica è simile alla precedente (anche se non tiene conto della priorità della moltiplicazione sull'addizione), ma ha un problema: è ***ambigua***. E che significa? Significa che la stessa stringa può essere generata da diversi alberi sintattici! Esistono linguaggi, detti ***inerentemente ambigui***, che possono essere generati solo e soltanto da grammatiche ambigue.","x":541,"y":-2042,"width":880,"height":565,"color":"4"},
		{"id":"0ae78bba12257fed","type":"file","file":"Linguaggi Context-Free/G4.png","x":0,"y":-2042,"width":399,"height":184},
		{"id":"d7de6946e4bc7f9a","type":"file","file":"Linguaggi Context-Free/AmbiguousG5.png","x":0,"y":-1597,"width":400,"height":120},
		{"id":"a2c08aa1f7f84ed6","type":"file","file":"Linguaggi Regolari/Esempi/M4_NFA.png","x":1181,"y":-372,"width":399,"height":89},
		{"id":"1d66725355e2923e","type":"text","text":"# Prova a Indovinare!\n\nSpesso gli NFA si basano su assunzioni e ipotesi, perché tanto ogni ipotesi è un singolo ramo dell'intera computazione.\n\nIn $M_5$ si usa l'***alfabeto unario*** che consta del solo carattere $0$, e la macchina accetta sono stringhe lunghe multipli di $2$ (testate nel ramo superiore) e di $3$ (nel ramo inferiore).","x":1708,"y":-273,"width":400,"height":287,"color":"4"},
		{"id":"3c7808314a6a65a4","type":"text","text":"#  Grammatiche Context-Free (CFG)\n\nUna grammatica è detta context-free se le regole di sostituzione non dipendono dal contesto. $G_1$, ad esempio, è una grammatica context-free. Formalmente, è una quadrupla $(V,\\Sigma,R,S)$ dove\n- $V$ è l'insieme finito delle variabili;\n- $\\Sigma$ è l'insieme finito dei terminali (disgiunto da $V$);\n- $R$ è l'insieme finito delle regole che associano ***una variabile ad una stringa***\n- $S$ è la variabile iniziale\n","x":502,"y":-2936,"width":959,"height":273,"color":"4"},
		{"id":"c65672ca13a7b7e6","type":"text","text":"# Grammatiche\n\nUna ***grammatica*** è un ***set di regole di sostituzione*** nella forma $\\text{variabile}\\to\\text{stringa}$, come ad esempio\n$$G_1=\\begin{cases}\nA \\to 0A1\\\\\nA \\to B\\\\\nB \\to \\# \n\\end{cases}\n$$\nNelle $\\text{stringhe}$ possono comparire $\\text{variabili}$ o $\\text{terminali}$ (in questo caso $0,1\\text{ e }\\#$).\n\nA partire dalla ***variabile iniziale***, che compare in genere come primo simbolo del set di regole (in questo caso $A$), posso usare queste regole per ***derivare*** stringhe di soli terminali. Usando $G_1$ posso ad esempio fare$$A\\to0A1\\to00A11\\to000A111\\to000B111\\to000\\#111$$Questa stessa informazione può essere visualizzata graficamente tramite un ***albero sintattico*** (***parse tree***). L'insieme delle stringhe così derivate costituiscono il ***linguaggio della grammatica***, in questo caso $\\mathcal{L}(G_1)=\\{0^n\\#1^n\\,|\\,n>0\\}$.\n\nSe $u, v$ e $w$ sono stringhe e $A\\to w$ è una regola, diciamo che\n\n- $uAv$ ***produce*** $uwv$, ovvero $uAv\\to uwv$;\n- $u$ ***deriva*** $v$ ($u\\to v$, ovvero da $u$ si deriva $v$) se $u=v$ o se esiste una catena $\\{u_k\\}$ tale che $u\\to u_1\\to...\\to u_k\\to...\\to v$.","x":503,"y":-3633,"width":959,"height":506,"color":"6"},
		{"id":"86f18021d67b2c84","type":"file","file":"Linguaggi Context-Free/EnglishGrammar.png","x":1561,"y":-3591,"width":400,"height":174},
		{"id":"d506de86a1bc8de2","type":"file","file":"Linguaggi Context-Free/ParseTree.png","x":-18,"y":-3550,"width":400,"height":340},
		{"id":"79aa400e94a1e523","type":"file","file":"Linguaggi Context-Free/EnglishGrammarExample.png","x":1561,"y":-3343,"width":400,"height":174},
		{"id":"ffe084b275eb59ea","type":"text","text":"# Forma Normale di Chomsky (CNF)\n\nUna grammatica context-free è in CNF se ha ogni regola nella forma$$\\begin{cases}A\\to BC\\\\A\\to a\\end{cases}$$dove\n- $A$ è ***tendenzialmente*** la variabile iniziale, mentre $B$ e $C$ no;\n\t- In che senso \"tendenzialmente\"? Ci sono situazioni in cui **può essere comodo** aggiungere una nuova variabile iniziale. Se la grammatica deve poter generare la stringa vuota posso introdurre una $\\varepsilon$-regola $S\\to A\\,|\\,\\varepsilon$, dove $S$ diventa la variabile iniziale che punta **o** ad $\\varepsilon$ **o** ad $A$, che era la vecchia variabile iniziale. Nota che **è solo una questione di comodo**, potrei benissimo non introdurre $S$ e mettere un `or` su tutte le regole aventi $A$ a sinistra.\n- $a$ è un terminale.\n","x":1761,"y":-3018,"width":720,"height":436,"color":"4"},
		{"id":"35512253a16ef8fb","type":"text","text":"# Automi a Pila (PDA)\n\nPrendi un automa a stati finiti e aggiungigli una pila. Fine. Che ci faccio? Un sacco di cose, in pratica ho aggiunto memoria illimitata.\n\nSe prendo un NFA e aggiungo la pila ottengo un PDA equivalente ai linguaggi context-free. Questo non è vero se faccio la stessa cosa partendo da un DFA, perché i DPDA non sono computazionalmente equivalenti agli NPDA.\n\nDa qui in poi utilizzo PDA per intendere un automa a pila non-deterministico.","x":4270,"y":-2472,"width":730,"height":300,"color":"6"},
		{"id":"b3cbd20b0f8552ad","type":"text","text":"# Esempi di PDA\n\nLe etichette sugli archi di un PDA sono della forma $a,\\,b\\to c$, dove\n\n- $a$ è il simbolo letto in input;\n- $b$ è il simbolo letto (e quindi eliminato, con una `pop`) dalla stack;\n- $c$ è il simbolo scritto (con una `push`) sulla stack.\n\nOgnuno di essi può essere $\\varepsilon$, nel qual caso si ha transizione senza eseguire quella specifica operazione (e.g. $a,\\varepsilon\\to c$ legge $a$ dall'input e pusha $c$ in stack).\n\n- $P_1$ può riconoscere il linguaggio irregolare $\\{0^n\\,1^n\\,|\\,n\\geq0\\}$. Dato che non esiste una primitiva esplicita per controllare che la stack sia vuota, $P_1$ ne demarca anzitutto la fine con il simbolo $\\$$, andando in $q_2$ e restandovi finché legge zeri. Quando inizierà a leggere uni andrà in $q_3$, spostandosi nello stato accettante solo se alla fine della stringa leggerà di nuovo $\\$$ in stack.\n- $P_2$ può riconoscere il linguaggio irregolare $\\{a^ib^jc^k\\,|\\,i,j,k\\geq0\\text{ e } i=j\\text{ oppure } i=k\\}$. È uno step verso la generalizzazione di $P_1$, in quanto prima la macchina segna la fine della stack e inizia ad accumulare le $a$, poi deve contare e confrontare sia le $b$ che le $c$. Lo fa in parallelo, perché è non-deterministico (si noti che un $\\varepsilon$-arco in un PDA ha etichetta $\\varepsilon,\\,\\varepsilon\\to\\varepsilon$).\n","x":3431,"y":-1760,"width":720,"height":547,"color":"4"},
		{"id":"1bba7fc6843da9ed","type":"text","text":"# Definizione Formale di PDA\n\nUn PDA è una sestupla $(Q,\\Sigma,\\Gamma, \\delta,q_0,F)$ dove\n\n- $Q$ è l'insieme finito degli stati;\n- $\\Sigma$ è l'alfabeto delle stringhe di input;\n- $\\Gamma$ è l'***alfabeto della pila***;\n- $\\delta:Q\\times \\Sigma_\\varepsilon\\times\\Gamma_\\varepsilon\\to \\mathcal{P}(Q\\times\\Gamma_\\varepsilon)$ è la funzione di transizione. Calma. Che significa?\n\t- Per decidere quali azioni intraprendere, $\\delta$ deve conoscere lo stato in cui si trova l'automa (i.e. un elemento di $Q$), il simbolo letto in input (potenzialmente anche nessuno, ed è per questo che uso $\\Sigma_\\varepsilon$) e il valore in cima alla pila (anche qui, potrei anche non leggere niente, ovvero non eseguire alcuna `pop`, per questo uso $\\Gamma_\\varepsilon$);\n\t- Quali azioni deve intraprendere? Potenzialmente cambiare stato ($\\in Q$) o scrivere qualcosa in stack con una `push` (quindi un elemento dell'alfabeto $\\Sigma_\\varepsilon$). $\\mathcal{P}$ sta lì perché quando diciamo PDA lo intendiamo sempre non-deterministico.\n- $q_0\\in Q$ è lo stato iniziale;\n- $F\\subseteq Q$ è l'insieme degli stati accettanti.\n","x":4270,"y":-1759,"width":730,"height":540,"color":"4"},
		{"id":"3165d6cf0955425d","type":"file","file":"Linguaggi Context-Free/P1.png","x":3330,"y":-1095,"width":400,"height":247},
		{"id":"889eef30368d267d","type":"file","file":"Linguaggi Context-Free/P2.png","x":3799,"y":-1095,"width":471,"height":247},
		{"id":"7afe9f86cb997f73","type":"text","text":"# Equivalenza tra PDA e CFG (e quindi CFL)\n\n`THM` - ***Un linguaggio è CF se e solo se $\\exists$ un PDA che lo riconosce.***\n\nQuesta roba si dimostra in due step.\n\n- `LMM` - ***Se il linguaggio è CF, allora esiste un PDA che lo riconosce***. Questo lemma si dimostra mostrando che è possibile trasformare la CFG $G$ associata al CFL in un PDA $P$ equivalente. Come? $P$ accetta solo le stringhe $w$ che sono generate da $G$, controllando che esista una derivazione di $w$ secondo $G$. ***Costruiamolo***! Yeee!\n\t1. Anzitutto mettiamo nella pila il ***simbolo di terminazione*** $\\$$, che dagli esempi di PDA abbiamo capito essere necessario per confrontare due stringhe. Dopo $\\$$ va messa la ***variabile iniziale*** $S$;\n\t\t- Questo si traduce in $\\delta(q,$`input`, `pop`$)=\\delta(q_{start},\\varepsilon,\\varepsilon) = \\{(q_{loop}, \\$S)\\}$ $=\\{(q,$`push`$\\}$;\n\t2. Iterativamente controlla la ***variabile*** in cima alla stack e la sostituisce in modo non-deterministico con una delle sue derivazioni;\n\t\t- Se ad esempio abbiamo $S\\to A$, $A\\to BC$ e $A\\to a$, il primo step sarà far passare la stack da $|\\$|S|$ a $|\\$|A|$. Poi però ***quando la computazione si divide, si dividono anche le stack***. Quindi esiste un ramo che sostituisce\n\t\t\t- $A\\to BC$, rendendo la stack $|\\$|C|B|$\n\t\t\t- $A\\to a$, rendendo la stack $|\\$|a|$\n\t\t- Questo si traduce in $\\delta(q_{loop},\\varepsilon, A) = \\{(q_{loop}, w)\\}$, dove $w$ è il generico membro destro della regola avente $A$ come membro sinistro.\n\t3. Se in cima alla stack non c'è una variabile ma un ***terminale***, legge dalla stack e confronta con il primo simbolo ancora da leggere della stringa in input. Se i due simboli sono diversi il ramo di computazione s'interrompe, altrimenti si prosegue con `2` o `3`;\n\t\t- Questo si traduce in $\\delta(q_{loop},s, a) = \\{(q_{loop}, \\varepsilon)\\}$, dove $s$ è un simbolo dell'`input`;\n\t4. Raggiungere $\\$$ porterà l'automa nello stato accettante finale. Se siamo giunti qui è perché finora tutti i simboli confrontati erano uguali. Se la stringa continua dopo lo stato finale, chiaramente viene rifiutata.\n\t\t- Questo si traduce in $\\delta(q_{loop},\\varepsilon, \\$) = \\{(q_{accept}, \\varepsilon)\\}$, dove $q_{accept}$ non ha archi uscenti.\n- `LMM` - ***Se il linguaggio è riconosciuto da un PDA, allora è CF***. Vogliamo ***costruire*** una CFG $G$ che generi tutte e sole le stringhe $x$ riconosciute da un PDA $P$. L'idea è la seguente: per ogni coppia di stati $p,q$ di $P$ si deve dotare $G$ di una variabile $A_{pq}$ che generi tutte e sole le stringhe tali che $P$ passa dallo stato $p$ con pila vuota allo stato $q$ con pila vuota (in generale, $P$ deve passare da $p$ a $q$ lasciando la pila inalterata).\n\t- Per semplicità di dimostrazione prendiamo $P$ tale che\n\t\t- ha un unico stato accettante;\n\t\t- svuota la sua pila prima di accettare una stringa;\n\t\t- ciascuna transizione effettua una `push` ***oppure*** una `pop`. Non entrambe contemporaneamente, né nessuna delle due. Si può sempre portare $P$ in questa forma sostituendo ogni arco che non rispetta questa condizione con due archi che la rispettano. Se le faceva entrambe, prima una e poi l'altra. Se non ne faceva alcuna, si inserisce e si toglie un simbolo arbitrario dalla pila.\n\t- Date queste premesse, è chiaro che la prima azione sulla stack di qualsiasi stringa deve essere una `push`, e che l'ultima deve essere una `pop`. A questo punto i casi sono due:\n\t\t- Il simbolo rimosso con l'ultima `pop` è esattamente quello inserito con la prima `push`. In questo caso posso scrivere in modo equivalente $A_{pq}\\to aA_{rs}b$, dove $a$ è il primo valore della stringa dato in input a $P$ e $b$ l'ultimo.\n\t\t\t- $A_{rs}$ è la stringa che porta $P$ dallo stato $r$ tale che $\\delta(p, a, \\varepsilon) = \\{(r,a)\\}$ allo stato $s$ tale che $\\delta(s, b, a) = \\{(q,\\varepsilon)\\}$, con caratteristiche generali identiche ad $A_{pq}$.\n\t\t- Il simbolo rimosso con l'ultima `pop` non è quello inserito con la prima `push`. Ciò implica che deve essere stato rimosso nel percorso da $p$ a $q$, diciamo in uno stato $r$. In tal caso scriviamo equivalentemente $A_{pq}\\to A_{pr}A_{rq}$.\n\t- A questo bisogna aggiungere l'ovvia informazione $A_{pp}\\to\\varepsilon$;\n\t- Si dimostra quindi per induzione che una tale costruzione soddisfa il lemma:\n\t\t- Se $A_{pq}$ genera $x$, allora $x$ può portare da $p$ con pila vuota a $q$ con pila vuota. La base induttiva è $A_{pp}\\to \\varepsilon$ (ovvia), dopodiché assumo vero per le stringhe lunghe $k$ e dimostro per $k+1$;\n\t\t- Se $x$ può portare da $p$ con pila vuota a $q$ con pila vuota, allora $A_{pq}$ genera $x$. La base induttiva è con $0$ passi, ovvero inizia e finisce in $p$. Se non faccio step non posso leggere alcun simbolo, quindi $x=\\varepsilon$, ma questo è scritto per ipotesi in $G$ ($A_{pp}\\to\\varepsilon$).\n\nQuesto implica un importante corollario. Dal momento che un automa a stati finiti è solo un caso particolare di PDA che ignora la sua pila, segue che\n\n`CRLL` - ***Ogni linguaggio regolare è context-free***.","x":5190,"y":-3167,"width":800,"height":1690,"color":"4"},
		{"id":"1a3d8be48d89cd10","type":"file","file":"Linguaggi Context-Free/PushdownAutomaton.png","x":4398,"y":-2903,"width":475,"height":273},
		{"id":"7399065d101f3426","type":"text","text":"# Pumping Lemma per i Linguaggi Context-Free\n\nEsistono linguaggi non riconoscibili da PDA, quindi non context-free. Abbiamo un ***pumping lemma*** anche per questi linguaggi.\n\nSe $A$ è un linguaggio context-free, allora $\\exists$ un numero $p>0$ detto ***lunghezza di pumping*** tale che qualsiasi stringa $s\\in A$ di lunghezza $\\geq p$ può essere suddivisa in cinque parti $p=uvxyz$ tali che\n\n1. $\\forall\\,i\\geq0,\\,\\,uv^ixy^iz\\in A$;\n2. $|vy|>0$ (almeno una tra $v$ e $y$ è non-vuota, se così non fosse sarebbe banale);\n3. $|vxy|\\leq p$.\n\nL'idea della dimostrazione è la seguente.\n\n- Se $G$ è tale che ogni regola ha al più $b$ simboli a destra, allora un albero sintattico di profondità $h$ ha al più $b^h$ foglie, e viceversa se $G$ genera una stringa di lunghezza $b^h$ allora ogni possibile albero sintattico ad essa associato deve avere una profondità $\\geq h$.\n- Se $V$ è il numero di variabili di $G$, poniamo $p=b^{V+1}$. Se $s$ ha lunghezza $\\geq p$, allora il suo albero sintattico deve avere profondità $\\geq V+1$. Ma questo significa che in un cammino dalla radice ad una foglia ci sono $V+2$ nodi, di cui uno è terminale e $V+1$ sono variabili. Ma se lungo il cammino incontro $V+1$ variabili avendone solo $V$ in $G$, ***per il principio della piccionaia $\\exists$ una variabile $R$ che si ripete***.\n- Consideriamo le diramazioni dell'albero sintattico generate dalla ripetizione di $R$, rappresentate schematicamente in alto in figura. Da qui nasce la ***divisione in 5 segmenti***. A questo punto posso fare due sostituzioni possibili mantenendo valido l'albero sintattico complessivo:\n\t1. Al posto dell'albero generato dalla variabile $R$ più in basso sostituisco l'albero generato dalla variabile $R$ più in alto. I due segmenti generati nello spazio tra le due $R$ contigue sono sempre $v$ ed $y$ (in basso a sinistra in figura), e posso iterare questa sostituzione un qualsiasi $i>0$ numero di volte;\n\t2. Viceversa, se sostituisco alla $R$ in alto l'albero sintattico generato dalla $R$ più in basso ottengo tre soli segmenti (in basso a destra in figura), da cui il caso $i=0$.\n- Ora, dato che $G$ è in CNF non esistono $\\varepsilon$-regole, né regole unitarie. Questo significa che nel fare il passaggio tra la prima e la seconda $R$ deve essere successa una cosa del tipo $R_{sopra}\\to...\\to BC$, dove $B\\to vR_{sotto}$ e $C\\to y$ o viceversa $B\\to v$ e $C\\to R_{sotto}y$. In entrambi i casi almeno una tra $v$ ed $y$ deve essere necessariamente $\\neq \\varepsilon$, da cui il ***secondo punto*** del teorema.\n- Infine, per il ***terzo punto*** $R_{sotto}$ si trova tra le ultime $V+1$ variabili, quindi il suo albero è alto $h'\\leq V+1$ e quindi ha al più $2^{h'-1}$ foglie. Quindi $$|vxy|\\leq2^V=p$$","x":2121,"y":-2042,"width":844,"height":1043,"color":"4"},
		{"id":"e3140b0888a10451","type":"text","text":"# Costruire la Grammatica di un Linguaggio\n\nÈ uno di quei processi che in generale richiedono creatività, ma a volte è possibile semplificarsi la vita.\n\n- Se il linguaggio è regolare, posso partire dal DFA corrispondente, costruendo la grammatica inserendo\n\t- Una variabile $R_i$ per ogni stato $q_i$ (la variabile iniziale $R_0$ è associata allo stato iniziale $q_0$);\n\t- Una regola $R_i\\to aR_j$ se $\\delta(q_i,a)=q_j$;\n\t- Una regola $R_i\\to\\varepsilon$ se $q_i$ è uno stato accettante.\n- Se si può scrivere il linguaggio di partenza come unione di linguaggi più semplici, scrivere grammatiche più semplici per poi mettere tutto insieme è più conveniente.\n- Alcuni linguaggi sono non-regolari perché c'è una correlazione tra le sottostringhe che genera. Ad esempio, $\\{0^n\\,1^n\\,|\\,n\\geq0\\}$ non è regolare perché un FSA avrebbe bisogno di ricordare quanti $0$ ha letto per confrontarli con gli $1$. Queste simmetrie sono molto semplici da gestire con una grammatica, perché basta una regola della forma $R\\to0\\,R\\,1\\,|\\,\\varepsilon$.\n- Quando c'è una ricorsione, l'implementazione è spesso semplificata. Ad esempio, in $G_4$ $\\langle \\mathtt{FACTOR}\\rangle$ può essere sia $a$ che un'intera espressione $(\\langle \\mathtt{EXPR}\\rangle)$ che poi a sua volta bla bla bla.","x":541,"y":-1447,"width":880,"height":448,"color":"4"},
		{"id":"81f7c5f806820e21","type":"file","file":"Linguaggi Context-Free/PumpingLemmaCFL.png","x":1580,"y":-1660,"width":400,"height":279},
		{"id":"c373c2bee7cda5f4","type":"text","text":"# Linguaggio $M_5$\n\nChe linguaggio accetta $M_5$?\n\n- Accetta la stringa vuota;\n- Seguendo $\\varepsilon$: accetta $a^+$;\n\t- Mettendo insieme le prime due diciamo che accetta $a^*$.\n- Seguendo $b$ arrivo in $q_2$, in cui finiscono le stringhe di tipo $ba^*$. Finisco in $q_3$ se\n\t- ci arrivo con una $a$, quindi $ba^+$;\n\t- ci arrivo con una $b$, quindi $ba^*b$.\n- A questo punto torno in $q_1$ con almeno una $a$, quindi\n\t- $baa^+$ = $baaa^*$\n\t- $ba^*ba^+$\n\nQuindi nel complesso $L = \\{a^+, baa^+, ba^*ba^+\\}$.","x":2300,"y":-380,"width":487,"height":500,"color":"4"},
		{"id":"a7bbbcf16d78be3d","type":"text","text":"# Un solo rapido esempio, perché non mi va\n\nIl linguaggio $B=\\{a^nb^nc^n\\,|\\,n\\geq0\\}$ non è context-free. Assumiamo che lo sia per trovare una contraddizione. Scegliamo $s=a^pb^pc^p$ e mostriamo che non importa come dividiamo $s=uvxyz$, in nessun modo si potrà iterare.\n\n- Anzitutto, né $v$ né $y$ possono contenere un solo simbolo, e ciò è ovvio;\n- Se però contengono simboli diversi, iterando saranno nell'ordine sbagliato.","x":2121,"y":-900,"width":844,"height":238,"color":"4"},
		{"id":"1f30c648db2dcf7a","type":"file","file":"Linguaggi Regolari/Esempi/M5.png","x":1708,"y":273,"width":400,"height":331},
		{"id":"61927ba45cbb9ee6","type":"file","file":"Linguaggi Regolari/Esempi/M6.png","x":2377,"y":273,"width":333,"height":331},
		{"id":"6cd1f84e59133423","type":"text","text":"","x":2550,"y":-3405,"width":250,"height":60},
		{"id":"d2b3b2bfc47be706","type":"text","text":"# Robustezza delle TM\n\nSe prendessi la TM ed iniziassi a variare un po' la definizione, e.g. aggiungendo la possibilità per la testina di restare ferma o $k$ nastri invece di uno solo? Questo cambierebbe forse la classe dei linguaggi riconoscibili? ***No***. Questo concetto (ovvero l'equivalenza tra la TM e le sue varianti) è noto come ***robustezza***. Data ad esempio la ***TM multinastro*** TM$^k$ definita da$$\\delta: Q\\times\\Gamma^k \\to Q\\times\\Gamma^k\\times\\{L,R, S\\}^k$$`THM` - Per ogni TM multinastro esiste una TM a singolo nastro equivalente.\n\nE semplice vedere questa cosa. Basta mettere il contenuto dei $k$ nastri sul singolo nastro, inframezzandoli con un nuovo simbolo speciale, e.g. $\\#$. Discorso simile per una ***TM non-deterministica*** definita come$$\\delta: Q\\times\\Gamma \\to \\mathcal{P}(Q\\times\\Gamma\\times\\{L,R\\})$$`THM` - Per ogni TM non-deterministica esiste una TM deterministica equivalente.\n\nPer dimostrare ciò dobbiamo considerare che una TM non-deterministica $N$ genera un albero, i cui nodi sono configurazioni. Il compito di $D$ è cercare una configurazione di accettazione o di rifiuto esplorando l'albero in ***ampiezza*** (***non*** in profondità, potrebbero esistere rami di altezza infinita...!). Ma come lo fa? $D$ ha tre nastri:\n\n- Input, in cui viene salvata solo la stringa di input;\n- Simulazione, in cui si copia la stringa di input e si esegue la computazione;\n- Indirizzi, in cui si identificano i singoli nodi dell'albero associato a $N$.\n\t- Come? `1532` indica, partendo dalla radice, di spostarsi al primo figlio, poi al quinto figlio, poi al terzo, ...\n\t- Il nastro viene costruito dinamicamente, scrivendo via via gli indirizzi dei nodi da esplorare.\n\n`CRLL` - Un linguaggio è Touring-Riconoscibile se e solo se esiste una TM multinastro o non-deterministica che lo riconosce.\n\nIn realtà, la TM è computazionalmente equivalente a quasi tutti i modelli che prevedono un accesso non restrittivo ad una memoria illimitata. Questo ci dice che non è molto importante l'esatta implementazione del modello generale, ma la ***classe di algoritmi*** che può eseguire. La stragrande maggioranza dei modelli descrive la stessa classe di algoritmi.","x":-2820,"y":-3680,"width":760,"height":917,"color":"4"},
		{"id":"4628d3cf67be0bac","type":"text","text":"# Computazione in una TM\n\nInizialmente il nastro contiene soltanto la stringa di input, che viene salvata nei primi $k$ slot. Il $(k+1)$-esimo contiene il carattere `blank`, a segnalarne la fine.\n\nLa ***configurazione*** di una TM è definita da tre elementi:\n- Lo ***stato attuale*** $q$;\n- Il ***contenuto dell'intero nastro***;\n- La ***posizione della testina*** sul nastro.\n\nQuesti tre elementi sono schematicamente indicati con la notazione $uqv$, dove $uv$ è il contenuto del nastro e $q$ indica la posizione della testina (che si trova sempre alla sua destra). Ad esempio, $1010q_31101$ indica che sul nastro c'è scritto `10101101` e la testina si trova sul terzo `1`. Una configurazione $C_1$ ***produce*** una configurazione $C_2$ se la TM può passare da $C_1$ a $C_2$ in un unico step.\n\n- $ua\\,q_i\\,bv\\to u\\,q_j\\,acv$ se $\\delta(q_i,b)=(q_j,c,L)$;\n- $ua\\,q_i\\,bv\\to uac\\,q_j\\,v$ se $\\delta(q_i,b)=(q_j,c,R)$;\n\nSe la testina si trova agli estremi (l'inizio del nastro a sinistra, un simbolo `blank` a destra), non può superarli (e.g. $q_i\\,bv$ può produrre solo $q_j\\,cv$ oppure spostamenti a destra).\n\nLe ***configurazioni di accettazione e rifiuto*** sono ***configurazioni di arresto***, cioè non producono alcuna configurazione. Una stringa che porta la TM in una configurazione di accettazione è ***accettata*** dalla TM. L'insieme delle stringhe accettate dalla TM è il linguaggio della TM.\n\n- Un linguaggio $L$ è ***Touring-riconoscibile*** (oppure ***ricorsivamente enumerabile*** se esiste una TM che accetta tutte le stringhe di $L$.\n\t- Non necessariamente tale TM rifiuta le stringhe $\\notin L$. Può anche entrare in un ***loop infinito*** in cui la TM non si fermerà mai.\n- Un linguaggio $L$ è ***decidibile*** (o ***ricorsivo***, o ***computabile***) se esiste una TM che accetta tutte le stringhe $\\in L$ e rifiuta tutte quelle $\\notin L$.\n","x":-2820,"y":-1920,"width":760,"height":834,"color":"4"},
		{"id":"1656b8c70cab4477","type":"text","text":"# Macchina di Turing (TM)\n\nÈ una ***generalizzazione degli automi a stati finiti***. Se nei PDA c'era una distinzione tra input e pila, nella Macchina di Turing sparisce. La struttura dati di supporto è un nastro partizionato (una sorta di array) sul quale è possibile spostarsi a piacimento con una testina per effettuare operazioni di lettura e scrittura.\n\nDiversamente dagli automi a stati finiti, invece, ***esiste sia uno specifico stato di accettazione che di rifiuto*** dell'input. Se la computazione non si ritrova mai su uno di questi due stati speciali, la macchina continuerà a computare all'infinito. \n\nFormalmente, la Macchina di Turing è una settupla $(Q,\\Sigma,\\Gamma, \\delta,q_0,q_{accept},q_{reject})$ dove\n\n- $Q$ è l'insieme degli stati;\n- $\\Sigma$ è l'***alfabeto di input***, che non deve contenere il ***carattere speciale*** `blank` utilizzato dalla macchina per indicare che una cella del nastro non è allocata;\n- $\\Gamma$ è l'***alfabeto del nastro***, che deve includere il carattere speciale `blank`;\n\t- Visto che scrivo l'input sul nastro e che `blank`$\\in\\Gamma$, $\\Sigma\\subset\\Gamma$.\n- La funzione di transizione $\\delta: Q\\times\\Gamma \\to Q\\times\\Gamma\\times\\{L,R\\}$ deve tenere conto dello spostamento della testina. Pertanto una scrittura del tipo $\\delta(q,a) = (p,b,L)$ significa che, nella posizione in cui si trova attualmente, la testina legge dal nastro il valore $a$ e vi scrive il valore $b$, passando dallo stato di controllo $q$ allo stato di controllo $p$ e spostandosi di una posizione a sinistra ($L=\\text{left}$).","x":-2820,"y":-2620,"width":760,"height":595,"color":"4"},
		{"id":"138aa249e84fcb30","type":"text","text":"# Tesi di Church-Touring\n\n***Cos'è un algoritmo?***\n\nFino ad inizio Novecento i matematici avevano la nozione intuitiva di \"processo in base al quale un problema può essere determinato in un numero finito di operazioni\", parafrasando un discorso tenuto da Hilbert nel 1900 che invitava, di base, a progettare un algoritmo per decidere se un polinomio avesse o meno una radice intera.\n\nCon una tale definizione intuitiva non è possibile dimostrare formalmente che un simile algoritmo non può esistere.\n\nNel ***1936*** viene formalizzata la ***tesi di Church-Touring***, che risolve questo problema: ***la nozione intuitiva di algoritmo è equivalente alla classe di algoritmi computabili da una TM***.\n\nPer il decimo problema di Hilbert, è dimostrabile che l'insieme$$D=\\{p\\,|\\,p\\text{ è un polinomio avente radice intera}\\}$$***è Touring-Riconoscibile*** (posso costruire una TM che accetta tutte le stringhe di $D$) ***ma non è Touring-Decidibile*** (non posso costruire una TM in grado di decidere se l'input appartiene o meno a $D$ in un numero finito di step).","x":-3700,"y":-2620,"width":660,"height":595,"color":"6"},
		{"id":"519ecc774af20316","type":"text","text":"# Decidibilità\n\nUn linguaggio $\\mathcal{L}$ è decidibile se **esiste una TM in grado di stabilire in un numero finito di operazioni se l'input appartiene o meno ad $\\mathcal{L}$.**\n\nInformalmente, **un problema è decidibile se è risolvibile mediante una TM**.","x":-4560,"y":-2408,"width":628,"height":171,"color":"6"},
		{"id":"20930ba61df4d18d","type":"file","file":"Linguaggi Regolari/RiduzioneGNFA.png","x":160,"y":2519,"width":400,"height":174},
		{"id":"1e66a8c6f7d0cfc8","type":"file","file":"Linguaggi Regolari/NFA.png","x":200,"y":1960,"width":319,"height":232},
		{"id":"699b4440e0614fe9","type":"text","text":"***Automi a stati finiti <-> catene di Markov***\n","x":-114,"y":57,"width":389,"height":50,"color":"4"},
		{"id":"4e5009f864f3c65f","type":"file","file":"Linguaggi Regolari/GNFA.png","x":2720,"y":1787,"width":400,"height":254},
		{"id":"fd7e1512a2c6ab8a","type":"file","file":"Macchine di Touring/ClassiDiLinguaggi.png","x":-5380,"y":-2450,"width":400,"height":255},
		{"id":"f654be1e89b267b1","type":"file","file":"SequenzaCaratteristica.png","x":-6860,"y":-2357,"width":400,"height":70},
		{"id":"c2535c4410e3aa2c","type":"text","text":"# Equivalenza tra due CFG\n\nSia\n$$EQ_{CFG}=\\{\\langle G,H\\rangle \\,|\\, G\\,e\\, H\\text{ sono CFG e }\\mathcal{L}(G) = \\mathcal{L}(H)\\}$$\n`THM` - $EQ_{CFG}$ ***non è decidibile***.","x":-6249,"y":-3340,"width":571,"height":240,"color":"2"},
		{"id":"9f79465d79f67d58","type":"text","text":"# Enumeratori\n\nL'***enumeratore*** è una variante della TM che stampa delle stringhe in output. Il linguaggio ***enumerato*** dall'enumeratore è la collezione di tutte le stringhe stampabili da esso.\n\n`THM` - Un linguaggio è Touring-riconoscibile se e solo se esiste un enumeratore che lo enumera.","x":-1925,"y":-1636,"width":433,"height":266,"color":"4"},
		{"id":"3c6616deb56d9fe1","type":"text","text":"# Non-Decidibilità e Non-Touring-Riconoscibilità\n\n`THM` - ***Alcuni linguaggi non sono Touring-Riconoscibili***. Come si dimostra?\n\n- L'insieme di tutte le stringhe $\\Sigma^*$ è $\\aleph_0$. Questo si può vedere notando che esiste solo un numero finito di stringhe per ogni lunghezza, quindi posso scriverle in sequenza;\n- Alcune di esse codificano una TM, motivo per cui anche ***l'insieme di tutte le possibili TM è*** $\\aleph_0$;\n- A questo punto è necessario il concetto di ***sequenza caratteristica*** $\\chi_A$ di un linguaggio $A\\in\\mathcal{L}$.\n\t- Abbiamo detto che $\\Sigma^*$ è numerabile, quindi deve esserlo anche qualsiasi linguaggio $A\\in\\mathcal{L}$, essendo un sottoinsieme di $\\Sigma^*$ (e.g. se $\\Sigma =\\{0,1\\}$, $A$ può essere l'insieme di tutte le stringhe che iniziano con uno zero, come in figura);\n\t- Per ogni simbolo ordinato che compare in $\\Sigma^*$ posso costruire la sequenza caratteristica $\\chi_A$  associando un `1` se la stringa appartiene ad $A$ ed uno `0` viceversa.\n- L'insieme $\\mathcal{B}$ di tutte le possibili sequenze binarie infinite è non-numerabile. $\\chi_A\\in \\mathcal{B}$, in particolare è una biezione $\\mathcal{L}\\to\\mathcal{B}$. Dal momento che esiste una biezione tra $\\mathcal{L}$ e $\\mathcal{B}$, $\\mathcal{L}$ ***è non-numerabile***;\n- Se $\\mathcal{L}$ è non-numerabile ma l'insieme di tutte le possibili TM lo è, significa che esistono più linguaggi che TM in grado di riconoscerli, pertanto segue il teorema.\n\nOra, esiste un teorema che lega la decidibilità alla Touring-riconoscibilità.\n\n`THM` - ***Un linguaggio è decidibile se e solo se è Touring-riconoscibile e coTouring-Riconoscibile***, dove per coTouring-riconoscibile (***cT-r***) si intende che il suo complemento è a sua volta riconoscibile.\n\n- Se $A$ è decidibile è automaticamente T-r, ed il suo complemento $\\overline{A}$  composto da tutte e sole le stringhe del linguaggio che $\\notin A$ è a sua volta decidibile (basta prendere il decisore $M_1$ per $A$ e farlo simulare ad una TM $M_2$ che accetta quando $M_1$ rifiuta, e viceversa);\n- Se $A$ è sia T-r che cT-r, eseguiamo due TM in parallelo come sottoprocessi di una TM $M$, in particolare due riconoscitori, uno per $A$ e uno per $\\overline{A}$. Se $M_A$ accetta, $M$ accetta. Se $M_{\\overline{A}}$ accetta, $M$ rifiuta. In tal modo $M$ decide $A$.\n","x":-6379,"y":-2692,"width":832,"height":741,"color":"4"},
		{"id":"7b25aacced81d60a","type":"text","text":"# Problemi Non-Decidibili e Non-Touring-Riconoscibili\n\nTutto questo ci porta a due esempi notevoli.\n\n- $A_{TM}=\\{\\langle M,w\\rangle\\,|\\,M\\text{ è una TM che decide l'input }w\\}$ ***non è decidibile***.\n\t- Gli elementi di questo linguaggio sono una concatenazione di\n\t\t- Una stringa $M$ che descrive una TM;\n\t\t- Una stringa $w$ accettata da $M$.\n\t- Decidere questo linguaggio significa, data la generica stringa $\\langle M,w\\rangle$, trovare una TM in grado di rispondere sempre con certezza (senza entrare in un `loop`), alternativamente,\n\t\t- Sì, la TM $M$ accetta l'input $w$, ovvero $\\langle M,w\\rangle\\in A_{TM}$;\n\t\t- No, la TM $M$ non accetta l'input $w$, ovvero $\\langle M,w\\rangle\\notin A_{TM}$.\n\t- Supponiamo che $H$ sia un decisore per $A_{TM}$, che accetta quando $M$ accetta $w$ e rifiuta altrimenti;\n\t- Ora costruiamo $D$ che esegue $H$ su input $\\langle M,\\langle M\\rangle\\rangle$, ovvero chiede ad $H$ se $M$ accetta la sua stessa rappresentazione, restituendo l'output opposto a quello di $H$ (i.e. accetta se $H$ rifiuta, e viceversa). Quindi $D(\\langle M\\rangle)$ accetta se $M$ non accetta $\\langle M\\rangle$.\n\t- Cosa succede se eseguo $D(\\langle D\\rangle)$? $D$ deve accettare se $D$ non accetta $\\langle D\\rangle$, il che è chiaramente una contraddizione. Quindi $H$ non può esistere.\n- $\\overline{A}_{TM}$ ***non è Touring-riconoscibile***.\n\t- Questo segue direttamente dal `THM` sopra. $A_{TM}$ non è decidibile, ma è T-r, il che significa che non può essere anche cT-r (se fosse sia T-r che c-Tr sarebbe anche decidibile).\n\t- Se ${A}_{TM}$ non è cT-r, allora $\\overline{A}_{TM}$ non è T-r.","x":-6379,"y":-1853,"width":832,"height":694,"color":"4"},
		{"id":"70f66f1d4a422169","type":"text","text":"# Altri esempi di Linguaggi non-decidibili\n\n- Il ***problema della fermata***, ovvero data una TM $M$ e una stringa $w$ capire se $M$ si ferma su $w$ (vale a dire, non entra in `loop`) è indecidibile.\n- Stabilire se il linguaggio accettato da una TM è esattamente $\\emptyset$ è un problema indecidibile.\n- È impossibile, data una TM, stabilire sempre se esiste o meno un DFA equivalente.\n- Date due TM, stabilire se hanno lo stesso linguaggio è un problema indecidibile","x":-6379,"y":-1040,"width":832,"height":224,"color":"4"},
		{"id":"0bb67531d979bdb2","type":"text","text":"# Riducibilità mediante funzione\n\nDicesi ***riducibilità*** il ricondurre la soluzione del problema $A$ ad un problema $B$.\n\n\t\tA: Mi sono perso! Qual è la strada giusta?\n\t\tB: Devo trovare una mappa, così potrò dedurne la strada giusta.\n\nIn particolare, la ***riducibilità mediante funzione*** (o ***molti-a-uno***) significa trovare una funzione calcolabile che trasforma le istanze del problema $A$ in istanze del problema $B$.\n\n`DEF` - Una funzione $f:\\Sigma^*\\to\\Sigma^*$ è ***calcolabile*** se esiste una TM che $\\forall$ input $w$ si ferma avendo solo e soltanto il risultato $f(w)$ sul proprio nastro.\n\nUn linguaggio $A$ è riducibile mediante funzione al linguaggio $B$ se esiste una $f$ calcolabile t.c.$$w\\in A \\Leftrightarrow f(w)\\in B\\qquad \\Leftrightarrow \\qquad A\\leq_mB$$In pratica è una ***trasformata***. E che ci faccio?\n\n`THM` - Se $A\\leq_mB$ e $B$ è decidibile, allora $A$ è decidibile.\n`CRLL` - Se $A\\leq_mB$ ed $A$ è indecidibile, allora $B$ è indecidibile.\n`THM` - Se $A\\leq_mB$ e $B$ è T-r, allora $A$ è T-r.\n`CRLL` - Se $A\\leq_mB$ ed $A$ non è T-r, allora $B$ non è T-r.\n\nFa esempi che non mi va di fare","x":-7440,"y":-1853,"width":780,"height":694,"color":"3"},
		{"id":"615cc889d34c2798","type":"text","text":"# Cenni di Teoria dell'Informazione\n\nMentre esiste una definizione universale di algoritmo (tesi di Church-Turing), non ne esiste una per l'***informazione***. Questa viene definita in modo diverso a seconda del contesto.\n\nUn possibile modo di definire l'informazione è attraverso la teoria della computazione.\n\n`DEF` - ***La quantità d'informazione contenuta in un oggetto è la dimensione della più piccola rappresentazione o descrizione di quell'oggetto***.\n\nLa stringa $A$ può ad esempio essere facilmente riassunta come la stringa `01`$\\times 20$ volte, mentre $B$ non ha una rappresentazione così compatta.\n\nIn genere si sceglie di rappresentare le stringhe insieme ad una TM che la produce, quindi nella forma $\\langle M\\rangle w$. Uso questa notazione con la stringa $w$ fuori dalle parentesi perché devo essere in grado di distinguere dove finisce $M$ e dove inizia $w$. Se lavoriamo con i bit, questo si realizza\n\n- raddoppiando ogni bit della descrizione di $M$ (i.e. scrivere `00110011` al posto di `0101`);\n- inserendo un delimitatore, tipicamente `01` (i.e. i primi due caratteri non uguali a coppia);\n- da qui in poi inizia $w$.\n\nA questo punto la ***descrizione minimale*** $d(w)$ di $w$ è la più corta tra le possibili stringhe $\\langle M\\rangle w$. La lunghezza di $K(w) = |d(w)|$ è detta ***complessità descrittiva*** (o di ***Kolmogorov***), che in pratica ***rappresenta la quantità di informazione*** di $w$.\n\nSeguono diversi risultati interessanti.\n\n- $\\forall\\,w\\,\\exists\\,c\\,\\text{ t.c. } K(w)\\leq |w|+c$ (`dim`:  $c=|\\langle M\\rangle|$).\n\t- La costante $c$ non dipende da $w$, ma solo dalla TM utilizzata per produrla;\n\t- $K$ è definita includendo una TM che stampa $w$. Questa è una necessità pratica se si parla di stringhe su alfabeto binario. Se prendiamo $A$, non posso semplicemente scrivere `01`$\\times20$ (né $\\times$ né $20$ fanno parte dell'alfabeto!), ma devo fornire una macchina che svolga tale compito e lo produca in output. Ad esempio, una descrizione per $A$ può essere$$\\langle M\\rangle w = \\langle\\text{TM che stampa 20 volte l'input\\rangle}01$$\n\t- Il teorema dice che il caso peggiore è che $w$ coincida con la stringa originale. Al più per ottenere $K$ gli va aggiunta una lunghezza costante, cioè $\\langle M\\rangle = \\langle\\text{stampa l'input}\\rangle$.\n- $\\forall\\,w\\,\\exists\\,c\\,\\text{ t.c. } K(ww)\\leq K(w)+c$, che in pratica dice che ripetere due volte la stessa cosa non aggiunge informazione in più, se non quella legata al mero fatto che l'hai ripetuta;\n- $\\forall\\,v, w\\,\\exists\\,c\\,\\text{ t.c. } K(vw)\\leq 2K(v)+K(w)+c$. Come faccio a far capire alla TM dove finisce $v$? Similmente al caso precedente, raddoppio i bit di $v$ fino ad un carattere di stop, da cui $2K(v)$;\n\t- Ci sono modi più efficienti per fare questa cosa, tipo anteporre a $v$ la sua lunghezza (che però deve comunque avere i bit raddoppiati, altrimenti non capisco dove finisce). Facendo i conti si trova che il caso peggiore diventa $2log_2(K(v))+K(w)+c$;\n\t- In ogni caso non si può raggiungere in alcun modo $K(v)+K(w)+c$.\n- $\\forall\\,w\\,K(w)\\leq K_p(w)+c$, ovvero si può dimostrare che la definizione di $K$ con le TM è ***ottimale***, nel senso che qualsiasi altra definizione $K_p$ è equivalente a meno di una costante. ","x":-5686,"y":-106,"width":820,"height":1147,"color":"5"},
		{"id":"5837e017ee10fc48","type":"file","file":"Informazione.png","x":-6246,"y":441,"width":400,"height":53},
		{"id":"b23054203a670419","type":"text","text":"# Compressibilità\n\nDiciamo che una stringa è ***c-compressibile*** se $K(w)\\leq|w|-c$.\n\nIn caso contrario, $w$ è ***c-incompressibile***. Se $c=1$, allora è semplicemente incompressibile. Queste hanno diverse proprietà interessanti, quali\n- Esistono almeno $2^n-2^{n-c+1}+1$ stringhe di lunghezza $n$ che sono c-incompressibili;\n- Alcune proprietà delle stringhe casuali, ad esempio\n\t- Una stringa incompressibile ha circa lo stesso numero di `0` e `1`;\n\t- La più lunga sequenza di `0` (o di `1`) ha circa $log_2(n)$ bit;\n\t- Se $f$ è una proprietà che vale per quasi tutte le stringhe, allora vale per quasi tutte le stringhe incompressibili (il che in pratica significa che se si prende una stringa incompressibile a caso è molto probabile che su di essa $f$ sia valida)\n\t\t- il \"quasi tutte\" è un po' un \"definitivamente\", cioè \"tutte tranne un insieme finito\".\n\nIl problema è che è difficile sapere se una stringa è incompressibile.\n\n- Stabilire se una stringa è incompressibile è in generale un problema indecidibile;\n- Nessun sottoinsieme infinito di stringhe incompressibili è Touring-riconoscibile;\n- Per qualche costante $b>0$ e $\\forall\\,w$ la descrizione minimale $d(w)$ di $w$ è incompressibile. Peccato che questo teorema non dia alcun procedimento operativo per trovare $d(w)$.","x":-4646,"y":182,"width":780,"height":572,"color":"5"},
		{"id":"84591e226f563dee","type":"text","text":"# Classe $\\mathbb{P}$ (Polynomial)\n\nFanno parte della classe $\\mathbb{P}$ tutti i linguaggi decidibili in tempo polinomiale su una TM deterministica.$$\\mathbb{P}=\\bigcup_k\\mathbb{TIME}(n^k)$$\n- $\\mathbb{P}$ è **invariante per tutti i modelli di calcolo polinomialmente equivalenti ad una TM**;\n\t- Questo consente di ignorare i dettagli implementativi del singolo modello.\n- $\\mathbb{P}$ è **abbastanza sovrapponibile con la classe dei problemi risolvibili da un computer**.\n\nSeguono esempi di algoritmi polinomiali.\n\n- ***Determinare se esiste un cammino su un grafo*** orientato. Parto da $s$, marcandolo, poi faccio un `loop` su tutti gli archi di $G$. Se ne trovo uno $a\\to b$ dove $a$ è marcato e $b$ no, marco $b$. Procedo finché non smetto di trovare nodi da marcare. Se a questo punto in nodo destinazione $t$ è marcato accetto.\n\t- Questa roba è polinomiale perché, dato il numero di nodi $n$, il `loop` viene eseguito al più $n$ volte, la ricerca in un elenco è $O(n)$ e marcare è un'operazione di costo $O(1)$ .\n- ***Determinare se due numeri sono coprimi***, ovvero l'appartenenza a $\\mathcal{coP}=\\{\\langle x,y\\rangle \\,|\\,\\text{x e y sono coprimi}\\}$. Questo si riduce nel calcolarne il MCD tramite l'algoritmo di Euclide. Ma è polinomiale?\n\t- Nel `loop` (`while y != 0`) abbiamo `resto = x%y`, ovvero iniziamo valutando il modulo tra `x` e `y`.\n\t\t- Ovviamente se fa `0` abbiamo finito, altrimenti procediamo sfruttando un `THM` che afferma che se $d$ è divisore di $a$ e $b$, allora è divisore anche di $r=a\\%b$, cioè `x = y` e `y = resto`. In questo modo il prossimo ciclo del `loop` ripete il problema con due numeri più piccoli.\n\t\t- Quanto più piccoli? L'operazione `%` può avere due risultati:\n\t\t\t- `resto = x`, il che significa che `x < y`. Questo succede al più una volta, al primo ciclo, perché poi il programma inverte `x` e `y`.\n\t\t\t- `resto < y`, il che significa che in tutti gli altri casi `x` viene più che dimezzato.\n\t\t- Quindi `x` e `y` vengono ridotti esponenzialmente ($O(\\log_2x)$).\n\n`THM` - ***Ogni linguaggio context-free è un elemento di $\\mathbb{P}$.*** Questo si vede modificando un po' l'algoritmo che dimostra che ogni CFL è decidibile.","x":-5786,"y":-5399,"width":880,"height":798,"color":"4"},
		{"id":"5885d0fdc9e36a95","type":"text","text":"# Complessità\n\nUn ***algoritmo*** che computa un problema decidibile necessita di ***tempo*** e ***memoria***.\n\nSe nella teoria della computabilità tutti i modelli di TM sono equivalenti, quando si parla di complessità ***il modello influenza le performance*** (e.g. una TM a doppio nastro permette di ridurre l'andamento asintotico rispetto ad una a nastro singolo).","x":-3720,"y":-5150,"width":700,"height":300,"color":"6"},
		{"id":"5a5636216755aaa2","type":"text","text":"# Ogni CFL è decidibile in tempo Polinomiale\n\nSe mi metto a provare da zero tutte le possibili derivazioni in $2n-1$ passi risulta uno scaling esponenziale.\n\nUn algoritmo in grado di decidere se una stringa lunga $n$ appartiene ad un CFL sfrutta la ***programmazione dinamica***, che è un modo simpatico per dire che invece di ricalcolarmi ogni volta tutto da capo mi salvo i risultati intermedi per usarli successivamente. E come si applica a questo caso?\n\n- Prendo $w$ ed esamino tutte le stringhe di lunghezza `1`. Dal momento che $G$ ***è in forma normale di Chomsky*** sono tutte derivabili da $G$ nella forma $A\\to w_i$. Per ogni simbolo $w_i$ inserisco $A$ nella ***tabella di corrispondenze*** in posizione $i, i$;\n- Qui parte un `loop` di tipo `for`, da lunghezza `2` a lunghezza `n` della stringa.\n\t- Procedo a valutare le coppie di simboli adiacenti, che sono stringhe di lunghezza `2`. Ora, sarebbe piuttosto stupido derivarle tutte da capo, perché il primo step l'ho già fatto: il resto delle regole di $G$ è della forma $A\\to BC$, quindi se ho la stringa $w_iw_j$ ed esistono le regole $B\\to w_i$ e $C\\to w_j$ (il che significa che c'è proprio $B$ in posizione $i,i$ e $C$ in posizione $j,j$) ne deduco che posso inserire $A$ in posizione $i,j$ (il che significa che $A$ può generare $w_iw_j$);\n\t\t- Si noti che se le stringhe hanno lunghezza `2` $j=i+1$. In generale, il fatto che una variabile sia salvata in posizione $i,j$ indica che questa genera una stringa di lunghezza $j-i+1$;\n\t- Generalizzo le operazioni del `loop` nel seguente modo:\n\t\t- Inserisco un `loop` annidato in cui se la stringa è lunga `3` la divido prima in `1+2` e poi in `2+1`. Per entrambe le divisioni controllo se esiste una regola che può generare la configurazione, inserendo la variabile in posizione adatta come prima;\n\t\t- Se la stringa è lunga `10` la divido prima in `1+9`, poi in `2+8`, e via dicendo.\n- Alla fine di questo `loop` controllo se la variabile iniziale $S$ compare in posizione $1, n$, ovvero se genera tutta la stringa. In caso positivo accetto, altrimenti rifiuto.\n\nCome si vede, qui ci sono solo cicli `for` annidati. Quanti sono?\n\n- Il `loop` sulla lunghezza, chiaramente $O(n)$;\n- Il `loop` sulla posizione della sotto-stringa, anche questo $O(n)$;\n- Il `loop` sulla posizione del taglio della sotto-stringa in due ulteriori sotto-stringhe, $O(n)$.\n\nDeduciamo quindi che il costo di questo programma è $O(n^3)$, pertanto $\\in\\mathbb{P}$.","x":-5786,"y":-4540,"width":880,"height":857,"color":"4"},
		{"id":"badc752724c05104","type":"text","text":"# Linguaggi Regolari, DFA, NFA, RegEx\n\nSpesso è comodo ***formulare i problemi in termini di linguaggi***. Ad esempio, verificare se un DFA $B$ accetta l'input $w$ coincide con il verificare se $\\langle B,w\\rangle$ è un elemento del linguaggio$$A_{DFA}=\\{\\langle B,w\\rangle\\,|\\,B\\text{ è un DFA che accetta l'input }w\\}$$\n`THM 1` - $A_{DFA}$ ***è decidibile***. È facile convincersene: il DFA è un caso particolare di TM, quindi è sufficiente per la TM simulare il DFA. Questo è rappresentato dalla classica quintupla, e la TM verifica preventivamente che questa rappresenti un DFA valido, rifiutando in caso contrario.\n\n`THM 2`- ***$A_{NFA}$ è decidibile***. La dimostrazione è quasi ovvia, la cosa carina è che posso prima trasformare l'NFA in un DFA e poi chiamare la TM del teorema precedente.\n\nIn modo analogo è possibile verificare se una RegEx $R$ genera una stringa $w$.$$A_{RegEx}=\\{\\langle R,w\\rangle\\,|\\,R\\text{ è una RegEx che genera la stringa }w\\}$$\n`THM 3` - $A_{RegEx}$ ***è decidibile***. Anche qui, traduco la RegEx in un NFA e torno al `THM 2`.\n\nÈ un problema decidibile anche determinare se due DFA riconoscono lo stesso linguaggio.$$EQ_{DFA}=\\{\\langle A,B\\rangle \\,|\\, A\\,e\\, B\\text{ sono DFA e }\\mathcal{L}(A) = \\mathcal{L}(B)\\}$$\n`THM 4` - $EQ_{DFA}$ ***è decidibile***. Come si procede? Si costruisce una terza TM ($C$) composta dalle stringhe accettate o da $A$ o da $B$ (non da entrambi!) e poi si verifica se il linguaggio $C$ accetta almeno una stringa o meno (a sua volta problema decidibile, è un teorema a sé stante ma l'ho saltato per pigrizia). Questo si fa tramite la ***differenza simmetrica***$$\\mathcal{L}(C) = \\big(L(A)\\cap\\overline{L_B}\\big)\\,\\cup\\,\\big(\\overline{L(A)}\\cap{L_B}\\big) = \\big(L(A)\\cup L(B)\\big)-\\big(L(A)\\cap L(B)\\big)$$","x":-4643,"y":-1880,"width":794,"height":694,"color":"4"},
		{"id":"d21bd307e22c7adf","type":"text","text":"# Linguaggi Context-Free\n\nCome per le RegEx, è possibile determinare se una certa CFG genera una stringa $w$.$$A_{CFG}=\\{\\langle G,w\\rangle\\,|\\,G\\text{ è una CFG che genera la stringa }w\\}$$\n`THM 1` - $A_{CFG}$ ***è decidibile***. Qui la cosa inizia a farsi interessante, perché non posso semplicemente provare tutte le derivazioni di $G$ fino a trovare $w$, perché potrei non trovarla mai (quindi il problema sarebbe non-decidibile). Devo allora portare $G$ in forma normale di Chomsky, in modo che qualsiasi derivazione di $w$ abbia esattamente $2n-1$ passi, dove $n$ è la lunghezza di $w$. A questo punto controllo solo un numero finito di derivazioni.\n\nQuesta roba è importantissima per il ***parsing dei linguaggi di programmazione*** (i.e. quello che ha scritto il programmatore è una stringa che ha senso nel linguaggio?).\n\n`THM 2` - $E_{CFG}=\\{\\langle G\\rangle\\,|\\,G\\text{ è una CFG tale che }L(G)=\\emptyset\\}$ ***è decidibile***. Come è fatto un simile algoritmo?\n- Marca tutti i simboli terminali;\n- `loop`: marca una variabile tale che in $A\\to U_1...U_n$ tutte le $U_i$ sono marcate;\n\t- Si noti che le $U_i$ possono essere sia variabili che terminali;\n\t- La condizione del `loop` è un `while`, finché viene marcata una nuova $A$ nel `loop`.\n- Se al termine del `loop` la variabile iniziale è marcata rifiuta, altrimenti accetta.\n\nQuesto è il teorema che ho saltato con le RegEx, e serve sostanzialmente a verificare se una certa grammatica produce almeno una stringa (i.e. di soli terminali). Ma soprattutto\n\n`THM 3` - ***Ogni linguaggio context-free è decidibile***. Questo segue direttamente dal `THM 1`, che banalmente ne è un caso specifico.","x":-4643,"y":-3571,"width":794,"height":699,"color":"4"},
		{"id":"042b72a6e40509ab","type":"text","text":"# Classe $\\mathbb{NP}$ (Non-Deterministic-Polynomial)\n\nDato un grafo orientato $G$ e due nodi $s, t\\in G$, bisogna determinare se esiste tra essi un cammino da $s$ a  $t$ che attraversa ogni nodo di $G$ esattamente una volta (***cammino Hamiltoniano***). Decidere$$\\text{HamPath} = \\{G,s,t\\,|\\,G\\text{ è un grafo orientato con cammino Hamiltoniano da s a t}\\}$$è, ad oggi, un ***problema esponenziale, la cui soluzione è però verificabile in tempo polinomiale***. Nessuno è stato in grado di esibire un algoritmo che lo risolva in tempo polinomiale, ma neanche è stato in grado di dimostrare che un tale algoritmo non esiste.\n\nFormalmente, un ***verificatore*** per un linguaggio $A$ è un algoritmo $V$ che decide$$A=\\{w\\,|\\,V\\text{ accetta }\\langle w,c\\rangle\\text{ per qualche stringa }c\\}$$$c$ è il ***certificato*** (o ***prova***) di appartenenza al linguaggio. Nel problema $\\text{HamPath}$, $c$ è un cammino. In generale, la classe $\\mathbb{NP}$ è formata da tutti i ***linguaggi che ammettono un verificatore polinomiale***.\n\nMa, come da titolo, $\\mathbb{NP}$ sta per tempo polinomiale non-deterministico. Perché?\n\n`THM` - Un linguaggio è $\\mathbb{NP}$ ***sse*** $\\exists$ una TM non-deterministica che lo decide in tempo polinomiale.\n\n- $\\Rightarrow$ : Se il linguaggio $A$ è $\\mathbb{NP}$ allora esiste $V$ polinomiale. Su input $w$ di lunghezza $n$, la NDTM seleziona in modo non-deterministico una stringa $c$ di lunghezza al più $n^k$ (i.e. considera simultaneamente tutte le possibili soluzioni...) e poi esegue $V$ (... e poi le verifica);\n- $\\Leftarrow$ : Se esiste una NDTM $N$ che decide $A$ in tempo polinomiale possiamo costruire $V$ facendogli banalmente eseguire $N$ su input $w$.\n\nCome `CRLL` possiamo definire la classe $\\mathbb{NTIME}(t(n))$ dei problemi decisi in tempo polinomiale da una NDTM, che ci porta in scioltezza a definire$$\\mathbb{NP}=\\bigcup_k\\mathbb{NTIME}(n^k)$$","x":-4657,"y":-6242,"width":823,"height":742,"color":"4"},
		{"id":"86f76c5a5c545ccf","type":"text","text":"# Esempi notevoli di problemi $\\mathbb{NP}$\n\n- La fattorizzazione, cioè l'appartenenza al linguaggio$$\\text{Composites} = \\{x\\,|\\,x=pq\\text{, dove }p,q\\in\\mathbb{N}^+\\}$$\n\t- Invero esiste un algoritmo per determinare se $x$ è primo in tempo polinomiale. Esibire la fattorizzazione, tuttavia, resta un problema $\\mathbb{NP}$.\n- Una ***clique*** è un sotto-grafo non-orientato in cui ogni nodo è collegato a tutti gli altri. Determinare se un grafo possegga o meno una $k$-clique (ovvero una clique contenente $k$ nodi) è un problema $\\mathbb{NP}$ in quanto, ad oggi, va esibita.\n- Dato un multinsieme, determinare se esiste un sotto-multinsieme i cui elementi sommano esattamente ad un certo valore $s$.\n\nSi possono dimostrare queste appartenenze a $\\mathbb{NP}$ sia costruendo un $V$ polinomiale sia esibendo una NDTM che esegue in tempo polinomiale (il trick per quest'ultima è sempre che seleziona in modo non-deterministico una possibile soluzione).","x":-3720,"y":-6091,"width":700,"height":441,"color":"4"},
		{"id":"113b371f38059915","type":"text","text":"# $\\mathbb{P=NP}$ ?\n\nGli algoritmi che scalano esponenziale sono in genere quelli che effettuano ricerche brute-force sull'intero spazio delle possibili soluzioni (che di norma è appunto una funzione esponenziale dell'input). Comprendere meglio il problema ed evitare un approccio brute-force risulta in genere nel rendere il problema $\\in\\mathbb{P}$.\n\nAd esempio, se per trovare il cammino tra due nodi in un grafo esamino tutti i possibili cammini chiedendomi se siano o meno soluzione, scopro che questi sono $O(n^n)$, con $n$ numero di nodi. Se invece rifletto trovo l'algoritmo polinomiale descritto nel riquadro sotto.\n\nDa cui la domanda: ***è sempre possibile ridurre un problema $\\mathbb{NP}$ ad un problema $\\mathbb{P}$ ? Non lo sappiamo***.\n\nSappiamo di non sapere, nel senso che ***ad oggi nessuno è mai stato in grado di dimostrare l'esistenza di anche un solo problema $\\mathbb{NP}$ che sicuramente non è in $\\mathbb{P}$.***","x":-5786,"y":-6054,"width":880,"height":367,"color":"4"},
		{"id":"c88a9399c22aee11","type":"text","text":"# Classe $\\mathbb{NP}$-$\\mathbf{Complete}$\n\nEsistono particolari problemi $\\mathbb{NP}$ la cui complessità è legata alla complessità della classe $\\mathbb{NP}$ stessa. Per dimostrare che $\\mathbb{P=NP}$ basterebbe dimostrare che anche uno solo di questi problemi attualmente $\\in\\mathbb{NP}$ sia anche $\\in\\mathbb{P}$. Tali problemi formano la classe $\\mathbb{NP}$-$\\mathbf{Complete}$.\n\nSe da un lato questo offre una vasta gamma di problemi su cui lavorare per provare a dimostrare la famosa congettura, dall'altro la gente è abbastanza convinta che $\\mathbb{P\\neq NP}$, quindi quando si rende conto che un problema $\\mathbb{NP}$ che sta cercando di ridurre a $\\mathbb{P}$ è $\\mathbb{NP}$-$\\mathbf{Complete}$ alza subito bandiera bianca.\n\nAnzitutto, quando si parla di \"ridurre\" si intende in tempo polinomiale. Un linguaggio $A$ è ***riducibile in tempo polinomiale*** mediante funzione al linguaggio $B$ se esiste una $f$ calcolabile in tempo polinomiale t.c.$$w\\in A \\Leftrightarrow f(w)\\in B\\qquad \\Leftrightarrow \\qquad A\\leq_PB$$Da questo ricaviamo che se $A\\leq_PB$ e $B\\in\\mathbb{P}$, allora $A\\in\\mathbb{P}$. A questo punto $B$ è $\\mathbb{NP}$-$\\mathbf{Complete}$ se $B\\in\\mathbb{NP}$ e se ogni $A\\in\\mathbb{NP}$ è riducibile in tempo polinomiale a $B$. Se poi $B\\in\\mathbb{P}$ allora $\\mathbb{P=NP}$.\n\nUna volta trovato il primo problema $\\mathbb{NP}$-$\\mathbf{Complete}$ è più facile trovarne altri, in quanto se $B\\leq_PC$ e $C\\in\\mathbb{NP}$, allora anche $C$ è $\\mathbb{NP}$-$\\mathbf{Complete}$. Il problema è appunto trovare il primo.","x":-5786,"y":-6820,"width":880,"height":511,"color":"4"},
		{"id":"1462ab03ca563271","type":"text","text":"# Teorema Cook-Levin\n\nData un'espressione booleana, questa è soddisfacibile se esiste un assegnamento di valori `0` e `1` alle variabili booleane tale che l'espressione nel complesso restituisca il valore `1`. Definiamo il linguaggio$$SAT=\\{\\phi\\,|\\,\\phi\\text{ è un'espressione booleana soddisfacibile}\\}$$\n`THM` (***Cook-Levin***) - $SAT$ è $\\mathbb{NP}$-$\\mathbf{Complete}$.\n\nConcettualmente è semplice: ad ogni linguaggio $A\\in\\mathbb{NP}$ corrisponde una TM rappresentabile tramite (i.e. polinomialmente riducibile ad) una stringa booleana (i.e. le TM sono implementabili tramite circuiti logici).\n\n$SAT\\in\\mathbb{NP}$ - Una NDTM sceglie non-deterministicamente un'assegnazione e accetta se il risultato è `1`.\n\n$A\\in\\mathbb{NP}$ è riducibile a $SAT$ - Per fare questa roba costruiamo un ***tableau***.\n\n- Un ***singolo tableau rappresenta un ramo della computazione non-deterministica***. Questo significa che ne esistono molteplici, e che il problema è decidibile se esiste almeno un tableau che decide. Ogni riga del tableau è la rappresentazione dello stato e del nastro della NDTM al passo $i$;\n- Definiamo l'***alfabeto*** del tableau come $C=Q\\cup\\Gamma\\cup\\{\\#\\}$, dove $\\#$ delimita le righe. Questo significa che un elemento di $C$ può essere uno ***stato***, un ***simbolo del nastro*** o un ***delimitatore***. Ogni ***cella*** del tableau contiene un elemento di $C$ (perché è una cella del nastro della NDTM);\n- Per rappresentare matematicamente il nastro (e quindi il tableau) uso le ***variabili booleane***. Se la cella $ij$ contiene l'elemento $k$, allora $x_{ijk}$ è vera (i.e. vale `1`).\n- A questo punto ci sono 4 condizioni da soddisfare:\n\t- ***In ogni cella del tableau ci deve essere esattamente un simbolo o uno stato***, che si traduce in$$\\phi_{cell} = \\bigwedge_{1\\le i,j\\le n^k}\\bigg[\\bigg(\\bigvee_{s\\in C}x_{ijs}\\bigg)\\wedge\\bigg(\\bigwedge_{s,t\\,\\in\\,C,\\,s \\neq t}(\\overline{x_{ijs}}\\vee\\overline{x_{ijt}}\\bigg)\\bigg]$$dove i simboli grandi sono abbreviazioni per iterazioni (e.g. $\\bigvee_{s\\in C}x_{ijs} = x_{ijs_1}\\vee ...\\vee x_{ijs_n}$ ). Il primo pezzo dice che almeno una variabile per ogni cella deve essere `1`, ovvero che **qualcosa deve essere scritto in ogni cella**, il secondo che non più di una variabile per cella sia uguale a `1`ovvero **solo una cosa può essere scritta in ogni cella**;\n\t- ***La prima riga deve essere esattamente la configurazione iniziale*** della NDTM. Questo si realizza imponendo un `AND` sulle singole variabili (i.e. $\\phi_{start} = x_{11\\#}\\wedge x_{12q_0}\\wedge x_{13w_1}\\wedge x_{14w_2}\\wedge...\\wedge x_{1n^k\\#}$);\n\t- ***Deve esistere una configurazione accettante***, ovvero $\\phi_{accept} = \\bigvee_{i,j} x_{ijq_{accept}}$;\n\t- ***Ogni riga deve essere legalmente derivabile da quella precedente***. Questa condizione si realizza analizzando delle matrici $2\\times3$ dette ***finestre***, che passano in rassegna ogni possibile tripla della riga di partenza e di quella successiva. $\\phi_{move}$ è la condizione booleana che tutte le finestre del tableau siano ***lecite***. Non mi dilungo perché è un delirio.\n\t\t- Se la prima riga rispetta $\\phi_{start}$ e tutte le finestre sono lecite, allora ogni riga è una configurazione legittimamente derivata dalla precedente.\n- L'espressione booleana equivalente alla NDTM che decide $A$ è quindi $\\phi_{cell}\\wedge\\phi_{start}\\wedge\\phi_{accept}\\wedge\\phi_{move}$.\n\nAbbiamo ridotto $A$ a $SAT$. Ma è una riduzione polinomiale? Sì. L'espressione booleana equivalente al tableau ha $O(n^{2k})$ variabili, esattamente come il tableau ha $O(n^{2k})$ celle (il che significa che la NDTM, e quindi ad $A$, hanno complessità $O(n^{2k})$).","x":-5786,"y":-8160,"width":880,"height":1150,"color":"4"},
		{"id":"b28ed044f0e6cdb1","type":"file","file":"ComplexityClasses2.png","x":-4445,"y":-7320,"width":400,"height":160},
		{"id":"18f18f4d08423a52","type":"text","text":"# Classe $\\mathbb{NP}$-$\\mathbf{Hard}$\n\nOvviamente esistono anche problemi non-polinomiali con verifica non-polinomiale. \"Eh, ma saranno cose super complicate e difficili anche solo da formulare\". ... ecco, no. Prova a verificare$$\\overline{\\text{HamPath\n}} = \\{G,s,t\\,|\\,G\\text{ è un grafo orientato privo di un cammino Hamiltoniano da s a t}\\}$$e dimmi se ci riesci. Devi provare tutti i possibili cammini orientati per poter affermare con certezza che non ne esiste uno. Benvenuto fuori da $\\mathbb{NP}$. Ma andiamo per gradi.\n\n***Un problema è $\\mathbb{NP}$-$\\mathbf{Hard}$ se tutti i problemi $\\mathbb{NP}$ sono ad esso riducibili in tempo polinomiale***:$$\\mathbb{NP}\\text{-}\\mathbf{Hard}=\\{B\\in\\Sigma^*\\,|\\,\\forall A\\in\\mathbb{NP}\\quad A\\leq_PB\\}$$Trovare un algoritmo polinomiale per anche un solo problema $\\mathbb{NP}$-$\\mathbf{Hard}$ significa dimostrare che $\\mathbb{P=NP}$). Ci ricorda qualcosa? Ma certo, questo è vero anche per la classe $\\mathbb{NP}$-$\\mathbf{Complete}$! Perché mai? Banalmente, ***un problema è $\\mathbb{NP}$-$\\mathbf{Complete}$ se è sia $\\mathbb{NP}$ che $\\mathbb{NP}$-$\\mathbf{Hard}$.***\n\nSe i problemi $\\mathbb{NP}$ riguardano decisioni (i.e. risposte `sì` o `no`), quelli $\\mathbb{NP}$-$\\mathbf{Hard}$ includono in generale problemi di ottimizzazione in cui la soluzione è, ad esempio, un cammino su un grafo, risultando così più ***difficili*** dei problemi $\\mathbb{NP}$, da cui il nome della classe.\n","x":-4657,"y":-6820,"width":823,"height":511,"color":"4"},
		{"id":"a24e2f4816cc28b5","type":"text","text":"# Spazio\n\nData una TM a nastro singolo, definiamo la complessità di spazio $f(n)$ come il massimo numero di celle che la TM scandisce su un qualsiasi input di lunghezza $n$, e conseguentemente le classi $\\mathbb{SPACE}$ dei linguaggi decisi con spazio $O(f(n))$ da una TM deterministica ed $\\mathbb{NSPACE}$ analogo non-deterministico.\n\nPer quanto riguarda lo spazio, in realtà, assumiamo che la TM abbia due nastri: uno per l'input, in sola lettura, ed uno standard read/write per l'esecuzione. Questo non è restrittivo.\n\nIl famoso problema $\\text{SAT}\\in\\mathbb{NP}$-$\\mathbf{Complete}$ (quindi non decidibile in tempo polinomiale, men che meno lineare) è invece risolto con complessità spaziale $O(n)$, poiché ad ogni step è necessario salvare solo la verità corrente delle $n$ variabili.\n\n***Lo spazio può essere riutilizzato, il che lo rende più potente del tempo***.\n\nQuesta roba è formalizzata dai teoremi di\n\n- ***Tempo limitante lo Spazio*** - Data una $f(n)\\geq n$ si ha$$\\mathbb{TIME}(f(n))\\subseteq \\mathbb{SPACE}(f(n))$$$$\\mathbb{NTIME}(f(n))\\subseteq \\mathbb{NSPACE}(f(n))$$\n- ***Spazio limitante il Tempo*** - Data una $f(n)\\geq \\log n$ si ha$$\\mathbb{SPACE}(f(n))\\subseteq \\mathbb{TIME}(2^{Of((n))})$$","x":-2837,"y":-5400,"width":794,"height":798,"color":"4"},
		{"id":"237d28d885cf8413","type":"text","text":"# Classi di Spazio\n\nPer via del Teorema di Savitch abbiamo che$$\\mathbb{PSPACE}=\\bigcup_k\\mathbb{SPACE}(n^k)=\\mathbb{NPSPACE}=\\bigcup_k\\mathbb{NSPACE}(n^k)$$\nConfrontando con le classi di tempo troviamo che sicuramente $\\mathbb{P\\subseteq PSPACE}$, poiché un problema eseguito velocemente non può richiedere uno spazio non polinomiale. Analogamente $\\mathbb{NP\\subseteq NPSPACE}$. In generale possiamo scrivere che$$\\mathbb{P\\subseteq NP\\subseteq PSPACE=NPSPACE\\subseteq EXPTIME}$$Sappiamo per certo solo che $\\mathbb{P\\ne EXPTIME}$, quindi almeno uno tra i $\\subseteq$ è in realtà un $\\subset$, ma ad oggi non sappiamo quale. Molti, tuttavia, ritengono che siano tutti dei $\\subset$.\n\nAnalogamente al tempo, esiste la $\\mathbb{PSPACE}$-$\\mathbf{Completezza}$. Sono quei problemi $B$ tali che\n\n- $B\\in\\mathbb{PSPACE}$;\n- $\\forall A\\in\\mathbb{PSPACE}$ si ha che $A\\leq_PB$.\n\nSe $B$ rispetta solo la seconda condizione, allora è $\\mathbb{PSPACE}$-$\\mathbf{Hard}$. Il problema $\\text{TQBF}$ che consiste nel decidere se una formula booleana totalmente quantificata (i.e. ogni variabile è associata ad un quantificatore, e.g. $\\forall x\\,\\exists y\\,|\\, xy=0$) è vera o falsa è $\\mathbb{PSPACE}$-$\\mathbf{Completo}$.\n\nDiversamente dal tempo, invece, definiamo le classi sub-lineari (logaritmiche) $\\mathbb{L=SPACE}(\\log n)$ e l'analogo non-deterministico $\\mathbb{NL=NSPACE}(\\log n)$. Perché? Basti pensare al fatto che posso leggere l'intero input usando dei puntatori al nastro di input.","x":-1866,"y":-5400,"width":794,"height":798,"color":"4"},
		{"id":"64b8624fa2711561","type":"text","text":"# Teoria dei Giochi? Forse? Non ho capito\n\nIl gioco è vagamente definito come una competizione in cui le parti che si contrappongono cercano di raggiungere un obiettivo in accordo a regole predefinite. I giochi sono strettamente legati ai quantificatori. Sia $\\mathcal{Q}$ il generico quantificatore $\\{\\forall,\\exists\\}$, e sia $\\phi = \\sum_k\\mathcal{Q}_kx_k\\,[\\psi]$ una formula booleana totalmente quantificata (TQBF). Mettiamo in mezzo due giocatori:\n\n- $A$ sceglie il valore delle variabili $x_i$ associate ad un quantificatore $\\mathcal{Q}_i=\\forall$, e vince se $\\psi$ è vera;\n- $E$ sceglie il valore delle variabili $x_i$ associate ad un quantificatore $\\mathcal{Q}_i=\\exists$, e vince se $\\psi$ è falsa.\n\nPossono esistere giochi (i.e. definizioni di $\\phi$) tali che uno dei due giocatori può avere una strategia vincente. Decidere se un gioco ammette una strategia vincente è $\\mathbb{PSPACE}$-$\\mathbf{Completo}$, in quanto una formulazione del problema TQBF.\n\nGiochi da tavolo come gli scacchi sono invece ad oggi $\\mathbb{PSPACE}$-$\\mathbf{Difficili}$.","x":-946,"y":-5400,"width":800,"height":798,"color":"3"},
		{"id":"3b299722dbb949ea","type":"file","file":"StrategiaVincente.png","x":-66,"y":-5150,"width":400,"height":298},
		{"id":"4a3db5d9f4f76c56","type":"text","text":"# Teorema di Savitch\n\nOgni NDTM che usa spazio $f(n)$ può essere convertita in una TM che usa spazio $f^2(n)$, ovvero$$\\mathbb{NSPACE}(f(n))\\subseteq\\mathbb{SPACE}(f^2(n))$$Come si dimostra questa roba?\n\n","x":-2837,"y":-4521,"width":794,"height":501,"color":"2"},
		{"id":"5eafa3a2b48a383f","type":"text","text":"# Intrattabilità\n\nAumentare lo spazio e il tempo a disposizione della TM aumenta il numero di problemi risolvibili. Questo viene formalizzato nei ***teoremi di gerarchia***.\n\nProblemi con esigenze di risorse esorbitanti possono essere considerati ***intrattabili***.\n\nSono solitamente considerati tali quelli appartenenti alle classi $\\mathbb{EXP}$.","x":-2790,"y":-5981,"width":700,"height":221,"color":"6"},
		{"id":"41fddac8468fe1b9","type":"text","text":"# Un esempio di problema intrattabile\n\nI problemi più difficili di tutti sono quelli $\\mathbb{EXPSPACE}$-$\\mathbf{Complete}$. Un esempio è il seguente: introduciamo l'operatore $\\uparrow$ tale che $R\\uparrow k$ significa concatenare la RegEx $R$ con se stessa $k$ volte.$$\\text{EQ}_{REX\\uparrow}=\\{\\langle Q,R\\rangle\\,|\\,\\text{Q ed R sono RegEx equivalenti e contengono l'operatore }\\uparrow\\,\\}$$Ci sono sei pagine di dimostrazione, non le faccio manco sotto tortura.","x":-1866,"y":-5981,"width":794,"height":221,"color":"4"},
		{"id":"7d835e05d31037b9","type":"text","text":"# Grammatiche CNF\n\nOgni grammatica context-free può essere portata in CNF. È utile farlo perché in questa forma è più facile dimostrare i teoremi ed eseguire algoritmi di parsing. Ad esempio,\n\n`THM` - **Ogni linguaggio context-free è generato da una grammatica context-free in forma normale di Chomsky.** Come si dimostra?\n\nDato che una generica grammatica context-free genera un linguaggio context-free, mi basta dimostrare che posso sempre portare una grammatica CF in CNF. Come?\n\n- Introduco una ***nuova variabile iniziale*** $S_0$ e la regola $S_0\\to S$. Questo garantisce che la variabile iniziale non comparirà mai a destra delle regole;\n- ***Elimino tutte le $\\varepsilon$-regole*** della forma $B\\to\\varepsilon$ (dove $B$ non è la variabile iniziale), e a cascata elimino ogni occorrenza di $B$ nei membri destri delle regole.\n\t- Se c'era $R\\to B$, aggiungo $R\\to\\varepsilon$;\n\t- Se c'era $R\\to uBv$, aggiungo $R\\to uv$;\n\t- Se c'era $R\\to uBvBw$ devo stare attento. Devo trattare separatamente ogni occorrenza di $B$, in particolare posso eliminare\n\t\t- solo al prima - $R\\to uvBw$;\n\t\t- solo la seconda - $R\\to uBvw$;\n\t\t- entrambe - $R\\to uvw$.\n\t\t- Nel complesso, ottengo $R\\to uvBw\\,|\\,uBvw\\,|\\,uvw$.\n\t- Se poi $B\\to\\varepsilon$ era l'unica regola in cui $B$ compare a sinistra posso eliminare le regole originali e sostituire $R\\to uvBw\\,|\\,uBvw\\,|\\,uvw$ con $R\\to uvw$.\n- ***Elimino tutte le regole unitarie*** della forma $A\\to B$, e sostituisco ogni regola $B\\to u$ con una regola $A\\to u$;\n- ***Rimpiazzo*** ogni regola della forma $A\\to u_1u_2...u_k$ dove $k>2$ con una serie di regole del tipo $A\\to u_1A_1$, $A_1\\to u_2A_2$, ..., $A_{k-2}\\to u_{k-1}u_k$. A questo punto rimpiazzo ogni $u_i$ con una variabile $U_i$ e per ognuna aggiungo la regola $U_i\\to u_i$.","x":2600,"y":-3189,"width":730,"height":780,"color":"4"},
		{"id":"1058f6e7a3cd10b1","type":"text","text":"# $\\mathbb{EXP}$, $\\mathbb{NEXP}$ e Classi Complementari\n\nA dispetto del nome, $\\mathbb{NP}$-$\\mathbf{Hard}$ non è la classe di complessità più generale. Tutti i problemi di $\\mathbb{NP}$-$\\mathbf{Hard}$ possono essere risolti in tempo esponenziale (classe $\\mathbb{EXP}$), ma non tutti i problemi di $\\mathbb{EXP}$ sono $\\mathbb{NP}$-$\\mathbf{Hard}$ (i.e. $\\mathbb{NP}$-$\\mathbf{Hard}\\subset \\mathbb{EXP}=\\bigcup_k\\mathbb{TIME}(2^{n^k})$).\n\nAncora oltre troviamo cose folli tipo i problemi decidibili in tempo non-polinomiale da una TM non-deterministica ($\\mathbb{EXP}\\subset\\mathbb{NEXP}$).\n\nVi sono poi le classi dedicate ai problemi il cui complemento è in una delle classi principali. Ad esempio, $\\overline{\\text{HamPath}}$ è un problema $\\mathbf{co}\\mathbb{NP}$, ovvero la classe di problemi i cui complementari sono in $\\mathbb{NP}$. In generale abbiamo che\n\n- $\\mathbf{co}\\mathbb{P}=\\mathbb{P}$, ovvero la classe $\\mathbb{P}$ è chiusa nel complemento;\n- $\\mathbf{co}\\mathbb{EXP}=\\mathbb{EXP}$, ovvero la classe $\\mathbb{EXP}$ è chiusa nel complemento;\n- Non sappiamo se la classe $\\mathbb{NP}$ sia chiusa nel complemento o meno. Se sapessimo per certo che $\\mathbf{co}\\mathbb{NP}\\ne\\mathbb{NP}$, questo implicherebbe che $\\mathbb{P}\\ne\\mathbb{NP}$.\n\t- Se trovassimo un linguaggio $B\\in\\mathbb{NP}$-$\\mathbf{Complete}$ tale che questo è anche $\\mathbf{co}\\mathbb{NP}$-$\\mathbf{Complete}$ (ovvero se $\\mathbb{NP}$-$\\mathbf{Complete}$ fosse chiuso nel complemento), allora dimostreremmo che $\\mathbf{co}\\mathbb{NP}=\\mathbb{NP}$;\n\t- Nota bene che, anche se fosse, $\\mathbf{co}\\mathbb{NP}=\\mathbb{NP}$ ***non implica*** $\\mathbb{P=NP}$. ","x":-3720,"y":-6838,"width":700,"height":547,"color":"4"},
		{"id":"a5773f254e5128d7","type":"text","text":"# Teoremi di Gerarchia\n\nDare più spazio ad una TM significa aumentare la classe di problemi da essa risolvibili. Non c'è un limite superiore, ovvero si può continuare all'infinito a fare questo gioco.\n- A livello tecnico, una ***funzione*** $f:\\mathbb{N\\to N}$ almeno $O(\\log n)$ è ***spazio-costruibile*** se la funzione $g$ che mappa la stringa $1^n$ nella rappresentazione binaria di $f(n)$ è computabile in spazio $O(f(n))$. Che significa?\n\t- $f$ ci dice quanto spazio possiamo usare;\n\t- $g$ verifica quanto spazio stiamo usando.\n- Il ***teorema di gerarchia di spazio*** afferma che per ogni $f:\\mathbb{N\\to N}$ spazio-costruibile esiste un linguaggio $A$ decidibile in spazio $O(f(n))$ ma non in spazio $o(f(n))$.\n\t- In pratica dice che se fisso la funzione $f(n)$ e cerco tra i problemi risolvibili usando tale spazio, ne troverò almeno uno che ha bisogno di esattamente quello spazio, non meno.\n\nDare più tempo ad una TM significa aumentare la classe di problemi da essa risolvibili.\n- Una ***funzione*** $t:\\mathbb{N\\to N}$ almeno $O(n\\log n)$ è ***tempo-costruibile*** se la funzione $g$ che mappa la stringa $1^n$ nella rappresentazione binaria di $t(n)$ è computabile in tempo $O(t(n))$.\n- Il ***teorema di gerarchia di spazio*** afferma che per ogni $t:\\mathbb{N\\to N}$ tempo-costruibile esiste un linguaggio $A$ decidibile in tempo $O(t(n))$ ma non in tempo $o($$t(n)\\over\\log t(n)$$)$.\n\t- Questa versione più debole discende dal fatto che per lo spazio assumiamo di lavorare con TM a due nastri (`input` e `work`), mentre con il tempo lavoriamo a nastro singolo. È plausibile che esista anche una versione \"forte\" di questo teorema, ma ad oggi non siamo in grado di dimostrarla su macchine a singolo nastro.","x":-2837,"y":-6891,"width":794,"height":654,"color":"4"},
		{"id":"a8ad49269f2ac9bb","type":"text","text":"# Implicazioni dei Teoremi di Gerarchia\n\n- Dato $f_1(n)=o(f_2(n))$ con $f_2$ spazio-costruibile, $\\mathbb{SPACE}(f_1(n))\\subset \\mathbb{SPACE}(f_2(n))^2$\n- Per ogni coppia di numeri reali $0\\leq \\varepsilon_1 < \\varepsilon_2$ si ha $\\mathbb{SPACE}(n^{\\varepsilon_1})\\subset \\mathbb{SPACE}((n^{\\varepsilon_2})$\n- $\\mathbb{NL=NSPACE}(\\log n) \\subset \\mathbb{SPACE}(n)$\n- $\\mathbb{PSPACE\\subset EXPSPACE}$, ovvero esistono problemi decidibili che sono intrattabili in spazio.\n\nTutti questi hanno l'analogo con il tempo.\n\n- Dato $t_1(n)=o($$t_2(n\\over\\log t_2(n)$$)$ con $f_2$ spazio-costruibile, $\\mathbb{TIME}(t_1(n))\\subset \\mathbb{TIME}(f_2(n))$\n- Per ogni coppia di numeri reali $0\\leq \\varepsilon_1 < \\varepsilon_2$ si ha $\\mathbb{TIME}(n^{\\varepsilon_1})\\subset \\mathbb{TIME}((n^{\\varepsilon_2})$\n- $\\mathbb{P\\subset EXPTIME}$, ovvero esistono problemi decidibili che sono intrattabili in tempo.\n\n","x":-1866,"y":-6737,"width":794,"height":347,"color":"3"},
		{"id":"51cbb52198466193","type":"file","file":"Tableau.png","x":-4445,"y":-7722,"width":399,"height":275},
		{"id":"a7193d37b6c8c4a4","type":"text","text":"# Esempi di problemi $\\mathbb{NP}$-$\\mathbf{Complete}$\n\nPer ragioni non ancora ben comprese, molti dei problemi che si presentano come $\\mathbb{NP}$ risultano essere $\\mathbb{P}$ o $\\mathbb{NP}$-$\\mathbf{Complete}$. Quando si prova a trovare un algoritmo $\\mathbb{P}$ per un nuovo problema $\\mathbb{NP}$ ha senso verificare anzitutto se questo è $\\mathbb{NP}$-$\\mathbf{Complete}$. Come? Tramite le tecniche che vediamo nei prossimi esempi ovviamente.\n\n\n- $3SAT$ - In logica booleana, una ***clausola*** consta di letterali legati da soli operatori $\\vee$. Un'espressione booleana è in ***forma normale congiuntiva*** (***cnf***) se consta di clausole connesse tramite operatori $\\wedge$. Infine, se tutte le clausole della cnf hanno esattamente 3 letterali, l'espressione è $\\mathbf{3cnf}$. Un esempio è$$(x_1\\vee\\overline{x_2}\\vee x_3)\\,\\wedge\\,(x_2\\vee x_4\\vee\\overline{x_3})\\,\\wedge\\,(x_2\\vee x_4\\vee\\overline{x_5})$$Sulla base di ciò possiamo definire analogamente a $SAT$ il linguaggio$$3SAT = \\{\\langle\\phi\\rangle\\,|\\,\\phi\\text{ è un'espressione 3cnf soddisfacibile}\\}$$Ora, $3SAT\\in\\mathbb{NP}$. A partire dalla dimostrazione per $SAT$, è possibile portare i singoli pezzi dell'espressione $\\phi_{cell}\\wedge\\phi_{start}\\wedge\\phi_{accept}\\wedge\\phi_{move}$ in $\\text{3cnf}$. Questo dimostra l'$\\mathbb{NP}$-$\\mathbf{Completeness}$ di $3SAT$.\n\nA partire da $3SAT$, troviamo linguaggi riducibili in tempo polinomiale ad esso.\n\n- $\\mathbf{Clique}$ - Esiste una riduzione polinomiale che converte formule booleane in grafi. Ogni nodo rappresenta un letterale, e il grafo è organizzato in $k$ ***triple*** di nodi, ognuna delle quali rappresenta quindi una clausola. Non ci sono archi all'interno di una stessa tripla, né tra letterali complementari (i.e. un nodo etichettato con il letterale $x_i$ non è mai connesso ad un nodo $\\overline{x_i}$). Data questa costruzione, la presenza di una $k$-clique è equivalente a soddisfare$$\\phi=(a_1\\vee b_1\\vee c_1)\\,\\wedge(a_2\\vee b_2\\vee c_2)\\wedge\\,...\\,\\wedge(a_k\\vee b_k\\vee c_k)$$\n- $\\mathbf{Vertex\\,Cover}$ - Se $G$ è un grafo non orientato, una ***vertex cover*** (***VC***) di $G$ è un sottoinsieme di nodi tali che questi toccano tutti gli archi di $G$. È ovvio che $G$ meno un singolo nodo è una VC di $G$, probabilmente anche meno due nodi. Decidere se $G$ ha una VC di $k$ nodi è un problema $\\mathbb{NP}$-$\\mathbf{Complete}$ perché $3SAT$ è riducibile in tempo polinomiale a VC. Come? Al solito, costruendo un grafo che simula $\\phi$ tale che $\\phi$ è soddisfacibile sse il grafo ha una VC di dimensione $k$.\n- $\\mathbf{HamPath}$ - Anche qui, costruiamo un grafo che simula $\\phi$ tale che $\\phi$ è soddisfatta sse esiste un cammino hamiltoniano tra $s$ e $t$.\n\t- Lo è anche la sua versione con grafo non orientato, $\\mathbf{UHamPath}$.","x":-7000,"y":-7560,"width":722,"height":979,"color":"4"},
		{"id":"e5b1cbb0be578016","type":"text","text":"# tl, dr\n\n- Metto in stack `$` di terminazione e variabile iniziale, poi sostituisco non-deterministicamente ogni variabile con le sue implicazioni secondo le regole della grammatica. Se vedo un terminale ed è diverso da quello che leggo in input, rifiuto. Altrimenti arrivo alla fine (`$`) e accetto;\n- Per ogni coppia di stati $p,q$ del PDA aggiungo a $G$ una variabile $A_{pq}$. E a destra?\n\t- Se $q$ rimuove dalla stack lo stesso simbolo di $p$ c'è $aA_{rs}b$;\n\t- Altrimenti c'è $A_{pr}A_{rq}$.\n\t- Per induzione dimostro che sta roba funziona.","x":6080,"y":-2475,"width":697,"height":307,"color":"4"},
		{"id":"0003cf3fcb0b822f","type":"text","text":"# Tempo\n\nLa classe di complessità $\\mathbb{TIME}(t(n))$ racchiude tutti i problemi $O(t(n))$.\n\nDecidere il linguaggio $A=\\{0^k1^k\\,|\\,k\\geq0\\}$ può essere, a seconda dell'algoritmo usato, un problema $O(n^2)$ o $O(n\\log n)$, ma con una TM a singolo nastro non si può scendere oltre. Si può dimostrare che con due nastri questo problema diventa $O(n)$, e meglio di così a questo punto non si può davvero più fare (devo quantomeno leggere l'input, che è $O(n)$!).\n\n`THM` - Sia $t(n)\\geq n$. Ogni TM multinastro (TM$^k$) che risolve in tempo $t(n)$ ammette una TM a nastro singolo (TM) equivalente che risolve in tempo $O(t^2(n))$.\n\n- Questo si dimostra constatando che ogni passo di una TM$^k$ si può simulare in $O(n)$ passi in una TM.\n- Le TM e le TM$^k$ sono ***polinomialmente equivalenti***, ovvero simulare un problema su una TM piuttosto che su una TM$^k$ comporta un aumento di tempo di esecuzione al più polinomiale.\n\t- Tutti i modelli deterministici ragionevoli sono polinomialmente equivalenti, dove per \"ragionevole\" non c'è una vera e propria definizione, devi rendertene conto tu (?)\n\t\t- La codifica in base unaria (e.g. $12_1$=`111111111111`) non è ragionevole, in quanto esponenzialmente più lunga di qualsiasi notazione in base $k$ (e.g. $12_2=$ `1100`).\n\n`THM` - Sia $t(n)\\geq n$. Ogni TM non-deterministica (NDTM) che risolve in tempo $t(n)$ ammette una TM a nastro singolo equivalente che risolve in tempo $2^{O(t(n))}$.\n\n- Il tempo di esecuzione $t(n)$ è calcolato sul ramo più lungo della NDTM. Se l'albero può avere al più $b$ figli, segue che ci sono al più $b^{t(n)}$ foglie. Se per visitare ognuna di esse impiego $O(t(n))$ nel complesso impiego $O(t(n)b^{t(n)})$, ovvero $\\sim 2^{O(t(n))}$.","x":-4642,"y":-5399,"width":794,"height":798,"color":"4"}
	],
	"edges":[
		{"id":"061a943f3f8dee09","fromNode":"99a579f63e8ed830","fromSide":"right","toNode":"e865a825bb442798","toSide":"left"},
		{"id":"b76926175745ecea","fromNode":"963502012eaccd57","fromSide":"bottom","toNode":"9ce2f5e78688648f","toSide":"top"},
		{"id":"abce62a4589be198","fromNode":"e865a825bb442798","fromSide":"right","toNode":"963502012eaccd57","toSide":"left"},
		{"id":"daac544ac6812e6b","fromNode":"e865a825bb442798","fromSide":"bottom","toNode":"0d399f2af310e7d9","toSide":"top"},
		{"id":"af971900a5afc97c","fromNode":"99a579f63e8ed830","fromSide":"right","toNode":"0d399f2af310e7d9","toSide":"left"},
		{"id":"33ac7368af6e41cf","fromNode":"0d399f2af310e7d9","fromSide":"bottom","toNode":"1e66a8c6f7d0cfc8","toSide":"top"},
		{"id":"3152fb493363c0ae","fromNode":"99a579f63e8ed830","fromSide":"left","toNode":"8bb56d96ae177393","toSide":"right"},
		{"id":"e8bb8888467e626d","fromNode":"4026031a39513573","fromSide":"bottom","toNode":"09eeba7d186cc631","toSide":"top"},
		{"id":"46d61fce2e556b06","fromNode":"202120fe71270d90","fromSide":"bottom","toNode":"9c7bf0e17764ae61","toSide":"top"},
		{"id":"cba74ded9d6eb313","fromNode":"f4475828cc860da0","fromSide":"bottom","toNode":"3ce00288d2634111","toSide":"top"},
		{"id":"ad5af5a9cac1f141","fromNode":"d570218de39c6a66","fromSide":"right","toNode":"3ce00288d2634111","toSide":"left"},
		{"id":"914cf7cc98beffc2","fromNode":"d570218de39c6a66","fromSide":"bottom","toNode":"cb4951b922ab48e7","toSide":"top"},
		{"id":"aeaac25706a7b91d","fromNode":"8bb56d96ae177393","fromSide":"top","toNode":"3ce00288d2634111","toSide":"bottom"},
		{"id":"f72976544f69804b","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"4026031a39513573","toSide":"left"},
		{"id":"b4dc878ef985faa8","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"202120fe71270d90","toSide":"left"},
		{"id":"358157fc48b5854e","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"d570218de39c6a66","toSide":"left"},
		{"id":"caa5fc4be3edbfa3","fromNode":"8bb56d96ae177393","fromSide":"right","toNode":"99a579f63e8ed830","toSide":"left"},
		{"id":"3fa67981659672f8","fromNode":"e865a825bb442798","fromSide":"top","toNode":"816848e0c2ad721f","toSide":"bottom"},
		{"id":"95c743f9cae72d10","fromNode":"a2c08aa1f7f84ed6","fromSide":"bottom","toNode":"73b289d2ddac85e0","toSide":"top"},
		{"id":"eddf13983ba20bcc","fromNode":"816848e0c2ad721f","fromSide":"top","toNode":"2154feb042ce2858","toSide":"bottom"},
		{"id":"ee30ff7d6d74d2a8","fromNode":"2154feb042ce2858","fromSide":"right","toNode":"a2c08aa1f7f84ed6","toSide":"left"},
		{"id":"560b2850f8356943","fromNode":"2154feb042ce2858","fromSide":"right","toNode":"73b289d2ddac85e0","toSide":"left"},
		{"id":"5f59ce4f1f9a5a79","fromNode":"816848e0c2ad721f","fromSide":"right","toNode":"1f30c648db2dcf7a","toSide":"left"},
		{"id":"ee7b4d04995f25a2","fromNode":"1f30c648db2dcf7a","fromSide":"top","toNode":"1d66725355e2923e","toSide":"bottom"},
		{"id":"f8152284aeb3cc64","fromNode":"61927ba45cbb9ee6","fromSide":"top","toNode":"c373c2bee7cda5f4","toSide":"bottom"},
		{"id":"3602e2d11390b764","fromNode":"0d399f2af310e7d9","fromSide":"left","toNode":"1362d388c8714d48","toSide":"right"},
		{"id":"ac57bb28ae028a75","fromNode":"1e66a8c6f7d0cfc8","fromSide":"bottom","toNode":"58b249e919fb0f61","toSide":"top"},
		{"id":"42c1593ce6b44636","fromNode":"0d399f2af310e7d9","fromSide":"bottom","toNode":"5bd9813160538beb","toSide":"top"},
		{"id":"779edd5a8b9eb05a","fromNode":"5bd9813160538beb","fromSide":"right","toNode":"4b19755e121bf99d","toSide":"left"},
		{"id":"a0b24ad9c5e000e9","fromNode":"5ce0efb2ba6f0a14","fromSide":"left","toNode":"5bd9813160538beb","toSide":"right"},
		{"id":"7330244647f4eed7","fromNode":"5ce0efb2ba6f0a14","fromSide":"right","toNode":"4e5009f864f3c65f","toSide":"left"},
		{"id":"95c4cfe55a4db7f7","fromNode":"5bd9813160538beb","fromSide":"right","toNode":"5ce0efb2ba6f0a14","toSide":"left"},
		{"id":"6a482a0f495351a5","fromNode":"5bd9813160538beb","fromSide":"left","toNode":"20930ba61df4d18d","toSide":"right"},
		{"id":"b46b5be3ecb555f3","fromNode":"20930ba61df4d18d","fromSide":"bottom","toNode":"043186a341c6fc88","toSide":"top"},
		{"id":"cc5f2a057df50ece","fromNode":"5bd9813160538beb","fromSide":"bottom","toNode":"2ada182acf4c1e0a","toSide":"top"},
		{"id":"12e34a34ef9e9eaa","fromNode":"2ada182acf4c1e0a","fromSide":"bottom","toNode":"99633375e6887712","toSide":"top"},
		{"id":"0284f77ac605ac68","fromNode":"f4475828cc860da0","fromSide":"right","toNode":"99a579f63e8ed830","toSide":"top"},
		{"id":"f876d328428f5777","fromNode":"2ada182acf4c1e0a","fromSide":"right","toNode":"eb7f2e8ab3192fd4","toSide":"left"},
		{"id":"3caa0aabc84a2399","fromNode":"c65672ca13a7b7e6","fromSide":"left","toNode":"d506de86a1bc8de2","toSide":"right"},
		{"id":"1d67aee39e66738c","fromNode":"2d31e0c1351d0ffb","fromSide":"bottom","toNode":"f4475828cc860da0","toSide":"top"},
		{"id":"a995b2a6e585b158","fromNode":"eb6a901325ad751e","fromSide":"bottom","toNode":"2d31e0c1351d0ffb","toSide":"top"},
		{"id":"361c468f29d4b689","fromNode":"eb6a901325ad751e","fromSide":"right","toNode":"25cf3ba9630cd073","toSide":"left"},
		{"id":"caa98c295496aee7","fromNode":"c65672ca13a7b7e6","fromSide":"bottom","toNode":"3c7808314a6a65a4","toSide":"top"},
		{"id":"caa8b976d1848a74","fromNode":"86f18021d67b2c84","fromSide":"bottom","toNode":"79aa400e94a1e523","toSide":"top"},
		{"id":"dd4a66700075fa12","fromNode":"c65672ca13a7b7e6","fromSide":"right","toNode":"86f18021d67b2c84","toSide":"left"},
		{"id":"82170d31d64806c8","fromNode":"3c7808314a6a65a4","fromSide":"bottom","toNode":"25cf3ba9630cd073","toSide":"top"},
		{"id":"370e85ebd8394a6d","fromNode":"25cf3ba9630cd073","fromSide":"bottom","toNode":"4b1bc6387b1400ff","toSide":"top"},
		{"id":"ad90537751766fe7","fromNode":"25cf3ba9630cd073","fromSide":"top","toNode":"3c7808314a6a65a4","toSide":"bottom"},
		{"id":"2dc5819dcb82cb03","fromNode":"3c7808314a6a65a4","fromSide":"top","toNode":"c65672ca13a7b7e6","toSide":"bottom"},
		{"id":"a619dc38421825f3","fromNode":"4b1bc6387b1400ff","fromSide":"bottom","toNode":"e3140b0888a10451","toSide":"top"},
		{"id":"4d03c22cb63d58e5","fromNode":"4b1bc6387b1400ff","fromSide":"left","toNode":"0ae78bba12257fed","toSide":"right"},
		{"id":"569a0fe9f3f9981c","fromNode":"4b1bc6387b1400ff","fromSide":"left","toNode":"d7de6946e4bc7f9a","toSide":"right"},
		{"id":"b027c99885f74414","fromNode":"3c7808314a6a65a4","fromSide":"right","toNode":"ffe084b275eb59ea","toSide":"left"},
		{"id":"f7e68e5fd0d42c75","fromNode":"25cf3ba9630cd073","fromSide":"right","toNode":"ffe084b275eb59ea","toSide":"left"},
		{"id":"171864d75758346d","fromNode":"ffe084b275eb59ea","fromSide":"right","toNode":"7d835e05d31037b9","toSide":"left"},
		{"id":"43d3b157131fc4fc","fromNode":"25cf3ba9630cd073","fromSide":"right","toNode":"35512253a16ef8fb","toSide":"left"},
		{"id":"fc5ee540e760d718","fromNode":"35512253a16ef8fb","fromSide":"bottom","toNode":"1bba7fc6843da9ed","toSide":"top"},
		{"id":"077b4590df67ba19","fromNode":"35512253a16ef8fb","fromSide":"bottom","toNode":"b3cbd20b0f8552ad","toSide":"top"},
		{"id":"ce44a8bcfce22c32","fromNode":"b3cbd20b0f8552ad","fromSide":"bottom","toNode":"3165d6cf0955425d","toSide":"top"},
		{"id":"1ffcb5b779a1157d","fromNode":"b3cbd20b0f8552ad","fromSide":"bottom","toNode":"889eef30368d267d","toSide":"top"},
		{"id":"923c3baeb65bf5ac","fromNode":"35512253a16ef8fb","fromSide":"right","toNode":"7afe9f86cb997f73","toSide":"left"},
		{"id":"a7952db1ead542b5","fromNode":"25cf3ba9630cd073","fromSide":"right","toNode":"7399065d101f3426","toSide":"top"},
		{"id":"30a8c832a56afeab","fromNode":"35512253a16ef8fb","fromSide":"top","toNode":"1a3d8be48d89cd10","toSide":"bottom"},
		{"id":"1dbf56fd8d433aa9","fromNode":"7399065d101f3426","fromSide":"left","toNode":"81f7c5f806820e21","toSide":"right"},
		{"id":"f9078574063e4ff6","fromNode":"7399065d101f3426","fromSide":"bottom","toNode":"a7bbbcf16d78be3d","toSide":"top"},
		{"id":"2fcb516facd4f334","fromNode":"35512253a16ef8fb","fromSide":"left","toNode":"7399065d101f3426","toSide":"top"},
		{"id":"e57dc089172dd8a4","fromNode":"eb6a901325ad751e","fromSide":"left","toNode":"1656b8c70cab4477","toSide":"right"},
		{"id":"bf7da4b8090b9855","fromNode":"1656b8c70cab4477","fromSide":"bottom","toNode":"4628d3cf67be0bac","toSide":"top"},
		{"id":"769771a7e6f67026","fromNode":"1656b8c70cab4477","fromSide":"top","toNode":"d2b3b2bfc47be706","toSide":"bottom"},
		{"id":"22b05630de858f38","fromNode":"1656b8c70cab4477","fromSide":"left","toNode":"138aa249e84fcb30","toSide":"right"},
		{"id":"a88319a519c456c2","fromNode":"d2b3b2bfc47be706","fromSide":"left","toNode":"138aa249e84fcb30","toSide":"top"},
		{"id":"4f97dcb04df596a6","fromNode":"4628d3cf67be0bac","fromSide":"left","toNode":"138aa249e84fcb30","toSide":"bottom"},
		{"id":"8f4f5c80054d94de","fromNode":"138aa249e84fcb30","fromSide":"left","toNode":"519ecc774af20316","toSide":"right"},
		{"id":"b73061e826e3f098","fromNode":"519ecc774af20316","fromSide":"bottom","toNode":"badc752724c05104","toSide":"top"},
		{"id":"b3bc360139295e54","fromNode":"519ecc774af20316","fromSide":"left","toNode":"fd7e1512a2c6ab8a","toSide":"right"},
		{"id":"28844fa4773ea536","fromNode":"519ecc774af20316","fromSide":"top","toNode":"d21bd307e22c7adf","toSide":"bottom"},
		{"id":"7d1d99d8154d38d8","fromNode":"f4475828cc860da0","fromSide":"right","toNode":"699b4440e0614fe9","toSide":"left"},
		{"id":"5d7354d78650723c","fromNode":"d21bd307e22c7adf","fromSide":"left","toNode":"fd7e1512a2c6ab8a","toSide":"top"},
		{"id":"9d2aaf4418c35a37","fromNode":"badc752724c05104","fromSide":"left","toNode":"fd7e1512a2c6ab8a","toSide":"bottom"},
		{"id":"f1e654611cec5b6f","fromNode":"fd7e1512a2c6ab8a","fromSide":"left","toNode":"3c6616deb56d9fe1","toSide":"right"},
		{"id":"0d6c5e9aa91062bf","fromNode":"d21bd307e22c7adf","fromSide":"left","toNode":"c2535c4410e3aa2c","toSide":"right"},
		{"id":"031de0cc9c5a761f","fromNode":"3c6616deb56d9fe1","fromSide":"top","toNode":"c2535c4410e3aa2c","toSide":"bottom"},
		{"id":"5b25c9dad47e3685","fromNode":"3c6616deb56d9fe1","fromSide":"left","toNode":"f654be1e89b267b1","toSide":"right"},
		{"id":"b5707f044d85c3e8","fromNode":"4628d3cf67be0bac","fromSide":"right","toNode":"9f79465d79f67d58","toSide":"left"},
		{"id":"68a4cc368ce21d03","fromNode":"3c6616deb56d9fe1","fromSide":"bottom","toNode":"7b25aacced81d60a","toSide":"top"},
		{"id":"3b5e984208b458d5","fromNode":"7b25aacced81d60a","fromSide":"left","toNode":"0bb67531d979bdb2","toSide":"right"},
		{"id":"082eb39f6dbb466a","fromNode":"7b25aacced81d60a","fromSide":"bottom","toNode":"70f66f1d4a422169","toSide":"top"},
		{"id":"a0c6c678149ec543","fromNode":"615cc889d34c2798","fromSide":"left","toNode":"5837e017ee10fc48","toSide":"right"},
		{"id":"7ca0fd35c1f1ccbf","fromNode":"615cc889d34c2798","fromSide":"right","toNode":"b23054203a670419","toSide":"left"},
		{"id":"10d476cd859271c0","fromNode":"138aa249e84fcb30","fromSide":"top","toNode":"5885d0fdc9e36a95","toSide":"bottom"},
		{"id":"8ff249ea9ce4873f","fromNode":"0003cf3fcb0b822f","fromSide":"left","toNode":"84591e226f563dee","toSide":"right"},
		{"id":"c1c34fb66e103dcd","fromNode":"0003cf3fcb0b822f","fromSide":"top","toNode":"042b72a6e40509ab","toSide":"bottom"},
		{"id":"e920cfa3d273a806","fromNode":"042b72a6e40509ab","fromSide":"left","toNode":"113b371f38059915","toSide":"right"},
		{"id":"efcfed55ddcf6db6","fromNode":"84591e226f563dee","fromSide":"top","toNode":"113b371f38059915","toSide":"bottom"},
		{"id":"820b7f696b1d23ef","fromNode":"5885d0fdc9e36a95","fromSide":"left","toNode":"0003cf3fcb0b822f","toSide":"right"},
		{"id":"866e8b0c7789e8f3","fromNode":"84591e226f563dee","fromSide":"bottom","toNode":"5a5636216755aaa2","toSide":"top"},
		{"id":"165238fa3492b3a1","fromNode":"d21bd307e22c7adf","fromSide":"top","toNode":"5a5636216755aaa2","toSide":"right"},
		{"id":"b179883088c82da2","fromNode":"5a5636216755aaa2","fromSide":"right","toNode":"d21bd307e22c7adf","toSide":"top"},
		{"id":"fee979d2e9a803ef","fromNode":"042b72a6e40509ab","fromSide":"top","toNode":"18f18f4d08423a52","toSide":"bottom"},
		{"id":"bf6ec2133ce0dff3","fromNode":"042b72a6e40509ab","fromSide":"right","toNode":"86f76c5a5c545ccf","toSide":"left"},
		{"id":"769ff0ab9422c8ca","fromNode":"113b371f38059915","fromSide":"top","toNode":"c88a9399c22aee11","toSide":"bottom"},
		{"id":"53c603fd44f81f50","fromNode":"042b72a6e40509ab","fromSide":"left","toNode":"c88a9399c22aee11","toSide":"right"},
		{"id":"e595bf298e9c012e","fromNode":"c88a9399c22aee11","fromSide":"top","toNode":"1462ab03ca563271","toSide":"bottom"},
		{"id":"60d8f971d2d6ac89","fromNode":"1462ab03ca563271","fromSide":"right","toNode":"51cbb52198466193","toSide":"left"},
		{"id":"dac37cad1ec42cd4","fromNode":"c88a9399c22aee11","fromSide":"top","toNode":"b28ed044f0e6cdb1","toSide":"bottom"},
		{"id":"7c76f7826208eeb3","fromNode":"18f18f4d08423a52","fromSide":"top","toNode":"b28ed044f0e6cdb1","toSide":"bottom"},
		{"id":"074ae8bb6b2a9c80","fromNode":"c88a9399c22aee11","fromSide":"left","toNode":"a7193d37b6c8c4a4","toSide":"right"},
		{"id":"26f6e0fde1c6d011","fromNode":"1462ab03ca563271","fromSide":"left","toNode":"a7193d37b6c8c4a4","toSide":"right"},
		{"id":"fb7dc2070746fd0d","fromNode":"c88a9399c22aee11","fromSide":"right","toNode":"18f18f4d08423a52","toSide":"left"},
		{"id":"38addd1d3e9938c0","fromNode":"18f18f4d08423a52","fromSide":"left","toNode":"c88a9399c22aee11","toSide":"right"},
		{"id":"a09e188b2aefab8f","fromNode":"18f18f4d08423a52","fromSide":"right","toNode":"1058f6e7a3cd10b1","toSide":"left"},
		{"id":"b2c2df99ef5fcae3","fromNode":"5885d0fdc9e36a95","fromSide":"right","toNode":"a24e2f4816cc28b5","toSide":"left"},
		{"id":"059534583f1e12ad","fromNode":"a24e2f4816cc28b5","fromSide":"right","toNode":"237d28d885cf8413","toSide":"left"},
		{"id":"e5198c67a41d08c9","fromNode":"237d28d885cf8413","fromSide":"right","toNode":"64b8624fa2711561","toSide":"left"},
		{"id":"513a5868dfdeb1cc","fromNode":"64b8624fa2711561","fromSide":"right","toNode":"3b299722dbb949ea","toSide":"left"},
		{"id":"a3b4ebb274935e06","fromNode":"a24e2f4816cc28b5","fromSide":"bottom","toNode":"4a3db5d9f4f76c56","toSide":"top"},
		{"id":"23dc22c4dd867c6d","fromNode":"4a3db5d9f4f76c56","fromSide":"right","toNode":"237d28d885cf8413","toSide":"bottom"},
		{"id":"7af06a8fecb9c70b","fromNode":"5885d0fdc9e36a95","fromSide":"top","toNode":"5eafa3a2b48a383f","toSide":"bottom"},
		{"id":"11e90a4e651f1649","fromNode":"5eafa3a2b48a383f","fromSide":"top","toNode":"a5773f254e5128d7","toSide":"bottom"},
		{"id":"6b836f9e409fe6f1","fromNode":"a5773f254e5128d7","fromSide":"right","toNode":"a8ad49269f2ac9bb","toSide":"left"},
		{"id":"4bfc5462fe9a963a","fromNode":"5eafa3a2b48a383f","fromSide":"right","toNode":"41fddac8468fe1b9","toSide":"left"},
		{"id":"b8ab0210d0234e20","fromNode":"7afe9f86cb997f73","fromSide":"right","toNode":"e5b1cbb0be578016","toSide":"left"}
	]
}