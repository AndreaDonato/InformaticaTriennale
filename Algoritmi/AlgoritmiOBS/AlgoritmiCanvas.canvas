{
	"nodes":[
		{"id":"3cb8fa98b476d018","type":"text","text":"# Notazione Asintotica\n\n- $O$ definisce il ***limite superiore asintotico*** (i.e. \"non oltre questo andamento asintotico\");\n- $\\Omega$ definisce il ***limite inferiore asintotico*** (i.e. \"non meno di questo andamento asintotico);\n- $\\Theta$ definisce l'***esatto comportamento asintotico*** (i.e. se $f(n)$ è sia in $O(g(n))$ sia in $\\Omega(g(n))$ allora è $\\Theta(g(n))$). \n\n$$1 ≺ log_a (n) ≺ \\sqrt[b]{n} ≺ n^c ≺ d^n ≺ n! ≺ n^n$$","x":800,"y":-21,"width":628,"height":520,"color":"4"},
		{"id":"d58e07debc64d646","type":"text","text":"# Algoritmi\n\nUn ***algoritmo*** è una ***sequenza di comandi elementari ed univoci che terminano in un tempo finito*** ed operano su strutture dati.\n","x":-120,"y":148,"width":628,"height":182,"color":"6"},
		{"id":"26ecf9a9035be6c9","type":"text","text":"# Costo Computazionale\n\nLe performance di un algoritmo sono valutate su un modello di macchina astratta (dunque indipendente dalla specifica macchina che lo esegue) detta ***Random Access Machine*** (***RAM***), tale che\n\n- Esiste un solo CPU core che esegue le operazioni sequenzialmente;\n- Esiste un limite alle dimensioni degli oggetti memorizzabili.\n- Esistono solo operazioni elementari, e richiedono un tempo costante;\n\t- Questo è vero solo se assumiamo che i dati siano più brevi delle *word* di memoria, ed è detta ***misura di costo uniforme***.\n\nIntuitivamente, il costo di un algoritmo è una funzione monotona non decrescente dell'input. In particolare, è la somma dei costi di tutte le istruzioni che lo compongono. Dal momento che ogni operazione elementare ha costo costante, l'unica cosa che fa crescere il costo asintotico sono i ***cicli***.\n\nIn generale, a seconda dell'input l'algoritmo può presentare un costo migliore o peggiore. Ci focalizziamo sul ***caso peggiore***.","x":-1080,"y":-21,"width":628,"height":520,"color":"4"},
		{"id":"c2548ea0755bf41c","type":"text","text":"# Ottimizzazione II\n\nProblema: devo calcolare un polinomio in un punto. Come faccio?\n\n```\ndef Calcola_Polinomio(A, x):\n\tsomma = 0\n\tfor i in range(len(a)):\n\t\tpotenza = 1\n\t\tfor j in range(i):\n\t\t\tpotenza = x*potenza\n\t\tsomma = somma + A[i]*potenza\n\treturn somma\n```\n\nQuesto algoritmo è $\\Theta(n^2)$. Posso fare di meglio? Sì, dal momento che le potenze sono sequenziali posso usare \"ricorsivamente\" quella precedente:\n\n```\ndef Calcola_Polinomio_Intelligente(A, x):\n\tsomma = 0\n\tpotenza = 1\n\tfor i in range(len(a)):\n\t\tpotenza = x*potenza\n\t\tsomma = somma + A[i]*potenza\n\treturn somma\n```\n\nC'è un solo ciclo `for`, ergo questo è $\\Theta(n)$.","x":-120,"y":-851,"width":628,"height":671,"color":"4"},
		{"id":"229254fddfcb152d","type":"text","text":"# Ottimizzazione I\n\nProblema: devo sommare i primi $n$ interi. Come faccio?\n\n```\ndef CalcolaSomma(n):\n\tsomma = 0\n\tfor i in range (1, n + 1):\n\t\tsomma += i\n\treturn somma\n```\n\nQuesto algoritmo ha costo $\\Theta(n)$. Ma posso fare di meglio? Sì, perché\n$$\\sum_{i=1}^nk = \\frac{n(n+1)}{2}$$\nche tradotto in codice significa\n\n```\ndef CalcolaSommaIntelligente(n):\n\tsomma = n*(n+1)/2\n\treturn somma\n```\nche ha costo $\\Theta(1)$. Morale della favola? A volte si può ottimizzare.","x":-1080,"y":-851,"width":628,"height":671,"color":"4"},
		{"id":"0c6a12bec4ec08b4","type":"text","text":"# Quante iterazioni?\n\nPrendiamo un `n` positivo, inizializziamo `x = r = 0` e valutiamo\n\n```\nwhile x*x < n:\n\tx += 1\n```\n\nLa condizione di terminazione del ciclo è $x^2 \\geq n$, quindi si ha uguaglianza dopo circa $x \\simeq \\sqrt{n}$ iterazioni $\\Rightarrow \\Theta(\\sqrt{n})$.\n\nSe invece consideriamo una situazione in cui decremento $n$ di $2^k$\n\n```\nwhile n > 1:\n\tn = n//2\n```\n\navrò uguaglianza nella condizione per $\\frac{n}{2^k} \\simeq 1$, ovvero dopo $k \\simeq log_2(n)$ iterazioni. Viene da sé che decrementare $n$ in modo logaritmico porta ad un numero esponenziale di iterazioni.","x":-1940,"y":-21,"width":560,"height":520,"color":"4"},
		{"id":"eb76c79fdbda44ba","type":"text","text":"# Esempio $\\Theta$ Esponenziale\n\n```\nx = t = 1\nfor i in range(n):\n\tt = 3*t\nt -= 1\nwhile t >= x:\n\tx += 2\n\tt -= 2\n```\n\nAl termine del primo ciclo (di costo $\\Theta(n)$) `t` vale $3^n$. Nel secondo ciclo `x` e `t` provano a colmare l'esponenziale distanza che li separa con incrementi lineari. Dopo $k$ iterazioni del `while` `x` vale $2k+1$, mentre `t` vale $3^n - (2k+1)$. La condizione per terminare il `while` è quindi $3^n = 2(2k+1)$, ovvero $k = \\frac{3^n-2}{4} \\Rightarrow \\Theta(3^n)$.","x":-2240,"y":640,"width":560,"height":431,"color":"4"},
		{"id":"0d969a895166efd0","type":"text","text":"# Esempio $\\Theta = log(log(n))$\n\n```\np = 2\nwhile n >= p:\n\tp=p*p\n```\n\nAd ogni iterazione `p` viene incrementato del suo quadrato. Dopo $k$ iterazioni sarà $2^{2^k}$. Condizione di terminazione è che $2^{2^k} = n + 1$, ovvero dopo $k \\simeq log_2(log_2(n+1))$ iterazioni $\\Rightarrow \\Theta\\big(log_2(log_2(n))\\big)$.","x":-1640,"y":640,"width":560,"height":431,"color":"4"},
		{"id":"69e1b6e849e034bc","type":"text","text":"# Tempo di Esecuzione\n\nUna volta stabilito l'andamento asintotico, possiamo stabilire quanto tempo impiega l'algoritmo ad essere eseguito su una macchina di cui conosciamo il numero $k$ di operazioni al secondo:\n\n$$T =\\frac{f(n)}{k}$$\nSe ad esempio la macchina esegue un'operazione elementare in un nanosecondo $k = 10^9$, per un input $n = 10^6$ abbiamo\n\n- $O(n)$ - $T = 1ms$\n- $O(nlog(n))$ - $T \\sim 20ms$\n- $O(n^2)$ - $T = 17\\,min$\n- $O(2^n)$ - $T \\sim 10^{13}\\,yrs$\n\n\n","x":-1940,"y":-721,"width":560,"height":411,"color":"4"},
		{"id":"5c46055a11913af6","type":"text","text":"# Proprietà della notazione asintotica\n\nSe mi ritrovo un ciclo annidato, il costo complessivo è dato da $$\\sum_{i=0}^n \\Theta(i) = \\Theta\\bigg(\\sum_{i=0}{i}\\bigg) = \\Theta(n^2)$$ \nÈ possibile ***portare la sommatoria dentro la $\\Theta$*** (e viceversa).","x":800,"y":-624,"width":628,"height":217,"color":"4"},
		{"id":"ec8b575605b1f28b","type":"text","text":"# Ricerca\n\nL'input di un problema di ricerca sono un ***array*** `A` di $n$ elementi ed un ***valore `v` da trovare*** al suo interno. L'output è l'indice del valore trovato, o un `NULL` in caso non esista.\n\n\n","x":-1914,"y":1696,"width":508,"height":150,"color":"6"},
		{"id":"8dc6dea62661677d","type":"text","text":"# Ricerca Sequenziale\n\n\nUn algoritmo di ***ricerca sequenziale*** è intuitivamente $O(n)$ (il caso peggiore è quello in cui il valore non esiste, devo scorrere tutto l'array), ma è anche $\\Omega(1)$ se l'elemento è in prima posizione.\n\nSegue che non è semplice determinare il costo asintotico stretto $\\Theta$ di un un simile algoritmo, motivo per cui per farlo si stima un valore atteso per il numero di iterazioni. La *pdf* per il valore $v$ lungo l'array è piatta a priori:\n$$P = \\frac{1}{n} \\Rightarrow \\langle n\\rangle = \\sum_{k = 0}^n\\frac{k}{n} = \\frac{1}{n}\\frac{n(n+1)}{2} = \\frac{n+1}{2} \\sim \\frac{n}{2}$$\nIl comando `in` di Python, ad esempio, usa una ricerca sequenziale per determinare condizioni del tipo `if v in A`, risultando quindi $\\Theta(n)$.","x":-2380,"y":2116,"width":700,"height":388,"color":"4"},
		{"id":"6d8b317b86100794","type":"text","text":"# Ricorsione\n\nUn algoritmo ricorsivo procede riducendo la dimensione del problema e richiamando se stesso finché l'input ridotto non lo fa ricadere nel ***caso base***, spesso di costo $\\Theta(1)$.","x":-60,"y":1696,"width":508,"height":150,"color":"6"},
		{"id":"309351163ae6947b","type":"text","text":"# Ordinamento\n\nLa classe di algoritmi più importante e dispendiosa a livello globale. Si basano sulla relazione d'ordine di un campo chiave del record da ordinare.","x":1794,"y":1696,"width":504,"height":150,"color":"6"},
		{"id":"6161eae15a3e550b","type":"text","text":"# Ricerca Ricorsiva\n\nOgni algoritmo ricorsivo ha una formulazione iterativa, magari non ovvia. Non è invece vero il viceversa. Gli algoritmi di ricerca possiedono una versione ricorsiva.\n\nLa ***ricerca sequenziale*** è implementabile ricorsivamente analizzando l'ultimo elemento dell'array e, nel caso in cui non venga trovato il valore `v`, effettuando la chiamata ricorsiva sull'array di dimensione `n-1`.\n\nLa ***ricerca binaria*** ha due possibili chiamate ricorsive, a seconda che sia necessario considerare la parte superiore o inferiore dell'array.\n\nIn generale, la versione iterativa è più efficiente della controparte ricorsiva. Quest'ultima si utilizza solo se a livello di codice è molto più ovvio rispetto all'iterazione (e.g. Fibonacci).","x":-1163,"y":1600,"width":860,"height":343,"color":"4"},
		{"id":"3b1ca8e5ad600d47","type":"text","text":"# Equazioni di Ricorrenza\n\nCome valuto il costo computazionale di un algoritmo ricorsivo?\n```\ndef Fattoriale(n):\n\tif (n == 0): return 1\n\treturn n*Fattoriale(n-1)\n```\nSe $T(n)$ è il costo dell'algoritmo, allora devo costruirlo come$$T=\\begin{cases}\nT(n) = \\Theta(1) + T(n-1)\\\\\nT(0) = \\Theta(1)\n\\end{cases}$$Questa è chiaramente un'equazione ricorsiva, e dove scrivo $\\Theta(1)$ sto assumendo che il costo del resto del codice (non ricorsivo) sia costante, così come che lo sia il caso base.\n\nCi sono sostanzialmente 4 modi di risolvere questa roba.","x":-90,"y":2116,"width":568,"height":461,"color":"4"},
		{"id":"7e4058ebe27c3056","type":"text","text":"# Metodo Iterativo\n\n$T(n) = \\Theta(1) + T(n-1)$, ma $T(n-1) = \\Theta(1) + T(n-2)$, quindi $$T(n) = k\\cdot \\Theta(1) + T(n-k)$$Questa roba va avanti finché $n-k = 1$ (caso base), quindi $k = n-1$. Banalmente sostituisco e trovo $$T(n) = (n-1)\\cdot \\Theta(1) + T(n-(n-1)) = \\Theta(n)$$In modo analogo se ad ogni chiamata dimezzo l'input (e.g. ricerca binaria) otterrò$$T(n) = T\\bigg(\\frac{n}{2^k}\\bigg)+k\\cdot\\Theta(1)$$caso base per $\\frac{n}{2^k} = 1 \\Rightarrow k = log_2(n)$, sostituendo ottengo$$T(n) = \\Theta(log_2(n))$$","x":-1011,"y":2920,"width":591,"height":446,"color":"4"},
		{"id":"bc1a401f9f7f9064","type":"text","text":"# Limiti del Metodo Iterativo\n\nSe provo a seguire questo procedimento per Fibonacci, mi rendo conto di non poter generalizzare, perché$$T (n) = T (n − 1) + T (n − 2) + Θ(1)$$porta ad uno zoo di termini non scrivibili in modo banale con un $k$.\n\nE quindi? ***Maggiorazione, minorazione***, ed eventualmente una variante asintotica del teorema dei carabinieri. Tipo, sicuramente$$T (n − 1) + T (n − 2) ≤ T (n − 1) + T (n − 1)$$il che è fattibile col metodo iterativo, portando ad una roba tipo$$T'(n) = 2[2\\,T' (n-2) + Θ(1)] + Θ(1) = [...] = 2^k\\,T'(n-k) +\n\\sum_{i=0}^{k-1}2^i\\,Θ(1)$$dove il caso base è raggiunto per $k=n-1$, dunque$$T'(n) = \\Theta(2^n) + (2^{n-1}-1)\\cdot\\Theta(1) = \\Theta(2^n)$$Se $T(n)\\leq T'(n)$, allora $T(n) = O(2^n)$. Con la minorazione la questione è un po' più *pelosa*, perché$$T (n − 1) + T (n − 2) \\geq T (n − 2) + T (n − 2)$$il che porta ad una$$T''(n) = 2\\cdot T''(n−2k) +\n\\sum^{k−1}_{i=0} 2^i Θ(1)$$\nquindi caso base per $k\\simeq n/2$, da cui ricavo $\\Theta(\\sqrt{2^n})$, ma essendo $T(n)\\geq T''(n)$ avrò che $T(n) = \\Omega(\\sqrt{2^n})$.\n\nIn questo caso limite superiore ed inferiore non coincidono, niente carabinieri. Posso solo dire che$$c_1 · \\sqrt{2^n} ≤ T (n) ≤ c_2 · 2^n$$","x":-1011,"y":3480,"width":591,"height":860,"color":"4"},
		{"id":"5ab0c89fe6fc2d30","type":"text","text":"# Metodo di Sostituzione\n\nDevi fare un *ansatz* e pregare.\n\n- Cerco anzitutto l'$O$-grande. Ipotizzo che $T(n) \\leq k\\cdot f(n)$;\n- Sostituisco le $\\Theta(1)$ con delle costanti;\n- Controllo il caso base per $n = 1$;\n- Faccio il passo induttivo, cioè uso l'*ansatz*.\n- Rifaccio il tutto con $\\Omega$. Chiaramente uso sempre la stessa $f(n)$.\n- Se sono vere entrambe, ho trovato $\\Theta$.","x":-308,"y":2920,"width":437,"height":446,"color":"4"},
		{"id":"90a96a97d8b70809","type":"text","text":"# Metodo dell'Albero\n\nÈ il ***metodo iterativo***, però con il grafico. Tipo regole di Feynman, ma inutile. Se ho ad esempio\n$$T (n) = 2\\cdot T\\bigg(\\frac{n}{2}\\bigg) + Θ(n^2)$$\n$\\Theta(n^2)$ è la radice, e ho $2$ figli chiamati $T(n/2)$. Per riottenere $T(n)$ devo sommare tutti i termini, quindi ho $2$ figli della forma $$T\\bigg(\\frac{n}{2}\\bigg)=2\\cdot T\\bigg(\\frac{n}{2^2}\\bigg) + Θ\\bigg((\\frac{n}{2})^2\\bigg)$$più ovviamente il nodo genitore $Θ(n^2)$. Raggiungo l'iterazione $k$, mi esce una roba oscena che generalizza l'espressione di $T(n)$, realizzo di essere tornato al metodo iterativo.","x":260,"y":2920,"width":437,"height":446,"color":"4"},
		{"id":"4f60934c85991f1d","type":"text","text":"# Metodo Principale\n\nConosco la soluzione esatta delle equazioni ricorsive della forma$$T(n) = α · Θ\\bigg(\\frac{n}{β}\\bigg)+ f(n)$$dove $\\alpha \\geq 1$ e $\\beta > 1$. A questo punto si possono verificare tre casi, che discendono dal confronto tra $f(n)$ ed $n^{log_\\beta(\\alpha)}$.\n\n- $f(n) = O(n^{log_\\beta(\\alpha)-\\varepsilon})$, ovvero se asintoticamente vince $n^{log_\\beta(\\alpha)}$ allora $T(n) = \\Theta(n^{log_\\beta(\\alpha)}))$;\n- $f(n) = \\Theta(n^{log_\\beta(\\alpha)})$ - In questo caso $T(n) = \\Theta(n^{log_\\beta(\\alpha)})\\cdot log(n))$;\n- $f(n) = \\Omega(n^{log_\\beta(\\alpha)+\\varepsilon})$, e per qualche motivo bisogna aggiungere che $c\\cdot f(n) \\geq \\alpha\\cdot f(n/\\beta)$, cioè nel complesso $f(n)$ vince asintoticamente su $n^{log_\\beta(\\alpha)}$ ed è più grande di quella roba (sempre asintoticamente), allora $T(n) = \\Theta(f(n))$;","x":829,"y":2920,"width":571,"height":446,"color":"4"},
		{"id":"839a6bd47e0cb007","type":"text","text":"# Insertion Sort\n\nParto dal secondo elemento, mi chiedo se è maggiore del primo. Se così non è, sposto l'elemento `1` in posizione `2` e inserisco l'elemento `2` in posizione `1`. In questo modo i primi due sono ordinati. Poi passo al terzo, e sposto a destra un elemento alla volta finché non trovo la posizione giusta secondo l'ordinamento, quindi lo inserisco.\n\nAl passo $i$ avrò tutti gli elementi $<i$ già ordinati (non necessariamente nell'ordine definitivo!) e quelli $>i$ ancora da ordinare. Pseudocodice:\n\n```\nfor j in range(1, len(A)):\n\tx = A[j]\n\ti = j-1\n\twhile (i >= 0 and A[i] > x)\n\t\tA[i+1] = A[i]\n\t\ti = i-1\n\tA[i+1] = x \n```\n\n- ***Caso migliore*** - L'array è già ordinato, ma devo comunque verificare che lo sia (quindi scorrerlo). $\\Theta(n)$.\n- ***Caso peggiore*** - L'array è ordinato in verso opposto, ogni while scorre nuovamente l'array a ritroso. $\\Theta(n^2)$.","x":829,"y":1441,"width":571,"height":660,"color":"4"},
		{"id":"308ddaa4fba0f145","type":"text","text":"# Selection Sort\n\nCerco il minimo, lo scambio con l'elemento in prima posizione. Ripeto iterativamente con l'array dal secondo elemento in poi.\n\n```\nfor i in range(len(A)-1):\n\tm = i\n\tfor j in range(i+1,len(A)):\n\t\tif (A[j] < A[m])\n\t\t\tm = j\n\t\tA[m], A[i] = A[i], A[m]\n```\n\nNon essendoci alcun `while` ma solo cicli `for`, c'è solo un andamento asintotico esatto $\\Theta(n^2)$.","x":1115,"y":2260,"width":571,"height":461,"color":"4"},
		{"id":"b49cf2c6d986d25c","type":"text","text":"# Bubble Sort\n\nScorro l'array da destra a sinistra analizzando gli elementi contigui. Se una coppia non rispetta la relazione d'ordine viene scambiata, altrimenti no. Viene da sé che automaticamente il minimo viene subito portato in prima posizione, quindi si ripete con il sotto-array con `n-1` elementi.\n```\nfor i in range(len(A)):\n\tfor j in range(len(A)-1, i-1):\n\t\tif (A[j] < A[j-1])\n\t\t\tA[j], A[j-1] = A[j-1], A[j]\n```\nDoppio ciclo `for` significa costo $\\Theta(n^2)$.","x":1761,"y":2260,"width":571,"height":461,"color":"4"},
		{"id":"70e8fb607562e26c","type":"text","text":"# Ricerca Binaria\n\nUn algoritmo di ***ricerca binaria***, invece, ***assume che gli elementi siano ordinati*** e procede per bisezione. Questo si riassume in due step.\n\n- Controllo l'elemento centrale dell'array. Se è esattamente il valore che cerco ho finito, altrimenti ci sono due possibili casi:\n\t- Il mio elemento è più piccolo $\\Rightarrow$ devo cercare nel mezzo-array di sinistra;\n\t- Il mio elemento è più grande $\\Rightarrow$ devo cercare nel mezzo-array di destra.\n- Itero finché non resta un solo elemento. Se corrisponde a $v$ restituisco l'indice, altrimenti restituisco `NULL` (o `-1`, o `come ti pare`).\n\nIl caso migliore è $\\Omega(1)$, ma quello peggiore? Devo dividere l'array fino ad avere un solo elemento. Se per farlo biseco $k$ volte la lunghezza è esprimibile come $\\frac{n}{2^k}$, che sarà quindi pari a $1$. Questo significa che $k = log_2(n)$, quindi è $O(log_2(n))$.\n\nE l'andamento stretto? Per farlo devo assumere che\n\n - La *pdf* per `v` all'interno di `A` (quindi $v\\in A$) è piatta;\n - Per semplicità di calcolo, $n$ è una potenza di $2$.\n\nDopo $k$ iterazioni sono state controllate $2^{k-1}$ posizioni ($1$ dopo una iterazione, $2$ dopo due, $4$ dopo tre, ...), quindi una frazione $\\frac{2^{k-1}}{n}$ dell'array. Ma visto che la *pdf* di `v` in `A` è piatta, questa è anche la probabilità di trovare `v` alla $k$-esima iterazione, ovvero la probabilità di fare esattamente $k$ iterazioni. Quindi il valor medio è\n$$\\langle n\\rangle = \\sum_{k=0}^{log_2(n)}\\bigg(k\\,\\cdot\\,\\frac{2^{k-1}}{n}\\bigg) = [...] = log_2(n) +\\frac{1}{n} - 1 = \\Theta(log_2(n))$$","x":-1640,"y":2116,"width":700,"height":697,"color":"4"},
		{"id":"465cbbbb72157ad0","type":"text","text":"# Complessità Minima dell'Ordinamento per Confronto \n\nGli algoritmi *naive* sono tutti $\\Theta(n^2)$. Si può fare di meglio? Se sì, quanto?\n\nPer rispondere a questa domanda costruiamo un ***albero di decisione binaria*** in cui\n\n- Ogni nodo è un confronto tra due valori, e ha esattamente due figli;\n\t- i.e. i casi sono due: $a>b$ oppure $a\\leq b$.\n- Ogni foglia è una permutazione della sequenza di input.\n\nA questo punto è utile notare alcune cose.\n\n1. Il caso peggiore corrisponde al percorso più lungo sull'albero, cioè ad $h$ step (dove $h$ è l'altezza dell'albero);\n2. Dato un input di $n$ elementi esistono $n!$ permutazioni, e una sola è soluzione;\n3. Un albero binario di altezza $h$ non può contenere più di $2^h$ foglie.\n\nSegue dalle affermazioni `2` e `3` che $2^h \\geq n!$, ovvero $h \\geq log_2(n!)$. Ma nel nome di Stirling sappiamo che $log(n!) = \\Theta(n\\,log(n))$, quindi$$h\\geq\\Theta(n\\,log(n)) \\Rightarrow h = \\Omega(n\\,log(n))$$Questo ci dice che ***qualsiasi algoritmo di ordinamento basato su confronti ha un costo asintotico minimo*** pari a $n\\,log(n)$. Esistono algoritmi che toccano questo minimo?","x":3160,"y":2200,"width":792,"height":581,"color":"4"},
		{"id":"302746ef669b26dc","type":"text","text":"# Merge Sort\n\nAlgoritmo basato sulla filosofia ***divide et impera***. Perché? Ma perché prende un array ed inizia a dimezzarlo fino ad ottenere i singoli elementi, che a questo punto sono facili da gestire.\n\nQuesta roba si fa chiamando ricorsivamente la funzione `MergeSort`, al cui interno ha la funzione di `Merge`che combina due array ordinati in un unico array ordinato con costo $\\Theta(n)$.\n\nCome faccio ad essere certo di partire con due array ordinati? Il caso base che ferma le chiamate ricorsive è quello in cui si ottengono i singoli elementi, che essendo singoli elementi sono per definizione array già ordinati.\n\nLo pseudocodice ricorsivo è una roba del tipo\n\n```\ndef MergeSort(A, LeftPointer = 0, EndPointer = len(A) - 1):\n\tif (LeftPointer < EndPointer)\n\t\tMiddlePointer = (LeftPointer + EndPointer) // 2\n\t\tMergeSort(A, LeftPointer, MiddlePointer)\n\t\tMergeSort(A, MiddlePointer + 1, EndPointer)\n\t\tMerge(A, LeftPointer, MiddlePointer, EndPointer)\n```\n\nTenendo traccia dell'ordine delle chiamate ricorsive, si entra sempre prima nella parte sinistra fino al caso base, che consiste semplicemente nello *skippare* l'intero corpo della funzione (perché controllo che `LeftPointer < EndPointer`, il che è falso se c'è un solo elemento). Una volta arrivati al primo elemento singolo a sinistra si procede con quello a destra, per poi finalmente ordinare la prima coppia. Poi si passa alla successiva coppia, quindi si ordinano i primi quattro elementi, e così via. Complessivamente, l'ordinamento avviene da sinistra a destra.\n\nE il costo computazionale? Possiamo scriverlo come$$T(n) = \\Theta(1) + 2T\\bigg(\\frac{n}{2}\\bigg) + \\Theta(n)$$dove $2\\,T(\\frac{n}{2})$ sono le due chiamate ricorsive in cui l'input è dimezzato e $\\Theta(n)$ è il costo di `Merge`.\nPer il costo complessivo possiamo applicare il ***metodo principale*** per le equazioni di ricorrenza.\n\n$\\alpha = \\beta = 2$, quindi $n^{log_\\beta(\\alpha)} = n$, motivo per cui $f(n) = \\Theta(n)$ ha proprio lo stesso andamento asintotico. Siamo nel caso di uguaglianza, quindi il costo complessivo è$$T_{\\text{MergeSort}} = \\Theta(n\\,log(n))$$Quindi d'ora in poi usiamo solo questo, no? ...no. Ci sono due problemi.\n\n- Serve necessariamente un array di appoggio, e se volessi modificare la funzione `Merge` per renderla simile all'Insertion Sort mi diventerebbe $\\Theta(n^2)$. Devo quindi mettere in conto che il Merge Sort ***usa una grande quantità di memoria*** (oltretutto è ricorsivo!);\n- Pur vero che il costo asintotico è molto basso, ***per piccoli input conviene l'Insertion Sort***.\n\nAllora posso mettere un `if` che per piccoli input $k < n$ usa l'Insertion al posto del Merge. Già, ma che significa \"piccolo\" in questo caso? Con dei conti che non ho voglia di fare si arriva a dire che il piccolo input $k$ deve essere tale che$$k\\leq c\\cdot log_b(k)$$Questa roba ha soluzioni solo se $c \\geq b$, e non esiste un modo giusto per determinarlo (se non con algoritmi di ottimizzazione che prendono in input l'algoritmo misto Merge-Insertion e lo testano su diversi dataset). Questa disequazione è una roba non lineare, per cui la soluzione è un range in cui $k$ è compreso. La larghezza di questo range è proporzionale a $k$, motivo per cui le librerie standard che implementano questa variante usano tipicamente valori tra `5` e `20`.\n\nConviene avere un range largo perché l'algoritmo vorrebbe \"vedere\" solo l'estremo superiore (e usarlo come soglia), perché appena la condizione è verificata si passa alla funzione che implementa l'Insertion Sort (quindi niente più check). Se il range è breve rischio di saltarlo!","x":3160,"y":3000,"width":792,"height":1443,"color":"4"},
		{"id":"9a1c5c47a77e2038","type":"text","text":"# Funzione di Merge\n\nDati due array ordinati esiste un modo molto ottimizzato di fonderli in un unico array ordinato.\n\nParto dai primi elementi di entrambi. Chiaramente il minimo complessivo è il minimo tra questi due valori. Diciamo che è nel primo array. Vado avanti confrontando l'elemento `2` del primo e l'elemento `1` del secondo. E via dicendo. La cosa bella è che se esaurisco gli elementi di uno dei due array posso banalmente copiare in blocco i rimanenti dell'altro. Quindi\n\n- ***Caso migliore*** - Uno dei due array contiene già tutti i minimi, devo solo fare $n/2$ iterazioni per verificare che lo siano e poi copio in blocco l'altro array.\n\t- Controllare i minimi è $\\Theta(n)$, ma per copiare i restanti devo pure fare $n/2$ iterazioni. Quindi nel complesso $\\Theta(n)+\\Theta(n)=\\Theta(n)$.\n- ***Caso peggiore*** - I minimi sono alternati, quindi mi accollo $n$ iterazioni in cui confronto uno per uno tutti gli elementi. In questo caso però non c'è nessun pezzo di algoritmo che copia gli elementi restanti (perché non ce ne sono), quindi nel complesso è ancora $\\Theta(n)$.\n","x":2408,"y":3000,"width":676,"height":502,"color":"4"},
		{"id":"5c0d1ea27e63b5d6","type":"file","file":"AlberoSuTreElementi.png","x":2408,"y":2340,"width":676,"height":301},
		{"id":"ed03fe8d87064a44","type":"file","file":"MergeSort.png","x":3520,"y":4560,"width":400,"height":368},
		{"id":"ea1ab7bdab75582f","type":"text","text":"# Pseudocodice MergeInsertionSort\n \n```\ndef MergeInsersionSort(A, LeftPointer = 0, EndPointer = len(A) - 1, k):\n\tif EndPointer > k:\n\t\tMiddlePointer = (LeftPointer + EndPointer) // 2\n\t\tMergeSort(A, LeftPointer, MiddlePointer, k)\n\t\tMergeSort(A, MiddlePointer + 1, EndPointer, k)\n\t\tMerge(A, LeftPointer, MiddlePointer, EndPointer)\n\telse:\n\t\tInsertionSort(LeftPointer, EndPointer)\n```","x":2640,"y":4585,"width":700,"height":319,"color":"#4545ff"},
		{"id":"dfd34ed380a58414","type":"text","text":"# Pseudocodice Merge\n\nUsa un ***vettore di appoggio*** `B` per poi copiare il risultato sull'originale `A`.\n\n```\ndef Merge(A, LeftPointer, MiddlePointer, EndPointer):\n\ti, j = LeftPointer, MiddlePointer + 1\n\tB = []\n\twhile ((i <= MiddlePointer) and (j <= EndPointer))\n\t\tif (A[i] <= A[j]):\n\t\t\tB.append(A[i])\n\t\t\ti += 1\n\t\telse:\n\t\t\tB.append(A[j])\n\t\t\tj += 1\n\t\t\t\n// Eseguito solo se il primo sotto-vettore non è terminato\n\twhile (i <= MiddlePointer)\n\t\tB.append(A[i])\n\t\ti += 1\n\t\t\n// Eseguito solo se il secondo sotto-vettore non è terminato\n\twhile (j <= EndPointer)\n\t\tB.append(A[j])\n\t\tj += 1\n\t\t\n\tfor i in range(len(B)):\n\t\tA[LeftPointer+i] = B[i]\n```","x":2408,"y":3722,"width":676,"height":719,"color":"#4545ff"},
		{"id":"999dd8de13fca977","type":"text","text":"# Struttura Dati Heap\n\nStruttura dati ad ***albero binario*** in cui ogni livello deve essere completato (i.e. riempito partendo da sinistra) prima di passare a quello successivo. È implementato tramite un array, e affinché rispecchi il modello teorico di \"cumulo\" deve rispettare le ***proprietà della struttura dati heap***.\n\n- L'array viene riempito a partire da sinistra;\n- L'heap ha un numero massimo di elementi, detto ***Heap Size***. Se inserisco un elemento in posizione maggiore dell'Heap Size, questo non fa parte dell'Heap;\n- Ogni nodo genitore deve contenere un valore $\\geq$ di entrambi i figli;\n\t- Segue che la radice $A[0]$ contiene il massimo valore presente in Heap;\n\t- Ne risulta un ordinamento verticale (che però wtf??????????)\n- I figli del nodo $A[i]$ si trovano nelle posizioni $A[2i+1]$ e $A[2i+2]$.\n- Similmente, il nodo genitore di un nodo $A[i]$ è in posizione $A[(i-1)//2]$;\n- Il livello $h$ contiene $2^h$ nodi, quindi la profondità è $h\\simeq log(n)$.","x":5320,"y":1342,"width":709,"height":450,"color":"4"},
		{"id":"f117e625335780b7","type":"file","file":"Heap.png","x":5475,"y":1900,"width":400,"height":223},
		{"id":"e1fecc256cca6f1d","type":"text","text":"# Ho detto che voglio un Heap!\n\nSe ho un vettore rappresentante un Heap in cui gli elementi sono dinamici, si pone un problema. Se cancello, modifico o inserisco un valore, la struttura dati potrebbe non rispettare più le proprietà di Heap. E quindi? Mi servono delle funzioni che mantengono la struttura coerente.\n\n- `Heapify` lavora sul trittico padre-figli, dando per scontato che i sottoalberi generati dai figli rispettino le condizioni di Heap. Se il padre è maggiore dei figli va tutto bene, altrimenti viene scambiato col maggiore dei figli. Se avviene lo scambio, `Heapify` controlla ricorsivamente se l'illegalità si è così trasferita sul figlio (quindi va in profondità);\n\t- Si dimostra che il suo costo computazionale è $\\Theta(log(n))$.\n- `BuildHeap` si occupa di chiamare correttamente la funzione `Heapify` per trasformare qualunque vettore in un Heap. In particolare, se `Heapify` agisce dall'alto verso il basso, `BuildHeap` si occupa di chiamarla scorrendo l'albero dal basso verso l'alto.\n\t- Ogni foglia è già un Heap, pertanto posso ridurre le chiamate a $n/2$.\n\t- Si dimostra che il suo costo computazionale è $\\Theta(n)$.","x":4160,"y":1342,"width":792,"height":450,"color":"4"},
		{"id":"09832ca107cfaf02","type":"text","text":"# Heap Sort\n\nVisto che per definizione di Heap il primo elemento dell'array è il massimo, mi basta scambiarlo con l'elemento finale, ridurre il problema a $n-1$ elementi, ricostruire l'Heap e ripetere.\n\n1. Chiamo `BuildHeap` sul vettore da ordinare;\n2. Scambio la radice con l'ultimo elemento;\n3. Devo ricostruire l'heap ignorando l'ultimo elemento. Ma so già che i sottoalberi sono un Heap per costruzione, quindi è sufficiente chiamare `Heapify`;\n4. Ripeto iterativamente i punti `2` e `3`.\n\n```\ndef Heapsort (A):\n\tBuildHeap(A)\n\tfor x in reversed(range(1,len(A))):\n\t\tA[0], A[x] = A[x], A[0]\n\t\tHeapify(A, 0, x)\n```\n\n`Heapify` ha costo $\\Theta(log(n))$ e viene chiamato $n$ volte, mentre `Buildheap` ha costo $\\Theta(n)$ e viene chiamata una sola volta. Nel complesso quindi `Heapsort` ha un costo$$T(n) = \\Theta(n\\,log(n))$$","x":4160,"y":2200,"width":792,"height":581,"color":"4"},
		{"id":"39277162e9de0e82","type":"text","text":"# Funzione Ausiliaria `Heapify`\n\n```\ndef Heapify (A, i, heap_size):\n\tL = A[2i+1]\n\tR = A[2i+2]\n\tindice_max = i\n\t\n\tif (L < heap_size) and (A[L] > A[i]):\n\t\tindice_max = L\n\tif (R <= heap_size) and (A[R] > A[indice_max]):\n\t\tindice_max = R\n\tif (indice_max != i):\n\t\tA[i], A[indice_max] = A[indice_max], A[i]\n\t\tHeapify (A, indice_max, heap_size)\n```\n\nCosto computazionale? Strano, c'è solo la chiamata ricorsiva ma non so con che input $n'$ perché non so la dimensione del sottoalbero più grande, nel caso peggiore. Però so maggiorarlo.\n\nSe l'albero di partenza raggiunge profondità $h$ allora avrà $\\sum2^h = 2^{h+1}-1 \\simeq 2^{h+1}$ nodi, equamente divisi tra il ramo destro e sinistro (ne hanno quindi $2^h$ a testa). Il caso peggiore è che io abbia già iniziato a popolare il livello $h+1$. Se lo riempio tutto avrà $2^{h+1}$ elementi, ma se lo riempio per metà avrà solo $2^h$ nodi, tutti nell'albero di sinistra. Sto dicendo che nel peggiore dei casi il massimo sbilanciamento tra gli alberi è il caso in cui quello di sinistra abbia $2^{h+1}$ nodi e quello di destra $2^h$. Se i nodi complessivi sono $n$, l'albero più grosso avrà al più $\\frac{2}{3}$ dei nodi.\n\nA questo punto la questione è semplice. L'equazione di ricorrenza è $$T(n) = T\\bigg(\\frac{2}{3}n\\bigg) + \\Theta(1) \\Rightarrow \\alpha = 1,\\,\\beta = \\frac{3}{2},\\,log_{\\frac{3}{2}}(1)=0 \\Rightarrow n^{log_{\\frac{3}{2}}(1)} = 1$$Per il Metodo Principale possiamo concludere che $T(n) = \\Theta(log(n))$.","x":4160,"y":480,"width":792,"height":773,"color":"4"},
		{"id":"2cdcb25cb319947f","type":"text","text":"# Pseudocodice `BuildHeap`\n\n```\ndef BuildHeap (A):\nfor i in reversed(range(len(A)//2)):\n\tHeapify (A, i, heap_size)\n```\n\n\n","x":3349,"y":1477,"width":414,"height":181,"color":"#4545ff"},
		{"id":"583996bcfd383a51","type":"file","file":"TerminologiaAlbero.png","x":7357,"y":1312,"width":399,"height":190},
		{"id":"b77aa226a6ec3a35","type":"text","text":"# Strutture Collegate Non-Lineari\n\nIl caso più generale di SCNL è il ***grafo***, definito come $G = (V,E)$, dove $V$ è un insieme finito di ***nodi*** ed $E$ un insieme di ***archi*** che collegano tali nodi (formalmente $E\\subseteq V\\times V$).\n\nSi dice ***cammino*** una sequenza di ***nodi distinti*** $\\{v_i\\}$ tali che per ogni coppia $(v_i, v_{i+1})$ esiste un arco che collega tali elementi. Se posso costruire un cammino tale che il primo e l'ultimo nodo coincidono ho formato un ***ciclo*** (i.e. sono su un ***grafo ciclico***).\n\nSe per ogni coppia di nodi $(u, v)$ esiste almeno un cammino tra $u$ e $v$, il grafo è detto ***connesso***.\n\nDetto tutto ciò, ***un grafo aciclico connesso si chiama albero***. Se distinguo un nodo radice (i.e. rappresentabile in modo tale che tutti i cammini da un nodo qualsiasi alla radice vadano sempre dal basso verso l'alto), l'albero è detto ***radicato***. Se esiste un ordine tra i figli di ogni nodo, l'albero è detto ***ordinato***.","x":7167,"y":645,"width":780,"height":390,"color":"4"},
		{"id":"d78a8546bc66a9fa","type":"text","text":"# Alberi Binari\n\nAlberi ***radicati e ordinati*** in cui ***ogni nodo può avere al massimo due figli*** (destro e sinistro). Se tutti i nodi (tranne quelli dell'ultimo livello) hanno due figli, l'albero è detto ***completo***. Se così è, il livello $i$ contiene $2^i$ nodi (conseguentemente ci sono $2^h$ foglie, dove $h$ è l'altezza dell'albero, che corrisponde al cammino più lungo dalla radice ad una foglia). Segue che un albero completo ha $n = 2^{h+1}-1$ nodi.\n\nDa questo possiamo ricavare l'altezza di un albero completo, ovvero $h = log(\\frac{n+1}{2})$. Questo significa che l'altezza è $\\Theta(log(n))$, mentre per un albero totalmente sbilanciato (e.g. solo figli sinistri, come nelle migliori famiglie) sarà $h = \\Theta(n)$.\n\nPosso ***rappresentare un albero binario*** in tre modi:\n\n- ***Puntatori*** - Campi `key`, `left` e `right`;\n- ***Indici Posizionali*** - Come nella struttura dati Heap;\n- ***Vettore dei padri*** - Usa due array. Il primo contiene in posizione $i$ il valore del nodo $i$, l'altro contiene in posizione $j$ l'indice del padre del nodo $j$.","x":6220,"y":617,"width":820,"height":446,"color":"4"},
		{"id":"fe7f208b5b0a5332","type":"text","text":"# Alberi (ING INF)\n\nL'***albero*** è un tipo di dato non lineare utilizzato per memorizzare informazioni in modo ***gerarchico***. È costituito da ***nodi***, che rappresentano le informazioni, e ***archi***, che rappresentano relazioni di discendenza diretta tra nodi. In particolare, dato un generico nodo `X` si possono riconoscere:\n\n- Suo ***padre***, ovvero il nodo che ha un collegamento in uscita verso `X`. In generale, ogni nodo ha esattamente un padre eccezion fatta per il ***nodo radice***, da cui si genera l'albero;\n- I suoi ***fratelli***, ovvero i nodi che hanno lo stesso padre di `X`;\n- I suoi ***figli***, ovvero nodi verso cui `X` ha collegamenti in uscita (di cui `X` è quindi il padre);\n- Le ***foglie dell'albero***, ovvero nodi che non sono padri o equivalentemente non hanno figli.\n\nIl nodo radice costituisce il ***livello zero*** dell'albero, e ogni nodo si trova al livello del padre + 1. Il massimo livello raggiunto da una foglia è detto ***profondità***. E' possibile individuare dei ***sottoalberi*** a partire da un generico nodo, ovvero alberi aventi come nodo radice, ad esempio, i figli di quel nodo. Si noti che tutti i sottoalberi sono disgiunti.","x":7083,"y":-1041,"width":949,"height":408,"color":"5"},
		{"id":"c7d02bbb0d8db2cb","type":"text","text":"# ALBERI BINARI (ING INF)\n\nSono alberi con il vincolo che ogni nodo può avere al più 2 figli, distinti in ***sinistro*** e ***destro***. Conviene definire l'albero binario nel seguente modo:\n\n- l'albero vuoto è un albero binario;\n- se S e D sono due alberi binari, allora l’albero che ha un nodo radice e S e D come sottoalberi è un albero binario;\n- nient’altro è un albero binario.\n\nQuesto perché si presta alla ricorsione. Se il numero massimo di figli è fissato, si può definire un albero ***completo*** se ogni nodo non-foglia ha esattamente due (N) figli e le foglie sono tutte allo stesso livello. Se la profondità è $k$, un albero binario completo ha esattamente $2^{k+1} - 1$ nodi.\n\n### TIPO ASTRATTO ALBERO BINARIO\n\nLe funzioni caratteristiche del tipo astratto albero binario sono:\n\n- `empty_binary_tree() → BinaryTree` - Restituisce l'albero binario vuoto (senza nodi);\n- `Create_Binary_Tree(tree_type x, BinaryTree s, BinaryTree d) → BinaryTree` - Restituisce l'albero avente radice x e sotto alberi destro e sinistro s e d;\n- `is_tree_empty(BinaryTree t) → Boolean` - True se l'albero in input è vuoto;\n- `tree_root(BinaryTree t) → tree_type` - Restituisce il valore del nodo radice;\n- `Left_SubTree(BinaryTree t) → BinaryTree` - Restituisce il sottoalbero sinistro di t;\n- `Right_SubTree(BinaryTree t) → BinaryTree` - Restituisce il sottoalbero destro di t.\n\nL'implementazione è effettuabile sia con array che con SCNL (NON LINEARE!).\n\n- ***Array*** -  Si presta particolarmente per alberi completi. Devo allocare memoria a priori. Dato un generico nodo in posizione $i$, per accedere al figlio sinistro dovrò andare in posizione $2i+1$, per il destro $2i+2$.\n\t- Se l'albero non è completo devo prevedere un carattere speciale per le locazioni prive di nodo. Ad esempio, ogni elemento è una struct a due campi contenenti l'informazione e un valore booleano di validità.\n\t- Se l'albero è molto vuoto alloco memoria $O(exp(n))$ inutilmente.\n- ***SCNL***: La rappresentazione collegata è dinamica dal punto di vista della memoria. L'albero vuoto è `NULL`. Il costo di un albero è costante per ogni nodo, dunque per $N$ nodi sarà $O(N)$. Notare che anche qui per un albero molto vuoto devo allocare memoria con costo $O(N)$.\n\n\t\tstruct StructAlbero\n\t\t{\n\t\t\ttree_type info;\n\t\t\tstruct StructAlbero *right, *left;\t\t// Due puntatori a struct -> NON LINEARE\n\t\t};\n\t\ttypedef struct StructAlbero Tree_Node;\n\t\ttypedef TipoNodoAlbero* Tree;\n- ***Stringhe*** - Anche detta ***Rappresentazione Parentetica***, particolarmente utile nell'I/O.\n\t- L'albero vuoto è rappresentato da ();\n\t- L'albero avente nodo radice R e sottoalberi S e D è indicato come $(R f(S) f(D))$, dove le f indicano le rappresentazioni degli alberi S e D. Rappresentazione sulle dispense p. 337.\n\n","x":5611,"y":-1455,"width":980,"height":1227,"color":"5"},
		{"id":"10a4ec34bd5576ba","type":"text","text":"# VISITA DEGLI ELEMENTI DELL'ALBERO (ING INF)\nCome sempre, si possono usare metodi iterativi o ricorsivi. Entrambi usano strutture dati di supporto di tipo pila o coda, ma mentre nell'iterazione deve scriverle esplicitamente il programmatore, nella ricorsione il tipo pila è implicito (pila dei RDA). Non essendo una struttura lineare ci sono diversi modi di visitare l'albero.\n\n- ***Visita in Profondità***: Ci si sposta ***lungo gli archi padre-figlio***. La struttura di supporto è di tipo ***pila***, quindi si predilige il paradigma ricorsivo (pur restando fattibile quello iterativo).\n\n\t\tif T non è vuoto\n\t\t{\n\t\t\tanalizza il nodo radice di T \t\t\t// 1 -  Oeperazione dominante\n\t\t\t// Se il punto 1 ha costo O(x) la visita ha costo complessivo O(Nx).\n\t\t\tvisita il sottoalbero sinistro di T \t        // 2\n\t\t\tvisita il sottoalbero destro di T \t\t// 3\n\t\t}\n\t\telse passo base;\n\n\tAnalogo alle SCL, ma con due chiamate ricorsive. Scambiare l'ordine delle operazioni porta a tipi di visite diverse:\n\t- ***Preordine***: sequenza di operazioni 1 2 3 (legge gli elementi dall'alto verso il basso e da\tdestra verso sinistra, schema a \"rette parallele\");\n\t- ***Simmetrica*** (o ***in-ordine***): sequenza di operazioni 2 1 3 (legge prima i sottoalberi sinistri in senso orario a partire dall'elemento sinistro, poi il nodo radice e poi i destri allo stesso modo);\n\t- ***Postordine***: sequenza di operazioni 2 3 1 (legge prima i sottoalberi sinistri in senso antiorario a partire dall'elemento destro, poi quelli destri allo stesso modo e infine risale al nodo radice);\n\n\tNonostante non siano scritti nelle dispense (e magari non serve a niente) aggiungo che\n\n\t- **Preordine inverso** (3 2 1) è uguale al postordine invertendo sinistro<->destro e orario<->antiorario;\n\t- **Simmetrica inversa** (3 1 2) è uguale alla simmetrica invertendo sinistro<->destro e orario<->antiorario;\n\t- **Postordine inverso** (1 3 2) è uguale al preordine invertendo destra<->sinistra.\n\n\tSeguono applicazioni (p. 343). Ad esempio, il calcolo della profondità come\n\n\t\tint depth(Tree T)\n\t\t{\n\t\t\treturn 1 + max(depth(T->Left), depth(T->Right));\n\t\t}\n\tè un processo in postordine (visito prima i sottoalberi e poi ne calcolo il massimo per aggiungerli al nodo\tradice).\n\n- ***Visita in Ampiezza*** (o ***per livelli***): Ci si sposta appunto per livelli, quindi tra fratelli. La struttura di supporto è una ***coda***, motivo per cui è altamente sconveniente usare la ricorsione (bisognerebbe implementare una coda a partire dalla pila dei RDA...). Si usa quindi solo l'***iterazione***.\n\nIn generale, il costo di qualsiasi tipo di visita è $\\Theta(n)$.","x":5610,"y":-2800,"width":980,"height":1146,"color":"5"},
		{"id":"31cdab338e348df8","type":"text","text":"# ALBERI BINARI DI RICERCA (ABR) (ING INF)\n\nStrutture collegate con ricerca efficiente (nelle SCL non potevo usare la ricerca binaria di costo $O(log(N))$. Contengono informazioni ordinabili (in modo algebrico, lessico-grafico, ...) e sono tali che\n\n- ***il valore di ogni nodo nel sottoalbero sinistro è minore o uguale al valore della radice*** rispetto alla relazione d’ordine;\n- il valore di ogni nodo nel sottoalbero ***destro è maggiore o uguale*** al valore della radice rispetto alla relazione d’ordine;\n- i sottoalberi sinistro e destro sono a loro volta alberi binari di ricerca.\n\nSegue che posso implementare la ***ricerca binaria***. Faccio al più una operazione per livello, quindi al più $k$ operazioni, dove $k$ è la profondità dell'albero. Ma devo esprimere il costo in funzione dell'input! Nel ***caso peggiore*** (albero degenere), il numero di elementi coincide con la profondità (quindi $O(N)$). Si tratta appunto di un caso peggiore, e ci sono metodi per far sì che l'albero sia bilanciato. Nel ***caso migliore*** l'albero è completo, e il costo è $O(log(N))$.\n\n\n### ESEMPIO: OPERAZIONI SU LIVELLI CON VISITA IN PROFONDITÀ\nEssendo la visita in ampiezza molto complessa, può essere utile sapere che alcuni problemi che lavorano sul livello possono essere risolti in modo ricorsivo. Questo avviene passando il livello come parametro e aggiornandolo nelle chiamate di funzione.\n\n\tvoid f(Tree T, ..., int level);\t\t\t// Poi chiamata come f(T->Left/Right, ..., level + 1);\n\nUn esempio può essere verificare se esiste una foglia al livello L, o stampare tutti i nodi di quel livello.","x":4160,"y":-2800,"width":1060,"height":619,"color":"5"},
		{"id":"7e3760652e3cd8b9","type":"text","text":"# RAPPRESENTAZIONE DELL'ARITMETICA E ALBERI SINTATTICI (ING INF)\nTramite gli alberi binari è possibile rappresentare espressioni algebriche.\n\n- I nodi non foglie rappresentano operazioni (+, -, *, /, ...);\n- Le foglie rappresentano valori numerici (2, 7, e, ...).\n\nCosì facendo, oltre a poter valutare le espressioni a partire dal loro albero, è possibile verificare la correttezza sintattica di un'espressione. Se dovessi scrivere `5*7-/` l'albero creato avrebbe `*` come nodo radice, `5` come sottoalbero sinistro (foglia), `-` come radice del sottoalbero destro avente a sua volta foglie `7` e `/`. Ma `/` non può essere una foglia, e infatti l'espressione di partenza non ha senso. Secondo questo stesso principio, il precompilatore costruisce l'***albero sintattico*** secondo le regole del linguaggio di programmazione da compilare e verifica eventuali errori del programmatore. Notare che l'esecuzione delle operazioni è un processo in postordine, mentre se si volesse stampare l'espressione a partire dall'albero sarebbe necessario un processo simmetrico. Inoltre è conveniente usare la condizione di essere su una foglia come caso base (piuttosto che l'albero vuoto).\n","x":4160,"y":-2053,"width":1060,"height":399,"color":"5"},
		{"id":"350f10e234c3ef7a","type":"text","text":"# Alberi Rosso-Neri\n\nAbbiamo detto che per ottimizzare l'efficienza della ricerca devo mantenere l'albero quanto più possibile bilanciato. Come faccio?\n\nUn albero rosso-nero (***A-RB***, per qualche motivo, tipo \"albero red-black\") stabilisce delle regole di colorazione dei nodi. Questi possono essere rossi o neri. La ***radice*** è sempre ***nera***, e quando inserisco un nuovo nodo questo di default è rosso con due foglie nere (anche se questo nodo non ha veramente dei figli, vengono inserite delle ***foglie fittizie nere*** con valore `NULL`).\n\nDetto questo, ci sono tre regole fondamentali:\n\n- **Ogni nodo non foglia deve avere esattamente due figli** (obiettivo raggiunto tramite l'uso delle foglie fittizie)\n- **Non possono esserci due nodi rossi consecutivi**: se un nodo è rosso i suoi figli sono entrambi neri.\n- Definiamo la ***black height (BH)*** come il numero di nodi neri incontrati dalla radice ad una foglia;\n\t- La black height è definita per ogni foglia. **Non può esserci una BH più grande del doppio di una qualsiasi altra**;\n\t- Qualsiasi sotto-albero con radice $x$ contiene almeno $2^{BH(x)}-1$ nodi interni;\n\t\t- Segue che un A-RB con $n$ nodi ha sempre un'altezza $h \\leq 2\\,\\text{log}(n+1)$.\n\nE se queste regole non sono rispettate a seguito di una cancellazione o di un inserimento? Esistono delle operazioni speciali, dette ***rotazioni***, che vengono eseguite in tempo $O(log(n))$ e che mirano a ripristinare le suddette proprietà. Come?\n\n- La ***rotazione a sinistra*** è eseguita in senso ***antiorario***. Il padre $X$  diventa il figlio sinistro, mentre il figlio destro $Y$ diventa il padre. Se $Y$ aveva due sotto-alberi figli, quello di sinistra diventa il nuovo sotto-albero destro di $X$;\n- Viceversa, la ***rotazione a destra*** è in verso ***orario***. Stesse considerazioni del sinistro, ma al contrario.\n\n","x":4160,"y":-3600,"width":1060,"height":586,"color":"4"},
		{"id":"b438b724129b737d","type":"file","file":"EsempioEliminazione.png","x":2680,"y":-2599,"width":400,"height":218},
		{"id":"0b0f3702d23dd294","type":"text","text":"# Eliminare un nodo\n\nSe la ricerca e l'inserimento sono implementazioni banali, l'eliminazione può fare casino.\n\n- Se elimino una foglia va tutto bene;\n- Se elimino un nodo con un solo sottoalbero, collego direttamente il sottoalbero al padre del nodo eliminato;\n- Se elimino un nodo con entrambi i figli devo trovare un sostituto tale che il risultato complessivo sia ancora un albero binario di ricerca. Questo si traduce nel ***sostituirlo con il predecessore o con il successore***, per poi propagare ricorsivamente le modifiche.\n\t- Nell'esempio a fianco, se elimino il `48` posso sostituirlo con il `23` o con il `39`. In entrambi i casi mi riconduco all'aver rimosso un nodo con un solo figlio, quindi al caso precedente.","x":3200,"y":-2675,"width":780,"height":369,"color":"4"},
		{"id":"790207f76db11656","type":"file","file":"RotazioniARB.png","x":4380,"y":-3920,"width":619,"height":252},
		{"id":"175892fce12234ff","type":"text","text":"# Strutture Collegate\n\nStrutture costituite da nodi che contengono due elementi:\n\n- Un `valore` (o un gruppo di valori);\n- Uno o più puntatori ad altri nodi.\n\nSe il puntatore è unico (o al più ve ne sono due che puntano ad un elemento `precedente` e ad un `successivo`) la struttura collegata è detta ***lineare*** (e.g. liste, pile, code).\n\nSe vi sono più puntatori verso nodi non serializzati, la struttura è ***non-lineare*** (e.g. alberi, grafi).","x":8474,"y":1233,"width":520,"height":347,"color":"4"},
		{"id":"d78749dca1e4aa0f","type":"text","text":"# Da Array ad SCL (ING INF)\n\nGli array presentano alcune limitazioni, tra cui la dimensione fissata e la difficoltà di aggiunta di un elemento. Una Struttura Collegata Lineare è una catena di record in cui ognuno ne chiama ricorsivamente un altro.\n\n\ttypedef ...TipoInfoSCL;\n\t// Definisce il tipo di informazione della SCL. Non serve se esiste già (es: int).\n\tstruct ElemSCL\t\t\t\t// Dichiaro la struct \"Elemento della SCL\"\n\t{\n\t\tTipoInfoSCL info;\t\t// contenente il dato del rispettivo tipo\n\t\tstruct ElemSCL *next;\t        // e un puntatore all'elemento successivo della catena.\n\t};\n\n\ttypedef struct ElemSCL TipoNodoSCL;\t// Definizioni di comodo: chiamo la struct \"TipoNodoSCL\"\n\ttypedef TipoNodoSCL* TipoSCL;\t\t// e il puntatore a questo tipo di struttura (è più chiaro \n\t\t\t\t\t\tdistinguere esplicitamente la struttura dal suo puntatore).\n\nNotare che ***non posso*** definire la struct direttamente col `typedef`, perché devo chiamarla dentro la sua stessa definizione. Mi serve quindi il tag `ElemSCL`. A questo punto creiamo e colleghiamo dei nodi.\n\n\t\n\tTipoSCL scl = (TipoNodoSCL*) malloc(sizeof(TipoNodoSCL));\t// Ricordiamo che TipoNodoSCL* == TipoSCL.\n\tscl->info = a;\t\t\t\t\t \t        // Assegno il valore di a al campo info.\n\tscl->next = NULL;\t\t\t\t\t\t// Al momento non c'è un modo successivo.\n\tTipoSCL temp = (TipoNodoSCL*) malloc(sizeof(TipoNodoSCL));\t// Nuovo nodo\n\ttemp->info = b;\t\t\t\t\t\t\t// il cui valore del campo info è b\n\ttemp->next = NULL;\t\t\t\t\t// che attualmente non punta a un nodo successivo\n\tscl->next = temp;\t\t\t\t\t// mentre ora il primo nodo punta al secondo.\n","x":9474,"y":1233,"width":1000,"height":727,"color":"5"},
		{"id":"76ac7d40adf06a17","type":"text","text":"# Strutture Collegate Lineari\n\nContrariamente agli array (che sono indicizzati) le liste puntate (campi `value` e `next`) richiedono un accesso sequenziale per la maggior parte delle operazioni.\n\n- La ricerca è sempre $O(n)$;\n- L'inserimento dipende da dove lo faccio.\n\t- Inserimento in testa (o in coda) è $\\Theta(1)$;\n\t- Inserimento in posizione $n$ è ovviamente $O(n)$.\n- La cancellazione richiede una ricerca, quindi è anch'essa $O(n)$.\n\nDue esempi immediati di lista sono\n\n- ***Pile*** - Struttura LIFO (Last In First Out) che usa le funzioni `push` (inserimento in testa) e `pop` (rimozione + restituzione dell'elemento in testa);\n- ***Code*** - Struttura FIFO (First In First Out) che usa le funzioni `enqueue` (inserimento in coda) e `dequeue` (rimozione + restituzione dell'elemento in testa).\n\t- Esiste un variante di coda con priorità, in cui l'ordine non è FIFO ma dato dalla chiave di ordinamento.\n\n","x":8284,"y":1771,"width":900,"height":482,"color":"4"},
		{"id":"ff82a5222aa32e06","type":"text","text":"# OPERAZIONI SUL NODO IN PRIMA POSIZIONE (ING INF)\nSe voglio creare una funzione per aggiungere un nodo devo stare attento. Ipotizziamo di partire da una SCL vuota,\novvero un puntatore `TipoSCL scl = NULL`. Per creare un nodo in prima posizione bisogna\n\n\t1 - Creare il nuovo nodo;\n\t2 - Assegnare al vecchio puntatore l'indirizzo del nuovo nodo;\n\t3 - Assegnare al puntatore del nuovo nodo l'indirizzo puntato dal vecchio.\n\nIl secondo step implica che dentro la funzione devo poter modificare il puntatore che passo come parametro (e non il\nsuo contenuto!). Per questo motivo devo passare un puntatore a `TipoSCL` (che a sua volta è un puntatore, da cui si\ncapisce il senso della definizione \"di comodo\" effettuata in precedenza: evitare il doppio asterisco).\n\n\tvoid addSCL(TipoSCL *scl_new, TipoInfoSCL e) \t// scl_new è una variabile del RDA di addSCL che\n\t\t\t\t\t\t\t// punta all'indirizzo di scl fuori dalla funzione.\n\t{\n\t\tTipoSCL temp = *scl_new;\t\t// Essendo stati costretti a passare un puntatore,\n\t\t\t\t\t\t\t// l'indirizzo puntato dal puntatore scl fuori dalla\n\t\t\t\t\t\t\t// funzione (ovvero quello che rimanda al nodo\n\t\t\t\t\t\t\t// successivo) si trova nel puntato da scl_new.\n\t\t*scl_new = (TipoNodoSCL*) malloc(sizeof(TipoNodoSCL));\t// Ed è proprio su questo indirizzo che va\n\t\t\t\t\t\t// assegnato il nuovo nodo (step 1 e 2 eseguiti in simultanea).\n\t\t(*scl_new)->info = e;\n\t\t(*scl_new)->next = temp;\n\t}\n\nNel main:\n\n\tTipoSCL scl = NULL;\n\taddSCL(&scl, 3);\t// NB: passare scl senza & sarebbe anzitutto un'incoerenza di tipo, ma oltre a questo\n\taddSCL(&scl, 2);\t// la variabile passata NON viene modificata (contrariamente rispetto al suo puntato).\n\taddSCL(&scl, 1);\t// Questo codice crea tre nodi contenenti nell'ordine i valori 1, 2, 3.\n\tscl->next->next->info  \t// Accede al valore 3.\n\nLa cancellazione del primo elemento è del tutto analogo al suo inserimento.\n\n\tvoid delSCL(TipoSCL *scl_to_delete) \t\t// Come prima, passo il puntatore al puntatore perché devo\n\t\t\t\t\t\t\t// modificarlo (in questo caso cancellarlo).\n\t{\n\t\tTipoSCL temp = *scl_to_delete;\t\t// Copio l'indirizzo della SCL di cui cancellare il primo\n\t\t\t\t\t\t\t// elemento (non posso liberarlo subito, mi perderei il resto\n\t\t\t\t\t\t\t// della SCL).\n\t\t*scl_to_delete = (*scl_to_delete)->next;\t// Assegno come nuovo indirizzo di partenza quello\n\t\t\t\t\t\t\t\t// contenuto nel campo next del secondo elemento.\n\t\tfree(temp);\t\t\t\t\t// A questo punto libero il primo elemento.\n\t}\n","x":9459,"y":2080,"width":1030,"height":1199,"color":"5"},
		{"id":"8f8360d10d823d4d","type":"text","text":"# OPERAZIONI CHE NON MODIFICANO LA STRUTTURA DELLA SCL\n\nPer definizione, le SCL si prestano a una formulazione ricorsiva. Nel caso di ***strutture non-lineari***, è l'unica via percorribile (***il metodo iterativo non funziona***). Se devo leggere gli elementi di una SCL lo schema ricorsivo è del tipo\n\n\tif(SCL vuota) {passo base;}\n\telse\n\t{\n\t\telaborazione primo elemento della SCL;\n\t\tchiamata ricorsiva sul resto della SCL;\n\t}\n\nSe invece devo creare o scrivere su una SCL avrò\n\n\tleggi dato\n\tif (dato valido) \n\t{\n\t\tinserimento del dato nella SCL;\n\t\tchiamata ricorsiva sui dati rimanenti;\t\t// p = p->next;\n\t}\n\nSi noti che le funzioni che non modificano la struttura della SCL hanno come parametro `TipoSCL` (senza `*`: non ho bisogno di modificare un indirizzo di un puntatore).\n\nEsistono anche le versioni iterative, tendenzialmente con il `while`. Cambia poco.\n\nSi usa usa la ***tecnica del nodo generatore***: si aggiunge un nodo in posizione iniziale in modo da poter trattare tutti gli elementi della SCL allo stesso modo. Viene rimosso prima di restituire il risultato.\n\n\tvoid creaSCL(TipoSCL *scl, int n, TipoInfoSCL e)\n\t{\n\t\tTipoSCL prec; \t\t\t        \t\t// Puntatore a elemento precedente\n\t\tprec = (TipoNodoSCL*) malloc(sizeof(TipoNodoSCL));\t// Creazione del nodo generatore\n\t\t*scl = prec;\n\t\twhile(n > 0)\t\t\t\t\t\t// Scansione e copia della lista\n\t\t{\n\t\t\tprec->next = (TipoNodoSCL*) malloc(sizeof(TipoNodoSCL));\n\t\t\tprec = prec->next;\n\t\t\tprec->info = e;\n\t\t\tn--;\n\t\t}\n\t\tprec->next = NULL; \t\t\t\t\t// Chiusura della SCL\n\t\tprec = *scl;\t\t\t\t\t\t// Eliminazione del nodo generatore\n\t\t*scl = (*scl)->next;\n\t\tfree(prec);\t\t\t\t\t\t\t\n\t}","x":10724,"y":1233,"width":1030,"height":1175,"color":"5"},
		{"id":"366c75dbe4439c2c","type":"text","text":"# Strutture Dati\n\nUn ***tipo di dato*** rappresenta in informatica una ***collezione di valori*** che il dato può assumere e un insieme di ***operazioni ammesse*** su tali valori.\n\nUna ***struttura dati*** riguarda invece l'***organizzazione dei dati***, indipendentemente dal tipo, e include degli ***operatori per manipolare tale struttura***.\n\nPrevedono la presenza di ***dati satellite***, che vengono gestiti con le ***chiavi***.\n\nParlando di strutture dati abbiamo tre grandi distinzioni:\n\n- ***Linearità*** - Un struttura dati è lineare se esiste una sequenzializzazione dei valori. Non-lineare altrimenti;\n- ***Dinamicità*** - Se la dimensione può variare nel tempo è detta dinamica. Statica altrimenti.\n- ***Omogeneità*** - Se i dati contenuti sono tutti dello stesso tipo è detta omogenea. Disomogenea altrimenti.","x":8284,"y":645,"width":900,"height":390,"color":"6"},
		{"id":"a44fc8dcd44442b6","type":"text","text":"# Operazioni sulle Strutture Dati\n\nVi sono due macro-categorie di operandi su strutture dati.\n\n- ***Interrogazioni*** - Non modificano la struttura dati. Esempi possono essere la ***ricerca*** di un elemento, trovare il ***massimo/minimo*** o il ***predecessore/successore*** di un certo elemento;\n- ***Manipolazioni*** - Modificano la struttura dati. Esempi standard sono l'***inserimento*** e l'***eliminazione***.","x":8284,"y":-35,"width":900,"height":208,"color":"4"},
		{"id":"8afe10a63942da8e","type":"text","text":"# ALBERI N-ARI (ING INF)\n\nDal momento che non conosco il numero di figli del generico nodo, ognuno di essi si compone del campo info e di un puntatore alla lista dei figli. Come sono fatti gli elementi della lista? Ognuno di essi ha un campo next che punta al figlio successivo e un campo puntatore a nodo, la cui struttura è di nuovo info + puntatore a lista di figli.\n\n- NodoAlbero\n\t- info\n\t- puntatore a ListaFigli\n\n- ListaFigli\n\t- next\n\t- puntatore a NodoAlbero\n\nSi tratta di una definizione circolare, in cui NodoAlbero è definita tramite ListaFigli e ListaFigli tramite NodoAlbero. Appare evidente che almeno in C/C++ è necessario prima dichiarare l'esistenza della seconda struct e poi scrivere l'implementazione. \n\n\ttypedef int tree_type;\n\tstruct StructNodoFiglio;\n\n\tstruct StructAlbero\n\t{\n\t\ttree_type info;\n\t\tstruct StructNodoFiglio* figli;\n\t};\n\n\tstruct StructNodoFiglio\t\t\t\t\t// Lista avente elementi puntatori ad albero\n\t{\n\t\tstruct StructAlbero* albero;\n\t\tstruct StructNodoFiglio* next;\n\t};\n\n\ttypedef struct StructAlbero Tree_Node;\n\ttypedef struct StructAlbero* Tree;\n\ttypedef struct StructNodoFiglio* Tree_Son;\n\nLe funzioni utilizzate per l'albero N-ario sono la naturale estensione di quelle usate nel caso binario. L'unica differenza sostanziale è che i figli non hanno un nome esplicito (destro/sinistro), e nel creare un albero devo aggiungere esplicitamente il subtree alla lista dei figli, preferibilmente in testa alla lista per motivi di efficienza (e quindi a sinistra). Il modo di visitare l'albero diventa\n\n- Preordine: Visito prima la radice e poi tutti i figli;\n- Postordine: Visito prima tutti i figli e poi la radice.\n\nNon ha molto senso la visita simmetrica, per ovvi motivi. Naturalmente non sapendo quante sono le chiamate per leggere i figli devo usare un metodo iterativo o ricorsivo. In genere il modo più semplice è scrivere una funzione ad hoc, che itera sui figli e a sua volta richiama la funzione di visita sui figli visitati, rendendo il tutto un processo ricorsivo.\n\nNB: Approssimativo. Riguarda lezione 32 su YT.\n\n","x":8260,"y":-2440,"width":949,"height":1242,"color":"5"},
		{"id":"53e73b5f0a51c58f","type":"text","text":"# Array\n\nLa più semplice struttura dati. Può essere ordinato o disordinato, con relativi costi.\n\n|                         | Disordinato | Ordinato         |\n| ----------------------- | ----------- | ---------------- |\n| Ricerca                 | $\\Theta(n)$ | $\\Theta(log(n))$ |\n| Min/Max                 | $\\Theta(n)$ | $\\Theta(1)$      |\n| Predecessore/Successore | $\\Theta(n)$ | $\\Theta(1)$      |\n| Insert                  | $\\Theta(1)$ | $\\Theta(n)$      |\n| Delete                  | $\\Theta(1)$ | $\\Theta(n)$      |\nCome si evince dalla tabella, nessuna delle due è \"meglio\" dell'altra, dipende dalla situa. I motivi di questi costi sono abbastanza ovvi, non li scrivo.","x":9582,"y":645,"width":784,"height":390,"color":"4"},
		{"id":"b71bc19e4715ff0d","type":"text","text":"# Dizionari (Tabelle)\n\nUn dizionario gestisce un insieme dinamico di dati tramite le sole operazioni di `insert`, `search` e `delete`. Segue nomenclatura.\n\n- $U$ - Il dominio dei valori delle chiavi, consta di soli valori interi;\n- $m$ - Il numero di posizioni a disposizione nella struttura dati;\n- $n$ - Il numero di elementi da memorizzare.\n\nGeneralmente si implementano tramite ABR o tabelle. Che tipo di tabelle?\n\n- ***Indirizzamento Diretto*** - Salvo i dati in un array, la chiave è l'indice. Nonostante sia ottimo in termini di efficienza di accesso, il problema è che ***spesso le chiavi sono sparse***, e dovrei allocare un vettore enorme per contenere pochi elementi;\n- ***Hash*** - Le chiavi sono numeri arbitrariamente grandi e c'è una funzione di hash che le riconduce in un range più piccolo. Visto che le chiavi sono poche si spera fortemente che questa cosa non produca ***collisioni*** in cui due chiavi sono mappate nello stesso valore di hash. Nonostante ci siano dei modi per diminuire questo rischio (i.e. l'***ipotesi di uniformità semplice***, ovvero dato un input la pdf dell'output è piatta nel range dei valori di hash) questa roba è ***inevitabile***;\n- ***Liste di Trabocco*** - Come nelle tabelle hash, ma visto che possono esserci più chiavi mappate nello stesso valore di hash ad ogni indice associo un ***puntatore ad una lista*** in cui salvo tutte le chiavi degeneri in quell'indice.\n\t- Usare le SCL porta ad un accesso che in linea di principio non è $\\Theta(1)$. L'***inserimento*** resta $\\Theta(1)$ (basta aggiungere in testa), ma la ***ricerca*** e l'***eliminazione*** sono $O(n)$ (nel caso peggiore tutte le chiavi sono degeneri nello stesso indice).\n- ***Indirizzamento Aperto*** - Cambio il mio modo di gestire le collisioni. La funzione ha due input, la chiave e le collisioni già trovate. Esempio, $H(k, 0)$ produce un risultato, ma c'è già un valore in quell'indice. Allora ricalcolo $H(k, 1)$ che mi restituisce un nuovo valore, e così via finché non riesco a piazzare l'elemento.\n\t- L'inserimento diventa $O(n)$, perché alla peggio tutte le $H(k, 0)$ sono uguali;\n\t- Utilizzabile solo se $m\\geq n$, o il fattore di carico $\\alpha = \\frac{n}{m}$ è $\\leq 1$;\n\t- Non ho capito perché, ma c'è un problema con l'eliminazione degli elementi (credo)","x":9582,"y":-342,"width":784,"height":849,"color":"4"},
		{"id":"5230741cf2445855","type":"text","text":"# GRAFI (ING INF)\nInsiemi di nodi collegati tra loro in qualunque modo. Oltre a questo, una prima distinzione è tra\n\n- Grafi NON ORIENTATI, ovvero in cui gli archi indicano collegamenti bidirezionali: se A è collegato a B, allora B è collegato ad A;\n- Grafi ORIENTATI, in cui gli archi si indicano con una freccia e implicano un verso di collegamento: A può essere collegato a B anche se B non è collegato ad A.\n\nOltre a questo, è possibile mettere delle ETICHETTE sugli archi (GRAFI PESATI). Una seconda distinzione è tra grafi\n\n- STATICI, in cui il numero dei nodi è noto a priori;\n\t- Si possono rappresentare in modo più semplice, come una matrice avente come ingressi i nodi e valori booleani che indicano se è presente o meno quel collegamento (MATRICE DI ADIACENZA). Si noti che per un grafo non orientato questa matrice è simmetrica. Se il grafo è pesato, al posto dei valori booleani 0/1 si possono mettere direttamente i pesi.\n\t- Se il grafo è SPARSO (pochi elementi collegati rispetto al totale) la matrice di adiacenza è sconveniente.\n\t\n- DINAMICI, in cui non lo è.\n\t- La rappresentazione dipende dal numero effettivo dei nodi e degli archi.\n\t- Si implementa con SCL. Ad esempio, vettore con elementi corrispondenti ai nodi che puntano a SCL con collegamenti degli archi (liste di successori). Oppure lista di liste. Oppure albero n-ario senza vincoli sui figli che devono fare riferimento a nodi adiacenti.\n\n","x":9474,"y":-1125,"width":1000,"height":577,"color":"5"},
		{"id":"de8fa994061ccee5","type":"text","text":"# Ordinamento Lineare (Counting Sort)\n\nScorro l'array `A` da ordinare (costo $\\Theta(n)$) per trovare il massimo, che chiamo $k$. Creo un array di supporto `C` lungo $k+1$ e scorro nuovamente `A`. Ogni volta che incontro il generico valore $i$ incremento di uno l'elemento `C[i]`. Alla fine di questo ballo, `C` contiene tutti i valori che compaiono in `A` con le relative frequenze. Basta copiarli ordinatamente di nuovo in `A`. Nel complesso, viene fuori una roba $\\Theta(n)$ (o $\\Theta(k))$, se $k>n$) che richiede un vettore di appoggio.\n\n```\ndef CountingSort (A):\n\tk = max(A)                    # Θ(n)\n\tn = len(A)\n\tC = [0]*(k+1)                 # Θ(k)\n\tfor j in range(n):\n\t\tC[A[j]] += 1\n\tj = 0\n\tfor i in range(k+1):          # Θ(k)\n\t\twhile (C[i] > 0)\n\t\tA[j] = i\n\t\tj += 1\n\t\tC[i] –= 1\n```","x":2691,"y":693,"width":786,"height":560,"color":"4"},
		{"id":"e7a61ba2a1daa959","type":"text","text":"# Counting Sort con Dati Satellite\n\nSi dicono ***dati satellite*** quelle informazioni che orbitano attorno ad un altro dato. Ad esempio, potrei avere il set di dati {`nome` `cognome` `età`} da ordinare secondo le età. Se faccio collassare tutte le età uguali in un unico punto, come mantengo le diverse informazioni di partenza?\n\nMi serve un terzo vettore, `B`.\n\nOra non mi va, forse lo faccio dopo.","x":2691,"y":200,"width":786,"height":380,"color":"2"},
		{"id":"135ae5cbed3cae62","type":"text","text":"# Droga\n\n[Dati random, one-by-one](https://www.youtube.com/watch?v=kPRA0W1kECg&ab_channel=Ardens).\n\nTante [varianti](https://www.youtube.com/watch?v=8MsTNqK3o_w&ab_channel=Musicombo) degli algoritmi standard, in sequenza.\n\nAlgoritmi standard visualizzati come [altezze](https://www.youtube.com/watch?v=ZZuD6iUe3Pc&ab_channel=ViktorBohush) e poi come [colore](https://www.youtube.com/watch?v=14oa9QBT5Js&ab_channel=ViktorBohush).\n\nTanti algoritmi standard visualizzati come [altezze](https://www.youtube.com/watch?v=BeoCbJPuvSE&ab_channel=ViktorBohush).\n","x":1794,"y":860,"width":504,"height":322,"color":"#45ff45"},
		{"id":"50021ea2700a7d6d","type":"text","text":"# Esempi di visite\n\n- ***Contare il numero di nodi*** - Sarebbe ricorsivamente il numero di nodi nel sottoalbero sinistro più quelli nel destro più 1 (il nodo radice). Quindi postordine.\n- ***Ricerca in un albero binario*** - Ha senso controllare il nodo attuale prima dei successivi, quindi preordine.\n- ***Calcolo dell'altezza*** - Devo sommare 1 al mio sottoalbero di altezza più grande, ma prima devo trovarlo, quindi postordine.\n- ***Stampare i valori*** di un albero binario di ricerca ***in ordine crescente*** - Dato che i valori più piccoli del padre sono nel sottoalbero sinistro devo visitare prima quest'ultimo, poi il genitore e infine il destro. Visita in-ordine.\n\t- Notare che in questo modo potrei implementare un algoritmo di ordinamento. La visita ha costo $\\Theta(n)$, costruire un albero binario di ricerca... dipende.\n\t\t- Nel caso peggiore, l'albero viene fuori completamente sbilanciato. L'altezza resta sempre $O(n)$ e pertanto il costo complessivo è$$T(n) = \\sum_{i=1}^n\\Theta(i) = \\Theta(n^2)$$Nel caso migliore, l'albero resta sempre bilanciato, l'altezza è $O(\\log(n))$ e pertanto il costo complessivo $O(n\\log(n))$, mentre nel caso medio (i.e. inserire gli elementi in modo casuale) è anch'esso $\\Theta(n\\log(n))$;\n\t\t- Posso però sfruttare alberi per i quali è garantito il bilanciamento ad ogni step, come gli ***alberi rosso-neri***.","x":5610,"y":-3600,"width":980,"height":586,"color":"4"},
		{"id":"fa33bc027fcd6616","type":"text","text":"# ... quindi non si può risolvere?!\n\nCerto che si può, usando il ***metodo delle radici caratteristiche***.\n\n- Ansatz: Ipotizzo soluzione della forma $T(n) = r^n$;\n- Sostituisco nell'equazione di ricorrenza di Fibonacci, ottenendo$$r^n = r^{n-1} + r^{n-2}\\Rightarrow r^2 = r+1$$\n- Risolvo, trovando le radici $\\phi$ e $\\psi$. In questo caso $\\phi\\simeq1.618$ è la ***sezione aurea***;\n- Scrivo la soluzione generale come somma dei due contributi$$T(n)=A\\phi^n+B\\psi^n$$dove le costanti $A$ e $B$ dipendono dalle condizioni iniziali;\n- Per l'andamento asintotico domina la radice più grande, ergo$$T(n) = \\Theta(\\phi^n)$$\n\nSi noti che le stime fatte con il metodo iterativo funzionano, poiché$$\\sqrt{2^n}<\\phi<2^n$$","x":-1760,"y":3639,"width":578,"height":542,"color":"4"},
		{"id":"62c35cb45576f46c","type":"text","text":"# Alberi n-ari e Grafi (ING INF)\n\nRilassare la condizione di avere al più due figli porta agli ***alberi n-ari***.\nRilassare la condizione di avere uno e un solo padre porta ai ***grafi***.","x":8438,"y":-897,"width":594,"height":121,"color":"5"},
		{"id":"51dc4b66c9d4edad","type":"text","text":"# Pseudocodice Visita per Livelli\n\n```\ndef visita_per_livelli (r; head, tail):\n\tif (r == None): return\n\tEnqueue(head, tail, r)\n\twhile (!CodaVuota(head)):\n\t\tp = Dequeue(head, tail)\n\t\tfun(p) #accesso al nodo e operazioni conseguenti\n\t\tif (p->left != None): Enqueue(head, tail, p->left)\n\t\tif (p->right != None): Enqueue(head, tail, p->right)\n\treturn\n```","x":7223,"y":-2162,"width":670,"height":343,"color":"4"},
		{"id":"33ca3a70b120e4d4","type":"file","file":"InDepthVisit.jpg","x":7223,"y":-2709,"width":669,"height":269},
		{"id":"8c2d484dbd89c2ce","type":"file","file":"InOrder.gif","x":7358,"y":-3080,"width":400,"height":184},
		{"id":"7f02fb167c10afcc","type":"file","file":"Postorder.gif","x":7893,"y":-3080,"width":400,"height":184},
		{"id":"837090654e9e454a","type":"file","file":"PreOrder.gif","x":6823,"y":-3080,"width":400,"height":184},
		{"id":"097ba6d89af122d2","type":"text","text":"# [Quicksort](https://www.youtube.com/watch?v=ZHVk2blR45Q&ab_channel=RobEdwards)\n\nAlgoritmo basato sulla filosofia ***divide et impera*** che cerca di prendere il meglio dei due mondi.\n\n- Dal Merge Sort il ridotto tempo di esecuzione;\n- Dal Selection Sort l'***ordinamento in loco***.\n\nLa divisione in due sotto-array non avviene esattamente esattamente a metà come nel Merge. Assumendo pdf piatta, si sceglie il primo valore dell'array come ***pivot***. E che ci faccio? Tramite due indici scorro il resto della lista e divido gli elementi restanti in due macro-gruppi.\n\n- Il primo indice (diciamo `i`) tiene conto di fin dove arrivano gli elementi più piccoli del pivot;\n- Il secondo indice scorre la lista, e se trova un elemento più piccolo del pivot lo scambia con l'elemento `i + 1`. A seguito di ciò, `i` viene incrementato.\n\nQuesta operazione, che possiamo chiamare funzione di `Partizionamento`, ha un costo $\\Theta(n)$ e restituisce un vettore che consta di due sotto-vettori aventi solo elementi rispettivamente più piccoli e più grandi del pivot. E poi? Chiamo ricorsivamente la `Quicksort` su questi sotto-vettori, esattamente come nel Merge. Il costo complessivo si calcola a partire da$$T (n) = Θ(1) + P (n) + T (k) + T (n − k)$$Poiché l'indice $k$ che divide l'array è variabile ci sono due casi limite.\n\n- ***Caso migliore*** - L'array viene sempre diviso esattamente a metà. Ricadiamo nel calcolo del costo del Merge Sort, che viene $\\Theta(n\\,log(n))$;\n- ***Caso peggiore*** - Scelgo sempre il peggior pivot possibile, ovvero quello che divide il vettore in due sotto-vettori di lunghezze $1$ ed $n-1$. In questo caso il costo è $\\Theta(n^2)$.\n\nDisastro! Il caso peggiore è terribile! ... sì, ma il ***caso medio*** è $\\Theta(n\\,log(n))$. Questa cosa si rompe solo se l'array è \"poco disordinato\" (i.e. la pdf non è piatta, quindi scegliere il primo elemento come pivot ha un enorme bias). Per ovviare a questa cosa si adottano strategie furbe.\n\n- Randomizzo l'array prima di darlo in pasto al Quicksort;\n- Scelgo un pivot a caso e non sistematicamente il primo o l'ultimo.","x":4240,"y":3000,"width":792,"height":834,"color":"4"}
	],
	"edges":[
		{"id":"ff9241251fd89e0a","fromNode":"d58e07debc64d646","fromSide":"right","toNode":"3cb8fa98b476d018","toSide":"left"},
		{"id":"f9dca02562002393","fromNode":"d58e07debc64d646","fromSide":"left","toNode":"26ecf9a9035be6c9","toSide":"right"},
		{"id":"99d8762d8e9c3acc","fromNode":"3cb8fa98b476d018","fromSide":"top","toNode":"5c46055a11913af6","toSide":"bottom"},
		{"id":"8277042a65c7cf18","fromNode":"26ecf9a9035be6c9","fromSide":"top","toNode":"229254fddfcb152d","toSide":"bottom"},
		{"id":"e2a46a418e98fd9c","fromNode":"229254fddfcb152d","fromSide":"right","toNode":"c2548ea0755bf41c","toSide":"left"},
		{"id":"c326851f2c9d862f","fromNode":"5c46055a11913af6","fromSide":"left","toNode":"c2548ea0755bf41c","toSide":"right"},
		{"id":"eb74c7ab3baa3fc6","fromNode":"c2548ea0755bf41c","fromSide":"right","toNode":"5c46055a11913af6","toSide":"left"},
		{"id":"b6b7ac2890c9e9ff","fromNode":"26ecf9a9035be6c9","fromSide":"left","toNode":"0c6a12bec4ec08b4","toSide":"right"},
		{"id":"5e6ea51877ea4c3d","fromNode":"0c6a12bec4ec08b4","fromSide":"bottom","toNode":"eb76c79fdbda44ba","toSide":"top"},
		{"id":"eb0664e14dc0bf8f","fromNode":"0c6a12bec4ec08b4","fromSide":"bottom","toNode":"0d969a895166efd0","toSide":"top"},
		{"id":"ea8b371593eebec3","fromNode":"d58e07debc64d646","fromSide":"bottom","toNode":"ec8b575605b1f28b","toSide":"top"},
		{"id":"3c18574c76a179fc","fromNode":"d58e07debc64d646","fromSide":"bottom","toNode":"309351163ae6947b","toSide":"top"},
		{"id":"4d25840c86304103","fromNode":"d58e07debc64d646","fromSide":"bottom","toNode":"6d8b317b86100794","toSide":"top"},
		{"id":"940cc061738ffab1","fromNode":"0c6a12bec4ec08b4","fromSide":"top","toNode":"69e1b6e849e034bc","toSide":"bottom"},
		{"id":"41dd4f681ccffce0","fromNode":"ec8b575605b1f28b","fromSide":"bottom","toNode":"8dc6dea62661677d","toSide":"top"},
		{"id":"c3f88e18ae98ad01","fromNode":"ec8b575605b1f28b","fromSide":"bottom","toNode":"70e8fb607562e26c","toSide":"top"},
		{"id":"7d5b3d1f70113351","fromNode":"6d8b317b86100794","fromSide":"left","toNode":"6161eae15a3e550b","toSide":"right"},
		{"id":"a0c3bbd0b36296f7","fromNode":"6d8b317b86100794","fromSide":"bottom","toNode":"3b1ca8e5ad600d47","toSide":"top"},
		{"id":"3dbda28e80ee89b5","fromNode":"ec8b575605b1f28b","fromSide":"right","toNode":"6161eae15a3e550b","toSide":"left"},
		{"id":"ab6d48e316035311","fromNode":"3b1ca8e5ad600d47","fromSide":"left","toNode":"7e4058ebe27c3056","toSide":"top"},
		{"id":"3e67aa738480c0ad","fromNode":"7e4058ebe27c3056","fromSide":"bottom","toNode":"bc1a401f9f7f9064","toSide":"top"},
		{"id":"e8b7fd6fbc9b88e1","fromNode":"3b1ca8e5ad600d47","fromSide":"bottom","toNode":"5ab0c89fe6fc2d30","toSide":"top"},
		{"id":"a4c45e59df6b6d20","fromNode":"3b1ca8e5ad600d47","fromSide":"bottom","toNode":"90a96a97d8b70809","toSide":"top"},
		{"id":"8d05f062ea75fe1a","fromNode":"3b1ca8e5ad600d47","fromSide":"right","toNode":"4f60934c85991f1d","toSide":"top"},
		{"id":"dcc986452120669a","fromNode":"309351163ae6947b","fromSide":"left","toNode":"839a6bd47e0cb007","toSide":"right"},
		{"id":"fdad2928b713b52f","fromNode":"309351163ae6947b","fromSide":"bottom","toNode":"308ddaa4fba0f145","toSide":"top"},
		{"id":"6f4951ff5ae7f772","fromNode":"309351163ae6947b","fromSide":"bottom","toNode":"b49cf2c6d986d25c","toSide":"top"},
		{"id":"80879acd51a4b603","fromNode":"309351163ae6947b","fromSide":"right","toNode":"465cbbbb72157ad0","toSide":"top"},
		{"id":"69e9cf448f245c31","fromNode":"465cbbbb72157ad0","fromSide":"left","toNode":"5c0d1ea27e63b5d6","toSide":"right"},
		{"id":"132cf3abc8a1ab71","fromNode":"309351163ae6947b","fromSide":"right","toNode":"de8fa994061ccee5","toSide":"bottom"},
		{"id":"548027074ecb58a2","fromNode":"465cbbbb72157ad0","fromSide":"bottom","toNode":"302746ef669b26dc","toSide":"top"},
		{"id":"e0e54f90a85eef39","fromNode":"465cbbbb72157ad0","fromSide":"right","toNode":"097ba6d89af122d2","toSide":"left"},
		{"id":"ba2e7a3155b2da5b","fromNode":"302746ef669b26dc","fromSide":"left","toNode":"9a1c5c47a77e2038","toSide":"right"},
		{"id":"ce6b0757230894bc","fromNode":"302746ef669b26dc","fromSide":"bottom","toNode":"ed03fe8d87064a44","toSide":"top"},
		{"id":"a8b7836210cc8146","fromNode":"9a1c5c47a77e2038","fromSide":"bottom","toNode":"dfd34ed380a58414","toSide":"top"},
		{"id":"1ded4e4ebdbc76e7","fromNode":"302746ef669b26dc","fromSide":"bottom","toNode":"ea1ab7bdab75582f","toSide":"top"},
		{"id":"e8787d1632d53097","fromNode":"302746ef669b26dc","fromSide":"right","toNode":"097ba6d89af122d2","toSide":"left"},
		{"id":"a6473740a47c6cc1","fromNode":"465cbbbb72157ad0","fromSide":"right","toNode":"09832ca107cfaf02","toSide":"left"},
		{"id":"f91d14b162b3f999","fromNode":"366c75dbe4439c2c","fromSide":"left","toNode":"b77aa226a6ec3a35","toSide":"right"},
		{"id":"869950b6cad4e8cd","fromNode":"b77aa226a6ec3a35","fromSide":"left","toNode":"d78a8546bc66a9fa","toSide":"right"},
		{"id":"0502c78680ef61ef","fromNode":"d78a8546bc66a9fa","fromSide":"left","toNode":"999dd8de13fca977","toSide":"top"},
		{"id":"69b4cd8b1de28f28","fromNode":"999dd8de13fca977","fromSide":"bottom","toNode":"f117e625335780b7","toSide":"top"},
		{"id":"38241e44070c6320","fromNode":"999dd8de13fca977","fromSide":"left","toNode":"e1fecc256cca6f1d","toSide":"right"},
		{"id":"a14fc35d3d96df82","fromNode":"09832ca107cfaf02","fromSide":"top","toNode":"e1fecc256cca6f1d","toSide":"bottom"},
		{"id":"5d5a1faad04f929f","fromNode":"e1fecc256cca6f1d","fromSide":"bottom","toNode":"09832ca107cfaf02","toSide":"top"},
		{"id":"877396eb93fe7dc7","fromNode":"e1fecc256cca6f1d","fromSide":"right","toNode":"999dd8de13fca977","toSide":"left"},
		{"id":"0d750dd478f3d3b4","fromNode":"e1fecc256cca6f1d","fromSide":"top","toNode":"39277162e9de0e82","toSide":"bottom"},
		{"id":"381bb78c036ade7f","fromNode":"e1fecc256cca6f1d","fromSide":"left","toNode":"2cdcb25cb319947f","toSide":"right"},
		{"id":"4ac81a4c1436ed33","fromNode":"de8fa994061ccee5","fromSide":"top","toNode":"e7a61ba2a1daa959","toSide":"bottom"},
		{"id":"c4aab41d58e67d04","fromNode":"366c75dbe4439c2c","fromSide":"top","toNode":"a44fc8dcd44442b6","toSide":"bottom"},
		{"id":"220b480638fdae37","fromNode":"366c75dbe4439c2c","fromSide":"right","toNode":"53e73b5f0a51c58f","toSide":"left"},
		{"id":"b2bf84508ce965bc","fromNode":"366c75dbe4439c2c","fromSide":"bottom","toNode":"175892fce12234ff","toSide":"top"},
		{"id":"11c2c0fea25747d7","fromNode":"175892fce12234ff","fromSide":"bottom","toNode":"76ac7d40adf06a17","toSide":"top"},
		{"id":"94dfe4bca4e881cf","fromNode":"175892fce12234ff","fromSide":"left","toNode":"b77aa226a6ec3a35","toSide":"bottom"},
		{"id":"02881e5dd2500f77","fromNode":"b77aa226a6ec3a35","fromSide":"bottom","toNode":"583996bcfd383a51","toSide":"top"},
		{"id":"bb02861f39e24c3c","fromNode":"b77aa226a6ec3a35","fromSide":"top","toNode":"fe7f208b5b0a5332","toSide":"bottom"},
		{"id":"be45bdcdf6592e80","fromNode":"fe7f208b5b0a5332","fromSide":"right","toNode":"62c35cb45576f46c","toSide":"left"},
		{"id":"54fc0d0cbc8e3d35","fromNode":"fe7f208b5b0a5332","fromSide":"left","toNode":"c7d02bbb0d8db2cb","toSide":"right"},
		{"id":"468f94c82d62563a","fromNode":"c7d02bbb0d8db2cb","fromSide":"top","toNode":"10a4ec34bd5576ba","toSide":"bottom"},
		{"id":"a3613bc6b6245bce","fromNode":"10a4ec34bd5576ba","fromSide":"left","toNode":"7e3760652e3cd8b9","toSide":"right"},
		{"id":"a3feba2341e37a4a","fromNode":"10a4ec34bd5576ba","fromSide":"left","toNode":"31cdab338e348df8","toSide":"right"},
		{"id":"1650b1482c0f6bff","fromNode":"62c35cb45576f46c","fromSide":"top","toNode":"8afe10a63942da8e","toSide":"bottom"},
		{"id":"bc0473aba34d250f","fromNode":"62c35cb45576f46c","fromSide":"right","toNode":"5230741cf2445855","toSide":"left"},
		{"id":"289ba17f8cfc88ad","fromNode":"10a4ec34bd5576ba","fromSide":"right","toNode":"51dc4b66c9d4edad","toSide":"left"},
		{"id":"a9c27af8eeb53a5f","fromNode":"10a4ec34bd5576ba","fromSide":"top","toNode":"50021ea2700a7d6d","toSide":"bottom"},
		{"id":"491aa9e55c764f9f","fromNode":"d78a8546bc66a9fa","fromSide":"left","toNode":"c7d02bbb0d8db2cb","toSide":"bottom"},
		{"id":"033f213c6968e5e8","fromNode":"31cdab338e348df8","fromSide":"top","toNode":"350f10e234c3ef7a","toSide":"bottom"},
		{"id":"34123b05f58d514b","fromNode":"31cdab338e348df8","fromSide":"left","toNode":"0b0f3702d23dd294","toSide":"right"},
		{"id":"32551ec16423373f","fromNode":"0b0f3702d23dd294","fromSide":"left","toNode":"b438b724129b737d","toSide":"right"},
		{"id":"d5f9d704d56e5aec","fromNode":"53e73b5f0a51c58f","fromSide":"bottom","toNode":"d78749dca1e4aa0f","toSide":"top"},
		{"id":"32f6fe346f0aaf32","fromNode":"d78749dca1e4aa0f","fromSide":"bottom","toNode":"ff82a5222aa32e06","toSide":"top"},
		{"id":"72a5610f159574e6","fromNode":"76ac7d40adf06a17","fromSide":"right","toNode":"d78749dca1e4aa0f","toSide":"left"},
		{"id":"8c9a015bbc5fdbb4","fromNode":"d78749dca1e4aa0f","fromSide":"left","toNode":"76ac7d40adf06a17","toSide":"right"},
		{"id":"4c78e0f445b0754b","fromNode":"d78749dca1e4aa0f","fromSide":"right","toNode":"8f8360d10d823d4d","toSide":"left"},
		{"id":"734020c0bc86711d","fromNode":"350f10e234c3ef7a","fromSide":"top","toNode":"790207f76db11656","toSide":"bottom"},
		{"id":"ec07a04f8b48d894","fromNode":"366c75dbe4439c2c","fromSide":"top","toNode":"b71bc19e4715ff0d","toSide":"left"},
		{"id":"d837ddb20e77c331","fromNode":"309351163ae6947b","fromSide":"top","toNode":"135ae5cbed3cae62","toSide":"bottom"},
		{"id":"093b414054cd0356","fromNode":"bc1a401f9f7f9064","fromSide":"left","toNode":"fa33bc027fcd6616","toSide":"right"},
		{"id":"16d066923480ca2f","fromNode":"10a4ec34bd5576ba","fromSide":"right","toNode":"33ca3a70b120e4d4","toSide":"left"},
		{"id":"c9ba0523ae2615f3","fromNode":"50021ea2700a7d6d","fromSide":"left","toNode":"350f10e234c3ef7a","toSide":"right"},
		{"id":"98ca5af2f4a88759","fromNode":"33ca3a70b120e4d4","fromSide":"top","toNode":"7f02fb167c10afcc","toSide":"bottom"},
		{"id":"19486e9cacc41085","fromNode":"33ca3a70b120e4d4","fromSide":"top","toNode":"8c2d484dbd89c2ce","toSide":"bottom"},
		{"id":"3dbaa69b70fed608","fromNode":"33ca3a70b120e4d4","fromSide":"top","toNode":"837090654e9e454a","toSide":"bottom"}
	]
}