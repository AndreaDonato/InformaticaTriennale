{
	"nodes":[
		{"id":"3cb8fa98b476d018","type":"text","text":"# Notazione Asintotica\n\n- $O$ definisce il ***limite superiore asintotico*** (i.e. \"non oltre questo andamento asintotico\");\n- $\\Omega$ definisce il ***limite inferiore asintotico*** (i.e. \"non meno di questo andamento asintotico);\n- $\\Theta$ definisce l'***esatto comportamento asintotico*** (i.e. se $f(n)$ è sia in $O(g(n))$ sia in $\\Omega(g(n))$ allora è $\\Theta(g(n))$). \n\n$$1 ≺ log_a (n) ≺ \\sqrt[b]{n} ≺ n^c ≺ d^n ≺ n! ≺ n^n$$","x":800,"y":-21,"width":628,"height":520,"color":"4"},
		{"id":"d58e07debc64d646","type":"text","text":"# Algoritmi\n\nUn ***algoritmo*** è una ***sequenza di comandi elementari ed univoci che terminano in un tempo finito*** ed operano su strutture dati.\n","x":-120,"y":148,"width":628,"height":182,"color":"6"},
		{"id":"26ecf9a9035be6c9","type":"text","text":"# Costo Computazionale\n\nLe performance di un algoritmo sono valutate su un modello di macchina astratta (dunque indipendente dalla specifica macchina che lo esegue) detta ***Random Access Machine*** (***RAM***), tale che\n\n- Esiste un solo CPU core che esegue le operazioni sequenzialmente;\n- Esiste un limite alle dimensioni degli oggetti memorizzabili.\n- Esistono solo operazioni elementari, e richiedono un tempo costante;\n\t- Questo è vero solo se assumiamo che i dati siano più brevi delle *word* di memoria, ed è detta ***misura di costo uniforme***.\n\nIntuitivamente, il costo di un algoritmo è una funzione monotona non decrescente dell'input. In particolare, è la somma dei costi di tutte le istruzioni che lo compongono. Dal momento che ogni operazione elementare ha costo costante, l'unica cosa che fa crescere il costo asintotico sono i ***cicli***.\n\nIn generale, a seconda dell'input l'algoritmo può presentare un costo migliore o peggiore. Ci focalizziamo sul ***caso peggiore***.","x":-1080,"y":-21,"width":628,"height":520,"color":"4"},
		{"id":"c2548ea0755bf41c","type":"text","text":"# Ottimizzazione II\n\nProblema: devo calcolare un polinomio in un punto. Come faccio?\n\n```\ndef Calcola_Polinomio(A, x):\n\tsomma = 0\n\tfor i in range(len(a)):\n\t\tpotenza = 1\n\t\tfor j in range(i):\n\t\t\tpotenza = x*potenza\n\t\tsomma = somma + A[i]*potenza\n\treturn somma\n```\n\nQuesto algoritmo è $\\Theta(n^2)$. Posso fare di meglio? Sì, dal momento che le potenze sono sequenziali posso usare \"ricorsivamente\" quella precedente:\n\n```\ndef Calcola_Polinomio_Intelligente(A, x):\n\tsomma = 0\n\tpotenza = 1\n\tfor i in range(len(a)):\n\t\tpotenza = x*potenza\n\t\tsomma = somma + A[i]*potenza\n\treturn somma\n```\n\nC'è un solo ciclo `for`, ergo questo è $\\Theta(n)$.","x":-120,"y":-851,"width":628,"height":671,"color":"4"},
		{"id":"229254fddfcb152d","type":"text","text":"# Ottimizzazione I\n\nProblema: devo sommare i primi $n$ interi. Come faccio?\n\n```\ndef CalcolaSomma(n):\n\tsomma = 0\n\tfor i in range (1, n + 1):\n\t\tsomma += i\n\treturn somma\n```\n\nQuesto algoritmo ha costo $\\Theta(n)$. Ma posso fare di meglio? Sì, perché\n$$\\sum_{i=1}^nk = \\frac{n(n+1)}{2}$$\nche tradotto in codice significa\n\n```\ndef CalcolaSommaIntelligente(n):\n\tsomma = n*(n+1)/2\n\treturn somma\n```\nche ha costo $\\Theta(1)$. Morale della favola? A volte si può ottimizzare.","x":-1080,"y":-851,"width":628,"height":671,"color":"4"},
		{"id":"0c6a12bec4ec08b4","type":"text","text":"# Quante iterazioni?\n\nPrendiamo un `n` positivo, inizializziamo `x = r = 0` e valutiamo\n\n```\nwhile x*x < n:\n\tx += 1\n```\n\nLa condizione di terminazione del ciclo è $x^2 \\geq n$, quindi si ha uguaglianza dopo circa $x \\simeq \\sqrt{n}$ iterazioni $\\Rightarrow \\Theta(\\sqrt{n})$.\n\nSe invece consideriamo una situazione in cui decremento $n$ di $2^k$\n\n```\nwhile n > 1:\n\tn = n//2\n```\n\navrò uguaglianza nella condizione per $\\frac{n}{2^k} \\simeq 1$, ovvero dopo $k \\simeq log_2(n)$ iterazioni. Viene da sé che decrementare $n$ in modo logaritmico porta ad un numero esponenziale di iterazioni.","x":-1940,"y":-21,"width":560,"height":520,"color":"4"},
		{"id":"eb76c79fdbda44ba","type":"text","text":"# Esempio $\\Theta$ Esponenziale\n\n```\nx = t = 1\nfor i in range(n):\n\tt = 3*t\nt -= 1\nwhile t >= x:\n\tx += 2\n\tt -= 2\n```\n\nAl termine del primo ciclo (di costo $\\Theta(n)$) `t` vale $3^n$. Nel secondo ciclo `x` e `t` provano a colmare l'esponenziale distanza che li separa con incrementi lineari. Dopo $k$ iterazioni del `while` `x` vale $2k+1$, mentre `t` vale $3^n - (2k+1)$. La condizione per terminare il `while` è quindi $3^n = 2(2k+1)$, ovvero $k = \\frac{3^n-2}{4} \\Rightarrow \\Theta(3^n)$.","x":-2240,"y":640,"width":560,"height":431,"color":"4"},
		{"id":"0d969a895166efd0","type":"text","text":"# Esempio $\\Theta = log(log(n))$\n\n```\np = 2\nwhile n >= p:\n\tp=p*p\n```\n\nAd ogni iterazione `p` viene incrementato del suo quadrato. Dopo $k$ iterazioni sarà $2^{2^k}$. Condizione di terminazione è che $2^{2^k} = n + 1$, ovvero dopo $k \\simeq log_2(log_2(n+1))$ iterazioni $\\Rightarrow \\Theta\\big(log_2(log_2(n))\\big)$.","x":-1640,"y":640,"width":560,"height":431,"color":"4"},
		{"id":"309351163ae6947b","type":"text","text":"# Ordinamento","x":1303,"y":1720,"width":250,"height":60},
		{"id":"69e1b6e849e034bc","type":"text","text":"# Tempo di Esecuzione\n\nUna volta stabilito l'andamento asintotico, possiamo stabilire quanto tempo impiega l'algoritmo ad essere eseguito su una macchina di cui conosciamo il numero $k$ di operazioni al secondo:\n\n$$T =\\frac{f(n)}{k}$$\nSe ad esempio la macchina esegue un'operazione elementare in un nanosecondo $k = 10^9$, per un input $n = 10^6$ abbiamo\n\n- $O(n)$ - $T = 1ms$\n- $O(nlog(n))$ - $T \\sim 20ms$\n- $O(n^2)$ - $T = 17\\,min$\n- $O(2^n)$ - $T \\sim 10^{13}\\,yrs$\n\n\n","x":-1940,"y":-721,"width":560,"height":411,"color":"4"},
		{"id":"70e8fb607562e26c","x":-1640,"y":1780,"width":700,"height":697,"color":"4","type":"text","text":"# Ricerca Binaria\n\nUn algoritmo di ***ricerca binaria***, invece, ***assume che gli elementi siano ordinati*** e procede per bisezione. Questo si riassume in due step.\n\n- Controllo l'elemento centrale dell'array. Se è esattamente il valore che cerco ho finito, altrimenti ci sono due possibili casi:\n\t- Il mio elemento è più piccolo $\\Rightarrow$ devo cercare nel mezzo-array di sinistra;\n\t- Il mio elemento è più grande $\\Rightarrow$ devo cercare nel mezzo-array di destra.\n- Itero finché non resta un solo elemento. Se corrisponde a $v$ restituisco l'indice, altrimenti restituisco `NULL` (o `-1`, o `come ti pare`).\n\nIl caso migliore è $\\Omega(1)$, ma quello peggiore? Devo dividere l'array fino ad avere un solo elemento. Se per farlo biseco $k$ volte la lunghezza è esprimibile come $\\frac{n}{2^k}$, che sarà quindi pari a $1$. Questo significa che $k = log_2(n)$, quindi è $O(log_2(n))$.\n\nE l'andamento stretto? Per farlo devo assumere che\n\n - La *pdf* per `v` all'interno di `A` (quindi $v\\in A$) è piatta;\n - Per semplicità di calcolo, $n$ è una potenza di $2$.\n\nDopo $k$ iterazioni sono state controllate $2^{k-1}$ posizioni ($1$ dopo una iterazione, $2$ dopo due, $4$ dopo tre, ...), quindi una frazione $\\frac{2^{k-1}}{n}$ dell'array. Ma visto che la *pdf* di `v` in `A` è piatta, questa è anche la probabilità di trovare `v` alla $k$-esima iterazione, ovvero la probabilità di fare esattamente $k$ iterazioni. Quindi il valor medio è\n$$\\langle n\\rangle = \\sum_{k=0}^{log_2(n)}\\bigg(k\\,\\cdot\\,\\frac{2^{k-1}}{n}\\bigg) = [...] = log_2(n) +\\frac{1}{n} - 1 = \\Theta(log_2(n))$$"},
		{"id":"8dc6dea62661677d","x":-2380,"y":1780,"width":700,"height":388,"color":"4","type":"text","text":"# Ricerca Sequenziale\n\n\nUn algoritmo di ***ricerca sequenziale*** è intuitivamente $O(n)$ (il caso peggiore è quello in cui il valore non esiste, devo scorrere tutto l'array), ma è anche $\\Omega(1)$ se l'elemento è in prima posizione.\n\nSegue che non è semplice determinare il costo asintotico stretto $\\Theta$ di un un simile algoritmo, motivo per cui per farlo si stima un valore atteso per il numero di iterazioni. La *pdf* per il valore $v$ lungo l'array è piatta a priori:\n$$P = \\frac{1}{n} \\Rightarrow \\langle n\\rangle = \\sum_{k = 0}^n\\frac{k}{n} = \\frac{1}{n}\\frac{n(n+1)}{2} = \\frac{n+1}{2} \\sim \\frac{n}{2}$$\nIl comando `in` di Python, ad esempio, usa una ricerca sequenziale per determinare condizioni del tipo `if v in A`, risultando quindi $\\Theta(n)$."},
		{"id":"ec8b575605b1f28b","type":"text","text":"# Ricerca\n\nL'input di un problema di ricerca sono un ***array*** `A` di $n$ elementi ed un ***valore `v` da trovare*** al suo interno. L'output è l'indice del valore trovato, o un `NULL` in caso non esista.\n\n\n","x":-1914,"y":1360,"width":508,"height":150,"color":"6"},
		{"id":"6d8b317b86100794","type":"text","text":"# Ricorsione","x":-60,"y":1360,"width":508,"height":150},
		{"id":"6161eae15a3e550b","x":-820,"y":1780,"width":700,"height":697,"type":"text","text":"# Ricerca Binaria Ricorsiva\n\nÈ possibile implementare "},
		{"id":"5c46055a11913af6","type":"text","text":"# Proprietà della notazione asintotica\n\nSe mi ritrovo un ciclo annidato, il costo complessivo è dato da $$\\sum_{i=0}^n \\Theta(i) = \\Theta\\bigg(\\sum_{i=0}{i}\\bigg) = \\Theta(n^2)$$ \nÈ possibile ***portare la sommatoria dentro la $\\Theta$*** (e viceversa).","x":800,"y":-624,"width":628,"height":217,"color":"4"}
	],
	"edges":[
		{"id":"ff9241251fd89e0a","fromNode":"d58e07debc64d646","fromSide":"right","toNode":"3cb8fa98b476d018","toSide":"left"},
		{"id":"f9dca02562002393","fromNode":"d58e07debc64d646","fromSide":"left","toNode":"26ecf9a9035be6c9","toSide":"right"},
		{"id":"99d8762d8e9c3acc","fromNode":"3cb8fa98b476d018","fromSide":"top","toNode":"5c46055a11913af6","toSide":"bottom"},
		{"id":"8277042a65c7cf18","fromNode":"26ecf9a9035be6c9","fromSide":"top","toNode":"229254fddfcb152d","toSide":"bottom"},
		{"id":"e2a46a418e98fd9c","fromNode":"229254fddfcb152d","fromSide":"right","toNode":"c2548ea0755bf41c","toSide":"left"},
		{"id":"c326851f2c9d862f","fromNode":"5c46055a11913af6","fromSide":"left","toNode":"c2548ea0755bf41c","toSide":"right"},
		{"id":"eb74c7ab3baa3fc6","fromNode":"c2548ea0755bf41c","fromSide":"right","toNode":"5c46055a11913af6","toSide":"left"},
		{"id":"b6b7ac2890c9e9ff","fromNode":"26ecf9a9035be6c9","fromSide":"left","toNode":"0c6a12bec4ec08b4","toSide":"right"},
		{"id":"5e6ea51877ea4c3d","fromNode":"0c6a12bec4ec08b4","fromSide":"bottom","toNode":"eb76c79fdbda44ba","toSide":"top"},
		{"id":"eb0664e14dc0bf8f","fromNode":"0c6a12bec4ec08b4","fromSide":"bottom","toNode":"0d969a895166efd0","toSide":"top"},
		{"id":"ea8b371593eebec3","fromNode":"d58e07debc64d646","fromSide":"bottom","toNode":"ec8b575605b1f28b","toSide":"right"},
		{"id":"3c18574c76a179fc","fromNode":"d58e07debc64d646","fromSide":"bottom","toNode":"309351163ae6947b","toSide":"left"},
		{"id":"4d25840c86304103","fromNode":"d58e07debc64d646","fromSide":"bottom","toNode":"6d8b317b86100794","toSide":"top"},
		{"id":"940cc061738ffab1","fromNode":"0c6a12bec4ec08b4","fromSide":"top","toNode":"69e1b6e849e034bc","toSide":"bottom"},
		{"id":"41dd4f681ccffce0","fromNode":"ec8b575605b1f28b","fromSide":"bottom","toNode":"8dc6dea62661677d","toSide":"top"},
		{"id":"c3f88e18ae98ad01","fromNode":"ec8b575605b1f28b","fromSide":"bottom","toNode":"70e8fb607562e26c","toSide":"top"},
		{"id":"ce9c40bee44f69d1","fromNode":"70e8fb607562e26c","fromSide":"right","toNode":"6161eae15a3e550b","toSide":"left"},
		{"id":"7d5b3d1f70113351","fromNode":"6d8b317b86100794","fromSide":"left","toNode":"6161eae15a3e550b","toSide":"top"}
	]
}