{
	"nodes":[
		{"id":"99a579f63e8ed830","type":"text","text":"# Automa Deterministico a Stati Finiti (DFA)\n\nUn automa deterministico a stati finiti è una quintupla $(Q,\\Sigma,\\delta,q_0,F)$ dove\n\n- $Q$ è l'insieme finito degli ***stati***, ognuno dei quali ha esattamente un arco uscente per ogni simbolo di $\\Sigma$;\n- $\\Sigma$ è l'***alfabeto*** compreso dall'automa;\n- $\\delta:Q\\times \\Sigma\\to Q$ è la ***funzione di transizione degli stati***, in pratica una matrice che associa ogni riga (simbolo dell'alfabeto) ad ogni colonna (stato di partenza), i cui elementi sono gli stati di arrivo.\n\t- Rappresenta la risposta dell'automa che si trova in un determinato stato ad un simbolo in input.\n- $q_0\\in Q$ è lo ***stato iniziale***;\n- $F\\subseteq Q$ è l'insieme degli ***stati accettanti***, ovvero stati in cui l'automa accetta di terminare l'esecuzione.\n\nPosso però dare all'automa una sequenza di simboli di input, ovvero una stringa. In tal caso posso definire ricorsivamente una ***funzione di transizione estesa*** tale che$$\\begin{cases}\n\\delta^*(q,\\varepsilon) = \\delta(q, \\varepsilon) = q\\\\\n\\delta^*(q, aw) = \\delta^*(\\delta(q, a), w) \\quad\\text{dove }a\\in\\Sigma,w\\in\\Sigma^*\n\\end{cases}$$In pratica significa che $\\delta^*$ restituisce lo stato finale a seguito di un input in formato stringa. In generale, ad ogni istante l'automa si trova in una specifica ***configurazione***, identificata dalla coppia $(q,w)$ formata dallo ***stato attuale*** $q$ e dalla ***stringa*** $w$ che deve ancora ***interpretare*** a partire da quello stato.\n\nOgni esecuzione di un singolo simbolo fa effettuare all'automa un singolo ***passo di computazione***. Dato un simbolo $a$ e due stati $p,q\\in Q$, dire che $\\delta(p,a)=q$ è equivalente a dire che $(p, aw) ⊢ (q, w)$. Questo concetto è generalizzabile ad una sequenza di passi. Sono equivalenti le scrittura $\\delta^*(q_i,w)=q_f$ e $q_i,w) ⊢^*(q_f,\\varepsilon)$.\n\nL'automa è detto ***deterministico*** se ad ogni passo di computazione segue una ed un'unica configurazione.\n\nLa stringa $w$ è ***accettata*** $A=(Q,\\Sigma,\\delta,q_0,F)$ se $\\delta^*(q_0, w)\\in F(A)$, ovvero se l'***interpretazione*** di tale stringa fa terminare l'automa su uno stato accettante. Di conseguenza definiamo il ***linguaggio*** di $A$ l'insieme di tutte le stringhe accettate da A o, in modo analogo, diciamo che ***$A$ riconosce $L(A)$***.","x":-360,"y":700,"width":880,"height":747,"color":"4"},
		{"id":"e865a825bb442798","type":"text","text":"# Automa Non-Deterministico a Stati Finiti (NFA)\n\nSe ***la funzione di transizione degli stati non è univoca*** (i.e. alla configurazione $(q,a)$ possono seguire diverse configurazioni), allora l'automa è non-deterministico. Formalmente,$$\\delta: Q\\times\\Sigma_\\varepsilon \\to \\mathcal{P}(Q)$$dove $\\Sigma_\\varepsilon$ è l'***alfabeto epsilon*** associato a $\\Sigma$ (banalmente, $\\Sigma \\cup \\{\\varepsilon\\}$) e $\\mathcal{P}$ rappresenta tutti i possibili sottoinsiemi di $Q$ (***insieme potenza***), intendendo che ogni input può produrre in output un qualsiasi sottoinsieme di stati.\n\nContemporaneamente? Beh no, però a livello teorico posso costruire un albero. L'automa ***si sdoppia***\n\n- ogni volta che c'è ***ambiguità di simbolo*** (e.g. partendo da $q_1$, $1$ porta sia allo stato $q_1$ che allo stato $q_2$);\n- ogni volta che esiste un ***$\\varepsilon$-arco in uscita***: un ramo considera l'attesa del simbolo successivo come \"non fare niente\" (e dunque interpreta $\\varepsilon$, spostandosi lungo l'arco) mentre l'altro resta nello stato corrente.\n\nOgni volta che arrivo in uno stato in cui il simbolo da interpretare non compare su un arco in uscita, ***la computazione termina*** (ogni stato può avere un qualsiasi numero di archi uscenti per ogni simbolo di $\\Sigma$). L'unico stato finale consentito è uno stato accettante in cui non restano ulteriori simboli da interpretare. Se ***almeno un ramo termina su uno stato accettante***, l'NFA ***accetta*** la stringa.","x":680,"y":700,"width":920,"height":491,"color":"4"},
		{"id":"963502012eaccd57","type":"file","file":"NooDeterministic.png","x":1708,"y":700,"width":400,"height":108},
		{"id":"9ce2f5e78688648f","type":"file","file":"NonDeterministicTree.png","x":1708,"y":934,"width":400,"height":459},
		{"id":"d570218de39c6a66","type":"file","file":"Esempi/M3.png","x":-1908,"y":595,"width":400,"height":245},
		{"id":"cb4951b922ab48e7","type":"text","text":"$A = \\{w|w$ la somma dei numeri della stringa è multiplo di 3$\\}$\n\n- $q_0$ è lo stato \"finora la somma modulo $3$ fa $0$ o c'è stato un `RESET`\"\n- $q_1$ è lo stato \"finora la somma modulo $3$ fa $1$\"\n- $q_0$ è lo stato \"finora la somma modulo $3$ fa $2$\"","x":-2008,"y":917,"width":600,"height":146,"color":"4"},
		{"id":"4026031a39513573","type":"file","file":"Esempi/M1.png","x":-1908,"y":-346,"width":400,"height":132},
		{"id":"09eeba7d186cc631","type":"text","text":"$A = \\{w|w$ Contiene almeno un $1$ e un numero pari di $0$ segue l'ultimo $1\\}$.\n\n- $q_1$ è lo stato \"non ho ancora letto alcun $1$\";\n- $q_2$ è lo stato che definisce l'alfabeto;\n- $q_3$ è lo stato \"dopo l'ultimo $1$ c'è un numero dispari di $0$\"","x":-2008,"y":-154,"width":600,"height":146,"color":"4"},
		{"id":"202120fe71270d90","type":"file","file":"Esempi/M2.png","x":-1909,"y":98,"width":400,"height":263},
		{"id":"9c7bf0e17764ae61","type":"text","text":"$A = \\{w|w$ inizia e finisce con lo stesso simbolo$\\}$\n\n- $q_1$ è lo stato \"la stringa inizia e finisce per $a$\" (analogo $r_1$ con $b$);\n- $q_2$ è lo stato \"la stringa inizia per $a$ ma finisce per $b$\" (analogo $r_2$).","x":-2008,"y":407,"width":600,"height":114,"color":"4"},
		{"id":"a95021f577a47f4e","type":"text","text":"# Progettare Automi\n\nGli automi non hanno memoria e non sanno quanti simboli mancano per finire la stringa. Pertanto, ad ogni simbolo letto devono essere in grado di decidere se la stringa letta ***finora*** fa parte del linguaggio.\n\nLe etichette degli stati sono fondamentali per capire cosa succede.","x":-2860,"y":129,"width":580,"height":201,"color":"4"},
		{"id":"3ce00288d2634111","type":"text","text":"# Esempio di rappresentazione formale\n\nUn automa che accetta stringhe i cui numeri sommati sono multiplo di $i$ non è rappresentabile graficamente, ma posso dire che\n\n- $\\delta_i(q_j,0) = q_j$\n- $\\delta_i(q_j,k) = q_n$, dove $n = (j+k)\\%\\,i$\n- $\\delta_i(q_j,\\langle RESET\\rangle) = q_0$\n- $q_0$ è sia lo stato iniziale che l'unico stato accettante.","x":-1182,"y":575,"width":693,"height":285,"color":"4"},
		{"id":"0d399f2af310e7d9","type":"text","text":"# Equivalenza tra NFA e DFA: Linguaggi Regolari\n\nLa classe dei linguaggi di $\\Sigma$ riconosciuti da un DFA $\\mathcal{L}(DFA)$ e quella dei linguaggi di $\\Sigma$ riconosciuti da un NFA $\\mathcal{L}(NFA)$ coincidono, e sono detti ***linguaggi regolari*** (linguaggio è regolare $\\Leftrightarrow \\exists$ NFA che lo riconosce).\n\nCome conseguenza, dato un NFA è sempre possibile costruire un DFA ad esso equivalente (il contrario è ovvio, perché il DFA è un sotto-caso dell'NFA). Come?\n\n- Identifica tutti i possibili sottoinsiemi di $Q$ (e.g. se $Q=\\{q_1,q_2,q_3\\}$ allora avrò $\\{\\emptyset, q_1, q_2, q_3, q_{12}, q_{13}, q_{23}, q_{123}\\}$). Questi saranno tutti e soli gli stati del DFA equivalente;\n- Definiamo l'***estensione*** di $R\\in Q$ come $E(R)$, intendendo gli stati di $R$ più tutti gli stati raggiungibili da $R$ tramite soli $\\varepsilon$-archi. Lo stato iniziale del DFA è l'estensione dello stato iniziale dell'NFA (e.g. $q_1\\to q_{13}$);\n- Gli stati accettanti sono tutti quelli che hanno almeno uno stato accettante dell'NFA di partenza. In questo caso, $\\{q_1, q_{12}, q_{13}, q_{23}, q_{123}\\}$;\n- A questo punto devo farmi tutte le transizioni per ogni stato e vedere per ognuna l'insieme di stati a cui porta. Con tanto lavoro e tanta fantasia ottengo una roba tipo l'esempio sotto.\n\nDetto questo, i linguaggi regolari godono della proprietà di ***chiusura*** rispetto a tutti gli operatori definiti in precedenza (***concatenazione***, ***complemento***, ***unione***, ***intersezione***, ***potenza***, ***star*** e ***plus***), i.e. se tali operatori prendono in input linguaggi regolari, l'output sarà ancora un linguaggio regolare.","x":680,"y":1260,"width":920,"height":584,"color":"4"},
		{"id":"816848e0c2ad721f","type":"text","text":"# Perché gli NFA?\n\n- Spesso costruire e capire un NFA è più semplice rispetto al suo DFA equivalente;\n\t- Sicuramente in generale un NFA è più piccolo del suo DFA equivalente.\n- Il paradigma di calcolo parallelo si presta a due parallelismi (pun intended):\n\t- Programmazione multi-thread;\n\t- Computazione quantistica.","x":700,"y":303,"width":880,"height":272,"color":"3"},
		{"id":"73b289d2ddac85e0","type":"file","file":"Esempi/M4-DFA.png","x":1181,"y":-73,"width":399,"height":193},
		{"id":"2154feb042ce2858","type":"text","text":"# Un semplice NFA\n\nCostruire un automa che riconosce le stringhe aventi un $1$ in terzultima posizione è un compito semplice con un NFA. È sufficiente tenere ***traccia dell'$1$ su un singolo ramo*** di computazione che ipotizza di essere a tre step dalla fine (se non lo è, lo stato $q_4$ muore perché non ha archi in uscita).\n\nSi noti che\n\n- con un DFA dovrei considerare tutte le possibili situazioni;\n- con piccole variazioni sull'NFA posso costruire un automa che accetta le stringhe aventi un $1$ in una delle ultime tre posizioni (i.e. aggiungendo $\\varepsilon$ nelle transizioni $q_2\\to q_3$ e $q_3\\to q_4$)","x":700,"y":-380,"width":420,"height":500,"color":"4"},
		{"id":"8bb56d96ae177393","type":"text","text":"# Computazione\n\nEseguire una computazione significa interpretare una sequenza di simboli $\\{w_i\\}$ percorrendo una sequenza di stati $\\{r_i\\}$ tali che\n\n- $r_0 = q_0$, cioè si parte dallo stato iniziale;\n- $r_n = q_F\\in F$, cioè si arriva in uno stato accettante;\n- $\\delta(r_i, w_{i}) = r_{i+1}$, ovvero in un ***DFA*** si passa da un elemento della sequenza al successivo tramite la funzione di transizione degli stati.\n\t- In un ***NFA*** questa definizione va generalizzata: $r_{i+1}\\in\\delta(r_i,w_i)$.","x":-1182,"y":925,"width":693,"height":297,"color":"4"},
		{"id":"1362d388c8714d48","type":"text","text":"# Dimostrare le Chiusure\n\n- ***Unione*** - Date $N_1$ ed $N_2$, basta creare un nuovo stato iniziale che si collega tramite $\\varepsilon$-archi agli stati iniziali delle macchine originali.\n\t- Per l'***intersezione*** non si possono usare gli NFA, bisogna costruire la prova tramite DFA.\n- ***Concatenazione*** - Collego tutti gli stati accettanti di $N_1$ allo stato iniziale di $N_2$ tramite $\\varepsilon$-archi.\n\t- Da questo segue la dimostrazione per la ***potenza***, in quanto sequenza di concatenazioni.\n- ***Star*** - Creo un nuovo stato iniziale che punta con un $\\varepsilon$-arco al vecchio stato iniziale, poi faccio puntare tutti gli stati accettanti al vecchio stato iniziale.\n\t- Questo dimostra anche il ***Plus***, perché $L^+ = L\\,L^*$, che è una concatenazione.","x":-360,"y":1535,"width":880,"height":309,"color":"4"},
		{"id":"4b19755e121bf99d","type":"file","file":"RegEx.png","x":1708,"y":2285,"width":400,"height":326},
		{"id":"5bd9813160538beb","type":"text","text":"# Linguaggi ed Espressioni Regolari\n\nI linguaggi regolari sono rappresentabili tramite le ***espressioni regolari*** (***regex***, $re(\\Sigma)$). $R$ è una regex se è\n\n- $a$, per qualche $a\\in \\Sigma$ (cioè se è costituita da simboli dell'alfabeto);\n- $\\varepsilon$ (la stringa vuota è una regex);\n- $\\emptyset$ (l'insieme vuoto è una regex);\n- unione, concatenazione o star di regex.\n\n`THM` - **Un linguaggio è regolare se e solo se esiste una regex che lo descrive**. Questo si dimostra nei due versi:\n\n- Se $\\mathcal{L}$ è descritto da una regex $R$, allora è regolare. Devo costruire un NFA che riconosce $\\mathcal{L}$ a partire da $R$. Posso farlo per ognuno dei punti che definiscono una regex.\n\t- $a$ - Un NFA $\\{\\{q_1,q_2\\}, \\Sigma, \\delta, q_1, \\{q_2\\}\\}$ che parte da $q_1$ e che va in $q_2$ accettante tramite $a$ riconosce $\\mathcal{L}(R) = \\{a\\}$\n\t- $\\varepsilon$ - Un NFA $\\{\\{q_1\\}, \\Sigma, \\delta, q_1, \\{q_1\\}\\}$ che parte da uno stato accettante riconosce $\\mathcal{L}(R) = \\{\\varepsilon\\}$;\n\t- $\\emptyset$ - Un NFA $\\{\\{q_1\\}, \\Sigma, \\delta, q_1, \\emptyset\\}$ privo di stati accettanti riconosce $\\mathcal{L}(R) = \\emptyset$;\n\t- Per unione, concatenazione e star: i linguaggi regolari sono chiusi rispetto alle operazioni regolari.\n- Se $\\mathcal{L}$ è regolare, allora esiste una regex che lo descrive. O, equivalentemente, devo dimostrare di poter trasformare un generico automa in una regex. Questo si può fare con i GNFA, secondo lo schema seguente:\n\t- Posso sempre trasformare un DFA in un GNFA aggiungendo un nuovo stato iniziale che punta con un $\\varepsilon$-arco al vecchio stato iniziale, e in modo analogo un nuovo stato accettante puntato dai vecchi stati accettanti. Inoltre se, ad esempio, tra i nodi $q_i$ e $q_j$ vi sono due archi che vanno nella stessa direzione e con etichette rispettivamente $a$ e $b$, li sostituisco con un unico arco avente etichetta $a\\cup b$;\n\t- Non è restrittivo dimostrare che posso trasformare un GNFA in una regex. Come? Riducendo il numero di nodi fino ad ottenerne esattamente due. Posso sempre farlo? Sì, togliendo un nodo alla volta e modificando l'automa in modo che accetti sempre lo stesso linguaggio;\n\t- L'etichetta dell'unico arco che va da $q_i$ a $q_f$ quando il GNFA è ridotto a due nodi è la regex cercata.","x":680,"y":1960,"width":920,"height":709,"color":"4"},
		{"id":"1e66a8c6f7d0cfc8","type":"file","file":"NFA.png","x":200,"y":1960,"width":319,"height":232},
		{"id":"5ce0efb2ba6f0a14","type":"text","text":"# NFA Generalizzati (GNFA)\n\nUn GNFA è una quintupla $(Q,\\Sigma,\\delta,q_i,q_f)$ in cui $|Q|\\geq 2$ e la funzione di transizione è definita come$$\\delta:(Q-\\{q_i\\})\\times(Q-\\{q_f\\}) \\to re(\\Sigma)$$ovvero\n- $q_i$ ha solo transizioni uscenti, $q_f$ ha solo transizioni entranti;\n- Ogni transizione tra tutte le possibili coppie di stati è un'***espressione regolare***.\n\nPer costruzione, le stringhe vengono lette a gruppi anziché a simboli. Ad esempio, dando in pasto alla GNFA a fianco la stringa `abbbaaab` si ha che\n\n- Dallo stato iniziale, viene letta la sequenza `abbb` (corrispondente alla regex $ab^*$) finendo in $q_2$;\n- Segue `aaab`. Qui essendo una NFA l'albero si sdoppia, in quanto si potrebbe interpretare\n\t- secondo la regex $a^*$. In questo caso vengono lette tre `a` e si finisce in $q_1$. Rimane solo `b`, che viene interpretata dalla regex $b^*$. Finiamo quindi in $q_{accept}$ come previsto;\n\t- secondo la regex $(aa)^*$. In questo caso vengono lette due `a` e restiamo in $q_2$. Rimane `ab`, che rientra nella regex $ab\\cup ba$, quindi anche qui finiamo in $q_{accept}$.\n\n\nI linguaggi GNFA sono più generali dei linguaggi DFA (e quindi NFA). Si ha infatti che $\\mathcal{L}(DFA)\\subseteq \\mathcal{L}(GNFA)$ (????).","x":1740,"y":1631,"width":880,"height":542,"color":"3"},
		{"id":"4e5009f864f3c65f","type":"file","file":"GNFA.png","x":2700,"y":1775,"width":400,"height":254},
		{"id":"58b249e919fb0f61","type":"file","file":"DFA_FromNFA.png","x":200,"y":2244,"width":319,"height":173},
		{"id":"043186a341c6fc88","type":"text","text":"# Algoritmo di Riduzione\n\nSia $k$ il numero di stati del GNFA $G$.\n\n```\ndef Convert(G):\n\tSe k = 2:\n\t\tRestituisci la regex;\n\tAltrimenti:\n\t\tScegli un nodo;\n\t\tEliminalo;\n\t\tAggiorna G in G';\n\t\tChiama Convert(G')\n```\n\nQuesto si basa sul fatto (dimostrabile per induzione) che $\\forall\\,G$, `Convert(G)` è equivalente a $G$.","x":130,"y":2780,"width":460,"height":423,"color":"#4545ff"},
		{"id":"20930ba61df4d18d","type":"file","file":"RiduzioneGNFA.png","x":160,"y":2495,"width":400,"height":174},
		{"id":"2ada182acf4c1e0a","type":"text","text":"# Pumping Lemma per i Linguaggi Regolari\n\nEsistono linguaggi non riconoscibili da automi finiti, quindi non regolari. Ma come faccio a capire se lo sono?\n\nEsiste un teorema, detto ***pumping lemma***, che individua una proprietà unica dei linguaggi regolari.\n\nSe $A$ è un linguaggio regolare, allora $\\exists$ un numero $p>0$ detto ***lunghezza di pumping*** tale che qualsiasi stringa $s\\in A$ di lunghezza $\\geq p$ può essere suddivisa in tre parti $p=xyz$ tali che\n\n1. $\\forall\\,i\\geq0,\\,\\,xy^iz\\in A$;\n2. $|y|>0$ (se così non fosse sarebbe banale);\n3. $|xy|\\leq p$.\n\nQuesta cosa è di facile dimostrazione.\n\n- Se nessuna stringa di $A$ è lunga almeno $p$, il teorema è automaticamente vero;\n- Viceversa, prendiamo un automa $M=(Q,\\Sigma,\\delta,q_1,F)$ con $p$ stati ed una stringa $s$ lunga $n>p$. L'automa attraversa $n+1$ stati, e ovviamente $n+1>p$. Per il principio della piccionaia deve esistere uno stato che si ripete. Questo significa che esistono tre percorsi:\n\t- Da $q_i$ a $q_r$, che chiamiamo $x$;\n\t- Da $q_r$ a $q_r$ stesso, che chiamiamo $y$ (ed è chiaro che posso ripetere $y$ un qualsiasi numero di volte);\n\t- Da $q_r$ a $q_f$, che chiamiamo $z$.\n- È ovvio che $|xy|\\leq p$. La macchina ha $p$ stati. Prima di arrivare a ripetermi (quindi prima della fine di $y$) non posso averli visitati tutti. Anche se mi ripeto la prima volta (arrivando in $q_r$) raggiungo al più $p$, perché non ho ancora raggiunto lo stato accettante (manca $z$).","x":680,"y":2780,"width":920,"height":636,"color":"4"},
		{"id":"99633375e6887712","type":"text","text":"# Applicazioni del Pumping Lemma\n\nPer ***dimostrare che un linguaggio non è regolare*** assumo che lo sia e trovo una stringa che viola il pumping lemma.\n\n- $B=\\{0^n1^n\\,|\\,n>0\\}$. Devo trovare una stringa della forma $xyz\\in B$ tale che $xy^iz\\in B$.\n\t- $y$ non può avere solo simboli uguali a $0$ o uguali a $1$. Se così fosse, si vede subito che $xyyz$ non ha lo stesso numero di $0$ e $1$, quindi $\\notin B$;\n\t- $y$ non può neanche avere entrambi i simboli, poiché in $yy$ non sarebbero nell'ordine corretto.\n\t- $B$ non è regolare perché si viola la condizione `1`.\n- $C=\\{w\\,|\\,w\\text{ ha lo stesso numero di zeri e uni}\\}$. Prendiamo $s=0^p1^p$.\n\t- Dato che per la condizione `3` deve essere $|xy|\\leq p$, se scelgo $x=\\varepsilon$ devo avere che $|y|\\leq p$, ergo è composta di soli zeri. Se itero $y$ ottengo più zeri che uni, da cui $xy^iz\\notin C$;\n\t- Alternativamente, posso notare che se $C$ fosse regolare lo sarebbe anche $C\\cap 0^*1^*$ (perché $0^*1^*$ è regolare e i linguaggi regolari sono chiusi rispetto all'intersezione). Ma $C\\cap 0^*1^* = B$, che non è regolare.\n- $F=\\{ww\\,|\\,w\\in\\{0,1\\}^*\\}$. Prendiamo $s=0^p\\,1\\,0^p\\,1$. Anche qui, basta prendere $x=\\varepsilon$ e notare che $y$ consta di soli $0$ mentre $z=1\\,0^p\\,1$, e che quindi già $xyyz\\notin F$.\n- $E=\\{0^i 1^j\\,|\\,i>j\\}$. In questo caso è utile il fatto che nella condizione `1` sia incluso $i=0$. Se divido $0^{p+1}1^p$ in $x=\\varepsilon$, $y=0^p$ e $z=01^p$, noto che per $i=0$ (ovvero ***cancellando*** $y$) la stringa $xz$ ha più uni che zeri, quindi $\\notin E$. Questa tecnica di cancellazione è detta ***pumping down***.","x":670,"y":3500,"width":940,"height":524,"color":"4"},
		{"id":"f4475828cc860da0","type":"text","text":"# Automi a Stati Finiti\n\nCos'è un computer?\n\nPer automatizzare le operazioni di calcolo è necessario un ***modello di computazione*** che rappresenti schematicamente ciò che deve accadere.\n\nL'***automa a stati finiti*** è il più semplice modello di computazione data poca memoria. Si basa sull'idea di avere ***pochissima memoria***, il che si traduce appunto in \"pochi\" stati esplorabili dal sistema (per capire dove mi trovo in un dato istante, i dati vanno indicizzati. $n$ bit di memoria codificano $2^n$ stati).\n\nL'automa a stati finiti è rappresentabile mediante ***diagramma di stato***. L'insieme $A$ di tutte e sole le stringhe accettate dalla macchina $M$ è detto linguaggio di $M$, e si indica con $L(M) = A$. In tal caso si dice che $M$ ***riconosce*** $A$. Se $M$ non accetta alcuna stringa non vuota accetta il linguaggio vuoto $\\emptyset$.\n\nSe esiste una $M$ che riconosce $A$, allora $A$ è un ***linguaggio regolare***.\n\nA volte è impossibile esibire il diagramma di stato, o perché sarebbe troppo grande o perché dipende da un generico parametro $k$. In tal caso bisogna ricorrere alla definizione formale di computazione.","x":-1275,"y":-154,"width":880,"height":471,"color":"6"},
		{"id":"699b4440e0614fe9","type":"text","text":"Automi a stati finiti <-> catene di Markov\n","x":-109,"y":67,"width":377,"height":29},
		{"id":"eb7f2e8ab3192fd4","type":"file","file":"PumpingLemmaRegex.png","x":1708,"y":2989,"width":399,"height":218},
		{"id":"15ec29fc11a1ee12","type":"text","text":"# Regex\n\n**Esempi di espressioni regolari:**\n\n1. **Caratteri singoli:**\n    \n    - `a` corrisponde al carattere `a`.\n    - `.` corrisponde a qualsiasi carattere singolo.\n2. **Gruppi e opzioni:**\n    \n    - `[abc]` corrisponde a `a`, `b` o `c`.\n    - `[a-z]` corrisponde a qualsiasi lettera minuscola da `a` a `z`.\n3. **Quantificatori:**\n    \n    - `a*` corrisponde a zero o più `a`.\n    - `a+` corrisponde a una o più `a`.\n    - `a?` corrisponde a zero o una `a`.\n    - `a{3}` corrisponde esattamente a tre `a`.\n    - `a{2,5}` corrisponde a due fino a cinque `a`.\n4. **Ancoraggi:**\n    \n    - `^a` corrisponde a `a` all'inizio di una riga.\n    - `a$` corrisponde a `a` alla fine di una riga.\n5. **Gruppi di cattura:**\n    \n    - `(abc)` corrisponde esattamente alla sequenza `abc` e può essere usato per catturare e riferirsi al contenuto corrispondente.","x":-649,"y":1960,"width":579,"height":709,"color":"1"},
		{"id":"eb6a901325ad751e","type":"text","text":"# Premesse ai Linguaggi\n\nUn ***insieme finito di simboli*** è detto ***alfabeto***. In particolare, $\\Sigma =\\{0, 1\\}$ è l'***alfabeto binario***.\n\nUna qualsiasi sequenza di simboli $\\{w_i\\in \\Sigma\\}$ si definisce ***stringa*** (o ***parola***) di $\\Sigma$. L'insieme (infinito) di tutte le possibili stringhe si indica con $\\Sigma^*$, ergo $w\\in \\Sigma^*$.\n\n- $|w|$ è la ***lunghezza*** di $w$, ovvero il numero di simboli che vi compaiono;\n- Date $x, y\\in\\Sigma^*$ definiamo la ***concatenazione*** come $xy = x_1...x_n\\,y_1...y_n$;\n- $\\varepsilon$ è la ***stringa vuota***, tale che $|\\varepsilon| = 0$, $\\forall w\\in\\Sigma^*$ $w\\varepsilon = \\varepsilon w = w$ e $\\Sigma^*\\neq\\emptyset \\Rightarrow \\varepsilon\\in\\Sigma^*$;\n- Dati $w\\in\\Sigma^*$ e $a\\in\\Sigma$, $|w|_a$ è il ***conteggio*** di $a$ in $w$, ovvero quante volte $a$ compare in $w$;\n- Se inverto la sequenza $a_1...a_n$ in $a_n...a_1$ ottengo la ***stringa rovesciata***;\n- Posso definire l'operazione di ***potenza*** di una stringa come$$w^n=\\begin{cases}\n\\varepsilon\\qquad\\quad\\text{ se }n=0\\\\\nww^{n-1}\\quad\\text{se }n>1\n\\end{cases}$$\n\nUn qualsiasi sottoinsieme di $\\Sigma^*$ si definisce ***linguaggio*** ***L***. Dati due linguaggi $L_1, L_2\\subseteq\\Sigma^*$ definiamo, oltre agli operatori banali di unione e intersezione,\n\n- ***Completamento*** - $\\overline{L} = \\{w ∈ \\Sigma^∗ | w \\notin L\\}$, cioè tutte quelle stringhe che non fanno parte di $L$;\n- ***Concatenazione*** - Una sorta di prodotto cartesiano. $L_1 ◦ L_2 = \\{xy ∈ \\Sigma^* | x ∈ L_1 , y ∈ L_2 \\}$;\n- ***Potenza*** - Tutte le possibili concatenazioni che si ottengono concatenando $n$ volte, ovvero $$L^n=\\begin{cases}\n\\{\\varepsilon\\}\\qquad\\quad\\text{ se }n=0\\\\\nL◦L^{n-1}\\quad\\text{ se }n>1\n\\end{cases}$$\n- ***Star di Kleene*** - $L^*$ restituisce tutte le possibili combinazioni di zero o più stringhe di $L$. Formalmente,$$L^* = \\bigcup_{n\\geq 0}L^n$$\n- ***Plus di Kleene*** - $L^+$ fa praticamente lo stesso lavoro di $L^*$, ma esclude la stringa vuota $\\varepsilon$.\n\nValgono inoltre le leggi di*** De Morgan*** per qualsiasi linguaggio regolare.\n\n- La negazione dell'intersezione è l'unione delle negazioni -  $\\overline{L_1\\cap L_2} = \\overline{L_1}\\cup\\overline{L_2}$\n\t- Riformulabile negando sia a destra che a sinistra - $L_1\\cap L_2 = \\overline{\\overline{L_1}\\cup\\overline{L_2}}$\n- La negazione dell'unione è l'intersezione delle negazioni - $\\overline{L_1\\cup L_2} = \\overline{L_1}\\cap\\overline{L_2}$ \n\t- Riformulabile negando sia a destra che a sinistra - $L_1\\cup L_2 = \\overline{\\overline{L_1}\\cap\\overline{L_2}}$","x":-1275,"y":-2800,"width":880,"height":955,"color":"6"},
		{"id":"2d31e0c1351d0ffb","type":"text","text":"# Linguaggi Regolari\n\nSono linguaggi rappresentabili tramite (e quindi equivalenti ad) ***Automi a Stati Finiti***. Rappresentano il più semplice modello di computazione data una quantità di memoria limitata.","x":-1275,"y":-1120,"width":880,"height":121,"color":"6"},
		{"id":"25cf3ba9630cd073","type":"text","text":"# Linguaggi Context-Free (CFL)\n\nSono linguaggi generati da ***Grammatiche Context-Free*** (***CFG***) e rappresentabili tramite (e quindi equivalenti ad) ***Automi a Pila*** (***PushDown Automata, PDA***).","x":541,"y":-2383,"width":880,"height":121,"color":"6"},
		{"id":"4b1bc6387b1400ff","type":"text","text":"# Esempi di Linguaggi Context-Free\n\n- $G_3 = (\\{S\\}, \\{a,b\\},R,S)$ dove $R=\\{S\\to aSb\\,|\\,SS\\,|\\,\\varepsilon\\}$. Così com'è può non dire nulla, ma se $a=$`(` e $b=$`)` notiamo che $\\mathcal{L}(G_3)$ è il linguaggio delle stringhe di parentesi correttamente annidate.\n- $G_4 = \\{V,\\Sigma,R,\\langle \\mathtt{EXPR}\\rangle\\}$ definisce la corretta sintassi espressioni con sole addizioni e moltiplicazioni.\n\t- $V = \\{\\langle \\mathtt{EXPR}\\rangle\\langle \\mathtt{TERM}\\rangle\\langle \\mathtt{FACTOR}\\rangle\\}$\n\t- $\\Sigma = \\{\\mathtt{a},\\mathtt{+},\\times,\\mathtt{(}, \\mathtt{)}\\}$$$R = \\begin{cases}\\langle \\mathtt{EXPR}\\rangle\\,\\,\\,\\,\\,\\,\\to\\langle \\mathtt{EXPR}\\rangle+\\langle \\mathtt{TERM}\\rangle\\quad\\,|\\,\\langle \\mathtt{TERM}\\rangle\\\\\\langle \\mathtt{TERM}\\rangle\\,\\,\\,\\,\\,\\,\\to\\langle\\mathtt{TERM}\\rangle\\times\\langle \\mathtt{FACTOR}\\rangle\\,|\\,\\langle \\mathtt{FACTOR}\\rangle\\\\\\langle \\mathtt{FACTOR}\\rangle\\to(\\langle \\mathtt{EXPR}\\rangle)\\qquad\\qquad\\,\\,\\,|\\,a\\end{cases}$$\n\t- È, seppur in maniera molto semplificata, il controllo che effettua il ***parser*** del compilatore. Nell'esempio a fianco, la le parentesi devono modificare l'ordine di esecuzione delle operazioni, e infatti l'albero sintattico risultante è completamente diverso.\n- $G_5$ è come $G_4$, ma tutte le regole sono condensate in una sola, della forma$$R = \\langle \\mathtt{EXPR}\\rangle\\to\\langle\\mathtt{EXPR}\\rangle+\\langle \\mathtt{EXPR}\\rangle\\,|\\,\\langle \\mathtt{EXPR}\\rangle\\times\\mathtt{EXPR}\\rangle\\,|\\,(\\langle \\mathtt{EXPR}\\rangle)\\,|\\,a$$Questa grammatica è simile alla precedente (anche se non tiene conto della priorità della moltiplicazione sull'addizione), ma ha un problema: è ***ambigua***. E che significa? Significa che la stessa stringa può essere generata da diversi alberi sintattici! Esistono linguaggi, detti ***inerentemente ambigui***, che possono essere generati solo e soltanto da grammatiche ambigue.","x":541,"y":-2042,"width":880,"height":565,"color":"4"},
		{"id":"0ae78bba12257fed","type":"file","file":"G4.png","x":0,"y":-2042,"width":399,"height":184},
		{"id":"d7de6946e4bc7f9a","type":"file","file":"AmbiguousG5.png","x":0,"y":-1597,"width":400,"height":120},
		{"id":"a2c08aa1f7f84ed6","type":"file","file":"Esempi/M4_NFA.png","x":1181,"y":-372,"width":399,"height":89},
		{"id":"1d66725355e2923e","type":"text","text":"# Prova a Indovinare!\n\nSpesso gli NFA si basano su assunzioni e ipotesi, perché tanto ogni ipotesi è un singolo ramo dell'intera computazione.\n\nIn $M_5$ si usa l'***alfabeto unario*** che consta del solo carattere $0$, e la macchina accetta sono stringhe lunghe multipli di $2$ (testate nel ramo superiore) e di $3$ (nel ramo inferiore).","x":1708,"y":-273,"width":400,"height":287,"color":"4"},
		{"id":"3c7808314a6a65a4","type":"text","text":"#  Grammatiche Context-Free (CFG)\n\nUna grammatica è detta context-free se le regole di sostituzione non dipendono dal contesto. $G_1$, ad esempio, è una grammatica context-free. Formalmente, è una quadrupla $(V,\\Sigma,R,S)$ dove\n- $V$ è l'insieme finito delle variabili;\n- $\\Sigma$ è l'insieme finito dei terminali (disgiunto da $V$);\n- $R$ è l'insieme finito delle regole che associano ***una variabile ad una stringa***\n- $S$ è la variabile iniziale\n","x":502,"y":-2936,"width":959,"height":273,"color":"4"},
		{"id":"82338f68ab451a7a","type":"text","text":"# Grammatiche Generali\n","x":502,"y":-4160,"width":959,"height":409},
		{"id":"c65672ca13a7b7e6","type":"text","text":"# Grammatiche\n\nUna ***grammatica*** è un ***set di regole di sostituzione*** nella forma $\\text{variabile}\\to\\text{stringa}$, come ad esempio\n$$G_1=\\begin{cases}\nA \\to 0A1\\\\\nA \\to B\\\\\nB \\to \\# \n\\end{cases}\n$$\nNelle $\\text{stringhe}$ possono comparire $\\text{variabili}$ o $\\text{terminali}$ (in questo caso $0,1\\text{ e }\\#$).\n\nA partire dalla ***variabile iniziale***, che compare in genere come primo simbolo del set di regole (in questo caso $A$), posso usare queste regole per ***derivare*** stringhe di soli terminali. Usando $G_1$ posso ad esempio fare$$A\\to0A1\\to00A11\\to000A111\\to000B111\\to000\\#111$$Questa stessa informazione può essere visualizzata graficamente tramite un ***albero sintattico*** (***parse tree***). L'insieme delle stringhe così derivate costituiscono il ***linguaggio della grammatica***, in questo caso $\\mathcal{L}(G_1)=\\{0^n\\#1^n\\,|\\,n>0\\}$.\n\nSe $u, v$ e $w$ sono stringhe e $A\\to w$ è una regola, diciamo che\n\n- $uAv$ ***produce*** $uwv$, ovvero $uAv\\to uwv$;\n- $u$ ***deriva*** $v$ ($u\\to v$, ovvero da $u$ si deriva $v$) se $u=v$ o se esiste una catena $\\{u_k\\}$ tale che $u\\to u_1\\to...\\to u_k\\to...\\to v$.","x":503,"y":-3633,"width":959,"height":506,"color":"6"},
		{"id":"86f18021d67b2c84","type":"file","file":"EnglishGrammar.png","x":1561,"y":-3591,"width":400,"height":174},
		{"id":"d506de86a1bc8de2","type":"file","file":"ParseTree.png","x":-18,"y":-3550,"width":400,"height":340},
		{"id":"79aa400e94a1e523","type":"file","file":"EnglishGrammarExample.png","x":1561,"y":-3343,"width":400,"height":174},
		{"id":"ffe084b275eb59ea","type":"text","text":"# Forma Normale di Chomsky (CNF)\n\nUna grammatica context-free è in CNF se ha ogni regola nella forma$$\\begin{cases}A\\to BC\\\\A\\to a\\end{cases}$$dove\n- $A$ è ***tendenzialmente*** la variabile iniziale, mentre $B$ e $C$ no;\n\t- In che senso \"tendenzialmente\"? Ci sono situazioni in cui **può essere comodo** aggiungere una nuova variabile iniziale. Se la grammatica deve poter generare la stringa vuota posso introdurre una $\\varepsilon$-regola $S\\to A\\,|\\,\\varepsilon$, dove $S$ diventa la variabile iniziale che punta **o** ad $\\varepsilon$ **o** ad $A$, che era la vecchia variabile iniziale. Nota che **è solo una questione di comodo**, potrei benissimo non introdurre $S$ e mettere un `or` su tutte le regole aventi $A$ a sinistra.\n- $a$ è un terminale.\n","x":1761,"y":-3018,"width":720,"height":436,"color":"4"},
		{"id":"35512253a16ef8fb","type":"text","text":"# Automi a Pila (PDA)\n\nPrendi un automa a stati finiti e aggiungigli una pila. Fine. Che ci faccio? Un sacco di cose, in pratica ho aggiunto memoria illimitata.\n\nSe prendo un NFA e aggiungo la pila ottengo un PDA equivalente ai linguaggi context-free. Questo non è vero se faccio la stessa cosa partendo da un DFA, perché i DPDA non sono computazionalmente equivalenti agli NPDA.\n\nDa qui in poi utilizzo PDA per intendere un automa a pila non-deterministico.","x":4270,"y":-2472,"width":730,"height":300,"color":"6"},
		{"id":"b3cbd20b0f8552ad","type":"text","text":"# Esempi di PDA\n\nLe etichette sugli archi di un PDA sono della forma $a,\\,b\\to c$, dove\n\n- $a$ è il simbolo letto in input;\n- $b$ è il simbolo letto (e quindi eliminato, con una `pop`) dalla stack;\n- $c$ è il simbolo scritto (con una `push`) sulla stack.\n\nOgnuno di essi può essere $\\varepsilon$, nel qual caso si ha transizione senza eseguire quella specifica operazione (e.g. $a,\\varepsilon\\to c$ legge $a$ dall'input e pusha $c$ in stack).\n\n- $P_1$ può riconoscere il linguaggio irregolare $\\{0^n\\,1^n\\,|\\,n\\geq0\\}$. Dato che non esiste una primitiva esplicita per controllare che la stack sia vuota, $P_1$ ne demarca anzitutto la fine con il simbolo $\\$$, andando in $q_2$ e restandovi finché legge zeri. Quando inizierà a leggere uni andrà in $q_3$, spostandosi nello stato accettante solo se alla fine della stringa leggerà di nuovo $\\$$ in stack.\n- $P_2$ può riconoscere il linguaggio irregolare $\\{a^ib^jc^k\\,|\\,i,j,k\\geq0\\text{ e } i=j\\text{ oppure } i=k\\}$. È uno step verso la generalizzazione di $P_1$, in quanto prima la macchina segna la fine della stack e inizia ad accumulare le $a$, poi deve contare e confrontare sia le $b$ che le $c$. Lo fa in parallelo, perché è non-deterministico (si noti che un $\\varepsilon$-arco in un PDA ha etichetta $\\varepsilon,\\,\\varepsilon\\to\\varepsilon$).\n","x":3431,"y":-1760,"width":720,"height":547,"color":"4"},
		{"id":"1bba7fc6843da9ed","type":"text","text":"# Definizione Formale di PDA\n\nUn PDA è una sestupla $(Q,\\Sigma,\\Gamma, \\delta,q_0,F)$ dove\n\n- $Q$ è l'insieme finito degli stati;\n- $\\Sigma$ è l'alfabeto delle stringhe di input;\n- $\\Gamma$ è l'***alfabeto della pila***;\n- $\\delta:Q\\times \\Sigma_\\varepsilon\\times\\Gamma_\\varepsilon\\to \\mathcal{P}(Q\\times\\Gamma_\\varepsilon)$ è la funzione di transizione. Calma. Che significa?\n\t- Per decidere quali azioni intraprendere, $\\delta$ deve conoscere lo stato in cui si trova l'automa (i.e. un elemento di $Q$), il simbolo letto in input (potenzialmente anche nessuno, ed è per questo che uso $\\Sigma_\\varepsilon$) e il valore in cima alla pila (anche qui, potrei anche non leggere niente, ovvero non eseguire alcuna `pop`, per questo uso $\\Gamma_\\varepsilon$);\n\t- Quali azioni deve intraprendere? Potenzialmente cambiare stato ($\\in Q$) o scrivere qualcosa in stack con una `push` (quindi un elemento dell'alfabeto $\\Sigma_\\varepsilon$). $\\mathcal{P}$ sta lì perché quando diciamo PDA lo intendiamo sempre non-deterministico.\n- $q_0\\in Q$ è lo stato iniziale;\n- $F\\subseteq Q$ è l'insieme degli stati accettanti.\n","x":4270,"y":-1759,"width":730,"height":540,"color":"4"},
		{"id":"3165d6cf0955425d","type":"file","file":"P1.png","x":3330,"y":-1095,"width":400,"height":247},
		{"id":"889eef30368d267d","type":"file","file":"P2.png","x":3799,"y":-1095,"width":471,"height":247},
		{"id":"7afe9f86cb997f73","type":"text","text":"# Equivalenza tra PDA e CFG (e quindi CFL)\n\n`THM` - ***Un linguaggio è CF se e solo se $\\exists$ un PDA che lo riconosce.***\n\nQuesta roba si dimostra in due step.\n\n- `LMM` - ***Se il linguaggio è CF, allora esiste un PDA che lo riconosce***. Questo lemma si dimostra mostrando che è possibile trasformare la CFG $G$ associata al CFL in un PDA $P$ equivalente. Come? $P$ accetta solo le stringhe $w$ che sono generate da $G$, controllando che esista una derivazione di $w$ secondo $G$. ***Costruiamolo***! Yeee!\n\t1. Anzitutto mettiamo nella pila il ***simbolo di terminazione*** $\\$$, che dagli esempi di PDA abbiamo capito essere necessario per confrontare due stringhe. Dopo $\\$$ va messa la ***variabile iniziale*** $S$;\n\t\t- Questo si traduce in $\\delta(q,$`input`, `pop`$)=\\delta(q_{start},\\varepsilon,\\varepsilon) = \\{(q_{loop}, \\$S)\\}$ $=\\{(q,$`push`$\\}$;\n\t2. Iterativamente controlla la ***variabile*** in cima alla stack e la sostituisce in modo non-deterministico con una delle sue derivazioni;\n\t\t- Se ad esempio abbiamo $S\\to A$, $A\\to BC$ e $A\\to a$, il primo step sarà far passare la stack da $|\\$|S|$ a $|\\$|A|$. Poi però ***quando la computazione si divide, si dividono anche le stack***. Quindi esiste un ramo che sostituisce\n\t\t\t- $A\\to BC$, rendendo la stack $|\\$|C|B|$\n\t\t\t- $A\\to a$, rendendo la stack $|\\$|a|$\n\t\t- Questo si traduce in $\\delta(q_{loop},\\varepsilon, A) = \\{(q_{loop}, w)\\}$, dove $w$ è il generico membro destro della regola avente $A$ come membro sinistro.\n\t3. Se in cima alla stack non c'è una variabile ma un ***terminale***, legge dalla stack e confronta con il primo simbolo ancora da leggere della stringa in input. Se i due simboli sono diversi il ramo di computazione s'interrompe, altrimenti si prosegue con `2` o `3`;\n\t\t- Questo si traduce in $\\delta(q_{loop},s, a) = \\{(q_{loop}, \\varepsilon)\\}$, dove $s$ è un simbolo dell'`input`;\n\t4. Raggiungere $\\$$ porterà l'automa nello stato accettante finale. Se siamo giunti qui è perché finora tutti i simboli confrontati erano uguali. Se la stringa continua dopo lo stato finale, chiaramente viene rifiutata.\n\t\t- Questo si traduce in $\\delta(q_{loop},\\varepsilon, \\$) = \\{(q_{accept}, \\varepsilon)\\}$, dove $q_{accept}$ non ha archi uscenti.\n- `LMM` - ***Se il linguaggio è riconosciuto da un PDA, allora è CF***. Vogliamo ***costruire*** una CFG $G$ che generi tutte e sole le stringhe $x$ riconosciute da un PDA $P$. L'idea è la seguente: per ogni coppia di stati $p,q$ di $P$ si deve dotare $G$ di una variabile $A_{pq}$ che generi tutte e sole le stringhe tali che $P$ passa dallo stato $p$ con pila vuota allo stato $q$ con pila vuota (in generale, $P$ deve passare da $p$ a $q$ lasciando la pila inalterata).\n\t- Per semplicità di dimostrazione prendiamo $P$ tale che\n\t\t- ha un unico stato accettante;\n\t\t- svuota la sua pila prima di accettare una stringa;\n\t\t- ciascuna transizione effettua una `push` ***oppure*** una `pop`. Non entrambe contemporaneamente, né nessuna delle due. Si può sempre portare $P$ in questa forma sostituendo ogni arco che non rispetta questa condizione con due archi che la rispettano. Se le faceva entrambe, prima una e poi l'altra. Se non ne faceva alcuna, si inserisce e si toglie un simbolo arbitrario dalla pila.\n\t- Date queste premesse, è chiaro che la prima azione sulla stack di qualsiasi stringa deve essere una `push`, e che l'ultima deve essere una `pop`. A questo punto i casi sono due:\n\t\t- Il simbolo rimosso con l'ultima `pop` è esattamente quello inserito con la prima `push`. In questo caso posso scrivere in modo equivalente $A_{pq}\\to aA_{rs}b$, dove $a$ è il primo valore della stringa dato in input a $P$ e $b$ l'ultimo.\n\t\t\t- $A_{rs}$ è la stringa che porta $P$ dallo stato $r$ tale che $\\delta(p, a, \\varepsilon) = \\{(r,a)\\}$ allo stato $s$ tale che $\\delta(s, b, a) = \\{(q,\\varepsilon)\\}$, con caratteristiche generali identiche ad $A_{pq}$.\n\t\t- Il simbolo rimosso con l'ultima `pop` non è quello inserito con la prima `push`. Ciò implica che deve essere stato rimosso nel percorso da $p$ a $q$, diciamo in uno stato $r$. In tal caso scriviamo equivalentemente $A_{pq}\\to A_{pr}A_{rq}$.\n\t- A questo bisogna aggiungere l'ovvia informazione $A_{pp}\\to\\varepsilon$;\n\t- Si dimostra quindi per induzione che una tale costruzione soddisfa il lemma:\n\t\t- Se $A_{pq}$ genera $x$, allora $x$ può portare da $p$ con pila vuota a $q$ con pila vuota. La base induttiva è $A_{pp}\\to \\varepsilon$ (ovvia), dopodiché assumo vero per le stringhe lunghe $k$ e dimostro per $k+1$;\n\t\t- Se $x$ può portare da $p$ con pila vuota a $q$ con pila vuota, allora $A_{pq}$ genera $x$. La base induttiva è con $0$ passi, ovvero inizia e finisce in $p$. Se non faccio step non posso leggere alcun simbolo, quindi $x=\\varepsilon$, ma questo è scritto per ipotesi in $G$ ($A_{pp}\\to\\varepsilon$).\n\nQuesto implica un importante corollario. Dal momento che un automa a stati finiti è solo un caso particolare di PDA che ignora la sua pila, segue che\n\n`CRLL` - ***Ogni linguaggio regolare è context-free***.","x":5190,"y":-3167,"width":800,"height":1690,"color":"4"},
		{"id":"1a3d8be48d89cd10","type":"file","file":"PushdownAutomaton.png","x":4398,"y":-2903,"width":475,"height":273},
		{"id":"7399065d101f3426","type":"text","text":"# Pumping Lemma per i Linguaggi Context-Free\n\nEsistono linguaggi non riconoscibili da PDA, quindi non context-free. Abbiamo un ***pumping lemma*** anche per questi linguaggi.\n\nSe $A$ è un linguaggio context-free, allora $\\exists$ un numero $p>0$ detto ***lunghezza di pumping*** tale che qualsiasi stringa $s\\in A$ di lunghezza $\\geq p$ può essere suddivisa in cinque parti $p=uvxyz$ tali che\n\n1. $\\forall\\,i\\geq0,\\,\\,uv^ixy^iz\\in A$;\n2. $|vy|>0$ (almeno una tra $v$ e $y$ è non-vuota, se così non fosse sarebbe banale);\n3. $|vxy|\\leq p$.\n\nL'idea della dimostrazione è la seguente.\n\n- Se $G$ è tale che ogni regola ha al più $b$ simboli a destra, allora un albero sintattico di profondità $h$ ha al più $b^h$ foglie, e viceversa se $G$ genera una stringa di lunghezza $b^h+1$ allora ogni possibile albero sintattico ad essa associato deve avere una profondità $\\geq h+1$.\n- Se $V$ è il numero di variabili di $G$, poniamo $p=b^{V+1}$. Se $s$ ha lunghezza $\\geq p$, allora il suo albero sintattico deve avere profondità $\\geq V+1$. Ma questo significa che in un cammino dalla radice ad una foglia ci sono $V+2$ nodi, di cui uno è terminale e $V+1$ sono variabili. Ma se lungo il cammino incontro $V+1$ variabili avendone solo $V$ in $G$, ***per il principio della piccionaia $\\exists$ una variabile $R$ che si ripete***.\n- Consideriamo le diramazioni dell'albero sintattico generate dalla ripetizione di $R$, rappresentate schematicamente in alto in figura. Da qui nasce la ***divisione in 5 segmenti***. A questo punto posso fare due sostituzioni possibili mantenendo valido l'albero sintattico complessivo:\n\t1. Al posto dell'albero generato dalla variabile $R$ più in basso sostituisco l'albero generato dalla variabile $R$ più in alto. I due segmenti generati nello spazio tra le due $R$ contigue sono sempre $v$ ed $y$ (in basso a sinistra in figura), e posso iterare questa sostituzione un qualsiasi $i>0$ numero di volte;\n\t2. Viceversa, se sostituisco alla $R$ in alto l'albero sintattico generato dalla $R$ più in basso ottengo tre soli segmenti (in basso a destra in figura), da cui il caso $i=0$.\n- Ora, dato che $G$ è in CNF non esistono $\\varepsilon$-regole, né regole unitarie. Questo significa che nel fare il passaggio tra la prima e la seconda $R$ deve essere successa una cosa del tipo $R_{sopra}\\to...\\to BC$, dove $B\\to vR_{sotto}$ e $C\\to y$ o viceversa $B\\to v$ e $C\\to R_{sotto}y$. In entrambi i casi almeno una tra $v$ ed $y$ deve essere necessariamente $\\neq \\varepsilon$, da cui il ***secondo punto*** del teorema.\n- Infine, per il ***terzo punto*** $R_{sotto}$ si trova tra le ultime $V+1$ variabili, quindi il suo albero è alto $h'\\leq V+1$ e quindi ha al più $2^{h'-1}$ foglie. Quindi $$|vxy|\\leq2^V=p$$","x":2121,"y":-2042,"width":844,"height":1043,"color":"4"},
		{"id":"e3140b0888a10451","type":"text","text":"# Costruire la Grammatica di un Linguaggio\n\nÈ uno di quei processi che in generale richiedono creatività, ma a volte è possibile semplificarsi la vita.\n\n- Se il linguaggio è regolare, posso partire dal DFA corrispondente, costruendo la grammatica inserendo\n\t- Una variabile $R_i$ per ogni stato $q_i$ (la variabile iniziale $R_0$ è associata allo stato iniziale $q_0$);\n\t- Una regola $R_i\\to aR_j$ se $\\delta(q_i,a)=q_j$;\n\t- Una regola $R_i\\to\\varepsilon$ se $q_i$ è uno stato accettante.\n- Se si può scrivere il linguaggio di partenza come unione di linguaggi più semplici, scrivere grammatiche più semplici per poi mettere tutto insieme è più conveniente.\n- Alcuni linguaggi sono non-regolari perché c'è una correlazione tra le sottostringhe che genera. Ad esempio, $\\{0^n\\,1^n\\,|\\,n\\geq0\\}$ non è regolare perché un FSA avrebbe bisogno di ricordare quanti $0$ ha letto per confrontarli con gli $1$. Queste simmetrie sono molto semplici da gestire con una grammatica, perché basta una regola della forma $R\\to0\\,R\\,1\\,|\\,\\varepsilon$.\n- Quando c'è una ricorsione, l'implementazione è spesso semplificata. Ad esempio, in $G_4$ $\\langle \\mathtt{FACTOR}\\rangle$ può essere sia $a$ che un'intera espressione $(\\langle \\mathtt{EXPR}\\rangle)$ che poi a sua volta bla bla bla.","x":541,"y":-1447,"width":880,"height":448,"color":"4"},
		{"id":"81f7c5f806820e21","type":"file","file":"PumpingLemmaCFL.png","x":1580,"y":-1660,"width":400,"height":279},
		{"id":"c373c2bee7cda5f4","type":"text","text":"# Linguaggio $M_5$\n\nChe linguaggio accetta $M_5$?\n\n- Accetta la stringa vuota;\n- Seguendo $\\varepsilon$: accetta $a^+$;\n\t- Mettendo insieme le prime due diciamo che accetta $a^*$.\n- Seguendo $b$ arrivo in $q_2$, in cui finiscono le stringhe di tipo $ba^*$. Finisco in $q_3$ se\n\t- ci arrivo con una $a$, quindi $ba^+$;\n\t- ci arrivo con una $b$, quindi $ba^*b$.\n- A questo punto torno in $q_1$ con almeno una $a$, quindi\n\t- $baa^+$ = $baaa^*$\n\t- $ba^*ba^+$\n\nQuindi nel complesso $L = \\{a^+, baa^+, ba^*ba^+\\}$.","x":2300,"y":-380,"width":487,"height":500,"color":"4"},
		{"id":"a7bbbcf16d78be3d","type":"text","text":"# Un solo rapido esempio, perché non mi va\n\nIl linguaggio $B=\\{a^nb^nc^n\\,|\\,n\\geq0\\}$ non è context-free. Assumiamo che lo sia per trovare una contraddizione. Scegliamo $s=a^pb^pc^p$ e mostriamo che non importa come dividiamo $s=uvxyz$, in nessun modo si potrà iterare.\n\n- Anzitutto, né $v$ né $y$ possono contenere un solo simbolo, e ciò è ovvio;\n- Se però contengono simboli diversi, iterando saranno nell'ordine sbagliato.","x":2121,"y":-900,"width":844,"height":238,"color":"4"},
		{"id":"1656b8c70cab4477","type":"text","text":"# Macchina di Turing (TM)\n\nÈ una generalizzazione degli automi a stati finiti. Se nei PDA c'era una distinzione tra input e pila, nella Macchina di Turing sparisce. La struttura dati di supporto è un nastro partizionato (una sorta di array) sul quale è possibile spostarsi a piacimento con una testina per effettuare operazioni di lettura e scrittura.\n\nDiversamente dagli automi a stati finiti, invece, ***esiste sia uno specifico stato di accettazione che di rifiuto*** dell'input. Se la computazione non si ritrova mai su uno di questi due stati speciali, la macchina continuerà a computare all'infinito. Questo è il motivo per cui esistono problemi ***non-decidibili***? E i ***non-computabili***?\n\n\nFormalmente, la Macchina di Turing è una settupla $(Q,\\Sigma,\\Gamma, \\delta,q_0,q_{accept},q_{reject})$ dove\n\n- $Q$ è l'insieme degli stati;\n- $\\Sigma$ è l'***alfabeto di input***, che non deve contenere il ***carattere speciale*** `blank` utilizzato dalla macchina per indicare che una cella del nastro non è allocata;\n- $\\Gamma$ è l'***alfabeto del nastro***, che deve includere il carattere speciale `blank`;\n\t- Visto che scrivo l'input sul nastro e che `blank`$\\in\\Gamma$, $\\Sigma\\subset\\Gamma$.\n- La funzione di transizione $\\delta: Q\\times\\Gamma \\to Q\\times\\Gamma\\times\\{L,R\\}$ deve tenere conto dello spostamento della testina. Pertanto una scrittura del tipo $\\delta(q,a) = (p,b,L)$ significa che, nella posizione in cui si trova attualmente, la testina legge dal nastro il valore $a$ e vi scrive il valore $b$, passando dallo stato di controllo $q$ allo stato di controllo $p$ e spostandosi di una posizione a sinistra ($L=\\text{left}$).","x":-2820,"y":-2633,"width":740,"height":621,"color":"3"},
		{"id":"619378ebff918988","type":"text","text":"","x":-3600,"y":-2361,"width":250,"height":78},
		{"id":"1f30c648db2dcf7a","type":"file","file":"Esempi/M5.png","x":1708,"y":273,"width":400,"height":331},
		{"id":"61927ba45cbb9ee6","type":"file","file":"Esempi/M6.png","x":2377,"y":273,"width":333,"height":331},
		{"id":"d2b3b2bfc47be706","type":"text","text":"# Robustezza\n\nSe prendessi la TM ed iniziassi a variare un po' la definizione, e.g. aggiungendo la possibilità per la testina di restare ferma o $k$ nastri invece di uno solo? Questo cambierebbe forse la classe dei linguaggi riconoscibili? ***No***. Questo concetto è noto come ***robustezza***. Data ad esempio la ***TM multinastro*** definita da$$\\delta: Q\\times\\Gamma^k \\to Q\\times\\Gamma^k\\times\\{L,R, S\\}^k$$`THM` - Per ogni TM multinastro esiste una TM a singolo nastro equivalente.\n\nE semplice vedere questa cosa. Basta mettere il contenuto dei $k$ nastri sul singolo nastro, inframezzandoli con un nuovo simbolo speciale, e.g. $\\#$. Discorso simile per una ***TM non-deterministica*** definita come$$\\delta: Q\\times\\Gamma \\to \\mathcal{P}(Q\\times\\Gamma\\times\\{L,R\\})$$`THM` - Per ogni TM non-deterministica esiste una TM deterministica equivalente.\n\nPer dimostrare ciò dobbiamo considerare che una TM non-deterministica $N$ genera un albero, i cui nodi sono configurazioni. Il compito di $D$ è cercare una configurazione di accettazione o di rifiuto esplorando l'albero in ***ampiezza*** (***non*** in profondità, potrebbero esistere rami di altezza infinita...!). Ma come lo fa? $D$ ha tre nastri:\n\n- Input, in cui viene salvata solo la stringa di input;\n- Simulazione, in cui si copia la stringa di input e si esegue la computazione;\n- Indirizzi, in cui si identificano i singoli nodi dell'albero associato a $N$.\n\t- Come? `1532` indica, partendo dalla radice, di spostarsi al primo figlio, poi al quinto figlio, poi al terzo, ...\n\t- Il nastro viene costruito dinamicamente, scrivendo via via gli indirizzi dei nodi da esplorare.\n\n`CRLL` - Un linguaggio è Touring-Riconoscibile se e solo se esiste una TM multinastro o non-deterministica che lo riconosce.","x":-2820,"y":-3580,"width":740,"height":805,"color":"4"},
		{"id":"4628d3cf67be0bac","type":"text","text":"# Computazione in una TM\n\nInizialmente il nastro contiene soltanto la stringa di input, che viene salvata nei primi $k$ slot. Il $(k+1)$-esimo contiene il carattere `blank`, a segnalarne la fine.\n\nLa ***configurazione*** di una TM è definita da tre elementi:\n- Lo ***stato attuale*** $q$;\n- Il ***contenuto dell'intero nastro***;\n- La ***posizione della testina*** sul nastro.\n\nQuesti tre elementi sono schematicamente indicati con la notazione $uqv$, dove $uv$ è il contenuto del nastro e $q$ indica la posizione della testina (che si trova sempre alla sua destra). Ad esempio, $1010q_31101$ indica che sul nastro c'è scritto `10101101` e la testina si trova sul terzo `1`. Una configurazione $C_1$ ***produce*** una configurazione $C_2$ se la TM può passare da $C_1$ a $C_2$ in un unico step.\n\n- $ua\\,q_i\\,bv\\to u\\,q_j\\,acv$ se $\\delta(q_i,b)=(q_j,c,L)$;\n- $ua\\,q_i\\,bv\\to uac\\,q_j\\,v$ se $\\delta(q_i,b)=(q_j,c,R)$;\n\nSe la testina si trova agli estremi (l'inizio del nastro a sinistra, un simbolo `blank` a destra), non può superarli (e.g. $q_i\\,bv$ può produrre solo $q_j\\,cv$ oppure spostamenti a destra). Le configurazioni di accettazione e rifiuto sono ***configurazioni di arresto***, cioè non producono alcuna configurazione. L'insieme delle stringhe ***accettate*** dalla TM è il linguaggio della TM. Un tale linguaggio è detto ***Touring-Riconoscibile*** (oppure ***ricorsivamente enumerabile***). Se invece è in qualche modo garantito che dato un linguaggio una TM non possa entrare in loop, il linguaggio è detto ***decidibile*** (o ***ricorsivo***)  CREDO. Se un linguaggio è Touring-decidibile, allora è Touring-riconoscibile, ma chiaramente non è vero il viceversa.\n\nL'***enumeratore*** è una variante della TM che stampa delle stringhe in output. Il linguaggio ***enumerato*** dall'enumeratore è la collezione di tutte le stringhe stampabili da esso.","x":-2820,"y":-1920,"width":740,"height":920,"color":"3"},
		{"id":"7b3f60917610b2f1","type":"text","text":"# Ciao\n\n***Questo*** è il *paragrafo* di **Vittorio**$$e^x\\sum_{i=0}^n\\frac{1}{n}$$\n```\nCodice\nFunzione x(te)\n\tciao\n\tforse\n\tfine\n\n```\n$\\text{Ciao}$ Ciao $\\mathbb{R}$     ","x":-4360,"y":-2521,"width":522,"height":398},
		{"id":"6cd1f84e59133423","type":"text","text":"","x":2550,"y":-3405,"width":250,"height":60},
		{"id":"7d835e05d31037b9","type":"text","text":"# Grammatiche CNF\n\nOgni grammatica context-free può essere portata in CNF. È utile farlo perché in questa forma è più facile dimostrare i teoremi ed eseguire algoritmi di parsing. Ad esempio,\n\n`THM` - **Ogni linguaggio context-free è generato da una grammatica context-free in forma normale di Chomsky.** Come si dimostra?\n\nDato che una generica grammatica context-free genera un linguaggio context-free, mi basta dimostrare che posso sempre portare una grammatica CF in CNF. Come?\n\n- Introduco una ***nuova variabile iniziale*** $S_0$ e la regola $S_0\\to S$. Questo garantisce che la variabile iniziale non comparirà mai a destra delle regole;\n- ***Elimino tutte le $\\varepsilon$-regole*** della forma $B\\to\\varepsilon$ (dove $B$ non è la variabile iniziale), e a cascata elimino ogni occorrenza di $B$ nei membri destri delle regole.\n\t- Se c'era $R\\to B$, questa diventa $R\\to\\varepsilon$;\n\t- Se c'era $R\\to uBv$, questa diventa $R\\to uv$;\n\t- Se c'era $R\\to uBvBw$ devo stare attento. Devo trattare separatamente ogni occorrenza di $B$, in particolare posso eliminare\n\t\t- solo al prima - $R\\to uvBw$;\n\t\t- solo la seconda - $R\\to uBvw$;\n\t\t- entrambe - $R\\to uvw$.\n\t\t- Nel complesso, ottengo $R\\to uvBw\\,|\\,uBvw\\,|\\,uvw$\n- ***Elimino tutte le regole unitarie*** della forma $A\\to B$, e sostituisco ogni regola $B\\to u$ con una regola $A\\to u$;\n- ***Rimpiazzo*** ogni regola della forma $A\\to u_1u_2...u_k$ dove $k>2$ con una serie di regole del tipo $A\\to u_1A_1$, $A_1\\to u_2A_2$, ..., $A_{k-2}\\to u_{k-1}u_k$. A questo punto rimpiazzo ogni $u_i$ con una variabile $U_i$ e per ognuna aggiungo la regola $U_i\\to u_i$.","x":2600,"y":-3164,"width":730,"height":729,"color":"4"}
	],
	"edges":[
		{"id":"061a943f3f8dee09","fromNode":"99a579f63e8ed830","fromSide":"right","toNode":"e865a825bb442798","toSide":"left"},
		{"id":"b76926175745ecea","fromNode":"963502012eaccd57","fromSide":"bottom","toNode":"9ce2f5e78688648f","toSide":"top"},
		{"id":"abce62a4589be198","fromNode":"e865a825bb442798","fromSide":"right","toNode":"963502012eaccd57","toSide":"left"},
		{"id":"daac544ac6812e6b","fromNode":"e865a825bb442798","fromSide":"bottom","toNode":"0d399f2af310e7d9","toSide":"top"},
		{"id":"af971900a5afc97c","fromNode":"99a579f63e8ed830","fromSide":"right","toNode":"0d399f2af310e7d9","toSide":"left"},
		{"id":"33ac7368af6e41cf","fromNode":"0d399f2af310e7d9","fromSide":"bottom","toNode":"1e66a8c6f7d0cfc8","toSide":"top"},
		{"id":"3152fb493363c0ae","fromNode":"99a579f63e8ed830","fromSide":"left","toNode":"8bb56d96ae177393","toSide":"right"},
		{"id":"e8bb8888467e626d","fromNode":"4026031a39513573","fromSide":"bottom","toNode":"09eeba7d186cc631","toSide":"top"},
		{"id":"46d61fce2e556b06","fromNode":"202120fe71270d90","fromSide":"bottom","toNode":"9c7bf0e17764ae61","toSide":"top"},
		{"id":"cba74ded9d6eb313","fromNode":"f4475828cc860da0","fromSide":"bottom","toNode":"3ce00288d2634111","toSide":"top"},
		{"id":"ad5af5a9cac1f141","fromNode":"d570218de39c6a66","fromSide":"right","toNode":"3ce00288d2634111","toSide":"left"},
		{"id":"914cf7cc98beffc2","fromNode":"d570218de39c6a66","fromSide":"bottom","toNode":"cb4951b922ab48e7","toSide":"top"},
		{"id":"aeaac25706a7b91d","fromNode":"8bb56d96ae177393","fromSide":"top","toNode":"3ce00288d2634111","toSide":"bottom"},
		{"id":"f72976544f69804b","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"4026031a39513573","toSide":"left"},
		{"id":"b4dc878ef985faa8","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"202120fe71270d90","toSide":"left"},
		{"id":"358157fc48b5854e","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"d570218de39c6a66","toSide":"left"},
		{"id":"caa5fc4be3edbfa3","fromNode":"8bb56d96ae177393","fromSide":"right","toNode":"99a579f63e8ed830","toSide":"left"},
		{"id":"3fa67981659672f8","fromNode":"e865a825bb442798","fromSide":"top","toNode":"816848e0c2ad721f","toSide":"bottom"},
		{"id":"95c743f9cae72d10","fromNode":"a2c08aa1f7f84ed6","fromSide":"bottom","toNode":"73b289d2ddac85e0","toSide":"top"},
		{"id":"eddf13983ba20bcc","fromNode":"816848e0c2ad721f","fromSide":"top","toNode":"2154feb042ce2858","toSide":"bottom"},
		{"id":"ee30ff7d6d74d2a8","fromNode":"2154feb042ce2858","fromSide":"right","toNode":"a2c08aa1f7f84ed6","toSide":"left"},
		{"id":"560b2850f8356943","fromNode":"2154feb042ce2858","fromSide":"right","toNode":"73b289d2ddac85e0","toSide":"left"},
		{"id":"5f59ce4f1f9a5a79","fromNode":"816848e0c2ad721f","fromSide":"right","toNode":"1f30c648db2dcf7a","toSide":"left"},
		{"id":"ee7b4d04995f25a2","fromNode":"1f30c648db2dcf7a","fromSide":"top","toNode":"1d66725355e2923e","toSide":"bottom"},
		{"id":"f8152284aeb3cc64","fromNode":"61927ba45cbb9ee6","fromSide":"top","toNode":"c373c2bee7cda5f4","toSide":"bottom"},
		{"id":"3602e2d11390b764","fromNode":"0d399f2af310e7d9","fromSide":"left","toNode":"1362d388c8714d48","toSide":"right"},
		{"id":"ac57bb28ae028a75","fromNode":"1e66a8c6f7d0cfc8","fromSide":"bottom","toNode":"58b249e919fb0f61","toSide":"top"},
		{"id":"42c1593ce6b44636","fromNode":"0d399f2af310e7d9","fromSide":"bottom","toNode":"5bd9813160538beb","toSide":"top"},
		{"id":"779edd5a8b9eb05a","fromNode":"5bd9813160538beb","fromSide":"right","toNode":"4b19755e121bf99d","toSide":"left"},
		{"id":"a0b24ad9c5e000e9","fromNode":"5ce0efb2ba6f0a14","fromSide":"left","toNode":"5bd9813160538beb","toSide":"right"},
		{"id":"7330244647f4eed7","fromNode":"5ce0efb2ba6f0a14","fromSide":"right","toNode":"4e5009f864f3c65f","toSide":"left"},
		{"id":"95c4cfe55a4db7f7","fromNode":"5bd9813160538beb","fromSide":"right","toNode":"5ce0efb2ba6f0a14","toSide":"left"},
		{"id":"6a482a0f495351a5","fromNode":"5bd9813160538beb","fromSide":"left","toNode":"20930ba61df4d18d","toSide":"right"},
		{"id":"b46b5be3ecb555f3","fromNode":"20930ba61df4d18d","fromSide":"bottom","toNode":"043186a341c6fc88","toSide":"top"},
		{"id":"cc5f2a057df50ece","fromNode":"5bd9813160538beb","fromSide":"bottom","toNode":"2ada182acf4c1e0a","toSide":"top"},
		{"id":"12e34a34ef9e9eaa","fromNode":"2ada182acf4c1e0a","fromSide":"bottom","toNode":"99633375e6887712","toSide":"top"},
		{"id":"0284f77ac605ac68","fromNode":"f4475828cc860da0","fromSide":"right","toNode":"99a579f63e8ed830","toSide":"top"},
		{"id":"f876d328428f5777","fromNode":"2ada182acf4c1e0a","fromSide":"right","toNode":"eb7f2e8ab3192fd4","toSide":"left"},
		{"id":"3caa0aabc84a2399","fromNode":"c65672ca13a7b7e6","fromSide":"left","toNode":"d506de86a1bc8de2","toSide":"right"},
		{"id":"1d67aee39e66738c","fromNode":"2d31e0c1351d0ffb","fromSide":"bottom","toNode":"f4475828cc860da0","toSide":"top"},
		{"id":"a995b2a6e585b158","fromNode":"eb6a901325ad751e","fromSide":"bottom","toNode":"2d31e0c1351d0ffb","toSide":"top"},
		{"id":"361c468f29d4b689","fromNode":"eb6a901325ad751e","fromSide":"right","toNode":"25cf3ba9630cd073","toSide":"left"},
		{"id":"caa98c295496aee7","fromNode":"c65672ca13a7b7e6","fromSide":"bottom","toNode":"3c7808314a6a65a4","toSide":"top"},
		{"id":"08b1984b28c5929f","fromNode":"c65672ca13a7b7e6","fromSide":"top","toNode":"82338f68ab451a7a","toSide":"bottom"},
		{"id":"caa8b976d1848a74","fromNode":"86f18021d67b2c84","fromSide":"bottom","toNode":"79aa400e94a1e523","toSide":"top"},
		{"id":"dd4a66700075fa12","fromNode":"c65672ca13a7b7e6","fromSide":"right","toNode":"86f18021d67b2c84","toSide":"left"},
		{"id":"82170d31d64806c8","fromNode":"3c7808314a6a65a4","fromSide":"bottom","toNode":"25cf3ba9630cd073","toSide":"top"},
		{"id":"370e85ebd8394a6d","fromNode":"25cf3ba9630cd073","fromSide":"bottom","toNode":"4b1bc6387b1400ff","toSide":"top"},
		{"id":"ad90537751766fe7","fromNode":"25cf3ba9630cd073","fromSide":"top","toNode":"3c7808314a6a65a4","toSide":"bottom"},
		{"id":"2dc5819dcb82cb03","fromNode":"3c7808314a6a65a4","fromSide":"top","toNode":"c65672ca13a7b7e6","toSide":"bottom"},
		{"id":"a619dc38421825f3","fromNode":"4b1bc6387b1400ff","fromSide":"bottom","toNode":"e3140b0888a10451","toSide":"top"},
		{"id":"4d03c22cb63d58e5","fromNode":"4b1bc6387b1400ff","fromSide":"left","toNode":"0ae78bba12257fed","toSide":"right"},
		{"id":"569a0fe9f3f9981c","fromNode":"4b1bc6387b1400ff","fromSide":"left","toNode":"d7de6946e4bc7f9a","toSide":"right"},
		{"id":"b027c99885f74414","fromNode":"3c7808314a6a65a4","fromSide":"right","toNode":"ffe084b275eb59ea","toSide":"left"},
		{"id":"f7e68e5fd0d42c75","fromNode":"25cf3ba9630cd073","fromSide":"right","toNode":"ffe084b275eb59ea","toSide":"left"},
		{"id":"171864d75758346d","fromNode":"ffe084b275eb59ea","fromSide":"right","toNode":"7d835e05d31037b9","toSide":"left"},
		{"id":"43d3b157131fc4fc","fromNode":"25cf3ba9630cd073","fromSide":"right","toNode":"35512253a16ef8fb","toSide":"left"},
		{"id":"fc5ee540e760d718","fromNode":"35512253a16ef8fb","fromSide":"bottom","toNode":"1bba7fc6843da9ed","toSide":"top"},
		{"id":"077b4590df67ba19","fromNode":"35512253a16ef8fb","fromSide":"bottom","toNode":"b3cbd20b0f8552ad","toSide":"top"},
		{"id":"ce44a8bcfce22c32","fromNode":"b3cbd20b0f8552ad","fromSide":"bottom","toNode":"3165d6cf0955425d","toSide":"top"},
		{"id":"1ffcb5b779a1157d","fromNode":"b3cbd20b0f8552ad","fromSide":"bottom","toNode":"889eef30368d267d","toSide":"top"},
		{"id":"923c3baeb65bf5ac","fromNode":"35512253a16ef8fb","fromSide":"right","toNode":"7afe9f86cb997f73","toSide":"left"},
		{"id":"a7952db1ead542b5","fromNode":"25cf3ba9630cd073","fromSide":"right","toNode":"7399065d101f3426","toSide":"top"},
		{"id":"30a8c832a56afeab","fromNode":"35512253a16ef8fb","fromSide":"top","toNode":"1a3d8be48d89cd10","toSide":"bottom"},
		{"id":"1dbf56fd8d433aa9","fromNode":"7399065d101f3426","fromSide":"left","toNode":"81f7c5f806820e21","toSide":"right"},
		{"id":"f9078574063e4ff6","fromNode":"7399065d101f3426","fromSide":"bottom","toNode":"a7bbbcf16d78be3d","toSide":"top"},
		{"id":"2fcb516facd4f334","fromNode":"35512253a16ef8fb","fromSide":"left","toNode":"7399065d101f3426","toSide":"top"},
		{"id":"585c8df2903bcc3c","fromNode":"1656b8c70cab4477","fromSide":"left","toNode":"619378ebff918988","toSide":"right"},
		{"id":"e57dc089172dd8a4","fromNode":"eb6a901325ad751e","fromSide":"left","toNode":"1656b8c70cab4477","toSide":"right"},
		{"id":"bf7da4b8090b9855","fromNode":"1656b8c70cab4477","fromSide":"bottom","toNode":"4628d3cf67be0bac","toSide":"top"},
		{"id":"769771a7e6f67026","fromNode":"1656b8c70cab4477","fromSide":"top","toNode":"d2b3b2bfc47be706","toSide":"bottom"},
		{"id":"8f75fb22850678c9","fromNode":"619378ebff918988","fromSide":"left","toNode":"7b3f60917610b2f1","toSide":"right"}
	]
}