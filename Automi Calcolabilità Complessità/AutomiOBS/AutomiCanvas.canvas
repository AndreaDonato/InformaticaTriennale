{
	"nodes":[
		{"id":"eb6a901325ad751e","type":"text","text":"# Premesse ai Linguaggi\n\nUn ***insieme finito di simboli*** è detto ***alfabeto***. In particolare, $\\Sigma =\\{0, 1\\}$ è l'***alfabeto binario***.\n\nUna qualsiasi sequenza di simboli $\\{w_i\\in \\Sigma\\}$ si definisce ***stringa*** (o ***parola***) di $\\Sigma$. L'insieme (infinito) di tutte le possibili stringhe si indica con $\\Sigma^*$, ergo $w\\in \\Sigma^*$.\n\n- $|w|$ è la ***lunghezza*** di $w$, ovvero il numero di simboli che vi compaiono;\n- Date $x, y\\in\\Sigma^*$ definiamo la ***concatenazione*** come $xy = x_1...x_n\\,y_1...y_n$;\n- $\\varepsilon$ è la ***stringa vuota***, tale che $|\\varepsilon| = 0$, $\\forall w\\in\\Sigma^*$ $w\\varepsilon = \\varepsilon w = w$ e $\\Sigma^*\\neq\\emptyset \\Rightarrow \\varepsilon\\in\\Sigma^*$;\n- Dati $w\\in\\Sigma^*$ e $a\\in\\Sigma$, $|w|_a$ è il ***conteggio*** di $a$ in $w$, ovvero quante volte $a$ compare in $w$;\n- Se inverto la sequenza $a_1...a_n$ in $a_n...a_1$ ottengo la ***stringa rovesciata***;\n- Posso definire l'operazione di ***potenza*** di una stringa come$$w^n=\\begin{cases}\n\\varepsilon\\qquad\\quad\\text{ se }n=0\\\\\nww^{n-1}\\quad\\text{se }n>1\n\\end{cases}$$\n\nUn qualsiasi sottoinsieme di $\\Sigma^*$ si definisce ***linguaggio*** ***L***. Dati due linguaggi $L_1, L_2\\subseteq\\Sigma^*$ definiamo, oltre agli operatori banali di unione e intersezione,\n\n- ***Completamento*** - $\\overline{L} = \\{w ∈ \\Sigma^∗ | w \\notin L\\}$, cioè tutte quelle stringhe che non fanno parte di $L$;\n- ***Concatenazione*** - Una sorta di prodotto cartesiano. $L_1 ◦ L_2 = \\{xy ∈ \\Sigma^* | x ∈ L_1 , y ∈ L_2 \\}$;\n- ***Potenza*** - Tutte le possibili concatenazioni che si ottengono concatenando $n$ volte, ovvero $$L^n=\\begin{cases}\n\\{\\varepsilon\\}\\qquad\\quad\\text{ se }n=0\\\\\nL◦L^{n-1}\\quad\\text{ se }n>1\n\\end{cases}$$\n- ***Star di Kleene*** - $L^*$ restituisce tutte le possibili combinazioni di zero o più stringhe di $L$. Formalmente,$$L^* = \\bigcup_{n\\geq 0}L^n$$\n- ***Plus di Kleene*** - $L^+$ fa praticamente lo stesso lavoro di $L^*$, ma esclude la stringa vuota $\\varepsilon$.\n\nValgono inoltre le leggi di*** De Morgan*** per qualsiasi linguaggio regolare.\n\n- La negazione dell'intersezione è l'unione delle negazioni -  $\\overline{L_1\\cap L_2} = \\overline{L_1}\\cup\\overline{L_2}$\n\t- Riformulabile negando sia a destra che a sinistra - $L_1\\cap L_2 = \\overline{\\overline{L_1}\\cup\\overline{L_2}}$\n- La negazione dell'unione è l'intersezione delle negazioni - $\\overline{L_1\\cup L_2} = \\overline{L_1}\\cap\\overline{L_2}$ \n\t- Riformulabile negando sia a destra che a sinistra - $L_1\\cup L_2 = \\overline{\\overline{L_1}\\cap\\overline{L_2}}$","x":-360,"y":-380,"width":880,"height":955,"color":"4"},
		{"id":"99a579f63e8ed830","type":"text","text":"# Automa Deterministico a Stati Finiti (DFA)\n\nUn automa deterministico a stati finiti è una quintupla $(Q,\\Sigma,\\delta,q_0,F)$ dove\n\n- $Q$ è l'insieme finito degli ***stati***, ognuno dei quali ha esattamente un arco uscente per ogni simbolo di $\\Sigma$;\n- $\\Sigma$ è l'***alfabeto*** compreso dall'automa;\n- $\\delta:Q\\times \\Sigma\\to Q$ è la ***funzione di transizione degli stati***, in pratica una matrice che associa ogni riga (simbolo dell'alfabeto) ad ogni colonna (stato di partenza), i cui elementi sono gli stati di arrivo.\n\t- Rappresenta la risposta dell'automa che si trova in un determinato stato ad un simbolo in input.\n- $q_0\\in Q$ è lo ***stato iniziale***;\n- $F\\subseteq Q$ è l'insieme degli ***stati accettanti***, ovvero stati in cui l'automa accetta di terminare l'esecuzione.\n\nPosso però dare all'automa una sequenza di simboli di input, ovvero una stringa. In tal caso posso definire ricorsivamente una ***funzione di transizione estesa*** tale che$$\\begin{cases}\n\\delta^*(q,\\varepsilon) = \\delta(q, \\varepsilon) = q\\\\\n\\delta^*(q, aw) = \\delta^*(\\delta(q, a), w) \\quad\\text{dove }a\\in\\Sigma,w\\in\\Sigma^*\n\\end{cases}$$In pratica significa che $\\delta^*$ restituisce lo stato finale a seguito di un input in formato stringa. In generale, ad ogni istante l'automa si trova in una specifica ***configurazione***, identificata dalla coppia $(q,w)$ formata dallo ***stato attuale*** $q$ e dalla ***stringa*** $w$ che deve ancora ***interpretare*** a partire da quello stato.\n\nOgni esecuzione di un singolo simbolo fa effettuare all'automa un singolo ***passo di computazione***. Dato un simbolo $a$ e due stati $p,q\\in Q$, dire che $\\delta(p,a)=q$ è equivalente a dire che $(p, aw) ⊢ (q, w)$. Questo concetto è generalizzabile ad una sequenza di passi. Sono equivalenti le scrittura $\\delta^*(q_i,w)=q_f$ e $q_i,w) ⊢^*(q_f,\\varepsilon)$.\n\nL'automa è detto ***deterministico*** se ad ogni passo di computazione segue una ed un'unica configurazione.\n\nLa stringa $w$ è ***accettata*** $A=(Q,\\Sigma,\\delta,q_0,F)$ se $\\delta^*(q_0, w)\\in F(A)$, ovvero se l'***interpretazione*** di tale stringa fa terminare l'automa su uno stato accettante. Di conseguenza definiamo il ***linguaggio*** di $A$ l'insieme di tutte le stringhe accettate da A o, in modo analogo, diciamo che ***$A$ riconosce $L(A)$***.","x":-360,"y":700,"width":880,"height":747,"color":"4"},
		{"id":"e865a825bb442798","type":"text","text":"# Automa Non-Deterministico a Stati Finiti (NFA)\n\nSe ***la funzione di transizione degli stati non è univoca*** (i.e. alla configurazione $(q,a)$ possono seguire diverse configurazioni), allora l'automa è non-deterministico. Formalmente,$$\\delta: Q\\times\\Sigma_\\varepsilon \\to \\mathcal{P}(Q)$$dove $\\Sigma_\\varepsilon$ è l'***alfabeto epsilon*** associato a $\\Sigma$ (banalmente, $\\Sigma \\cup \\{\\varepsilon\\}$) e $\\mathcal{P}$ rappresenta tutti i possibili sottoinsiemi di $Q$ (***insieme potenza***), intendendo che ogni input può produrre in output un qualsiasi sottoinsieme di stati.\n\nContemporaneamente? Beh no, però a livello teorico posso costruire un albero. L'automa ***si sdoppia***\n\n- ogni volta che c'è ***ambiguità di simbolo*** (e.g. partendo da $q_1$, $1$ porta sia allo stato $q_1$ che allo stato $q_2$);\n- ogni volta che esiste un ***$\\varepsilon$-arco in uscita***: un ramo considera l'attesa del simbolo successivo come \"non fare niente\" (e dunque interpreta $\\varepsilon$, spostandosi lungo l'arco) mentre l'altro resta nello stato corrente.\n\nOgni volta che arrivo in uno stato in cui il simbolo da interpretare non compare su un arco in uscita, ***la computazione termina*** (ogni stato può avere un qualsiasi numero di archi uscenti per ogni simbolo di $\\Sigma$). L'unico stato finale consentito è uno stato accettante in cui non restano ulteriori simboli da interpretare. Se ***almeno un ramo termina su uno stato accettante***, l'NFA ***accetta*** la stringa.","x":680,"y":700,"width":920,"height":491,"color":"4"},
		{"id":"963502012eaccd57","type":"file","file":"NooDeterministic.png","x":1708,"y":700,"width":400,"height":108},
		{"id":"9ce2f5e78688648f","type":"file","file":"NonDeterministicTree.png","x":1708,"y":934,"width":400,"height":459},
		{"id":"d570218de39c6a66","type":"file","file":"Esempi/M3.png","x":-1908,"y":595,"width":400,"height":245},
		{"id":"cb4951b922ab48e7","type":"text","text":"$A = \\{w|w$ la somma dei numeri della stringa è multiplo di 3$\\}$\n\n- $q_0$ è lo stato \"finora la somma modulo $3$ fa $0$ o c'è stato un `RESET`\"\n- $q_1$ è lo stato \"finora la somma modulo $3$ fa $1$\"\n- $q_0$ è lo stato \"finora la somma modulo $3$ fa $2$\"","x":-2008,"y":917,"width":600,"height":146,"color":"4"},
		{"id":"4026031a39513573","type":"file","file":"Esempi/M1.png","x":-1908,"y":-346,"width":400,"height":132},
		{"id":"09eeba7d186cc631","type":"text","text":"$A = \\{w|w$ Contiene almeno un $1$ e un numero pari di $0$ segue l'ultimo $1\\}$.\n\n- $q_1$ è lo stato \"non ho ancora letto alcun $1$\";\n- $q_2$ è lo stato che definisce l'alfabeto;\n- $q_3$ è lo stato \"dopo l'ultimo $1$ c'è un numero dispari di $0$\"","x":-2008,"y":-154,"width":600,"height":146,"color":"4"},
		{"id":"202120fe71270d90","type":"file","file":"Esempi/M2.png","x":-1909,"y":98,"width":400,"height":263},
		{"id":"9c7bf0e17764ae61","type":"text","text":"$A = \\{w|w$ inizia e finisce con lo stesso simbolo$\\}$\n\n- $q_1$ è lo stato \"la stringa inizia e finisce per $a$\" (analogo $r_1$ con $b$);\n- $q_2$ è lo stato \"la stringa inizia per $a$ ma finisce per $b$\" (analogo $r_2$).","x":-2008,"y":407,"width":600,"height":114,"color":"4"},
		{"id":"a95021f577a47f4e","type":"text","text":"# Progettare Automi\n\nGli automi non hanno memoria e non sanno quanti simboli mancano per finire la stringa. Pertanto, ad ogni simbolo letto devono essere in grado di decidere se la stringa letta ***finora*** fa parte del linguaggio.\n\nLe etichette degli stati sono fondamentali per capire cosa succede.","x":-2860,"y":129,"width":580,"height":201,"color":"4"},
		{"id":"3ce00288d2634111","type":"text","text":"# Esempio di rappresentazione formale\n\nUn automa che accetta stringhe i cui numeri sommati sono multiplo di $i$ non è rappresentabile graficamente, ma posso dire che\n\n- $\\delta_i(q_j,0) = q_j$\n- $\\delta_i(q_j,k) = q_n$, dove $n = (j+k)\\%\\,i$\n- $\\delta_i(q_j,\\langle RESET\\rangle) = q_0$\n- $q_0$ è sia lo stato iniziale che l'unico stato accettante.","x":-1182,"y":575,"width":693,"height":285,"color":"4"},
		{"id":"699b4440e0614fe9","type":"text","text":"Automi a stati finiti <-> catene di Markov\n","x":-108,"y":-720,"width":377,"height":100},
		{"id":"f4475828cc860da0","type":"text","text":"# Introduzione ai Linguaggi Regolari\n\nCos'è un computer?\n\nPer automatizzare le operazioni di calcolo è necessario un ***modello di computazione*** che rappresenti schematicamente ciò che deve accadere.\n\nL'***automa a stati finiti*** è il più semplice modello di computazione. Si basa sull'idea di avere ***pochissima memoria***, il che si traduce appunto in \"pochi\" stati esplorabili dal sistema (per capire dove mi trovo in un dato istante, i dati vanno indicizzati. $n$ bit di memoria codificano $2^n$ stati).\n\nL'automa a stati finiti è rappresentabile mediante ***diagramma di stato***. L'insieme $A$ di tutte e sole le stringhe accettate dalla macchina $M$ è detto linguaggio di $M$, e si indica con $L(M) = A$. In tal caso si dice che $M$ ***riconosce*** $A$. Se $M$ non accetta alcuna stringa non vuota accetta il linguaggio vuoto $\\emptyset$.\n\nSe esiste una $M$ che riconosce $A$, allora $A$ è un ***linguaggio regolare***.\n\nA volte è impossibile esibire il diagramma di stato, o perché sarebbe troppo grande o perché dipende da un generico parametro $k$. In tal caso bisogna ricorrere alla definizione formale di computazione.","x":-1182,"y":-174,"width":693,"height":543,"color":"5"},
		{"id":"0d399f2af310e7d9","type":"text","text":"# Equivalenza tra NFA e DFA: Linguaggi Regolari\n\nLa classe dei linguaggi di $\\Sigma$ riconosciuti da un DFA $\\mathcal{L}(DFA)$ e quella dei linguaggi di $\\Sigma$ riconosciuti da un NFA $\\mathcal{L}(NFA)$ coincidono, e sono detti ***linguaggi regolari*** (linguaggio è regolare $\\Leftrightarrow \\exists$ NFA che lo riconosce).\n\nCome conseguenza, dato un NFA è sempre possibile costruire un DFA ad esso equivalente (il contrario è ovvio, perché il DFA è un sotto-caso dell'NFA). Come?\n\n- Identifica tutti i possibili sottoinsiemi di $Q$ (e.g. se $Q=\\{q_1,q_2,q_3\\}$ allora avrò $\\{\\emptyset, q_1, q_2, q_3, q_{12}, q_{13}, q_{23}, q_{123}\\}$). Questi saranno tutti e soli gli stati del DFA equivalente;\n- Definiamo l'***estensione*** di $R\\in Q$ come $E(R)$, intendendo gli stati di $R$ più tutti gli stati raggiungibili da $R$ tramite soli $\\varepsilon$-archi. Lo stato iniziale del DFA è l'estensione dello stato iniziale dell'NFA (e.g. $q_1\\to q_{13}$);\n- Gli stati accettanti sono tutti quelli che hanno almeno uno stato accettante dell'NFA di partenza. In questo caso, $\\{q_1, q_{12}, q_{13}, q_{23}, q_{123}\\}$;\n- A questo punto devo farmi tutte le transizioni per ogni stato e vedere per ognuna l'insieme di stati a cui porta. Con tanto lavoro e tanta fantasia ottengo una roba tipo l'esempio sotto.\n\nDetto questo, i linguaggi regolari godono della proprietà di ***chiusura*** rispetto a tutti gli operatori definiti in precedenza (***concatenazione***, ***complemento***, ***unione***, ***intersezione***, ***potenza***, ***star*** e ***plus***), i.e. se tali operatori prendono in input linguaggi regolari, l'output sarà ancora un linguaggio regolare.","x":680,"y":1260,"width":920,"height":584,"color":"4"},
		{"id":"816848e0c2ad721f","type":"text","text":"# Perché gli NFA?\n\n- Spesso costruire e capire un NFA è più semplice rispetto al suo DFA equivalente;\n\t- Sicuramente in generale un NFA è più piccolo del suo DFA equivalente.\n- Il paradigma di calcolo parallelo si presta a due parallelismi (pun intended):\n\t- Programmazione multi-thread;\n\t- Computazione quantistica.","x":700,"y":303,"width":880,"height":272,"color":"3"},
		{"id":"85713a3ea9d687ed","type":"text","text":"# Glossario\n\n- ***Linguaggio Regolare*** - Linguaggio riconosciuto da un DFA, o equivalentemente da un NFA. Esprimibile tramite espressioni regolari.","x":520,"y":-823,"width":659,"height":206},
		{"id":"1f30c648db2dcf7a","type":"file","file":"M5.png","x":1708,"y":303,"width":400,"height":331},
		{"id":"73b289d2ddac85e0","type":"file","file":"Esempi/M4-DFA.png","x":1181,"y":-73,"width":399,"height":193},
		{"id":"a2c08aa1f7f84ed6","type":"file","file":"Esempi/M4_NFA.png","x":1181,"y":-283,"width":399,"height":89},
		{"id":"2154feb042ce2858","type":"text","text":"# Un semplice NFA\n\nCostruire un automa che riconosce le stringhe aventi un $1$ in terzultima posizione è un compito semplice con un NFA. È sufficiente tenere ***traccia dell'$1$ su un singolo ramo*** di computazione che ipotizza di essere a tre step dalla fine (se non lo è, lo stato $q_4$ muore perché non ha archi in uscita).\n\nSi noti che\n\n- con un DFA dovrei considerare tutte le possibili situazioni;\n- con piccole variazioni sull'NFA posso costruire un automa che accetta le stringhe aventi un $1$ in una delle ultime tre posizioni (i.e. aggiungendo $\\varepsilon$ nelle transizioni $q_2\\to q_3$ e $q_3\\to q_4$)","x":700,"y":-380,"width":420,"height":500,"color":"4"},
		{"id":"1d66725355e2923e","type":"text","text":"# Prova a Indovinare!\n\nSpesso gli NFA si basano su assunzioni e ipotesi, perché tanto ogni ipotesi è un singolo ramo dell'intera computazione.\n\nIn $M_5$ si usa l'***alfabeto unario*** che consta del solo carattere $0$, e la macchina accetta sono stringhe lunghe multipli di $2$ (testate nel ramo superiore) e di $3$ (nel ramo inferiore).","x":1708,"y":-73,"width":400,"height":287,"color":"4"},
		{"id":"61927ba45cbb9ee6","type":"file","file":"M6.png","x":2317,"y":303,"width":333,"height":331},
		{"id":"c373c2bee7cda5f4","type":"text","text":"# Linguaggio $M_5$\n\nChe linguaggio accetta $M_5$?\n\n- Accetta la stringa vuota;\n- Seguendo $\\varepsilon$: accetta $a^+$;\n\t- Mettendo insieme le prime due diciamo che accetta $a^*$.\n- Seguendo $b$ arrivo in $q_2$, in cui finiscono le stringhe di tipo $ba^*$. Finisco in $q_3$ se\n\t- ci arrivo con una $a$, quindi $ba^+$;\n\t- ci arrivo con una $b$, quindi $ba^*b$.\n- A questo punto torno in $q_1$ con almeno una $a$, quindi\n\t- $baa^+$ = $baaa^*$\n\t- $ba^*ba^+$\n\nQuindi nel complesso $L = \\{a^+, baa^+, ba^*ba^+\\}$.","x":2240,"y":-283,"width":487,"height":497,"color":"4"},
		{"id":"aefa1f33137bd254","type":"text","text":"# Teoria degli Automi\n\nGli automi rappresentano il più semplice modello di computazione data poca memoria.","x":-1045,"y":-580,"width":420,"height":120,"color":"6"},
		{"id":"8bb56d96ae177393","type":"text","text":"# Computazione\n\nEseguire una computazione significa interpretare una sequenza di simboli $\\{w_i\\}$ percorrendo una sequenza di stati $\\{r_i\\}$ tali che\n\n- $r_0 = q_0$, cioè si parte dallo stato iniziale;\n- $r_n = q_F\\in F$, cioè si arriva in uno stato accettante;\n- $\\delta(r_i, w_{i}) = r_{i+1}$, ovvero in un ***DFA*** si passa da un elemento della sequenza al successivo tramite la funzione di transizione degli stati.\n\t- In un ***NFA*** questa definizione va generalizzata: $r_{i+1}\\in\\delta(r_i,w_i)$.","x":-1182,"y":925,"width":693,"height":297,"color":"4"},
		{"id":"1362d388c8714d48","type":"text","text":"# Dimostrare le Chiusure\n\n- ***Unione*** - Date $N_1$ ed $N_2$, basta creare un nuovo stato iniziale che si collega tramite $\\varepsilon$-archi agli stati iniziali delle macchine originali.\n\t- Per l'***intersezione*** non si possono usare gli NFA, bisogna costruire la prova tramite DFA.\n- ***Concatenazione*** - Collego tutti gli stati accettanti di $N_1$ allo stato iniziale di $N_2$ tramite $\\varepsilon$-archi.\n\t- Da questo segue la dimostrazione per la ***potenza***, in quanto sequenza di concatenazioni.\n- ***Star*** - Creo un nuovo stato iniziale che punta con un $\\varepsilon$-arco al vecchio stato iniziale, poi faccio puntare tutti gli stati accettanti al vecchio stato iniziale.\n\t- Questo dimostra anche il ***Plus***, perché $L^+ = L\\,L^*$, che è una concatenazione.","x":-360,"y":1535,"width":880,"height":309,"color":"4"},
		{"id":"4b19755e121bf99d","type":"file","file":"RegEx.png","x":1708,"y":2285,"width":400,"height":326},
		{"id":"5bd9813160538beb","type":"text","text":"# Linguaggi ed Espressioni Regolari\n\nI linguaggi regolari sono rappresentabili tramite le ***espressioni regolari*** (***regex***, $re(\\Sigma)$). $R$ è una regex se è\n\n- $a$, per qualche $a\\in \\Sigma$ (cioè se è costituita da simboli dell'alfabeto);\n- $\\varepsilon$ (la stringa vuota è una regex);\n- $\\emptyset$ (l'insieme vuoto è una regex);\n- unione, concatenazione o star di regex.\n\n`THM` - **Un linguaggio è regolare se e solo se esiste una regex che lo descrive**. Questo si dimostra nei due versi:\n\n- Se $\\mathcal{L}$ è descritto da una regex $R$, allora è regolare. Devo costruire un NFA che riconosce $\\mathcal{L}$ a partire da $R$. Posso farlo per ognuno dei punti che definiscono una regex.\n\t- $a$ - Un NFA $\\{\\{q_1,q_2\\}, \\Sigma, \\delta, q_1, \\{q_2\\}\\}$ che parte da $q_1$ e che va in $q_2$ accettante tramite $a$ riconosce $\\mathcal{L}(R) = \\{a\\}$\n\t- $\\varepsilon$ - Un NFA $\\{\\{q_1\\}, \\Sigma, \\delta, q_1, \\{q_1\\}\\}$ che parte da uno stato accettante riconosce $\\mathcal{L}(R) = \\{\\varepsilon\\}$;\n\t- $\\emptyset$ - Un NFA $\\{\\{q_1\\}, \\Sigma, \\delta, q_1, \\emptyset\\}$ privo di stati accettanti riconosce $\\mathcal{L}(R) = \\emptyset$;\n\t- Per unione, concatenazione e star: i linguaggi regolari sono chiusi rispetto alle operazioni regolari.\n- Se $\\mathcal{L}$ è regolare, allora esiste una regex che lo descrive. O, equivalentemente, devo dimostrare di poter trasformare un generico automa in una regex. Questo si può fare con i GNFA, secondo lo schema seguente:\n\t- Posso sempre trasformare un DFA in un GNFA aggiungendo un nuovo stato iniziale che punta con un $\\varepsilon$-arco al vecchio stato iniziale, e in modo analogo un nuovo stato accettante puntato dai vecchi stati accettanti. Inoltre se, ad esempio, tra i nodi $q_i$ e $q_j$ vi sono due archi che vanno nella stessa direzione e con etichette rispettivamente $a$ e $b$, li sostituisco con un unico arco avente etichetta $a\\cup b$;\n\t- Non è restrittivo dimostrare che posso trasformare un GNFA in una regex. Come? Riducendo il numero di nodi fino ad ottenerne esattamente due. Posso sempre farlo? Sì, togliendo un nodo alla volta e modificando l'automa in modo che accetti sempre lo stesso linguaggio;\n\t- L'etichetta dell'unico arco che va da $q_i$ a $q_f$ quando il GNFA è ridotto a due nodi è la regex cercata.","x":680,"y":1960,"width":920,"height":709,"color":"4"},
		{"id":"1e66a8c6f7d0cfc8","type":"file","file":"NFA.png","x":200,"y":1960,"width":320,"height":232},
		{"id":"5ce0efb2ba6f0a14","type":"text","text":"# NFA Generalizzati (GNFA)\n\nUn GNFA è una quintupla $(Q,\\Sigma,\\delta,q_i,q_f)$ in cui $|Q|\\geq 2$ e la funzione di transizione è definita come$$\\delta:(Q-\\{q_i\\})\\times(Q-\\{q_f\\}) \\to re(\\Sigma)$$ovvero\n- $q_i$ ha solo transizioni uscenti, $q_f$ ha solo transizioni entranti;\n- Ogni transizione tra tutte le possibili coppie di stati è un'***espressione regolare***.\n\nPer costruzione, le stringhe vengono lette a gruppi anziché a simboli. Ad esempio, dando in pasto alla GNFA a fianco la stringa `abbbaaab` si ha che\n\n- Dallo stato iniziale, viene letta la sequenza `abbb` (corrispondente alla regex $ab^*$) finendo in $q_2$;\n- Segue `aaab`. Qui essendo una NFA l'albero si sdoppia, in quanto si potrebbe interpretare\n\t- secondo la regex $a^*$. In questo caso vengono lette tre `a` e si finisce in $q_1$. Rimane solo `b`, che viene interpretata dalla regex $b^*$. Finiamo quindi in $q_{accept}$ come previsto;\n\t- secondo la regex $(aa)^*$. In questo caso vengono lette due `a` e restiamo in $q_2$. Rimane `ab`, che rientra nella regex $ab\\cup ba$, quindi anche qui finiamo in $q_{accept}$.\n\n\nI linguaggi GNFA sono più generali dei linguaggi DFA (e quindi NFA). Si ha infatti che $\\mathcal{L}(DFA)\\subseteq \\mathcal{L}(GNFA)$ (????).","x":1740,"y":1631,"width":880,"height":542,"color":"3"},
		{"id":"4e5009f864f3c65f","type":"file","file":"GNFA.png","x":2700,"y":1775,"width":400,"height":254},
		{"id":"58b249e919fb0f61","type":"file","file":"DFA_FromNFA.png","x":200,"y":2244,"width":320,"height":173},
		{"id":"043186a341c6fc88","type":"text","text":"# Algoritmo di Riduzione\n\nSia $k$ il numero di stati del GNFA $G$.\n\n```\ndef Convert(G):\n\tSe k = 2:\n\t\tRestituisci la regex;\n\tAltrimenti:\n\t\tScegli un nodo;\n\t\tEliminalo;\n\t\tAggiorna G in G';\n\t\tChiama Convert(G')\n```\n\nQuesto si basa sul fatto (dimostrabile per induzione) che $\\forall\\,G$, `Convert(G)` è equivalente a $G$.","x":130,"y":2780,"width":460,"height":423,"color":"#4545ff"},
		{"id":"15ec29fc11a1ee12","type":"text","text":"# Regex\n\n**Esempi di espressioni regolari:**\n\n1. **Caratteri singoli:**\n    \n    - `a` corrisponde al carattere `a`.\n    - `.` corrisponde a qualsiasi carattere singolo.\n2. **Gruppi e opzioni:**\n    \n    - `[abc]` corrisponde a `a`, `b` o `c`.\n    - `[a-z]` corrisponde a qualsiasi lettera minuscola da `a` a `z`.\n3. **Quantificatori:**\n    \n    - `a*` corrisponde a zero o più `a`.\n    - `a+` corrisponde a una o più `a`.\n    - `a?` corrisponde a zero o una `a`.\n    - `a{3}` corrisponde esattamente a tre `a`.\n    - `a{2,5}` corrisponde a due fino a cinque `a`.\n4. **Ancoraggi:**\n    \n    - `^a` corrisponde a `a` all'inizio di una riga.\n    - `a$` corrisponde a `a` alla fine di una riga.\n5. **Gruppi di cattura:**\n    \n    - `(abc)` corrisponde esattamente alla sequenza `abc` e può essere usato per catturare e riferirsi al contenuto corrispondente.","x":-600,"y":2011,"width":579,"height":639,"color":"1"},
		{"id":"20930ba61df4d18d","type":"file","file":"RiduzioneGNFA.png","x":160,"y":2495,"width":400,"height":174},
		{"id":"2ada182acf4c1e0a","type":"text","text":"# Pumping Lemma per i Linguaggi Regolari\n\nEsistono linguaggi non riconoscibili da automi finiti, quindi non regolari. Ma come faccio a capire se lo sono?\n\nEsiste un teorema, detto ***pumping lemma***, che individua una proprietà unica dei linguaggi regolari.\n\nSe $A$ è un linguaggio regolare, allora $\\exists$ un numero $p>0$ detto ***lunghezza di pumping*** tale che qualsiasi stringa $s\\in A$ di lunghezza $\\geq p$ può essere suddivisa in tre parti $p=xyz$ tali che\n\n- $\\forall\\,i\\geq0,\\,\\,xy^iz\\in A$;\n- $|y|>0$;\n- $|xy|\\leq p$.\n\nQuesta cosa è di facile dimostrazione.\n\n- Se nessuna stringa di $A$ è lunga almeno $p$, il teorema è automaticamente vero;\n- Viceversa, prendiamo un automa $M=(Q,\\Sigma,\\delta,q_1,F)$ con $p$ stati ed $s$ lunga $n>p$. L'automa attraversa $n+1$ stati, e $n+1>p$. Per il principio della piccionaia deve esistere uno stato che si ripete. Questo significa che esistono tre percorsi:\n\t\n\t- Da $q_i$ a $q_r$, che chiamiamo $x$;\n\t- Da $q_r$ a $q_r$ stesso, che chiamiamo $y$ (ed è chiaro che posso ripetere $y$ un qualsiasi numero di volte);\n\t- Da $q_r$ a $q_f$, che chiamiamo $z$.\n- La seconda condizione è verificata ","x":680,"y":2780,"width":920,"height":620,"color":"4"},
		{"id":"8365756e7cae103f","type":"text","text":"2 Lupi\n2 Contadini\n1 Maga\n1 Veggente\n1 Cacciatore","x":49,"y":3282,"width":311,"height":198},
		{"id":"eb7f2e8ab3192fd4","type":"file","file":"PumpingLemmaRegex.png","x":1680,"y":2941,"width":400,"height":218}
	],
	"edges":[
		{"id":"9df37de89323b256","fromNode":"eb6a901325ad751e","fromSide":"bottom","toNode":"99a579f63e8ed830","toSide":"top"},
		{"id":"061a943f3f8dee09","fromNode":"99a579f63e8ed830","fromSide":"right","toNode":"e865a825bb442798","toSide":"left"},
		{"id":"b76926175745ecea","fromNode":"963502012eaccd57","fromSide":"bottom","toNode":"9ce2f5e78688648f","toSide":"top"},
		{"id":"abce62a4589be198","fromNode":"e865a825bb442798","fromSide":"right","toNode":"963502012eaccd57","toSide":"left"},
		{"id":"daac544ac6812e6b","fromNode":"e865a825bb442798","fromSide":"bottom","toNode":"0d399f2af310e7d9","toSide":"top"},
		{"id":"af971900a5afc97c","fromNode":"99a579f63e8ed830","fromSide":"right","toNode":"0d399f2af310e7d9","toSide":"left"},
		{"id":"33ac7368af6e41cf","fromNode":"0d399f2af310e7d9","fromSide":"bottom","toNode":"1e66a8c6f7d0cfc8","toSide":"top"},
		{"id":"3152fb493363c0ae","fromNode":"99a579f63e8ed830","fromSide":"left","toNode":"8bb56d96ae177393","toSide":"right"},
		{"id":"e8bb8888467e626d","fromNode":"4026031a39513573","fromSide":"bottom","toNode":"09eeba7d186cc631","toSide":"top"},
		{"id":"46d61fce2e556b06","fromNode":"202120fe71270d90","fromSide":"bottom","toNode":"9c7bf0e17764ae61","toSide":"top"},
		{"id":"cba74ded9d6eb313","fromNode":"f4475828cc860da0","fromSide":"bottom","toNode":"3ce00288d2634111","toSide":"top"},
		{"id":"ad5af5a9cac1f141","fromNode":"d570218de39c6a66","fromSide":"right","toNode":"3ce00288d2634111","toSide":"left"},
		{"id":"914cf7cc98beffc2","fromNode":"d570218de39c6a66","fromSide":"bottom","toNode":"cb4951b922ab48e7","toSide":"top"},
		{"id":"aeaac25706a7b91d","fromNode":"8bb56d96ae177393","fromSide":"top","toNode":"3ce00288d2634111","toSide":"bottom"},
		{"id":"f72976544f69804b","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"4026031a39513573","toSide":"left"},
		{"id":"b4dc878ef985faa8","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"202120fe71270d90","toSide":"left"},
		{"id":"358157fc48b5854e","fromNode":"a95021f577a47f4e","fromSide":"right","toNode":"d570218de39c6a66","toSide":"left"},
		{"id":"caa5fc4be3edbfa3","fromNode":"8bb56d96ae177393","fromSide":"right","toNode":"99a579f63e8ed830","toSide":"left"},
		{"id":"3fa67981659672f8","fromNode":"e865a825bb442798","fromSide":"top","toNode":"816848e0c2ad721f","toSide":"bottom"},
		{"id":"95c743f9cae72d10","fromNode":"a2c08aa1f7f84ed6","fromSide":"bottom","toNode":"73b289d2ddac85e0","toSide":"top"},
		{"id":"eddf13983ba20bcc","fromNode":"816848e0c2ad721f","fromSide":"top","toNode":"2154feb042ce2858","toSide":"bottom"},
		{"id":"ee30ff7d6d74d2a8","fromNode":"2154feb042ce2858","fromSide":"right","toNode":"a2c08aa1f7f84ed6","toSide":"left"},
		{"id":"560b2850f8356943","fromNode":"2154feb042ce2858","fromSide":"right","toNode":"73b289d2ddac85e0","toSide":"left"},
		{"id":"5f59ce4f1f9a5a79","fromNode":"816848e0c2ad721f","fromSide":"right","toNode":"1f30c648db2dcf7a","toSide":"left"},
		{"id":"ee7b4d04995f25a2","fromNode":"1f30c648db2dcf7a","fromSide":"top","toNode":"1d66725355e2923e","toSide":"bottom"},
		{"id":"f8152284aeb3cc64","fromNode":"61927ba45cbb9ee6","fromSide":"top","toNode":"c373c2bee7cda5f4","toSide":"bottom"},
		{"id":"8701a8b2641809db","fromNode":"aefa1f33137bd254","fromSide":"right","toNode":"eb6a901325ad751e","toSide":"top"},
		{"id":"ab7b96d681b24a4f","fromNode":"aefa1f33137bd254","fromSide":"bottom","toNode":"f4475828cc860da0","toSide":"top"},
		{"id":"3602e2d11390b764","fromNode":"0d399f2af310e7d9","fromSide":"left","toNode":"1362d388c8714d48","toSide":"right"},
		{"id":"ac57bb28ae028a75","fromNode":"1e66a8c6f7d0cfc8","fromSide":"bottom","toNode":"58b249e919fb0f61","toSide":"top"},
		{"id":"42c1593ce6b44636","fromNode":"0d399f2af310e7d9","fromSide":"bottom","toNode":"5bd9813160538beb","toSide":"top"},
		{"id":"779edd5a8b9eb05a","fromNode":"5bd9813160538beb","fromSide":"right","toNode":"4b19755e121bf99d","toSide":"left"},
		{"id":"a0b24ad9c5e000e9","fromNode":"5ce0efb2ba6f0a14","fromSide":"left","toNode":"5bd9813160538beb","toSide":"right"},
		{"id":"7330244647f4eed7","fromNode":"5ce0efb2ba6f0a14","fromSide":"right","toNode":"4e5009f864f3c65f","toSide":"left"},
		{"id":"95c4cfe55a4db7f7","fromNode":"5bd9813160538beb","fromSide":"right","toNode":"5ce0efb2ba6f0a14","toSide":"left"},
		{"id":"6a482a0f495351a5","fromNode":"5bd9813160538beb","fromSide":"left","toNode":"20930ba61df4d18d","toSide":"right"},
		{"id":"b46b5be3ecb555f3","fromNode":"20930ba61df4d18d","fromSide":"bottom","toNode":"043186a341c6fc88","toSide":"top"},
		{"id":"cc5f2a057df50ece","fromNode":"5bd9813160538beb","fromSide":"bottom","toNode":"2ada182acf4c1e0a","toSide":"top"},
		{"id":"0f4520095e6dddea","fromNode":"f4475828cc860da0","fromSide":"right","toNode":"eb6a901325ad751e","toSide":"left"},
		{"id":"9ec1d475bbc62f36","fromNode":"eb6a901325ad751e","fromSide":"left","toNode":"f4475828cc860da0","toSide":"right"}
	]
}