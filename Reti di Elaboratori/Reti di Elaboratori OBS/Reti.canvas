{
	"nodes":[
		{"id":"b72f299bae389d13","type":"text","text":"# Nodi\n\nSi distinguono in due macro-categorie:\n\n- **_Nodi estremali_** (o **_sistemi terminali_**) - situati alle **periferie** della rete. C'è una distinzione (non così rigida) tra\n\t- **_Host_** - tipicamente è l'utente, in generale vuole usare un servizio;\n\t- **_Server_** - un dispositivo a elevate prestazioni che offre servizi.\n- **_Nodi di interconnessione_** - sostanzialmente dei ripetitori, che all'occorrenza possono modificare il segnale che vi transita (e.g. amplificazione, incremento di un counter per tenere traccia del passaggio). Una trasmissione senza modifiche è detta **trasparente**. Ulteriormente divisi in\n\t- **_Router_** - collegano tra loro più reti;\n\t- **_Switch_** - collegano tra loro più nodi estremali all'interno di una rete;\n\t- **_Modem_** - trasformano la codifica dei dati (e.g. ????????????).\n","x":-4940,"y":1198,"width":700,"height":448,"color":"3"},
		{"id":"06174ae2aacf2d26","type":"text","text":"# Tipi di Reti\n\nLe Reti si classificano in base a quanto sono grosse. Già.\n\n- **Personal Area Network** (**PAN**) - tipicamente pochi metri (e.g. Bluetooth);\n- **_Local Area Network_** (**_LAN_**) - tipicamente entro un appartamento (e.g. Wi-Fi, Ethernet). Ogni nodo estremale possiede un indirizzo (**MAC**) che lo identifica univocamente all’interno della LAN. Si può implementare come\n\t- **cavo condiviso** - tutti i dispositivi sono connessi al router tramite un cavo comune. Questa roba non si fa più, anche perché si creano interferenze e non esiste la privacy (chiunque poteva attaccarsi al cavo e leggere il traffico dati di tutti, \"oggi a meno che tu non sia l'NSA non lo fai\");\n\t- **switch** - da un lato ha i vari dispositivi in parallelo, dall'altra il router. Permette la trasmissione simultanea di più host.\n- **Metropolitan Area Network** (**MAN**) - tipicamente copre una città;\n- **_Wide Area Network_** (**_WAN_**) - tipicamente copre un paese o una nazione ed è gestita da un **_Internet Service Provider_** (**_ISP_**). Abbiamo anche qui due casi:\n\t- **point-to-point** - ho due reti collegate tramite un singolo mezzo di trasmissione. Questo è il modo più semplice di realizzare una **internet** (con la i minuscola, che qui ci tengono, abbreviativo per **internetwork**), ovvero una rete di reti;\n\t- **commutazione** - ho più reti collegate tramite più mezzi di trasmissione, il che probabilmente includerà anche più nodi di interconnessione.\n- **_Internet_** - la rete di tutte le reti, il Tutto, il MoaN (Mother of All Networks), una specie di divinità, un concetto filosofico, ...","x":-4128,"y":340,"width":660,"height":740,"color":"4"},
		{"id":"23227e82062b49bc","type":"text","text":"# Struttura delle Reti","x":-3968,"y":1397,"width":340,"height":50,"color":"6"},
		{"id":"1ec4d0918042c205","type":"text","text":"# Tramissioni su Rete","x":-3972,"y":1960,"width":348,"height":50,"color":"6"},
		{"id":"4f9f693b64bc0e3f","type":"text","text":"# Glossario delle Reti\n\n- **_edge router_** - i router più periferici dell'Internet;\n- **_headend_** - termine generico che si riferisce a un nodo cruciale di una rete di telecomunicazioni, in cui convergono e vengono aggregati più segnali. Un edge router è un headend, ma se ad esempio vi sono molti cavi coassiali che vorrebbero entrarvi si può usare un cable headend, ovvero un dispositivo fisico che raggruppa le varie sorgenti per trasmetterle all'edge router;\n- **_access point_** - pezzetto di HW che funge da interfaccia tra il segnale Wi-Fi e il router;\n- **_Internet Service Provider_** (**_ISP_**) - riferito ad un'organizzazione di qualsiasi tipo (privata, no-profit, ...) che fornisce il servizio per l'accesso a Internet. Sono gestite da ISP\n\t- le **reti di accesso** ad Internet;\n\t- alcune infrastrutture che collegano più reti di accesso locali (**ISP regionale**)\n\t- le componenti del **nucleo di rete** a cui si connettono le reti di accesso e gli ISP regionali (**ISP globali**, o di **livello 1**)","x":-5752,"y":340,"width":716,"height":740,"color":"4"},
		{"id":"795690d5ce7e1c11","type":"text","text":"# Link\n\nI collegamenti fisici tra nodi possono essere realizzati in diversi modi.\n\n- **_Supporti guidati_** - I segnali si propagano in mezzi solidi (cavi). Esempi sono\n\t- **Doppino intrecciato** - due fili di rame isolati, uno per inviare i dati ed uno per riceverli (e.g. Ethernet, fino a 10 Gbps). Suscettibile a interferenze EM;\n\t- **Cavo coassiale** - due fili di rame concentrici, entrambi bidirezionali. Supporta i canali (**FDM**, $\\sim 100$ Mbps ciascuno), molto resistente alle  interferenze ma ad oggi soppiantato dalla fibra ottica;\n\t- **Fibra ottica** - fibra di vetro che sfrutta la riflessione totale interna della luce. Ogni fotone trasporta un singolo bit. Velocissimo ($v \\sim c$), basso rate di errore, ovviamente immune all'interferenza EM, costituisce la quasi totalità dei collegamenti nelle dorsali di Internet;\n- **_Propagazione libera_** - Spazia dal **Wi-Fi** domestico al **segnale satellitare**, e sfrutta lo spettro elettromagnetico con tutti gli ostacoli che ne conseguono (riflessione, attenuazione, interferenza). La potenza del segnale sferico decade come $1/r^2 \\Rightarrow$ molto forte nelle immediate vicinanze, molto debole poco dopo. Questo rende i link a propagazione libera dei canali **_half-duplex_** $\\Rightarrow$ chi riceve non può trasmettere a sua volta, perché con il forte segnale in uscita coprirebbe il segnale debole in entrata.","x":-4940,"y":1703,"width":700,"height":565,"color":"4"},
		{"id":"5cf8d16de6efff56","type":"text","text":"# Commutazione di Pacchetto","x":-4032,"y":2685,"width":468,"height":50,"color":"6"},
		{"id":"0c876453e3807959","type":"text","text":"# Pose e Coreografia\n\nHo un pacchetto con una destinazione. Devo avere chiare due cose:\n\n- Il percorso che seguirà nell'Internet attraverso i vari router, detto **_instradamento_** o **_routing_**. Definito da speciali **_algoritmi di instradamento_**, è un'azione **_globale_** (che riguarda cioè la rete nella sua interezza);\n- Il modo in cui il singolo router smista i pacchetti nel link corretto, ovvero la funzione interna che lega il segnale in ingresso a quello in uscita: internamente, ogni router ha una **_local forwarding table_** contenente le varie associazioni con i nodi adiacenti. Per scrivere le tabelle mi servono i percorsi. Viene detto **_commutazione_** (o **_forwarding_**, o **_switching_**).\n\nIn pratica, se il *forwarding* è la regola locale che definisce come si \"posiziona\" il singolo router, il *routing* è la \"coreografia\" globale risultante.","x":-3273,"y":2130,"width":700,"height":410,"color":"4"},
		{"id":"4958894e7197fe3c","type":"text","text":"# Rete\n\nInfrastruttura \"a grafo\" composta da dispositivi (_**nodi**_) che possono scambiarsi informazioni tramite dei collegamenti (**_link_**)","x":-3084,"y":1605,"width":323,"height":196,"color":"6"},
		{"id":"a569f47822207faf","type":"text","text":"# Struttura di Internet\n\nL'Internet può essere suddiviso con un criterio di \"profondità\".\n\n- **Periferia della rete** (**network edge**) - host e server;\n- **_Reti di accesso_** (**_access network_**) - tutto ciò che è connesso al router più periferico (**edge router**, ovvero il primo router che incontra il segnale partito da un host o da un server), a sua volta connesso con l'Internet. La connessione all'edge router può presentarsi in diversi gusti.\n\t- **Cavo** - Puro e semplice, non ci sono intermediari. Si collega insieme agli altri cavi della zona a un **cable headend**;\n\t- **Digital Subscriber Line** (**DSL**) - Sfrutta le linee telefoniche come cavi. Usa un **DSLAM** (**DSL Access Multiplexer**), uno specifico **headend** che smista il traffico internet e telefonico;\n\t- **Wireless LAN** (**WLAN**) - Mediato da un **access point** fisico che si interfaccia con il router domestico;\n\t- Rete cellulare;\n- **_Nucleo di Rete_** (**_dorsale_**, **_core_**, **_backbone_**) - questi termini vengono spesso usati in modo intercambiabile in quanto reti ad alta velocità che rappresentano la \"spina dorsale\" di Internet. In pratica, il nucleo di rete si occupa di collegare tra loro le reti di accesso (gestite da **ISP locali**). **NON** ciascuna di esse con tutte le altre (sono milioni e sarebbe $O(n^2)$), ma attraverso delle reti di più alto livello. ","x":-4940,"y":340,"width":700,"height":740,"color":"4"},
		{"id":"c842e00522cec07d","type":"text","text":"## Velocità e latenze\n\n- DSL\n\t- Downstream: $24\\div52$ Mbps\n\t- Upstream: $3\\div16$ Mbps\n\t- Latenza: ?????\n- Ethernet\n\t- 100 Mbps, 1 Gbps, 10 Gbps\n- HFC\n\t- Downstream: $40\\div1200$ Mbps\n\t- Upstream: $30\\div100$ Mbps\n\t- Latenza: ???\n- Fibra\n- Microonde\n- Wi-Fi\n\t- Trasmissione: 11-54-450 Mbps\n\t- Latenza: ????\n- 4G\n- Satellite\n\t- Trasmissione: fino a $45$ Mbps\n\t-  latenza (end-end): $\\sim 270 ms$.","x":-5752,"y":1703,"width":716,"height":565,"color":"2"},
		{"id":"0276409902e40e9c","type":"text","text":"## Tradurre \"bursty\" in matematica\n\nCi sono $n$ utenti, ognuno dei quali ha una (bassa) probabilità $p$ di essere attivo in un dato istante. Quanti utenti sono attivi contemporaneamente?\nOvviamente problema binomiale.\n\n$$\nP(x) = \\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$\nda cui segue la cumulativa (qui nel caso $x > k$)\n\n$$\nP(x > k) = \\sum^n_{i = k}\\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$","x":-5736,"y":2490,"width":700,"height":440,"color":"4"},
		{"id":"165209213bc6a130","type":"text","text":"## Sulla divisione delle Reti e di Internet\n\nIn pratica, Internet è un sistema talmente complesso che ho una mezza infinità di modi di suddividerlo. Diciamo che a seconda di cosa mi serve fare uso la divisione che più mi è utile. ","x":-4570,"y":40,"width":772,"height":137,"color":"4"},
		{"id":"ed6dd0d5b788bd3e","type":"text","text":"# In pratica e in breve\n\nPer accedere ad Internet ($\\Rightarrow$ scambiare dati con qualsiasi altro nodo collegato), gli host si devono in qualche modo connettere agli ISP (aziendali, università, commerciali), i quali a loro volta devono essere interconnessi (tramite ISP più grandi o IXP).\n\nLa risultante rete di reti è molto complessa, perché la sua evoluzione è figlia di un abnorme ammasso disordinato di fattori (politici, economici, nazionali, ...).","x":-4570,"y":-301,"width":772,"height":300,"color":"3"},
		{"id":"a3eaa4b44f0f3c44","type":"text","text":"# Giungla pseudo-gerarchica ISP\n\nISP è quasi un concetto filosofico. Io che ti metto l'hotspot sono tanto ISP quanto lo è Fastweb. Circa. In realtà c'è una specie di gerarchia.\n\n- Io che metto l'hotspot sono considerabile un edge router che funge da ISP locale (livello 3);\n- Il mio telefono però ha a sua volta un ISP, stavolta regionale (livello 2, e.g. *Fastweb*). Questo ISP ha accordi alla pari (**_peer-to-peer_**) per comunicare con altri ISP regionali senza passare dal nucleo di Internet. Tuttavia può essere necessario raggiungere nodi che necessitano un passaggio per le dorsali, motivo per cui i *livello 2* **_pagano il transito_** ai *livello 1*;\n- In cima alla catena alimentare troviamo gli **_ISP globali_** (livello 1, e.g. *AT&T*), connessi tra loro tramite degli **_Internet Exchange Point_** (**_IXP_**);\n- Ultimamente vi sono entità (e.g. Google, Netflix) che non hanno tutta questa voglia di pagare gli ISP più grossi, motivo per cui costruiscono delle proprie _**reti dei content provider**_ a livello degli ISP globali riuscendo a bypassarli e ad offrire un servizio più efficiente ai consumatori.","x":-5540,"y":-480,"width":504,"height":657,"color":"4"},
		{"id":"44898ee22f42afdc","type":"text","text":"# Prestazioni","x":-1800,"y":1960,"width":240,"height":50,"color":"6"},
		{"id":"665f35bd71acbb90","type":"text","text":"# Forwarding","x":-1800,"y":2310,"width":240,"height":50,"color":"6"},
		{"id":"981b264b7f7630c2","type":"text","text":"# Store&Forward\n\nUn pacchetto deve raggiungere completamente il nodo destinazione prima che questo possa iniziare il processo di *forwarding* (**_store&forward_**).\n\nLa trasmissione però richiede tempo, quindi è possibile che arrivino più pacchetti di quanti il router ne riesce effettivamente a smistare.\nQuesto implica che deve avere un *buffer* in cui mettere in coda i pacchetti in attesa. Nel migliore dei casi questo mi genera un **_queuing delay_**, e nel peggiore, ovvero se il buffer si riempie, può verificarsi la **_perdita dei pacchetti_**.\n\nD'altronde, quando mando un pacchetto su Internet devo essere consapevole che nessuno mi potrà mai garantire il suo effettivo arrivo a destinazione.\n\nNotare che il primo bit di un pacchetto può arrivare a destinazione prima che questo sia stato completamente trasmesso dal router di partenza sul link!","x":-1280,"y":2130,"width":680,"height":410,"color":"4"},
		{"id":"c45a83a3705f7881","type":"text","text":"# Latenza\n\nIl tempo totale necessario ad un pacchetto per essere inviato completamente da un nodo origine ad un nodo destinatario è detto **_latenza_** o _**delay**_.\n\nSi può scrivere come somma di 4 contributi:\n\n- Delay di Queuing ($D_q$) - dato dal tempo di attesa in coda dovuto al meccanismo di **store&forward**, qui il pacchetto aspetta di essere processato. Difficile da stimare, divergente se il pacchetto si perde;\n- Delay di Elaborazione ($D_e$) - dato dalle operazioni interne effettuate dal nodo sul pacchetto (controllo errori, determinazione del link di uscita, ...), in genere trascurabile rispetto agli altri ($D_e \\lesssim\\mu s$);\n- Delay di Trasmissione ($D_t$) - il router deve caricare tutto il pacchetto di lunghezza $L$ sul link avente bit rate $R$ $\\Rightarrow$ ci mette un tempo $D_t = L/R$. Tipicamente è il termine dominante, nonché l'unico che dipende dalla lunghezza del pacchetto. Trasmettere un $L$ enorme su un $R$ basso fa da bottleneck per l'intero sistema;\n- Delay di Propagazione ($D_p$) - quanto ci mette il pacchetto a transitare sul link, e dipende esclusivamente dalle caratteristiche di quest'ultimo. Se è lungo $k$ e i bit si propagano a velocità $v$ serve un tempo $D_p = k/v$. In genere è indicato come tempo di propagazione dell'ultimo bit del pacchetto (non cambia nulla, è solo per ricordarsi che esiste la politica di *store&forward*).\n\nIn sintesi quelli fondamentali sono [trasmissione e propagazione](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/transmission-vs-propogation-delay/transmission-propagation-delay-ch1/index.html), e ogni router da cui passa il segnale (anche detto **_hop_**) introduce un termine dominante $L/R$.","x":-1280,"y":1340,"width":680,"height":674,"color":"4"},
		{"id":"45a11294a8434cf8","type":"text","text":"# Glossario delle Prestazioni\n\n- **_trasmissione_** - il caricamento del pacchetto sul link da parte del router (\"modulare il segnale nel cavo\"). **_NON_** include la propagazione sul link.\n\t- Ogni link è caratterizzato da una **massima velocità di trasmissione** $R$ (*Rate*, misurato in bit/s), anche detta **_bit rate_** o **transmission rate**;\n- **_larghezza di banda_** (**_bandwidth_**) - si può usare per intendere\n\t- la larghezza dell'intervallo di frequenze utilizzate dal sistema trasmissivo ($Hz$);\n\t- il **bit rate** (bit/s), ad essa proporzionale.\n- **_throughput_** ($T$)- quantità di bit al secondo che passano a regime attraverso un generico punto della rete. Notare che è una misura di velocità effettiva, e che il suo massimo è il **bit rate** $\\Rightarrow$ è una misura effettiva di bit rate, e si effettua con un **_ping_**, ovvero un bit-sonda che mando avanti e indietro dal server che mi interessa;\n- **_bottleneck_** - quel collegamento che limita il throughput dell'intero percorso end-to-end;","x":-1940,"y":1055,"width":520,"height":617,"color":"4"},
		{"id":"305c16fa5fcbfca6","type":"text","text":"# Teoria delle Code\n\nPer il Delay di Queuing c'è tutta una teoria (delle code) che calcola il ritardo medio in coda in funzione dell'intensità del traffico $La/R$ , dove $a$ è il rate di arrivo di pacchetti in coda.\n\nIn questo modo si trova che questo ritardo diverge già per un traffico $La/R = 1$ $\\Rightarrow$ il router non sopporta un rate di arrivo dei pacchetti identico al rate di smistamento ([vedere per credere!](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/queuing-loss-applet/index.html)).\n\nQuesto succede perché $a$ è un rate medio, e \"quando sono fortunato e me ne arrivano meno mentre la queue è vuota non posso anticiparmi il lavoro\".\n\nCredo in realtà succeda anche perché non sto considerando il micro-ritardo di processamento interno, che seppur trascurabile sul singolo pacchetto magari sulla coda fa effetto.","x":-1280,"y":845,"width":680,"height":420,"color":"3"},
		{"id":"f1e9ad03f9edbfdd","type":"text","text":"# Prova\n\n- a cambiare la dimensione dei pacchetti TCP/IP di un computer (impostazioni del SO? chissà)","x":-420,"y":935,"width":420,"height":240,"color":"5"},
		{"id":"0e49609704fa8c9e","type":"text","text":"# Gestire le Congestioni\n\nCosa succede se a un certo punto del percorso tra i router un pacchetto entra in un loop? Resta intrappolato all'infinito, sprecando banda? Sconveniente. Devo metterci un *cut-off* $\\Rightarrow$ introduco un **_Time To Live_** (**_TTL_**), in pratica un numero che viene decrementato a ogni router che incontra (e che quindi rappresenta quanti altri router possono inoltrarlo).\n\nQuando il TTL diventa 0 il pacchetto muore. In questi casi sarebbe buona educazione da parte del router mandare un feedback a chi glielo ha inviato (\"*hey, ti ricordi quel bellissimo pacchetto che mi avevi mandato? sì, ecco, è morto*\").\n\nConoscere il motivo della perdita di un pacchetto è fondamentale. Se ad esempio viene perso per traffico (e quindi per via di una coda piena) dovrei rallentare la trasmissione per evitare di perderne altri.\n\nIl protocollo TCP/IP, ad esempio, è in grado di capire se una perdita è causata dal traffico o da altri fattori.","x":-2540,"y":1120,"width":540,"height":552,"color":"4"},
		{"id":"56958c816f8128f6","type":"text","text":"# Sicurezza","x":-3042,"y":1150,"width":240,"height":50,"color":"6"},
		{"id":"d7a25775f996e167","type":"text","text":"# Leak della struttura di rete (Latenza + TTL)\n\nScelgo una destinazione e mando pacchetti con un TTL sempre maggiore. Grazie al progressivo delay sono in grado di stimare il percorso end-to-end. \n\n... o quasi. Nessuno mi garantisce che ogni pacchetto seguirà sempre lo stesso percorso. Esistono però programmi diagnostici (e.g. **_traceroute_** su UNIX, o **_tracert_** su Windows) che restituiscono suddetti delay.\n\nNon c'è da stupirsi se a volte i router scelgono di non mandare feedback alla morte di un pacchetto per esaurimento del TTL.\nSe accetto il meccanismo dei TTL potrei far leakare la struttura interna della rete. ","x":-2540,"y":540,"width":540,"height":440,"color":"4"},
		{"id":"5b16a0a8827edeef","type":"text","text":"# Formulario (?)\n\n- Massimo numero di bit su un link - $R\\cdot D_p$\n- Avere un TDM (e.g. 10 slot/s) tipicamente in un esercizio significa che ad ogni host è associato uno solo degli slot indicati nel TDM (e.g. 1 slot/s).","x":-422,"y":1527,"width":422,"height":267,"color":"2"},
		{"id":"45b932caa35cd5e2","type":"text","text":"# Rete (guarda slides) tipo intro ai termini\n\nrete = nodi (computer) collegati da collegamenti (link). Distinguo i nodi estremali (host (vuole usare il servizio) o server (lo fornisce), non è una distinzione rigida) e quelli di interconnessione (router collega due reti o switch collegano terminali in locale). Dispositivi che possono scambiarsi info. Durante i passaggi di info queste spesso si modificano (fisico, quindi amplificazione, o tenere traccia del passaggio. esistono anche trasmissioni trasparenti).\n\nperiferia della rete -> host e server\nrete di accesso: utenti (problemi: max utenti per antenna)\nnucleo di rete: router interconnessi che fanno interagire sottoreti indirizzando il traffico\n\n(guarda slides)\n\nreti via cavo: tutto collegato allo stesso cavo condiviso. ogni casa ha splitter e modem.\n\nasimmetria: ci si aspetta che l'host scarichi più di quanto carica\n\na casa modem, router e access point sono integrati nello stesso coso.\n\n\"half duplex\" -> mentre trasmetto non posso ricevere. Questo perché la potenza del segnale scende come 1/r^2, e chi riceve vede un segnale debole -> non può trasmettere a sua volta, perché copro il segnale debole. Questo per il wifi e simili, su cavo faccio come voglio.\n\nsplitting di frequenze (anche su stesso cavo) ha costo (multiplexing?), nell'esempio del cavo sopra (credo) sia tutto su stessa frequenza.\n\n\n","x":-2270,"y":-1340,"width":640,"height":860,"color":"1"},
		{"id":"38f42aa977e02595","type":"text","text":"# (\"... comunque lo vedremo meglio\")\n\nnon ci sono computer, solo router che fanno commutazione di pacchetto (= forwarding = switching: qualcosa entra da una porta, lo faccio uscire da un'altra, ognuno ha una tabella di corrispondenze, è na roba LOCALE). NON sa che percorso farà. Ma chi le scrive le tabelle? Serve sapere i percorsi -> serve Algoritmo di Instradamento. Il ROUTING è un'azione GLOBALE.\n\nforwarding: come mi devo mettere; routing: coreografia\n\nstore and forward: prima ricevo tutto, poi mando. na specie de buffering. Pushare il pacchetto nel cavo = trasmettere, ergo se devo mettere L bit di pacchetto a velocità R bit/s ci metto L/R secondi ed è detto ritardo di trasmissione (trasmissione è solo l'uploat del pacchetto nel collegamento (cavo), poi c'è delay di trasporto ma spesso è trascurabile). \"modulare il segnale nel cavo\". ogni router che trasmette (HOP) porta un ritardo +L/R. Se poi mi interessa il delay del segnale totale trasportato da N pacchetti moltiplico per N. Poi c'è ritardo di accodamento (vedi slides).\n\nTEORIA DELLE CODE???\n\nA - algoritmo per ottimizzare commutaizone di circuito?\n\nSe multiplexo sulle frequenze (costo alto) mitigo il problema delle code. Posso farlo anche sul tempo (costo minore, eg bluetooth), ma sono a rischio latenza. Qual è meglio? Dipende da che ci devo fare. Comm di circuito però non si usa su Internet. cellulari usano entrambi. pacchetto consente a più utenti di usare la rete. Internet è _bursty_, impulsiva, dati inframezzati da lunghi silenzi. Mi baso sul fatto che molti stanno zitti per permettere a più persone di parlare (e.g. se ho 35 utenti P(attivi>20) $\\sim$ poco, conto con binomiale). se uso comm circuito dedico una linea fissa e non sfrutto le \"caratteristiche\" degli utenti (che stanno spesso zitti).\n\nSe mando un pacchetto su Internet non ho garanzie che arrivi a destinazione. Tutti i tentativi per dare garanzie (ovvero strutturare diversamente i protocolli) hanno fallito miseramente. Comm di circuito garantisce, ma se non comunico spreco risorse. \"Internet è accettare che tutti provano e provare a risolvere quando si creano problemi\".\n\nISP punto debole di interet, in mano ai grandi fornitori. interconnessi, guidati dagli interessi aziendali più che geografici. Abbiamo milioni di ISP di accesso. Li collego tutti tra loro? No, è $O(n^2)$. Inizialmente: ISP di transito globale a fare da centralino (pagato da ISP locali). Ora ci sono tanti ISP globali collegati da IXP (internet exchange point, collegamento di peering). La rete degli IXP ha una rete dei content provider.\n\nSegue discorso sulla legislazione perché sta roba dà un sacco di potere\n\n","x":-1580,"y":-1421,"width":640,"height":1120,"color":"1"},
		{"id":"435d7ec357e56abd","type":"text","text":"# prestazioni slides 3\n\nthroughput è una misura a regime (un po' una misura del bitrate effettivo, ed è sistematicamente minore o uguale). è il flusso/portata della fluidodinamica. Non basta un ping (singolo bit, quello misura la latenza).\ncolli di bottiglia creano grossi problemi su internet, ma non nelle dorsali (backbone, sono enormi), quanto quelli che si collegano.\ntutto questo comunque resta molto teorico perché non considero perdite e ritardi, all'atto pratico misuro per sapere quant'è.\nSeguono i ritardi che sommati fanno la latenza\n- processamento (elaborazione del pacchetto: controllo errori, switching, ... tipicamente svariati odg meno degli altri)\n- Trasmissione (tutta  la dipendenza dalla grandezza del pacchetto è qua)\n- Accodamento (queuing delay, dipende dal traffico, difficile da calcolare, c'è teoria delle code)\n- propagazione (SOLO lunghezza del cavo, satellite 300ms, cavo oceanico 30ms)\n\ni primi bit caricati in trasmissione non devono aspettare gli ultimi. Infatti, se ho n bit e ognuno ci mette m secondi, l'ultimo verrà processato dopo nxm secondi. Ma intanto il primo è partito. Magari è pure arrivato all'altro router, il quale però deve aspettare di ricevere tutto il pacchetto per inoltrarlo.\nAttenzione a fare pacchetti troppo grossi, il ritardo di trasmissione schizza alle stelle. (posso cambiarlo su pc con la mia connessione???)\n\nSe sto trasmettendo un pacchetto enorme con bassa velocità ci metto un botto, il che blocca la rete per tutti!\n\n","x":-920,"y":-1280,"width":640,"height":740,"color":"1"},
		{"id":"c3e8022233e42700","type":"text","text":"# Ritardi\n\n- accodamento (\"quando siamo fortunati non possiamo portarci avanti col lavoro) rivedilo che non ho capito cosa vuole dire (vedi animazione di due slides dopo, perdita di pacchetti, mettendo stesso rate di emission e transmission) --> se si riempie la coda perdo pacchetti --> un pacchetto perso ha tempo di attesa infinito\n\nse ci stanno dei loop nel percorso router i pacchetti intrappolati restano all'infinito? Devo metterci un cut-off -> tempo di vita (TTL time to live), spesso espresso in \"quanti altri router possono inoltrarlo\". Se il pacchetto muore in genere il router manda un feedback a chi glielo ha inviato (\"hey, il tuo pacchetto è morto). Se mando TTL sempre crescenti stimo il percorso (non proprio, nessuno mi dice che faccio sempre lo stesso $\\forall$ invio).\nPer vari motivi i router possono non rispondere quando muore il pacchetto. Se accetto i TTL potrei far leakare la struttura interna della rete. Se il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). TCP/IP capisce se è una perdita per traffico o casuale. Importante perché se perdo per traffico dovrei rallentare, altrimenti scialla.\n\n- rate\\*ritardo = numero massimo di bit nel buffer (-> definisce grandezza del buffer). volume del \"tubo\" di trasmissione. non utilissimo perché a me interessa il throughput, cioè la sezione\n\n","x":-280,"y":-1270,"width":640,"height":720,"color":"1"},
		{"id":"187dc42cfef0546d","type":"text","text":"# Appunti lezioni raw in rosso - magari poi ci faccio un txt","x":-1492,"y":-1640,"width":465,"height":102,"color":"1"},
		{"id":"5b4bbd10c0ed915d","type":"text","text":"# Sicurezza\n\nOSI bello ma mai stato implementato, la sicurezza sta all'applicazione\n\nQuasi tutti i governi fanno sniffing, anche se è crittografato.\nBanalmente ho i metadati, quindi posso risalire a chi parla (magari senza sapere cosa), ma posso mettermi ad ascoltare più \"vicino\" ai due che parlano. Se sei un governo puoi fare la qualunque, compreso con le crittografie (non tutto no? se faccio RSA col cazzo mi sa). Tecnicamente sniffing era attaccarmi col cavo (quando c'era un cavo per tutti) ma oggi dipende dalla tecnologia usata ed è un concetto astratto.\n\nPosso fare cose illegali in N (con N enorme) modi. Tipo, posso inviare pacchetti mettendo un mittente che non sono io (se mando la droga e metto come mittente qualcun altro quello non va in galera perché non è dimostrabile che l'ha mandato lui), oppure da router posso tenermi i pacchetti e leggerli, o inoltrarli a una macchina a mia scelta.\n\nContro queste cose c'è roba tipo\n- l'autenticazione\n- confidenzialità (crittografia)\n- autenticità\n- restrizioni di accesso (e.g. VPN protetta da password)\n- firewall (a livello di rete)\n\nCi sono attacchi diversi a seconda di\n- come reagisco alle richieste\n- come creo la connessione (e.g. TCP)\n- ...\n\nDi base si può fare tutto, è una giungla!\nSe mi fingo un altro comunque l'altro può trasmettere, a rigore dovrei anche preoccuparmi di bloccare quello che interpreto (man-in-the-middle).\n\n","x":-3360,"y":127,"width":739,"height":853,"color":"1"},
		{"id":"1b501ca1023c98e0","type":"text","text":"# Perdite\n\n\nSe il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). ","x":-2020,"y":2580,"width":680,"height":215,"color":"1"},
		{"id":"a69d18b26b90862d","type":"text","text":"# Algoritmi di Instradamento","x":-1898,"y":3240,"width":437,"height":50,"color":"6"},
		{"id":"9ed19d6e9980b34b","type":"text","text":"# Come invio i messaggi sui Link?\n\nHo sostanzialmente due modi per farlo.\n\n- **_Commutazione di Circuito_** - Letteralmente, creo un collegamento fisico riservato alla coppia sorgente-destinazione, sulla quale sono gli unici a poter comunicare (salvo collegamenti fisici alla linea da parte di terzi, dove i terzi sono verosimilmente i servizi segreti). Garantisce prestazioni stabili, e viene usato nelle linee telefoniche. Naturalmente si può fare anche senza dedicare un intero cavo al singolo canale di comunicazione:\n\t- **_Frequency Division Multiplexing_** (**_FDM_**) - Ogni cavo trasmette un certo range di frequenze EM. Allora le suddivido in N canali, e ad ognuno di questi assegno una certa larghezza di banda (che però sarà stretta);\n\t- **_Time Division Multiplexing_** (**_TDM_**) - Sostanzialmente tratto i canali come una *ready queue* e faccio *preemptive scheduling*. Entro il proprio intervallo di tempo assegnatogli, ogni canale trasmette avendo a disposizione la banda massima;\n- **_Commutazione di Pacchetto_** - Ogni messaggio viene suddiviso in **_pacchetti_**. La rete si occupa di instradare i singoli pacchetti e *tenta* di non fare casino. Interessante notare come nonostante possa fare casino in molti modi (e in effetti lo fa: li perde, sbaglia l'ordine di arrivo, li inoltra a terzi, ...) è il metodo più utilizzato su Internet. Ovviamente il motivo c'è: le comunicazioni sono spesso **_bursty_**, nel senso che gli host stanno *quasi* sempre zitti, tranne in singoli momenti isolati in cui vomitano un enorme messaggio da inviare. Non ha senso dedicare un circuito a una comunicazione in cui non succede *quasi* mai niente: blocco delle risorse che restano inutilizzate quando magari altri host rimasti tagliati fuori potrebbero comunicare il proprio messaggio *bursty*. Idealmente dovrei dare la sensazione all'host di avere una connessione dedicata, il che in parte si risolve aumentando la banda e in parte non si risolve perché ci stanno mille problemi.","x":-4907,"y":2321,"width":700,"height":780,"color":"4"},
		{"id":"1a0fe951bbf51b93","type":"text","text":"# Why bidirezionale?\n\nPerché se comunico voglio sia inviare che ricevere, quindi\n\n- ci sono almeno due stack, una per chi invia e una per chi riceve;\n- tutti gli host possono essere sia mittente che destinatario.\n\nDa questo segue che guardando le varie stack in **_orizzontale_** troviamo una **_simmetria logica_**, ovvero **protocolli omologhi** e **oggetti identici**.\n\nConcettualmente, il **_collegamento logico_** è tra layer di pari livello di tutte le stack, che parlano la stessa \"lingua\" $\\Rightarrow$ il layer $N$ di un dispositivo comunica virtualmente solo e soltanto con il layer $N$ degli altri dispositivi.\n\nL'effettivo **_flusso di informazione_** è però **_verticale_**, eccetto per il livello più basso che rappresenta lo spostamento fisico.\n\nLungo la propria stack, il mittente applica delle funzioni per incapsulare il messaggio (e.g. lo critta e lo mette in una scatola), questo viene fisicamente trasportato al nodo successivo dal livello più basso (e.g. il furgone delle poste) e infine il destinatario applica le funzioni inverse (in ordine inverso, perché stavolta il messaggio risale la stack) per riottenere il messaggio originale (e.g. apre la scatola e lo decritta). \n\nNel complesso, l'informazione \"scende\" e \"risale\" lungo le stack protocollari.\n","x":-4907,"y":3993,"width":700,"height":627,"color":"4"},
		{"id":"1bd86960d6e5a8e2","type":"text","text":"# Stack protocollare","x":-3966,"y":3675,"width":336,"height":50,"color":"6"},
		{"id":"3881465ee755981e","type":"text","text":"# Stack Protocollare TCP/IP\n\nL'unica e incontrastata stack protocollare rimasta in vita. **_TCP/IP_** prevede **_5 livelli_**, che descriverò in approccio _down-top_ (si dice? chissà), partendo quindi dalla realtà fisica per arrivare alla virtualizzazione di più alto livello.\n\n- **_Livello Fisico_** - l'infrastruttura fisica, dove avviene il vero e proprio **_trasferimento dei segnali_** (e.g. **cavi**). Più che un layer è una constatazione che \"a un certo punto deve avvenire la propagazione\", l'HW nudo e crudo;\n- **_Livello di Collegamento_** (o **_Link_**) - a livello HW, regola e gestisce il **_trasferimento dei pacchetti da un nodo al successivo_** (e.g. **Ethernet**, **Wi-Fi**, **PPP**, ...). Lungo il suo percorso, un singolo pacchetto può essere gestito da protocolli diversi.\n- **_Livello di Rete_** - a livello matematico, regola e gestisce l’**_instradamento dei pacchetti_** dall'origine alla destinazione attraverso opportuni algoritmi (e.g. **IP**);\n- **_Livello di Trasporto_** - a livello SW, regola e gestisce il trasferimento dei pacchetti dal processo (??????????) del dispositivo mittente a quello del dispositivo destinatario (protocolli TCP, UDP, ...).\n- **_Livello di Applicazione_** - è la vista di più alto livello. (protocolli HTTP, SMTP, FTP, DNS, ...).\n\nOra però passiamo all'approccio *top-down* per seguire l'evoluzione di un messaggio.\n\n- il **_messaggio_** corrisponde al pacchetto originale, per come visto dall'utente a livello di Applicazione;\n- il layer di partenza applica delle trasformazioni utili (e.g. compressione, aggiunta di metadati, crittografia, ...) e lo passa al Trasporto attraverso la loro **_interfaccia_**;\n- il Trasporto riceve il messaggio e gli aggiunge le proprie informazioni (**_header_**), portando a termine il primo **_incapsulamento_** e rendendo il messaggio un **_segmento_** (o **_datagramma utente_**). L'header del Trasporto è comprensibile per la Rete, che saprà cosa farci, e contiene _almeno_ mittente e destinatario;\n- in modo analogo il Trasporto passa il segmento alla Rete, che aggiunge il proprio header e crea un **_datagramma_**, comprensibile per il Collegamento;\n- si passa quindi al Collegamento, che aggiungendo il proprio header rende il pacchetto un **_frame_**, utile a livello di collegamento Fisico.\n\nA questo punto il pacchetto ha completamente disceso la stack, e un altro dispositivo può applicare le trasformazioni inverse per risalire prima al datagramma, poi al segmento e infine al messaggio.","x":-4148,"y":3993,"width":700,"height":1067,"color":"3"},
		{"id":"010165be9fd56b6c","type":"text","text":"# Livello di Rete","x":-3055,"y":3675,"width":264,"height":50,"color":"6"},
		{"id":"4df27d69ac9764ca","type":"text","text":"# Why stack protocollare?\n\nUn **_protocollo_** definisce l’insieme di regole che mittente e destinatario (e tutti i sistemi intermedi coinvolti) devono rispettare per essere in grado di comunicare.\n\nSituazioni complesse richiedono una suddivisione dei compiti fra più livelli (**_layer_**, o *strati*), indipendenti secondo il principio di modularità. In questo caso è richiesto almeno un protocollo per ciascun livello $\\Rightarrow$ **_layering di protocolli_** (o **_stack protocollare_**). Un protocollo diventa quindi quell'insieme di regole che definiscono il formato e il significato dei messaggi scambiati tra pari all'interno del singolo layer.\n\nQuesto porta in generale diversi vantaggi:\n\n- La struttura modulare esplicita facilita la modellizzazione (e.g. TCP/IP);\n- L'aggiornamento e/o la sostituzione dei moduli è più semplice e trasparente (è ben chiaro cosa sto facendo, e dove), e non influisce sul resto del sistema.\n\nOgni layer deve essere in grado di _comunicare in modo_ **_bidirezionale_** _con i livelli adiacenti_. In particolare, ogni coppia di livelli adiacenti si deve configurare come *provider-user*, in cui il primo offre al secondo un **_servizio_**.\n","x":-4907,"y":3444,"width":700,"height":513,"color":"4"},
		{"id":"472a39255272296f","type":"file","file":"Layering.png","x":-5736,"y":4231,"width":717,"height":389},
		{"id":"f6c22dc935238119","type":"text","text":"# Protocolli e Servizi\n\nIl servizio è il **_cosa_** garantisco (e.g. in questo caso un insieme di primitive che uno strato offre a quello superiore), il protocollo è **_come_** implemento il servizio.\n\n```\nServizio del livello di trasporto: \"Usa la mia primitiva INVIA. Ti garantisco che i tuoi pacchetti arriveranno a destinazione tutti e in ordine, se si disordinano ci penso io a rimetterli a posto\"\nProtocollo del livello di trasporto: TCP\n```\n\nOgni layer, secondo il proprio protocollo, implementa dei servizi usando le proprie risorse e i servizi forniti dal livello sottostante.\n\n Tramite i servizi si possono vedere i layer come delle **_black box_** $\\Rightarrow$ ci si può dimenticare dell'implementazione (protocollo) sottostante in favore di una vista di più alto livello che consta di input e output (servizi e/o informazioni).","x":-5736,"y":3444,"width":717,"height":440,"color":"4"},
		{"id":"8ca68ef0d9cba75a","type":"text","text":"# Where stack protocollare?\n\nOvunque sia necessario far comunicare più elaboratori, in un range che spazia da una semplice LAN fino all'Internet.\n\nSu **LAN** si possono trovare diversi esempi di stack protocollari proprietarie nate tra gli anni '70 e '90, come **NetBIOS** (**Microsoft**) o **AppleTalk**.\n\nCon l'avvento di **_Internet_** si è però tutto uniformato a **_TCP/IP_**, rimasto praticamente l'unico ad oggi in uso.","x":-5736,"y":3920,"width":717,"height":276,"color":"4"},
		{"id":"6e7c8cc6c0993984","type":"text","text":"Livello un po' filosofico, né HW né SW","x":-2660,"y":3675,"width":250,"height":60},
		{"id":"179ce6b66f1a29fe","type":"text","text":"# Livello di Applicazione","x":-4907,"y":5944,"width":400,"height":50,"color":"6"},
		{"id":"349ec5026bac8b92","type":"text","text":"# protocolli applicazione\n\nprotocolli comuni con complicazioni sw. API socket -> mi servono i servizi del livello sotto per funzionare, sono interessato solo a cosa posso usare. creare un'app a questo livello ignora la complessità della rete (percorso pacchetti, reinvio in caso di perdita, ...). Anche i router ignorano il livello applicazione (non esiste http sui router).\nDue tipi di paradigmi\n- client-server (posso farlo anche tra due \"client\", ma uno dei due deve fare roleplay e chiamarsi server). se il server si scollega non posso avere comunicazione (in p2p sì...?)\n- p2p, più complesso da gestire perché non ho indirizzi fissi\n\nsocket = canale di comunicazione virtuale. client e server ne aprono uno a testa per comunicare col livello inferiore\nIP identifica host, poi serve la porta (cioè identifico prima a chi comunicare e poi come) -> identifier\n\nil come in realtà è gestito dal protocollo (sintassi, semantica, regole).\nprotocolli proprietari più ottimizzati ma a volte meno efficienti (difficile trovare problemi con poca statistica). open source aiuta a ridurre vulnerabilità (cruciale tempo tra ritrovamento bug e suo fix).\n\nregola livello app: \"se cancello messaggio qui lo cancelli anche dall'altra parte\". cosa mi serve? integrità - il pacchetto con l'info deve arrivare a destinazione, e voglio la garanzia (magari temporale, se faccio una chiamata non voglio pacchetti in disordine, o videogioco), throughput (ovvio), sicurezza. E se non ho queste garanzie? sono cazzi miei, me la risolvo a livello applicazione.\n\nAPI fornite dal livello di trasporto: TCP e UDP.\n\n- TCP - è lawful good. dà garanzie di arrivo, di non-congestione dell'utente (controllo flusso) e della rete (controllo congestione) (\"se su TCP vado al massimo blocco anche me stesso\"). NON dà garanzie di velocità. chi va piano... ma tanto timing e throughput non può mai essere garantito in commutazione di pacchetto, devo fare circuito con linea dedicata. è in chiaro, non offre crittografia. orientato alla connessione -> esiste paradigma mittente destinatario \n- UDP - è chaotic evil, non fornisce manco la connessione (l'altro non sa che gli ho inviato la richiesta di connessione). \"io ci provo a trasmettere i dati, poi... da parte mia best effort fratello\". può essere veloce, non è necessario il paradigma client-server. ogni servizio che offre tcp aggiunge complessità e potenzialmente ritardi e/o capacità computazionale. ma io posso costruire il mio trasporto affidabile a livello sw e poi sparare tutto su udp che potenzialmente ci mette meno. infatti tutti oggi tendono a implementare regole a livello applicazione, e se http era basato su tcp si sta lentamente passando a udp. http3 usa udp e si costruisce i servizi di tcp a livello applicazione, il che mi garantisce flessibilità. (\"deve rimanere leggero\")\n\nmentre tutto ciò che è implementato a livello di trasporto (e.g. i protocolli garanzie di tcp) deve essere implementato ( -> leggibile, interpretabile) a livello di SO (per usare un certo protocollo di trasporto mi servono le librerie di quel protocollo), con il livello applicazione posso implementare tutto su un browser -> più rapido nello sviluppo!\n\nci sono anche delle vie di mezzo tipo TLS (sicurezza). prima se mandavo una password era in chiaro, chi trovava il pacchetto (non facilissimo) aveva vinto. Transport Layer Security usa TCP ma sta sotto l'applicazione. Quindi io scrivo la phrase in chiaro, tls la critta e la passa a tcp. non lo faccio a livello tcp perché è un casino cambiare un protocollo così lento ad evolversi (super diffuso).","x":-7000,"y":5460,"width":1100,"height":1020},
		{"id":"3c83dc58c55637a4","type":"text","text":"\n(Tendono ad essere più che altro descrittivi, un insieme di regole fenomenologiche che possono rompersi in qualsiasi momento.??????)\n\n\n\"avere protocolli aperti permette a tutti di competere\"\n\n\n\nIl livello N prende il payload (mole di dati) del livello N-1 e gli aggiunge le proprie etichette (header, ...)\n\nSwitch non fa niente, router fa entrambe le cose\n\nIP e MAC fanno riferimento a layer (protocolli) diversi.","x":-5800,"y":6433,"width":385,"height":507},
		{"id":"34401d45639b449d","type":"text","text":"# Livello di Trasporto","x":-3968,"y":5944,"width":341,"height":50,"color":"6"},
		{"id":"9f731eac72823c6c","type":"text","text":"# Livello di Collegamento","x":-3118,"y":5944,"width":391,"height":50,"color":"6"},
		{"id":"0719791a80c12eb2","type":"text","text":"# Chi fa cosa?\n\nMittente e destinatario devono implementare tutti gli step dell'incapsulamento o decapsulamento, naturalmente mediante dispositivi diversi.\n\nUn router vede solo dal livello di Rete in giù. Una sua azione tipica è **distruggere l'header di Rete** del pacchetto in ingresso **e crearne uno nuovo** ($\\Rightarrow$ così realizza il **reindirizzamento**).\n\nNon ha bisogno di avere i protocolli software di Trasporto e Applicazione (tipicamente implementati solo a livello di SO), perché non arriva a vederli. Si limita a collegare $N$ sottoreti tramite $N$ strutture diverse sottostanti.\n\nUno switch si ferma al Collegamento. Non dovendo reindirizzare, non distrugge/crea alcun header.","x":-4907,"y":4660,"width":700,"height":400,"color":"3"},
		{"id":"d0bc31a12d2847f8","x":-5736,"y":4753,"width":717,"height":214,"type":"file","file":"chifacosa.png"},
		{"id":"2edbb402780f44c6","type":"text","text":"# HTTP\n\nuniform resource locator (URL). HTTP è un RFC (???). Protocollo **richiesta-risposta**. http stateless nonostante tcp supporterebbe lo storico. (\"è come Dory della Ricerca di Nemo). Non mi interessa se l'azione che fai ha step intermedi, non mi interessa quello che hai fatto prima. Cosa diversa è la persistenza! all'inizio era non persistente, ma lo è diventato a partire da http 1.1. non persistent prende almeno 2 ritardi di propagazione per oggetto (RTT round trip time, definito come \"piccolo pacchetto\" perché così $D_t \\sim 0$). all'inizio browser mandavano richieste in parallelo, ma TCP non è pensato per una cosa del genere e rischia di compromettere controllo di congestione. lasciare la connessione aperta non è banale.\n\nheader: insieme di campi che danno informazioni al destinatario. non fa parte dell'incapsulamento (leggo-distruggo-replace), payload del (parte del messaggio visto dal) livello sottostante, non cambia (resta leggibile\n\n- Messaggio di richiesta - in una richiesta POST il corpo contiene informazioni da mandare al server. In GET host parametro obbligatorio (devo sapere a chi mando la richiesta). Se metto `?` poi seguono parametri separati da `&`. PUT, UPDATE sono pericolosissimi, come si gestiscono??? parametro if-modified-since si lega alla cache.\n\n- Messaggio di risposta - Etag rappresenta il file (if-modified since, accept ranges se accetto file multipli (??), gli altri dopo quanto il server chiuderà la connessione). Se sono un server devo rispondere bene, altrimenti dall'altra parte non capiscono (codici risposta e.g. 204 tipo salva pagina, tutto ok ma nessun dato da inviare in risposta). Quelli degni di nota sono segnati. (header ha peso del file, magari scarico prima l'header e valuto se voglio scaricare tutto) (e.g. 400-bad request contiene un messaggio html che è la pagina web che ti compare di conseguenza)\n\ntelnet?? interfaccia con tcp a livello testuale, devo mandare a capo due volte. una volta che si apre una connessione ogni carattere fa un roundtrip, ma di default non vedo l'echo di quello che ho scritto su terminale.\nbrowser fa questo ma in automatico con le librerie TCP.\nwirehark???\n\nperché stateless è un problema? How-To-Cookie\nvoglio fare 2 modifiche a un oggetto e non accetto che ne venga fatta una sola.\nse sono stateful uso un lock fino a fine operazioni, ma non è http! Uso i cookie, che tengono traccia dello stato del client. in richiesta mando un cookie, in risposta faccio un \"set-cookie\". solo con i cookie il server identifica il browser di origine. Se mi arriva una richiesta senza cookie, io server te lo creo unico e te lo rimando, così so cosa hai visitato. ogni server ha il proprio cookie e non dovrebbe passarlo agli altri. Alcuni cookie muoiono subito, altri non sono interessato a ucciderli (ma posso sempre??). esiste una forma di attacco basato sul furto dei cookie di sessione (impersono il browser senza avere alcuna password) ma ci si è iniziati a difendere subito. Di per sé non sono pericolosi, ovvio che il server sa che richieste faccio. Il problema sono i cookie di terze parti (cioè non del server che contatto direttamente) che permettono a gruppi di server di tracciare le attività del client. (e.g. di cookie: fingerprint che include browser, font, latenza, risoluzione schermo e io server posso venderlo a terzi). Come trasferisco la risoluzione?? HTTP non lo fa, è difficile profilare (so solo IP, latenza e poca roba). Potrei forzare il browser a limitarsi a questo. Però uso spesso anche javascript (-> il server fa girare codice sul client) e le regole a riguardo sono molto \"rilassate\". Posso fare injection per farmi mandare la risoluzione schermo o altra roba. Si può mascherare ma dall'altra parte possono accorgersi che tu mascheri ed attirare l'attenzione. l'unico metodo funzionante è disabilitare javascript. Attacco canvas??\n\nHo dei modi alternativi? Certo, ma più complessi.","x":-7000,"y":6560,"width":1100,"height":1020},
		{"id":"1a7e522c18045e6d","type":"text","text":"# Interfacce e (de)multiplexing\n\nTCP/IP prevede più protocolli per uno stesso layer (e.g. HTTP ed FTP per l'Applicazione, TCP e UDP per il Trasporto), da cui la domanda: come faccio a sapere quale protocollo \"adiacente\" voglio/devo usare?\n\nRisposta semplice: lo scrivo nell'header.\n\nRisposta complessa: devo essere in grado di\n\n\n\nnecessario eseguire il multiplexing alla sorgente e il demultiplexing alla destinazione\nTCP deve sapere se deve dare il pacchetto a FTP o HTTP. Demultiplexo con le porte. e.g. uso 80 per HTTP. Il multiplexing è: qualsiasi protocollo può mandare pacchetti a TCP, al quale non deve fregare niente del protocollo sovrastante.\n\nleggi: l'header deve identificare il protocollo, ma poi TCP fa lui.\n\n\n•Multiplexing: un protocollo può incapsulare (uno alla volta) i pacchetti ottenuti da più\nprotocolli del livello superiore\n•Demultiplexing: un protocollo può decapsulare e consegnare i pacchetti a più\nprotocolli del livello superiore\n\nPer poter effettuare le operazioni di multiplexing e\ndemultiplexing, ogni pacchetto deve avere un campo\nall’interno dell’header per identificare a quale protocollo\nappartien","x":-3347,"y":4540,"width":620,"height":520,"color":"1"}
	],
	"edges":[
		{"id":"6ddf40dd3d233286","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"23227e82062b49bc","toSide":"right"},
		{"id":"f97b165cd5b79ca1","fromNode":"23227e82062b49bc","fromSide":"top","toNode":"06174ae2aacf2d26","toSide":"bottom"},
		{"id":"79cea350f5f65501","fromNode":"a569f47822207faf","fromSide":"left","toNode":"4f9f693b64bc0e3f","toSide":"right"},
		{"id":"6d5ee26096e39af5","fromNode":"06174ae2aacf2d26","fromSide":"left","toNode":"a569f47822207faf","toSide":"right"},
		{"id":"efca276162b37995","fromNode":"a569f47822207faf","fromSide":"right","toNode":"06174ae2aacf2d26","toSide":"left"},
		{"id":"a779e63db92ba963","fromNode":"06174ae2aacf2d26","fromSide":"top","toNode":"165209213bc6a130","toSide":"bottom"},
		{"id":"9f06416bd06bfdef","fromNode":"a569f47822207faf","fromSide":"top","toNode":"165209213bc6a130","toSide":"bottom"},
		{"id":"61b78f68c63f4e8a","fromNode":"23227e82062b49bc","fromSide":"left","toNode":"b72f299bae389d13","toSide":"right"},
		{"id":"6f94fecf4639c0f4","fromNode":"4958894e7197fe3c","fromSide":"bottom","toNode":"1ec4d0918042c205","toSide":"right"},
		{"id":"18732b858dd6d8e8","fromNode":"b72f299bae389d13","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"top"},
		{"id":"236fb80dc10bcb1c","fromNode":"795690d5ce7e1c11","fromSide":"top","toNode":"b72f299bae389d13","toSide":"bottom"},
		{"id":"08f8c4d75162bc70","fromNode":"1ec4d0918042c205","fromSide":"left","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"2ad6aae7b242e920","fromNode":"795690d5ce7e1c11","fromSide":"left","toNode":"c842e00522cec07d","toSide":"right"},
		{"id":"6231bef59e40ecfa","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"5cf8d16de6efff56","toSide":"top"},
		{"id":"7ddcd8cf952994b6","fromNode":"9ed19d6e9980b34b","fromSide":"left","toNode":"0276409902e40e9c","toSide":"right"},
		{"id":"b9f2cee56ecc6884","fromNode":"165209213bc6a130","fromSide":"top","toNode":"ed6dd0d5b788bd3e","toSide":"bottom"},
		{"id":"fceeaf4ae4ae9491","fromNode":"23227e82062b49bc","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"818a74c3caa1b0b6","fromNode":"5cf8d16de6efff56","fromSide":"bottom","toNode":"1bd86960d6e5a8e2","toSide":"top"},
		{"id":"c16c39c9b26ca69c","fromNode":"1ec4d0918042c205","fromSide":"right","toNode":"44898ee22f42afdc","toSide":"left"},
		{"id":"91f484736f73f3df","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"56958c816f8128f6","toSide":"bottom"},
		{"id":"49bc3d9146b806bb","fromNode":"665f35bd71acbb90","fromSide":"top","toNode":"44898ee22f42afdc","toSide":"bottom"},
		{"id":"4d323ae12dc8b711","fromNode":"44898ee22f42afdc","fromSide":"right","toNode":"c45a83a3705f7881","toSide":"left"},
		{"id":"7534cf6c10d8c863","fromNode":"5cf8d16de6efff56","fromSide":"right","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"fe0cb992b8bb8e89","fromNode":"0c876453e3807959","fromSide":"right","toNode":"665f35bd71acbb90","toSide":"left"},
		{"id":"9ab56fb991918b05","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"892fdf290715d14d","fromNode":"795690d5ce7e1c11","fromSide":"bottom","toNode":"9ed19d6e9980b34b","toSide":"top"},
		{"id":"ebcab486927cb5de","fromNode":"9ed19d6e9980b34b","fromSide":"right","toNode":"5cf8d16de6efff56","toSide":"left"},
		{"id":"6a0ae24e30667e00","fromNode":"665f35bd71acbb90","fromSide":"right","toNode":"981b264b7f7630c2","toSide":"left"},
		{"id":"7286f70c7c7e9e6f","fromNode":"981b264b7f7630c2","fromSide":"top","toNode":"c45a83a3705f7881","toSide":"bottom"},
		{"id":"9e27c5c48748361f","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"45a11294a8434cf8","toSide":"bottom"},
		{"id":"8af8a5f3e2ad1274","fromNode":"a569f47822207faf","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"4bc5fcb03b652768","fromNode":"4f9f693b64bc0e3f","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"a0745a8a10aa21ec","fromNode":"c45a83a3705f7881","fromSide":"bottom","toNode":"981b264b7f7630c2","toSide":"top"},
		{"id":"1c2152fd9676e1e4","fromNode":"c45a83a3705f7881","fromSide":"top","toNode":"305c16fa5fcbfca6","toSide":"bottom"},
		{"id":"7d0ac71b97316b5b","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"0e49609704fa8c9e","toSide":"bottom"},
		{"id":"feab48c838e8a738","fromNode":"0e49609704fa8c9e","fromSide":"top","toNode":"d7a25775f996e167","toSide":"bottom"},
		{"id":"4def83e52862fb08","fromNode":"665f35bd71acbb90","fromSide":"bottom","toNode":"1b501ca1023c98e0","toSide":"top"},
		{"id":"7b97b8d400a17d62","fromNode":"56958c816f8128f6","fromSide":"top","toNode":"d7a25775f996e167","toSide":"bottom"},
		{"id":"3d362e6251207397","fromNode":"349ec5026bac8b92","fromSide":"bottom","toNode":"2edbb402780f44c6","toSide":"top"},
		{"id":"a0084f53024ed26a","fromNode":"4df27d69ac9764ca","fromSide":"bottom","toNode":"1a0fe951bbf51b93","toSide":"top"},
		{"id":"ee61d1fcc7c2de03","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"f6c22dc935238119","toSide":"right"},
		{"id":"5edcd65f331c9876","fromNode":"1a0fe951bbf51b93","fromSide":"left","toNode":"472a39255272296f","toSide":"right"},
		{"id":"f14f75bb6f530e76","fromNode":"1bd86960d6e5a8e2","fromSide":"left","toNode":"4df27d69ac9764ca","toSide":"right"},
		{"id":"47a253347dc37b5d","fromNode":"1bd86960d6e5a8e2","fromSide":"bottom","toNode":"3881465ee755981e","toSide":"top"},
		{"id":"148209a19c204da7","fromNode":"179ce6b66f1a29fe","fromSide":"left","toNode":"349ec5026bac8b92","toSide":"right"},
		{"id":"5d939219c7bb9a7a","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"34401d45639b449d","toSide":"top"},
		{"id":"7db3cb5e783eb5a1","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"179ce6b66f1a29fe","toSide":"right"},
		{"id":"51f9edd90972a19b","fromNode":"0c876453e3807959","fromSide":"bottom","toNode":"010165be9fd56b6c","toSide":"top"},
		{"id":"f0bd2107ddee8ba5","fromNode":"3881465ee755981e","fromSide":"right","toNode":"010165be9fd56b6c","toSide":"left"},
		{"id":"121d6e0e6a0bbfac","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"9f731eac72823c6c","toSide":"left"},
		{"id":"cd673b03983e203e","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"8ca68ef0d9cba75a","toSide":"right"},
		{"id":"7dd2c2ef84da8b02","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"0719791a80c12eb2","toSide":"bottom"},
		{"id":"43fcfa35c628c802","fromNode":"0719791a80c12eb2","fromSide":"left","toNode":"d0bc31a12d2847f8","toSide":"right"}
	]
}