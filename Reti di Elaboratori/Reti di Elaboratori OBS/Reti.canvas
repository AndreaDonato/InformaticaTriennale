{
	"nodes":[
		{"id":"b72f299bae389d13","type":"text","text":"# Nodi\n\nSe le Reti sono grafi, cosa sono i nodi? Abbiamo due macro-categorie:\n\n- **_Nodi estremali_** (o **_sistemi terminali_**) - situati alle **periferie** della rete, sono le \"foglie\". C'è una distinzione interna tra\n\t- **_Host_** - tipicamente è il nome che si dà al dispositivo (dell') utente che vuole usare un servizio;\n\t- **_Server_** - tipicamente è il nome che si dà al dispositivo (spesso a elevate prestazioni) che offre servizi agli host.\n- **_Nodi di interconnessione_** - sostanzialmente dei ripetitori, che all'occorrenza possono modificare il segnale che vi transita (e.g. amplificazione, incremento di un counter per tenere traccia del passaggio). Una trasmissione senza modifiche è detta **trasparente**. Ulteriormente divisi in\n\t- **_Router_** - collegano tra loro più reti;\n\t- **_Switch_** - collegano tra loro più nodi estremali all'interno di una rete.\n","x":-4940,"y":638,"width":700,"height":448,"color":"4"},
		{"id":"4f9f693b64bc0e3f","type":"text","text":"# Glossario delle Reti\n\n- **_edge router_** - i router più periferici dell'Internet;\n- **_headend_** - termine generico che si riferisce a un nodo cruciale di una rete di telecomunicazioni, in cui convergono e vengono aggregati più segnali. Un edge router è un headend, ma se ad esempio vi sono molti cavi coassiali che vorrebbero entrarvi si può usare un **cable headend**, ovvero un dispositivo fisico che raggruppa le varie sorgenti per trasmetterle all'edge router;\n- **_access point_** - pezzetto di HW che funge da interfaccia tra il segnale Wi-Fi e il router;\n- **_Internet Service Provider_** (**_ISP_**) - riferito ad un'organizzazione di qualsiasi tipo (privata, no-profit, ...) che fornisce il servizio per l'accesso a Internet. Sono gestite da ISP\n\t- le **reti di accesso** ad Internet;\n\t- alcune infrastrutture che collegano più reti di accesso locali (**ISP regionale**)\n\t- le componenti del **nucleo di rete** a cui si connettono le reti di accesso e gli ISP regionali (**ISP globali**, o di **livello 1**)","x":-5752,"y":-220,"width":716,"height":740,"color":"4"},
		{"id":"795690d5ce7e1c11","type":"text","text":"# Link (Layer Fisico)\n\nI collegamenti fisici tra nodi possono essere realizzati in diversi modi.\n\n- **_Supporti guidati_** - I segnali si propagano in mezzi solidi (cavi). Esempi sono\n\t- **Doppino intrecciato** - due fili di rame isolati, uno per inviare i dati ed uno per riceverli (e.g. Ethernet, fino a 10 Gbps). Suscettibile a interferenze EM;\n\t- **Cavo coassiale** - due fili di rame concentrici, entrambi bidirezionali. Supporta i canali (**FDM**, $\\sim 100$ Mbps ciascuno), molto resistente alle  interferenze ma ad oggi soppiantato dalla fibra ottica;\n\t- **Fibra ottica** - fibra di vetro che sfrutta la riflessione totale interna della luce. Ogni fotone trasporta un singolo bit. Velocissimo ($v \\sim c$), basso rate di errore, ovviamente immune all'interferenza EM, costituisce la quasi totalità dei collegamenti nelle dorsali di Internet;\n- **_Propagazione libera_** - Spazia dal **Wi-Fi** domestico al **segnale satellitare**, e sfrutta lo spettro elettromagnetico con tutti gli ostacoli che ne conseguono (riflessione, attenuazione, interferenza). La potenza del segnale sferico decade come $1/r^2 \\Rightarrow$ molto forte nelle immediate vicinanze, molto debole poco dopo. Questo rende i link a propagazione libera dei canali **_half-duplex_** $\\Rightarrow$ chi riceve non può trasmettere a sua volta, perché con il forte segnale in uscita coprirebbe il segnale debole in entrata.","x":-4940,"y":1143,"width":700,"height":565,"color":"4"},
		{"id":"0c876453e3807959","type":"text","text":"# Pose e Coreografia\n\nHo un pacchetto con una destinazione. Devo avere chiare due cose:\n\n- Il percorso che seguirà nell'Internet attraverso i vari router, detto **_instradamento_** o **_routing_**. Definito da speciali **_algoritmi di instradamento_**, è un concetto **_globale_** (che riguarda cioè la rete nella sua interezza);\n- Il modo in cui il singolo router smista i pacchetti nel link corretto, ovvero la funzione interna che lega il segnale in ingresso a quello in uscita: internamente, ogni router ha una **_local forwarding table_** contenente le varie associazioni con i nodi adiacenti. Per scrivere le tabelle mi servono i percorsi. Viene detto **_commutazione_** (o **_forwarding_**, o **_switching_**).\n\nIn pratica, se il *forwarding* è la regola locale che definisce come si \"posiziona\" il singolo router, il *routing* è la \"coreografia\" globale risultante.","x":-3273,"y":1570,"width":700,"height":410,"color":"4"},
		{"id":"4958894e7197fe3c","type":"text","text":"# Rete\n\nInfrastruttura \"a grafo\" composta da dispositivi (_**nodi**_) che possono scambiarsi informazioni tramite dei collegamenti (**_link_**)","x":-3084,"y":1045,"width":323,"height":196,"color":"6"},
		{"id":"a569f47822207faf","type":"text","text":"# Struttura di Internet\n\nL'Internet può essere suddiviso con un criterio di \"profondità\".\n\n- **Periferia della rete** (**network edge**) - host e server;\n- **_Reti di accesso_** (**_access network_**) - tutto ciò che è connesso al router più periferico (**edge router**, ovvero il primo router che incontra il segnale partito da un host o da un server), a sua volta connesso con l'Internet. La connessione all'edge router può presentarsi in diversi gusti.\n\t- **Cavo** - Puro e semplice, non ci sono intermediari. Si collega insieme agli altri cavi della zona a un **cable headend**;\n\t- **Digital Subscriber Line** (**DSL**) - Sfrutta le linee telefoniche come cavi. Usa un **DSLAM** (**DSL Access Multiplexer**), uno specifico **headend** che smista il traffico internet e telefonico;\n\t- **Wireless LAN** (**WLAN**) - Mediato da un **access point** fisico che si interfaccia con il router domestico;\n\t- Rete cellulare;\n- **_Nucleo di Rete_** (**_dorsale_**, **_core_**, **_backbone_**) - questi termini vengono spesso usati in modo intercambiabile in quanto reti ad alta velocità che rappresentano la \"spina dorsale\" di Internet. In pratica, il nucleo di rete si occupa di collegare tra loro le reti di accesso (gestite da **ISP locali**). **NON** ciascuna di esse con tutte le altre (sono milioni e sarebbe $O(n^2)$), ma attraverso delle reti di più alto livello. ","x":-4940,"y":-220,"width":700,"height":740,"color":"4"},
		{"id":"c842e00522cec07d","type":"text","text":"## Velocità e latenze\n\n- DSL\n\t- Downstream: $24\\div52$ Mbps\n\t- Upstream: $3\\div16$ Mbps\n\t- Latenza: ?????\n- Ethernet\n\t- 100 Mbps, 1 Gbps, 10 Gbps\n- HFC\n\t- Downstream: $40\\div1200$ Mbps\n\t- Upstream: $30\\div100$ Mbps\n\t- Latenza: ???\n- Fibra\n- Microonde\n- Wi-Fi\n\t- Trasmissione: 11-54-450 Mbps\n\t- Latenza: ????\n- 4G\n- Satellite\n\t- Trasmissione: fino a $45$ Mbps\n\t-  latenza (end-end): $\\sim 270 ms$.","x":-5752,"y":1143,"width":716,"height":565,"color":"2"},
		{"id":"a3eaa4b44f0f3c44","type":"text","text":"# Giungla pseudo-gerarchica ISP\n\nQuello di ISP è quasi un concetto filosofico. Io che ti metto l'hotspot sono tanto ISP quanto lo è Fastweb. Circa. In realtà c'è una specie di gerarchia.\n\n- Io che metto l'hotspot sono considerabile un edge router che funge da ISP locale (livello 3);\n- Il mio telefono però ha a sua volta un ISP, stavolta regionale (livello 2, e.g. *Fastweb*). Questo ISP ha accordi alla pari (**_peer-to-peer_**) per comunicare con altri ISP regionali senza passare dal nucleo di Internet. Tuttavia può essere necessario raggiungere nodi che necessitano un passaggio per le dorsali, motivo per cui i *livello 2* **_pagano il transito_** ai *livello 1*;\n- In cima alla catena alimentare troviamo gli **_ISP globali_** (livello 1, e.g. *AT&T*), connessi tra loro tramite degli **_Internet Exchange Point_** (**_IXP_**);\n- Ultimamente vi sono entità (e.g. Google, Netflix) che non hanno tutta questa voglia di pagare gli ISP più grossi, motivo per cui costruiscono delle proprie _**reti dei content provider**_ a livello degli ISP globali riuscendo a bypassarli e ad offrire un servizio più efficiente ai consumatori.","x":-5752,"y":-880,"width":716,"height":497,"color":"4"},
		{"id":"44898ee22f42afdc","type":"text","text":"# Prestazioni","x":-1800,"y":1400,"width":240,"height":50,"color":"6"},
		{"id":"665f35bd71acbb90","type":"text","text":"# Forwarding","x":-1800,"y":1750,"width":240,"height":50,"color":"6"},
		{"id":"981b264b7f7630c2","type":"text","text":"# Store&Forward\n\nUn pacchetto deve raggiungere completamente il nodo destinazione prima che questo possa iniziare il processo di *forwarding* (**_store&forward_**).\n\nLa trasmissione però richiede tempo, quindi è possibile che arrivino più pacchetti di quanti il router ne riesce effettivamente a smistare.\nQuesto implica che deve avere un *buffer* in cui mettere in coda i pacchetti in attesa. Nel migliore dei casi questo mi genera un **_queuing delay_**, e nel peggiore, ovvero se il buffer si riempie, può verificarsi la **_perdita dei pacchetti_**.\n\nD'altronde, quando mando un pacchetto su Internet devo essere consapevole che nessuno mi potrà mai garantire il suo effettivo arrivo a destinazione.\n\nNotare che il primo bit di un pacchetto può arrivare a destinazione prima che questo sia stato completamente trasmesso dal router di partenza sul link!","x":-1280,"y":1570,"width":680,"height":410,"color":"4"},
		{"id":"c45a83a3705f7881","type":"text","text":"# Latenza\n\nIl tempo totale necessario ad un pacchetto per essere inviato completamente da un nodo origine ad un nodo destinatario è detto **_latenza_** o _**delay**_.\n\nSi può scrivere come somma di 4 contributi:\n\n- ***Delay di Queuing*** ($D_q$) - dato dal tempo di attesa in coda dovuto al meccanismo di **store&forward**, qui il pacchetto aspetta di essere processato. Difficile da stimare, divergente se il pacchetto si perde;\n- ***Delay di Elaborazione*** ($D_e$) - dato dalle operazioni interne effettuate dal nodo sul pacchetto (controllo errori, determinazione del link di uscita, ...), in genere trascurabile rispetto agli altri ($D_e \\lesssim\\mu s$);\n- ***Delay di Trasmissione*** ($D_t$) - il router deve caricare tutto il pacchetto di lunghezza $L$ sul link avente bit rate $R$ $\\Rightarrow$ ci mette un tempo $D_t = L/R$. Tipicamente è il termine dominante, nonché l'unico che dipende dalla lunghezza del pacchetto. Trasmettere un $L$ enorme su un $R$ basso fa da bottleneck per l'intero sistema;\n- ***Delay di Propagazione*** ($D_p$) - quanto ci mette il pacchetto a transitare sul link, e dipende esclusivamente dalle caratteristiche di quest'ultimo. Se è lungo $k$ e i bit si propagano a velocità $v$ serve un tempo $D_p = k/v$. In genere è indicato come tempo di propagazione dell'ultimo bit del pacchetto (non cambia nulla, è solo per ricordarsi che esiste la politica di *store&forward*).\n\nIn sintesi quelli fondamentali sono [trasmissione e propagazione](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/transmission-vs-propogation-delay/transmission-propagation-delay-ch1/index.html), e ogni router da cui passa il segnale (anche detto **_hop_**) introduce un termine dominante $L/R$.","x":-1280,"y":780,"width":680,"height":674,"color":"4"},
		{"id":"45a11294a8434cf8","type":"text","text":"# Glossario delle Prestazioni\n\n- **_trasmissione_** - il caricamento del pacchetto sul link da parte del router (\"modulare il segnale nel cavo\"). **_NON_** include la propagazione sul link.\n\t- Ogni link è caratterizzato da una **massima velocità di trasmissione** $R$ (*Rate*, misurato in bit/s), anche detta **_bit rate_** o **transmission rate**;\n- **_larghezza di banda_** (**_bandwidth_**) - si può usare per intendere\n\t- la larghezza dell'intervallo di frequenze utilizzate dal sistema trasmissivo ($Hz$);\n\t- il **bit rate** (bit/s), ad essa proporzionale.\n- **_throughput_** ($T$)- quantità di bit al secondo che passano a regime attraverso un generico punto della rete. Notare che è una misura di velocità effettiva, e che il suo massimo è il **bit rate** $\\Rightarrow$ è una misura effettiva di bit rate, e si effettua con un **_ping_**, ovvero un bit-sonda che mando avanti e indietro dal server che mi interessa;\n- **_bottleneck_** - quel collegamento che limita il throughput dell'intero percorso end-to-end;","x":-1940,"y":495,"width":520,"height":617,"color":"4"},
		{"id":"305c16fa5fcbfca6","type":"text","text":"# Teoria delle Code\n\nPer il Delay di Queuing c'è tutta una teoria (delle code) che calcola il ritardo medio in coda in funzione dell'intensità del traffico $La/R$ , dove $a$ è il rate di arrivo di pacchetti in coda.\n\nIn questo modo si trova che questo ritardo diverge già per un traffico $La/R = 1$ $\\Rightarrow$ il router non sopporta un rate di arrivo dei pacchetti identico al rate di smistamento ([vedere per credere!](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/queuing-loss-applet/index.html)).\n\nQuesto succede perché $a$ è un rate medio, e \"quando sono fortunato e me ne arrivano meno mentre la queue è vuota non posso anticiparmi il lavoro\".\n\nCredo in realtà succeda anche perché non sto considerando il micro-ritardo di processamento interno, che seppur trascurabile sul singolo pacchetto magari sulla coda fa effetto.","x":-1280,"y":285,"width":680,"height":420,"color":"3"},
		{"id":"0e49609704fa8c9e","type":"text","text":"# Gestire le Congestioni\n\nCosa succede se a un certo punto del percorso tra i router un pacchetto entra in un loop? Resta intrappolato all'infinito, sprecando banda? Sconveniente. Devo metterci un *cut-off* $\\Rightarrow$ introduco un **_Time To Live_** (**_TTL_**), in pratica un numero che viene decrementato a ogni router che incontra (e che quindi rappresenta quanti altri router possono inoltrarlo).\n\nQuando il TTL diventa 0 il pacchetto muore. In questi casi sarebbe buona educazione da parte del router mandare un feedback a chi glielo ha inviato (\"*hey, ti ricordi quel bellissimo pacchetto che mi avevi mandato? sì, ecco, è morto*\").\n\nConoscere il motivo della perdita di un pacchetto è fondamentale. Se ad esempio viene perso per traffico (e quindi per via di una coda piena) dovrei rallentare la trasmissione per evitare di perderne altri.\n\nIl protocollo TCP/IP, ad esempio, è in grado di capire se una perdita è causata dal traffico o da altri fattori.","x":-2540,"y":560,"width":540,"height":552,"color":"4"},
		{"id":"d7a25775f996e167","type":"text","text":"# Leak della struttura di rete (Latenza + TTL)\n\nScelgo una destinazione e mando pacchetti con un TTL sempre maggiore. Grazie al progressivo delay sono in grado di stimare il percorso end-to-end. \n\n... o quasi. Nessuno mi garantisce che ogni pacchetto seguirà sempre lo stesso percorso. Esistono però programmi diagnostici (e.g. **_traceroute_** su UNIX, o **_tracert_** su Windows) che restituiscono suddetti delay.\n\nNon c'è da stupirsi se a volte i router scelgono di non mandare feedback alla morte di un pacchetto per esaurimento del TTL.\nSe accetto il meccanismo dei TTL potrei far leakare la struttura interna della rete. ","x":-2540,"y":-20,"width":540,"height":440,"color":"#4545ff"},
		{"id":"9ed19d6e9980b34b","type":"text","text":"# Come invio i messaggi sui Link?\n\nHo sostanzialmente due modi per farlo.\n\n- **_Commutazione di Circuito_** - Letteralmente, creo un collegamento fisico riservato alla coppia sorgente-destinazione, sulla quale sono gli unici a poter comunicare (salvo collegamenti fisici alla linea da parte di terzi, dove i terzi sono verosimilmente i servizi segreti). Garantisce prestazioni stabili, e viene usato nelle linee telefoniche. Naturalmente si può fare anche senza dedicare un intero cavo al singolo canale di comunicazione:\n\t- **_Frequency Division Multiplexing_** (**_FDM_**) - Ogni cavo trasmette un certo range di frequenze EM. Allora le suddivido in N canali, e ad ognuno di questi assegno una certa larghezza di banda (che però sarà stretta);\n\t- **_Time Division Multiplexing_** (**_TDM_**) - Sostanzialmente tratto i canali come una *ready queue* e faccio *preemptive scheduling*. Entro il proprio intervallo di tempo assegnatogli, ogni canale trasmette avendo a disposizione la banda massima;\n- **_Commutazione di Pacchetto_** - Ogni messaggio viene suddiviso in **_pacchetti_**. La rete si occupa di instradare i singoli pacchetti e *tenta* di non fare casino. Interessante notare come nonostante possa fare casino in molti modi (e in effetti lo fa: li perde, sbaglia l'ordine di arrivo, li inoltra a terzi, ...) è il metodo più utilizzato su Internet. Ovviamente il motivo c'è: le comunicazioni sono spesso **_bursty_**, nel senso che gli host stanno *quasi* sempre zitti, tranne in singoli momenti isolati in cui vomitano un enorme messaggio da inviare. Non ha senso dedicare un circuito a una comunicazione in cui non succede *quasi* mai niente: blocco delle risorse che restano inutilizzate quando magari altri host rimasti tagliati fuori potrebbero comunicare il proprio messaggio *bursty*. Idealmente dovrei dare la sensazione all'host di avere una connessione dedicata, il che in parte si risolve aumentando la banda e in parte non si risolve perché ci stanno mille problemi.","x":-4940,"y":1761,"width":700,"height":780,"color":"4"},
		{"id":"deea8f39a16646e1","type":"text","text":"**Throughput Minimo Garantito**: Questo è come l'assicurazione che un servizio Internet ti dà. Supponiamo che tu stia giocando a un videogioco online e non vuoi che la connessione diventi troppo lenta. Il \"throughput minimo garantito\" è come la promessa dell'azienda che la tua connessione rimarrà almeno a una certa velocità. Quindi, anche se Internet diventa affollato, sei sicuro di avere almeno quella velocità per continuare a giocare senza problemi.","x":-1680,"y":-260,"width":546,"height":267},
		{"id":"f1e9ad03f9edbfdd","type":"text","text":"# Prova\n\n- a cambiare la dimensione dei pacchetti TCP/IP di un computer (impostazioni del SO? chissà)","x":-545,"y":1182,"width":420,"height":240,"color":"5"},
		{"id":"5b16a0a8827edeef","type":"text","text":"# Formulario (?)\n\n- Massimo numero di bit su un link - $R\\cdot D_p$\n- Avere un TDM (e.g. 10 slot/s) tipicamente in un esercizio significa che ad ogni host è associato uno solo degli slot indicati nel TDM (e.g. 1 slot/s).","x":-545,"y":1454,"width":422,"height":267,"color":"2"},
		{"id":"e98fee2b8eb0a179","type":"file","file":"0 - Stack Protocollare/RitardoMedioInCoda.png","x":-545,"y":285,"width":461,"height":420},
		{"id":"23227e82062b49bc","type":"text","text":"# Struttura delle Reti","x":-3964,"y":836,"width":340,"height":50,"color":"6"},
		{"id":"1ec4d0918042c205","type":"text","text":"# Tramissioni su Rete","x":-3968,"y":1401,"width":348,"height":50,"color":"6"},
		{"id":"5cf8d16de6efff56","type":"text","text":"# Commutazione di Pacchetto","x":-4028,"y":2125,"width":468,"height":50,"color":"6"},
		{"id":"1a0fe951bbf51b93","type":"text","text":"# Simmetrie tra le stack protocollari\n\nSe comunico voglio sia inviare che ricevere, quindi\n\n- ci sono almeno due stack, una per chi invia e una per chi riceve;\n- tutti gli host possono essere sia mittente che destinatario.\n\nDa questo segue che guardando le varie stack in **_orizzontale_** troviamo una **_simmetria logica_**, ovvero **protocolli omologhi** e **oggetti identici**.\n\nConcettualmente, il **_collegamento logico_** è tra layer di pari livello di tutte le stack, che parlano la stessa \"lingua\" $\\Rightarrow$ il layer $N$ di un dispositivo comunica virtualmente solo e soltanto con il layer $N$ degli altri dispositivi.\n\nL'effettivo **_flusso di informazione_** è però **_verticale_**, eccetto per il livello più basso che rappresenta lo spostamento fisico.\n\nLungo la propria stack, il mittente applica delle funzioni per incapsulare il messaggio (e.g. lo critta e lo mette in una scatola), questo viene fisicamente trasportato al nodo successivo dal livello più basso (e.g. il furgone delle poste) e infine il destinatario applica le funzioni inverse (in ordine inverso, perché stavolta il messaggio risale la stack) per riottenere il messaggio originale (e.g. apre la scatola e lo decritta). \n\nNel complesso, l'informazione \"scende\" e \"risale\" lungo le stack protocollari.\n","x":-4940,"y":2716,"width":700,"height":620,"color":"4"},
		{"id":"4df27d69ac9764ca","type":"text","text":"# What is stack protocollare?\n\nUn **_Protocollo_** definisce l’insieme di regole che mittente e destinatario (e tutti i sistemi intermedi coinvolti) devono rispettare per essere in grado di comunicare.\n\nSe ho una situazione complessa è comodo suddividere i compiti fra più livelli (detti **_layer_**, o *strati*) indipendenti, secondo il buon vecchio principio di modularità.\n\nAd ogni livello corrisponderà quindi (almeno) un \"sotto-Protocollo\" (inteso come modularizzazione del Protocollo che definisce l'intero scambio di messaggi) che da qui in poi chiamerò **_protocollo_** (già... fa ridere).\n\nPer realizzare il Protocollo abbiamo creato una stratificazione di protocolli detta **_layering di protocolli_** o **_stack protocollare_**.\n\nQuesto porta in generale diversi vantaggi:\n\n- Concettualmente è più chiaro cosa succede $\\Rightarrow$ è più facile costruire modelli;\n- L'aggiornamento e/o la sostituzione dei moduli è più semplice e trasparente (è ben chiaro cosa sto facendo, e dove), e non influisce sul resto del sistema.\n\nOgni layer _comunica in modo_ **_bidirezionale_** _con i livelli adiacenti_, realizzando coppie *provider-user*, in cui il primo offre al secondo un **_servizio_**.\n","x":-4940,"y":3376,"width":700,"height":584,"color":"4"},
		{"id":"472a39255272296f","type":"file","file":"0 - Stack Protocollare/Layering.png","x":-5736,"y":2716,"width":700,"height":380},
		{"id":"89560ca8221b899c","type":"text","text":"# Messaggio di Richiesta HTTP\n\n Inviato dal client al server, consta di tre parti:\n \n - ***Riga di richiesta*** - Una stringa avente sintassi `metodo URI versione_HTTP \\r \\n`, dove\n\t- `metodo` specifica *cosa* voglio fare;\n\t- `URI` specifica l'oggetto all'interno del server con cui voglio interagire;\n\t- `versione_HTTP` serve ad assicurarmi che parleremo la stessa lingua;\n\t- `\\r \\n`, caratteri di ritorno a capo e avanzamento riga, comunicano la fine della stringa di richiesta.\n- ***Intestazione (header)*** - Varie righe aventi sintassi `parametro: valore` che specificano informazioni utili alla richiesta;\n- ***Corpo (body)*** - Payload diretto al server, preceduto da una riga vuota. Tipicamente vuoto a sua volta, a meno che non si faccia una richiesta di upload (metodo POST).\n\t","x":-11985,"y":7956,"width":473,"height":580,"color":"4"},
		{"id":"a30868312d411d98","type":"text","text":"# Messaggio di Risposta HTTP\n\nRisposta del server al client, anche qui tre parti:\n\n- Riga di stato - Una stringa avente sintassi `versione_HTTP STATUS PHRASE \\r \\n`, dove\n\t- `versione_HTTP` serve ad assicurarmi che parleremo la stessa lingua;\n\t- `STATUS` è un codice che identifica l'esito della richiesta;\n\t- `PHRASE` è una breve descrizione testuale associata al codice `STATUS`.\n- ***Intestazione (header)*** - Varie righe aventi sintassi `parametro: valore` che specificano informazioni utili alla risposta;\n- ***Corpo (body)*** - L'effettivo contenuto della risposta. Spesso in caso di errore si tratta della stampa a schermo a caratteri cubitali del codice di errore.","x":-11437,"y":7956,"width":473,"height":580,"color":"4"},
		{"id":"55d3231875e83cc8","type":"text","text":"# Codici di Risposta\n\n\tSe sei un Server devi rispondere bene, altrimenti dall'altra parte non capiscono\nVi sono 5 categorie di codici `STATUS`, il cui significato è poi chiarito dalla `PHRASE`:\n\n- ***Codici 1xx*** - la risposta contiene solo informazioni.\n\t- `100 Continue` indica che il server è pronto a ricevere la richiesta del client;\n- ***Codici 2xx*** - l'operazione è andata a buon fine.\n\t- `200 OK` è la risposta che vorremmo ricevere sempre, e restituisce del contenuto;\n\t- `204 No Content` significa \"tutto bene, ma non ho niente da inviarti\", può succedere se ad esempio chiedo di salvare la pagina;\n- ***Codici 3xx*** - \"ho dovuto reindirizzare la richiesta che mi hai fatto\".\n\t- `301 Moved Permanently` significa esattamente \"quello che chiedi non è più qui, da adesso in poi reindirizzo tutte le tue richieste per questo oggetto al nuovo URI;\n- ***Codici 4xx*** - errore nella richiesta del client.\n\t- `400 Bad Request` significa \"non ho capito, ed è colpa tua\";\n\t- `403 Forbidden` è un \"non hai i permessi per chiedermi questa risorsa\";\n\t- `404 Not Found` è un \"la risorsa che chiedi non esiste su questo server\";\n- ***Codici 5xx*** - \"non ci sono riuscito, ma è colpa mia\".\n\t- `500 Internal Server Error` significa \"non so manco io che è successo\";\n\t- `503 Service Unavailable` indica che il server al momento non può gestire la richiesta, in pratica è un \"riprova più tardi\"\n\t- `505 HTTP Version Not Supported` significa \"no hablo tacos\".","x":-10855,"y":7956,"width":700,"height":1040,"color":"4"},
		{"id":"973215b7fd31a26a","type":"text","text":"### Esempio di GET\n```\nGET /page.html?parametro=valore HTTP/1.1\nHost: example.com\n```","x":-13000,"y":9096,"width":459,"height":160,"color":"4"},
		{"id":"ee9aa768d32eb89f","type":"text","text":"# Parametri delle query\n\nSebbene esistano parametri per diversi metodi, quelli che compaiono nell'URL sono comunemente associati al metodo GET.\n\nNon esiste una lista assoluta di parametri standard, poiché dipendono da come è scritto il singolo server.\n\nComplessivamente possiamo trovare parametri di\n\n- **ricerca o filtro** - specificano una query all'interno del server:\n\t`?q=termine_di_ricerca`\n\t`?categoria=notizie&anno=2022`\n- **ordinamento** - specificano l'ordine dei risultati restituiti dal server:\n\t`?ordine=asc&campo=data`\n- **paginazione** - specificano come vengono visualizzati i risultati della richiesta:\n\t`?pagina=2&per_pagina=10`\n- **autenticazione** - comunicano token di accesso e/o credenziali utente:\n\t`?token=abc123`\n- **localizzazione** - specificano la localizzazione e/o le preferenze linguistiche dell'utente:\n\t`?lingua=it_IT&paese=IT`\n\nChi crea il server può definire dei parametri personalizzati per trasmettere informazioni specifiche:\n\n\t ?parametro1=valore1&parametro2=valore2","x":-13000,"y":9307,"width":459,"height":904,"color":"4"},
		{"id":"ada1ce65a17b1ff7","type":"text","text":"### Esempio di POST\n```\nPOST /endpoint HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 25\n\nparametro1=valore1&parametro2=valore2\n```","x":-12444,"y":9096,"width":459,"height":301,"color":"4"},
		{"id":"be024ab3c20ae124","type":"text","text":"### Esempio di PUT\n```\nPUT /risorsa HTTP/1.1\nHost: example.com\nContent-Type: application/json\nContent-Length: 43\n\n{\"chiave\": \"valore\", \"altro\": \"dato da salvare\"}\n```","x":-12444,"y":9436,"width":459,"height":301,"color":"4"},
		{"id":"ff01e5961e252647","type":"text","text":"# Campi degli Header\n\n### Solo Client\n\n- **Accept** - Indica i tipi di contenuto che accetta come risposta;\n- **Accept-Charset** - Indica i set di caratteri che accetta come risposta;\n- **Accept-Encoding** - Indica le codifiche che accetta come risposta;\n- **Accept-Language** - Indica le lingue in cui accetta la risposta;\n- **Authorization** - Trasmette le credenziali di autenticazione;\n- **Cookie** - Invia i cookie al server.\n- **Host** - Specifica il nome dell'host e la relativa porta al quale è destinata la richiesta;\n- **If-Modified-Since**: Richiede la risorsa solo se è stata modificata dopo una data specificata;\n- **Upgrade** - Usato dal client per chiedere al server di cambiare il protocollo utilizzato;\n- **User-Agent** - Specifica al server il software utilizzato per inviare il messaggio HTTP;\n### Solo Server\n- **Last-Modified** - Indica la data e l'ora dell'ultima modifica alla risorsa;\n- **Expires** - Specifica la scadenza della risorsa ($\\Rightarrow$ quando non deve più essere considerata valida se trovata in cache);\n- **ETag** - Identificatore univoco per una specifica versione di una risorsa;\n- **Accept-Ranges** - Stai scaricando un file e ti salta la connessione. Devi riscaricarlo tutto? No, se questo valore è impostato a `bytes` puoi riprendere da dove ti eri interrotto! \n- **Location** - Reindirizza il client a una nuova locazione URL;\n- **Server** - Comunica al client il processo server che ha generato la risposta;\n- **Set-Cookie** - Invia cookie al client;\n### Sia Client che Server\n- **Cache-Control** - Specifica le istruzioni di caching;\n- **Connection** - Indica se a seguito del messaggio voglio chiudere la connessione (`close`, comportamento predefinito di HTTP/1.0) o se voglio mantenerla attiva (`keep-alive`, comportamento predefinito di HTTP/1.1); \n- **Content-Encoding** - Indica la codifica del corpo del messaggio;\n- **Content-Language** - Indica la lingua del corpo del messaggio;\n- **Content-Length** - Indica la lunghezza del messaggio nel body. Utile quando uso il metodo HEAD per capire quanto è grande il file che voglio scaricare;\n- **Content-Type** - Indica il tipo di contenuto presente nel body (INDICA ANCHE QUELLO RICHIESTO??? IN ESAME DICE QUESTO!!!);\n- **Date** - Specifica data e ora d'invio del messaggio;\n- **Keep-Alive** - Quando `Connection` è impostato su `keep-alive`, questo parametro specifica dopo quanto tempo il server chiuderà la connessione dopo l'ultimo messaggio inviato (`timeout=60` imposta la tolleranza a 1 minuto) oppure al raggiungimento di quale numero massimo di richieste (`max`);\n- **Server**: Usato dal server per identificarsi con il client.\n","x":-11875,"y":8656,"width":805,"height":1224,"color":"3"},
		{"id":"6ce8f85f78362603","type":"text","text":"# Metodi di Richiesta\n\n- ***GET*** - Richiede la risorsa `path` al server. Può essere usato per richiedere metadati o per far generare sul momento la risorsa di cui ho bisogno.\n\t- Lo stesso indirizzo IP con cui ho stabilito la connessione potrebbe contenere più domini, per cui sono obbligato a specificare il campo `host` dell'header;\n\t- Posso fornire al server ulteriori specifiche su *come* rispondermi aggiungendo `?` alla fine dell'`URI` e scrivendo ***parametri*** (nella forma `parametro=valore`) separati da `&` (e.g. `/page.html?categoria=notizie&anno=2022`);\n\t- Esiste una variante del GET, detto ***GET CONDIZIONALE***, per sfruttare il **_web caching_** $\\Rightarrow$ richiede la pagina al server solo se è stata modificata rispetto alla versione che conosce;\n\t- Il GET dovrebbe essere sempre una richiesta ***idempotente***, nel senso che due GET di fila dovrebbero produrre lo stesso risultato. Questo non è sempre vero, perché esistono parametri dinamici che possono modificare lo stato del server. Possiamo considerarla una vulnerabilità, potrei usarli per fare injection (e.g. SQL), cambiare le autorizzazioni o accedere a risorse riservate;\n- ***HEAD*** - Richiede l'header che verrebbe restituito a seguito di una richiesta GET. Usato principalmente nei controlli di validità della ***web cache*** (e.g. \"la pagina è stata modificata?\");\n- ***POST*** - Invia dati al server tramite il body. E come fa il server a sapere cosa fare con questi dati?\n\t- L'applicazione server definisce degli ***endpoint*** (in pratica degli URL), ovvero dei \"contenitori\" di richieste di azioni simili (e.g. `/crea`, `/aggiungi`, `/elimina`, ...);\n\t- Nella richiesta POST posso quindi specificare direttamente l'endpoint a cui è diretta (e.g. so di voler creare un file e so che il server usa l'endpoint `/crea`);\n\t- Se non conosco l'endpoint corretto posso indirizzare le richieste a un endpoint generico. A quel punto il server prova a capire cosa farci ($\\Rightarrow$ a quale endpoint mandarlo), magari anche interpretando il body (l'implementazione specifica sono fatti suoi);\n\t\t- Se non conosco neanche l'endpoint generico tocca cercare la documentazione, salvo avere voglia di fare trial-and-error: se specifico un endpoint che non esiste il server mi risponde 404;\n\t\t- Inviare deliberatamente un gran numero di richieste POST generiche per costringere il server ad un overhead di smistamento è considerabile un **attacco DoS**;\n\n- **_PUT_** - Invia nel body un intero documento da salvare nella locazione `URI`, sovrascrivendo qualsiasi cosa ci fosse prima. Ovviamente è un'operazione rischiosa, sta al server gestirla bene;\n- **_DELETE_** - Autoesplicativo;\n- ***PATCH*** - applica modifiche parziali a una risorsa.\n- **_COPY, MOVE_** - Copiano o spostano la risorse in una nuova locazione (anche un'altro server);\n- **_LOCK, UNLOCK_** - Primitive di sincronizzazione (come in un SO) (ESISTONO ??????);\n- **_OPTIONS, TRACE_** - Opzioni e diagnostica della connessione;\n- ***CONNECT*** - Stabilisce una connessione di tunnel (e.g. VPN).","x":-12907,"y":7956,"width":837,"height":1040,"color":"4"},
		{"id":"2edbb402780f44c6","type":"text","text":"# HTTP (Porta 80)\n\nParadigma **_richiesta-risposta (client-server)_** di tipo ***stateless*** basato su ***TCP*** che convenzionalmente utilizza la ***porta 80***.\n","x":-12762,"y":7716,"width":548,"height":160,"color":"6"},
		{"id":"8b3faa26de750a2c","type":"text","text":"# Protocollo HTTP","x":-11619,"y":7771,"width":290,"height":50,"color":"6"},
		{"id":"349ec5026bac8b92","type":"text","text":"# Protocolli Applicazione\n\nSono i protocolli di livello più alto, e ignorano completamente la complessità della rete (e.g. percorso dei pacchetti, reinvio in caso di perdita, ...).\n\nA ogni porta è convenzionalmente associato un protocollo, che definisce\n\n- le **_tipologie_** dei messaggi scambiati (e.g. richiesta, risposta, ...);\n- la **_sintassi_** del messaggio ($\\Rightarrow$ come va scritto, e.g. definisce i **campi**);\n- la **_semantica_** del messaggio ($\\Rightarrow$ cosa significa quello che scrivo secondo la sintassi);\n- le **_regole_** che devono rispettare mittente e destinatario per scambiarsi i messaggi (e.g. quanto aspettare tra un messaggio e l'altro, \"se cancello un messaggio qui va cancellato anche dall'altra parte\").\n\nTra i protocolli applicazione troviamo due macro-categorie:\n\n- **_open-source_** (e.g. HTTP), definiti con uno standard pubblico ([RFC](https://it.wikipedia.org/wiki/Request_for_Comments)). Paradossalmente questo aiuta a ridurre le vulnerabilità del protocollo, in quanto aumentano le persone che possono individuarle e conseguentemente correggerle. La condivisione del protocollo è in generale un principio ben noto in ambito sicurezza, e di norma i problemi di vulnerabilità in questi casi si riducono al tempo che intercorre tra il ritrovamento di un bug e il suo *fix*;\n- **_proprietari_** (e.g. Skype), più ottimizzati ma a volte meno efficienti (difficile trovare problemi con poca statistica).\n\n","x":-10856,"y":6005,"width":700,"height":1072,"color":"4"},
		{"id":"ea111d8cb579b650","type":"text","text":"# Paradigmi di Comunicazione\n\nUn **_paradigma di comunicazione_** è uno schema secondo cui avvengono lo scambio di informazioni e la gestione delle connessioni all'interno di una rete (tendenzialmente si implementa a livello di Internet).\n\nVi sono due paradigmi di comunicazione principali:\n\n- **_client-server_** - utilizzato da protocolli Applicazione quali HTTP, FTP e IMAP. I sistemi terminali vengono divisi in due categorie:\n\t- **_server_** - host sempre attivo ($\\Rightarrow$ **_sempre in ascolto_**) e con indirizzo IP permanente ($\\Rightarrow$ sempre identificabile nella rete). **_Fornisce servizi_** al client. Se si scollega non può esserci comunicazione, neanche tra client (in quanto si basano su percorsi di tipo client -> server -> client);\n\t- **_client_** - host che comunica solo e soltanto con un terminale di tipo server, a cui **_richiede servizi_**. Non è tenuto ad essere sempre attivo, né ad avere un IP fisso $\\Rightarrow$ non è tenuto ad essere reperibile (da chi, poi?);\n- **_peer-to-peer (p2p)_** - ogni host (*peer*, \"di egual importanza\") può essere sia client che server, richiedendo e fornendo servizi. Questo paradigma rende la rete estremamente **_scalabile_**, in quanto al crescere dei peer aumenta anche l'offerta di servizi. Più complesso da gestire, perché non ci sono indirizzi fissi e nessun peer è tenuto ad essere sempre in ascolto. Utilizzato tipicamente da protocolli legati alla condivisione di file.\n","x":-10856,"y":4181,"width":700,"height":610,"color":"4"},
		{"id":"aa2f1768f7663ebf","type":"text","text":"# Come?\n\nChi vuole avviare una comunicazione ha bisogno di far girare un **_processo client_**. Questo dovrà scegliere un canale di comunicazione virtuale, detto **_socket_** (o **identifier**, che puoi vedere come un'***interfaccia virtuale*** con il layer di Trasporto), una coppia di valori che rappresentano\n\n- **_indirizzo IP_**, che identifica univocamente da dove il client sta comunicando (e quindi dove inviare la risposta);\n- **_porta_**, un numero che convenzionalmente specifica con quale tipo di protocollo Applicazione standard *mi aspetto* di inviare e ricevere, ma che più in generale serve a identificare il ***socket***. Quello di porta è un concetto ***virtuale***.\n\nLa creazione del socket avviene tramite le API fornite dal livello di Trasporto.\n\nA questo punto la richiesta discende la stack protocollare del client e risale quella del **_destinatario_**, che per ricevere il messaggio a livello Applicazione deve essere **_già in ascolto_** sulla porta richiesta dal client. Questo si realizza tramite un **_processo server_**, che a sua volta per ascoltare ha creato un **_socket_**.\n\nIl che ci fa capire che in realtà quello che rompe il ghiaccio è il server. Costui runna il suo processo server mettendosi in ascolto, e si fa pubblicità (*\"Ciao a tutti, sono 6.6.6.6! Mandatemi pure un messaggio PAI (Protocollo che ho Appena Inventato) sulla porta 69!\"*). A questo punto il client sa a chi scrivere e su quale porta.\n\nLa coppia di socket definisce il **_canale di comunicazione_** $\\Rightarrow$ entrambi sanno a chi comunicare (IP) e come comunicare (porta). Stabilito il canale di comunicazione, i due processi usano uno schema di tipo **_message passing_**.\n\nO meglio, questo succede se uso TCP. A UDP non frega niente di creare canali di comunicazione. *\"Sei in ascolto? ... scherzo, non serve che tu lo sia, era una domanda retorica. Tieni questo pacchetto! Ciao!\"*. Sarà arrivato a destinazione?","x":-10856,"y":3340,"width":700,"height":797,"color":"4"},
		{"id":"40ee9c3447f7fb82","type":"text","text":"# Trasferimento File","x":-12648,"y":7047,"width":319,"height":60,"color":"6"},
		{"id":"acea343615dea605","type":"text","text":"# Protocolli Applicazione","x":-12681,"y":6508,"width":386,"height":66,"color":"6"},
		{"id":"877a13b60a49c414","type":"text","text":"# Posta Elettronica (Porta 25)\n\nSchema per scambio di messaggi tra server basato su ***TCP*** che usa tre protocolli: ***SMTP*** per il *push*, ***POP*** e ***IMAP*** per il *pull*.","x":-11605,"y":5648,"width":548,"height":160,"color":"6"},
		{"id":"a13ba86d0881bc3c","type":"text","text":"# Evoluzione del protocollo HTTP\n\nIl prototipo di ***Hypertext Transfer Protocol***, ***HTTP/0.9***, nasce nel 1991 con il World Wide Web. Si trattava di un protocollo scarno, in cui esisteva solo il metodo GET con pochi parametri.\n\nNella sua prima versione ufficiale _**HTTP/1.0**_ ([RFC 1945](https://www.rfc-editor.org/rfc/pdfrfc/rfc1945.txt.pdf), 1996) era prevista una connessione di tipo ***non-persistente*** (si apre il canale TCP, si invia uno e un solo oggetto, si chiude il canale TCP).\n\nIl problema ovvio è che per richiedere $N$ oggetti devo aprire e chiudere $N$ connessioni, ognuna delle quali deve fare *handshaking* sprecando un RTT. \n\nAllora i browser dissero \"abbiamo la soluzione! mandiamo $N$ richieste TCP in parallelo!\". Bello, ma TCP non è pensato per una cosa del genere, e questa pratica congestiona la rete.\n\nLa vera soluzione la porta **_HTTP/1.1_** ([RFC 2616](https://www.rfc-editor.org/rfc/pdfrfc/rfc2616.txt.pdf), 1999), lasciando la connessione aperta e introducendo introducendo i GET in successione (può essere visto come una forma di **multiplexing**, essendo più informazioni su singolo canale che vengono poi smistate dal server).\n\nQuesto mitiga il problema, ma non lo risolve del tutto. Una pagina web è un contenitore di elementi \"grandi\" e \"piccoli\", i quali vengono richiesti al server, che gestisce le richieste GET secondo l'ordine di arrivo (FCFS), motivo per cui\n\n- Un oggetto piccolo può ritrovarsi dietro oggetti grandi, facendo schizzare alle stelle l'*average waiting time* $\\Rightarrow$ **blocco head-of-line (HOL)**;\n- Per come è scritto TCP, se perdo anche un solo pacchetto dell'oggetto grande perdo un sacco di tempo prima di ritrasmetterlo $\\Rightarrow$ l'attesa media cresce ancora.\n\nQuesto problema viene risolto da ***HTTP/2*** (**RFC 7540, 2015**) \"spezzettando\" ogni richiesta/risposta in **frame** e costruendo una **pipeline** (migliora quindi il multiplexing di HTTP/1.1, trasmettendo più oggetti contemporaneamente).\n\nInclude anche migliorie generali al protocollo:\n\n- ***server push*** - cerca di fare prediction e inviarti cose che non hai ancora richiesto, potenzialmente riducendo il numero di richieste. In teoria questi elementi non vengono eseguiti se non richiesti, ma potrebbero restare salvati in una qualche cache;\n- ***priorità*** - consente di assegnare una priorità alle richieste;\n- ***compressione degli header*** - riduce l'overhead di trasferimento.\n\nResta ancora un problema. TCP assume che ogni client instauri una e una sola connessione, e gestisce il sovraccarico di rete e l'affidabilità dando questo per scontato. In pratica, è un protocollo basato su grandi oggetti e su pochi flussi (connessioni), mentre Internet di fatto funziona al contrario.\n\nNasce quindi l'idea di spostare HTTP su UDP sfruttando ***QUIC*** (**Quick UDP Internet Connections**), un protocollo di trasporto sviluppato da ***Google***. Questo protocollo, chiamato ***HTTP/3*** ([RFC 9914](https://www.rfc-editor.org/rfc/rfc9114.html), 2022), al momento in cui scrivo è in fase di sviluppo e sperimentazione.\n\n\tOnce a client knows that an HTTP/3 server exists at a certain endpoint, it opens a QUIC connection. QUIC provides protocol negotiation, stream-based multiplexing, and flow control.","x":-14838,"y":7956,"width":700,"height":1395,"color":"4"},
		{"id":"6694e27578406638","type":"text","text":"# Ma essere stateless è un problema!\n\n- **Autenticazione** - Faccio una richiesta mandando username e password. Il server mi dice `200 OK`, ma alla richiesta successiva non sa che sono io (`chi siete? cosa portate? un fiorino!`);\n- **Sessione** - Non posso memorizzare le preferenze sui siti;\n- **Lock** - Voglio fare due modifiche consecutive un oggetto, e non accetto che ne venga fatta una sola o che qualcuno usi l'oggetto tra una modifica e l'altra. Usando un protocollo *stateful* posso usare un *lock* fino a fine operazioni, ma HTTP non sa chi sono (`chi l'ha messo quel lucchetto? Boh vabbè, per me resta così`);","x":-13980,"y":8251,"width":837,"height":280,"color":"4"},
		{"id":"f99413b00ff804a3","type":"text","text":"# Una possibile soluzione: i Cookies di Sessione\n\nSono costretto ad usare qualcosa di esterno al protocollo che tenga traccia dello stato del client, e si chiama ***cookie***.\n- All'apertura di una connessione, il server riceve una prima richiesta senza cookie;\n- Al server non piace non sapere chi sei, quindi quando manda la prima risposta riempie il campo `set-cookie` dell'header con un valore che identifica univocamente l'utente (e.g. `1678`);\n- Il client riceve il cookie come stringa (e.g. `set-cookie: nome-cookie=1678; Max-Age=3600; Domain=example.com`), e sta a lui manipolarla per estrarne i dati. Tipicamente il browser si crea un file (e.g. `.txt`) che mantiene in RAM e che usa come riferimento per le richieste successive;\n- Quando invia una nuova richiesta, il client include nel campo `Cookie` dell'header le informazioni di cui è in possesso;\n- Adesso il server saprà con chi sta parlando e agirà di conseguenza fino alla scadenza del cookie, al termine della quale il client si ritroverà stampato a schermo `session expired`.\n\n**Il singolo cookie è associato a uno specifico dominio del server**, e vale solo per quest'ultimo. Si possono specificare ulteriori domini di validità del cookie nel campo `Domain`(e.g. `Domain=.eg.com` rende il cookie valido per tutti i sottodomini di tipo `subdomain.eg.com`).","x":-13980,"y":8576,"width":837,"height":520,"color":"4"},
		{"id":"2661b4a7e85defac","type":"text","text":"# Perché lasciare aperta una connessione TCP (HTTP 1.1) non è banale a livello implementativo?\n\nLasciare aperta una connessione TCP, come previsto dal protocollo HTTP/1.1, non è banale a livello implementativo per diversi motivi:\n\n1. **Gestione delle risorse del server**: Ogni connessione TCP aperta richiede risorse da parte del server, come memoria e capacità di elaborazione. Mantenere molte connessioni aperte contemporaneamente può esaurire rapidamente le risorse del server, riducendo le prestazioni complessive del sistema.\n    \n2. **Gestione dello stato della connessione**: Quando una connessione TCP rimane aperta, il server deve mantenere uno stato associato a quella connessione, che include informazioni sullo stato della sessione, i dati in sospeso e altre informazioni di controllo. Gestire lo stato di molte connessioni aperte contemporaneamente può diventare complesso e richiedere una gestione accurata delle risorse.\n    \n3. **Rischio di esaurimento delle risorse**: Se non gestite correttamente, le connessioni TCP aperte possono portare all'esaurimento delle risorse del server, che può causare degrado delle prestazioni o addirittura un blocco completo del server.\n    \n4. **Potenziali problemi di sicurezza**: Le connessioni TCP aperte possono essere soggette a attacchi come attacchi di tipo DoS (Denial of Service) o DDoS (Distributed Denial of Service), che sfruttano la disponibilità delle connessioni per sovraccaricare o saturare il server.\n    \n5. **Complessità dell'implementazione del pooling delle connessioni**: Per mitigare i problemi sopra menzionati, è comune utilizzare meccanismi di pooling delle connessioni, che consentono di riutilizzare le connessioni TCP esistenti anziché aprirne continuamente di nuove. Tuttavia, la corretta implementazione di un pool di connessioni può essere complessa e richiedere una gestione accurata delle risorse e dei timeout.\n    \n\nIn sintesi, sebbene mantenere aperte le connessioni TCP possa offrire vantaggi come tempi di risposta più rapidi e una maggiore efficienza complessiva della comunicazione client-server, è necessario affrontare diverse sfide implementative e gestionali per farlo in modo sicuro ed efficiente.","x":-16680,"y":8135,"width":848,"height":817,"color":"#641e32"},
		{"id":"c25570b5d51372e2","type":"file","file":"5 - Applicazione/HTTP/HTTP_1.0.png","x":-15541,"y":7991,"width":460,"height":411},
		{"id":"04b979f48c716c0b","type":"file","file":"5 - Applicazione/HTTP/HTTP_2.0.png","x":-15660,"y":8952,"width":698,"height":313},
		{"id":"77ddaf1188c7b900","type":"file","file":"5 - Applicazione/HTTP/HTTP_1.1.png","x":-15660,"y":8494,"width":698,"height":319},
		{"id":"dab2f7463a1544fc","type":"text","text":"# Cookies Traccianti\n\nCi sono siti che si ricordano chi sei anche quando riavvii il computer. Ma il browser non si limita a salvare i cookie in RAM? Non proprio. A seconda della sua implementazione interna può decidere di salvarli su disco (e.g. se mi arriva un cookie che scade tra una settimana forse ha senso conservarlo).\n\nOra, è chiaro che mi va bene non dover loggare su Steam ogni volta che riavvio il computer. Infatti, finché questi ***cookies persistenti*** sono solo quelli del server con cui sto parlando non c'è problema.\n\nNon va più bene se oltre ai suoi cookies il server mi manda quelli di altri server che non contatto direttamente (***cookies di terze parti***), che permettono a gruppi di server di tracciare le attività del client.","x":-14031,"y":9176,"width":420,"height":568,"color":"4"},
		{"id":"431962e65465019d","type":"text","text":"# Sicurezza\n\nE se intercetto un cookie di sessione? In linea di principio posso impersonare un client regolarmente loggato pur non avendo alcuna password.\n\nIn pratica ci sono diverse forme di difesa:\n\n- Utilizzare il flag `Secure`, che consente lo scambio del cookie solo con ***HTTPS***;\n- Utilizzare il flag `HttpOnly`, che impedisce al codice ***Javascript*** di accedere al contenuto del cookie tramite l'API `document.cookie`;\n- Settare il parametro `SameSite` al valore `Strict` consente l'invio del cookie solo e soltanto al server che l'ha creato.\n\nChe c'entra Javascript?\n\nIl cookie è in generale un contenitore di informazioni i cui campi sono inizialmente stabiliti dal server che lo crea, ma il Javascript ($\\Rightarrow$ il server fa girare codice sul client) può aggiungerne e riempirli con le informazioni del client. Segue che il cookie può trasformarsi in una vera e propria ***fingerprint*** contenente informazioni come font, risoluzione dello schermo, latenza e preferenze sui siti che visito, e che il server può rivendere a gruppi di server interessati a tracciare un profilo dei miei gusti (e.g. siti di e-commerce).\n\n\tSi possono mascherare queste informazioni, ma dall'altra parte possono accorgersi che tu mascheri, quindi attiri l'attenzione. L'unico metodo funzionante è disabilitare Javascript\n","x":-13520,"y":9176,"width":420,"height":1035,"color":"#4545ff"},
		{"id":"beb0fa9d0cb9609a","type":"text","text":"### Cross-Site Scripting (XSS)\n\nSei su un forum, e un tizio senza foto profilo posta un link. Tu lo apri, sembra un sito tranquillo, interagisci ed esci. Fine.\n\nO almeno, questo è quello che vedi tu.\n\nCiò che succede è che in qualsiasi punto (URL compreso, in questo caso hai perso anche solo cliccando sul link) di questo *nuovo sito* (*Cross-Site*) potrebbe esserci *codice Javascript* (*scripting*) malevolo.\n\n\"Vabbè, ma cosa potrà mai fare il Javascript\".\n\n- Leggere e/o modificare la zona di memoria del browser (e quindi credenziali d'accesso, cookies, ...);\n- Inviare richieste web, come scaricare contenuto o inviare informazioni a un server malevolo;\n- Sfruttare vulnerabilità del browser per accedere al filesystem locale del client.","x":-14031,"y":9791,"width":420,"height":612,"color":"#4545ff"},
		{"id":"51c10dffbde894c3","type":"text","text":"Un attacco Canvas, anche noto come Canvas Fingerprinting, è una tecnica di tracciamento utilizzata dai siti web per identificare univocamente gli utenti visitatori basandosi sulle caratteristiche grafiche del loro browser e del loro dispositivo. Questa tecnica sfrutta l'elemento HTML5 Canvas, che consente ai browser di disegnare grafica dinamica e manipolare immagini utilizzando JavaScript.\n\nNell'attacco Canvas, il sito web genera un'immagine invisibile all'interno dell'elemento Canvas e utilizza JavaScript per manipolarne i pixel in modo specifico e univoco per ogni visita. Questa manipolazione dei pixel è sottoposta a un algoritmo che crea un \"fingerprint\" grafico univoco del dispositivo e del browser dell'utente, basato su caratteristiche come la precisione del colore, la profondità di bit, la risoluzione dello schermo e altre proprietà grafiche.\n\nIl fingerprint ottenuto attraverso l'attacco Canvas può essere utilizzato per tracciare gli utenti attraverso le loro visite a diversi siti web, anche se questi siti non condividono direttamente i dati di tracciamento. Questo perché il fingerprint grafico rimane costante anche quando l'utente visita diversi siti, consentendo ai tracker di profilare l'utente e seguire le sue attività online.\n\nGli attacchi Canvas sono considerati una minaccia alla privacy degli utenti, poiché consentono ai siti web di tracciare e profilare gli utenti senza il loro consenso esplicito. Tuttavia, le moderne tecnologie di privacy e sicurezza dei browser cercano di limitare l'efficacia di queste tecniche e offrono agli utenti opzioni per proteggere la propria privacy online, come il blocco dei fingerprinting e l'uso di estensioni anti-tracciamento.","x":-13520,"y":10237,"width":420,"height":1040},
		{"id":"8235584e2a6409b7","type":"text","text":"# HTTPS (Porta 443)\n\nA ognuna delle versioni di HTTP posso affiancare il layer di sicurezza SSL/TLS e chiamare il protocollo risultante HTTPS. In realtà posso farlo con tutti i protocolli Applicazione (e.g. FTPS, SSHS, ...), ma nessuno di loro è mainstream come HTTPS.","x":-14838,"y":7497,"width":700,"height":162,"color":"#4545ff"},
		{"id":"b42a1d8cb55878e0","type":"text","text":"# Proxy Server per Web Cache HTTP\n\nUn ***proxy server*** è in generale un intermediario tra un client e un server.  \n\nPosso usarlo per tante cose, tra le quali costruire una ***cache*** del \"vero\" server a cui è indirizzata la richiesta del client, mirando a **ridurre i tempi di risposta** e **alleggerire il traffico del server** di origine.\n\nIn che modo viene gestita questa web cache?\n\n- Il server distribuisce ai propri proxy delle copie dei dati, specificando per ognuno valori come `Last-Modified`, `ETag`, `TTL`, ...;\n- Quando il client fa una richiesta GET al proxy possono verificarsi due scenari:\n\t- ***cache miss*** - non ha il dato richiesto, si accolla il compito di recuperarlo con un GET dal server e se lo salva per eventuali richieste future.\n\t\t- Notare che il motivo per cui non ha il dato richiesto dipende dalle **politiche di gestione della cache**. Magari semplicemente non lo ha mai avuto, ma magari l'ha dovuto sacrificare perché aveva esaurito lo spazio. Come in tutte le cache, l'algoritmo che sceglie cosa rimuovere è fondamentale per l'ottimizzazione dei *cache hit*.\n\t- ***cache hit*** - ha il dato richiesto. Ma è aggiornato? Seguono esempi di **politiche di cache hit**:\n\t\t- il proxy non si pone nemmeno la domanda - \"`la copia che ho resta valida fino alla scadenza del TTL`\". Rischia di dare al client roba non aggiornata, ma non perde tempo;\n\t\t- il proxy manda una richiesta HEAD al server - è interessato al valore di `Last-Modified`:\n\t\t\t- se coincide con la propria copia, la congestione di rete tira un sospiro di sollievo. Il client un po' meno, perché per fare questo check serve comunque almeno un RTT;\n\t\t\t- se non coincide con la propria copia non solo ho già aspettato un RTT per l'HEAD, ma ora mi tocca aspettarne un altro per il GET (più il tempo di trasmissione!). In pratica è **peggio di un cache miss**!\n- A questo punto (e senza curarsi di quello che è successo internamente alla rete) il client è certo che il proxy gli fornirà il dato richiesto.\n\nNotare che in questo scenario anche nel caso migliore il proxy invia un file al client. Posso fare di meglio? Certamente, usando il ***GET condizionale***. Nella richiesta GET specifico una certa data e ora nel campo `If-Modified-Since`, intendendo \"dammi questo dato solo se è stato modificato rispetto alla versione indicata\". Dall'altra parte possono rispondere con\n\n- `304 Not Modified` - nessun payload in risposta;\n- `200 OK` - \"`è stato modificato, eccoti la versione più recente`\";\n- Eventuali codici di errore se il server non ha il dato.\n\nQuesto semplifica di parecchio lo schema di prima, sfrutta la cache del client e riduce ulteriormente i tempi di attesa, dal momento che il caso peggiore è il *cache miss*:\n\n- Il client manda un GET condizionale di un elemento che evidentemente ha in cache;\n- **cache miss** - \"`E che ne so? Chiedo al server usando un GET condizionale!`\";\n- **cache hit** - Se è aggiornato è finita, se non lo è ricadiamo nel cache miss. Uso il TTL per aggiornare periodicamente il contenuto della cache.","x":-13980,"y":6511,"width":837,"height":1148,"color":"#006400"},
		{"id":"acb4f16f12e3f2e9","type":"text","text":"# ... ma perché stateless?!\n\nSe TCP supporta lo storico, perché HTTP sceglie di non implementarlo?\n\n- Da qualche parte devo salvare (grandi quantità di) dati $\\Rightarrow$ mi serve altro spazio di archiviazione;\n- Client e Server devono in ogni momento concordare sullo storico, il che richiede sincronizzazione e causa problemi se un terminale crasha;\n- In generale, i protocolli non-stateless sono più complessi.","x":-13980,"y":7956,"width":837,"height":254,"color":"4"},
		{"id":"52edf2e6ee84f9b0","type":"text","text":"# P2P (cenni)\n\nvedi slides\n\nserve un sistema per coordinare il gruppo di peer. si può anche decentralizzare (database distribuito).\nI vicini sono scelti secondo criterio di download più veloce. potrei anche fare solo download (greedy), servono incentivi a condividere.\n\ndevo iniziare chiedendo lista dei blocchi e scaricando i pezzi di di file più rari. \"optimistic unchoke\" anche se non sei nella top 4 ti includo (altrimenti si scambiano dati solo i primi 4) (tutti questi numeri sono parametri modificabili)\n\ntesto randomicamente velocità dei vicini per vedere se è top, in caso ci accoppiamo e inizia il torrent\n\nnel protocollo non è richiesto che qualcuno abbia il file intero, così come potrei mettere a disposizione il file e poi scollegarmi a metà\n\nil protocollo aumenta la velocità di download secondo la disponibilità di upload\n\nskype era p2p, poi l'ha preso microsoft e hanno centralizzato e non ha funzionato bene fino al dimensionamento dei server.\n\nci sono modi per fare l'Internet decentralizzato, ogni oggetto è rappresentato in modo univoco tramite un oggetto hash e poi \"boh qualcuno ce lo avrà\"","x":-11691,"y":3340,"width":720,"height":1451},
		{"id":"aa76e477e11e779d","type":"text","text":"# SMTP, IMAP (posta elettronica)\n\n\nforse cronolgicamente prima di HTTP. slides. in teoria posso farlo p2p ma in quel caso devo essere acceso. allora uso il server (al tempo potevano anche essere spenti a tratti). quello di uscita poteva tenere le cose se il secondo non rispondeva. smtp è un protocollo di tipo push, serve a scrivere i messaggi. per il pull (leggere i messaggi) serve pop3 o imap. smtp è anche usato end-to-end tra server di posta (p2p), ma in mezzo ci sono i router e TCP. Posso creare io stesso un server di posta con smtp. porta 25 vedi slides per protocollo.\n\nConnessione tcp persistente fino al quit. server ha timeout lungo. 7bit (8 con primo bit 0). dopo fine messaggio (CRLF, ovvero semanticamente cr+lf) ne aspetta un altro a meno che non scrivo quit.\n\nintestazione stessa della mail (to, from, subject) ma non è SMTP. prima c'è handshaking con comandi helo, ...\n\nQuesto è solo ascii 8bit. per altri formati c'è un altro protocollo (MIME). Immagine convertita in ascii e poi riconvertita a destinazione.\nDi nuovo, i protocolli interni sono lenti a cambiare. piuttosto che modificare SMTP creo un altro protocollo a livello più alto.\n\nCome accedo alla posta? POP3 o IMAP, o addirittura HTTP se lo faccio da browser. non specifico quante connessioni apro.\n- POP3 porta 110 (slides), quando il client scarica i messaggi il server li cancella (posso non farlo togliendo comando dele). basta definire regole per comunicare. problemi: pensato per un solo client. se ne ho tanti devo sincronizzare tutto, ma è difficile senza stato. allora uso\n- IMAP, che tiene traccia dello stato (e.g. ci sono le cartelle tipo spam, i tag, ...), se faccio modifiche in locale viene aggiornata anche sugli altri client.\n- HTTP, l'agente è un browser\n\ninizialmente associavo mail ad ogni utente linux, ora no (?) (se uso postfix?) \"sono vago perché serve poco\".\n\nse uso thunderbird (IMAP) per mettere gmail (HTTP) posso trovare differenze in cose tipo la divisione in cartelle, i tag, ...\n\n\n\" a livello applicativo è abbastanza lasciato libero\"","x":-11691,"y":4937,"width":720,"height":596},
		{"id":"0efd970a1119442f","type":"text","text":"# FTP (Porte 20 e 21)\n\nParadigma ***client-server*** di tipo ***stateful*** basato su ***due connessioni TCP*** parallele:\n\n- **Connessione di Controllo (Porta 21)** - Resta sempre aperta (***persistente***), e viene usata per handshaking, autenticazione e scambio dei parametri della Connessione Dati (e.g. username e password, inizio e fine trasferimento dati, ...);\n- **Connessione Dati (Porta 20)** - Viene aperta dalla Connessione di Controllo ogniqualvolta sia necessario trasferire un file, e viene richiusa a trasmissione terminata (***non-persistente***).\n\nI parametri di controllo hanno una connessione dedicata e restano quindi separati dai dati. Questo schema è detto ***out-of-band***, e presenta diversi vantaggi:\n\n- per come è strutturato TCP è ottimale (poche connessioni, grandi quantità di dati);\n- posso abortire il download in caso di sovraccarico della rete;\n\t- protocolli in cui l'`abort` viene mandato nello stesso canale dei dati (**in-band**) come HTTP il segnale si perde nel traffico della rete.\n\nLato server, questo mantiene lo stato della connessione (directory di lavoro, autenticazione, ...) senza bisogno di cookies.\n\nRETR (retrieve)\n\nper il resto è simile a smtp, http.\n\n\nSFTP, FTPS","x":-11691,"y":6747,"width":720,"height":660,"color":"3"},
		{"id":"6bf7cded55aa9efd","type":"file","file":"5 - Applicazione/FTP.png","x":-12148,"y":7157,"width":400,"height":250},
		{"id":"bedf94234f8fbd9d","type":"text","text":"nel browser posso usare ftp (scrivendo `ftp:` al posto di `http:`).???????????????","x":-10925,"y":7236,"width":250,"height":171},
		{"id":"2c357555847a692e","type":"text","text":"# DNS Overview\n\nI siti web sono hostati su server aventi un certo indirizzo IP. Questi però sono **difficili da ricordare** (e.g. 174.252.76.196) e **possono variare** (e.g. il sito può essere spostato su un altro server).\n\nInfatti nessuno usa gli indirizzi IP. Apro il browser e nel campo URL scrivo `google.com`. Come fa la rete a conoscere la locazione del server che hosta il sito che cerco?\n\nCon un servizio di ***traduzione dei nomi*** (semplici e fissi, utilizzabili dagli umani) ***in indirizzi IP*** (complessi e variabili, utilizzati dalla rete per indirizzare i datagrammi), detto ***Domain Name System (DNS)***. In pratica è una ***tabella di corrispondenze***, inizialmente ([RFC 882](https://www.rfc-editor.org/rfc/rfc882), 1983) contenuta in un singolo file (con allegato un povero cristo che la aggiornava).\n\nIn generale, il server DNS è quello che \"sa a chi devi chiedere\", e se non è direttamente il server che hosta il sito che cerchi sarà un altro server DNS che probabilmente ha le informazioni di tuo interesse.\n\nOggi ([RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) ed [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035), 1987) è un DB hostato su più server (***distribuito***) avente struttura ad albero (***gerarchico***). Con DNS si può intendere sia il DB che il protocollo applicazione che fa da DMBS.\n\n","x":-13980,"y":5897,"width":837,"height":532,"color":"4"},
		{"id":"6efc85167597eec6","type":"text","text":"# DNS (Porta 53)\n\nServizio (***client-server***) di ***traduzione dei nomi in indirizzi IP*** implementato tramite ***DB delocalizzato*** che sfrutta principalmente ***UDP***.","x":-13835,"y":5648,"width":548,"height":160,"color":"6"},
		{"id":"0d69bbc0efaf38ce","type":"text","text":"# Gerarchia DNS\n\nConsideriamo l'URL `www.uniroma1.it.`. Sì, in teoria ci sarebbe un punto alla fine. Perché? In generale, ***il punto divide i livelli gerarchici***. Leggiamo questo indirizzo da destra verso sinistra.\n\n- ***Root nameserver*** - Il punto finale si riferisce alla ***radice dell'albero*** gerarchico del DB distribuito, il *punto* (no pun intended) da cui devo partire per trovare il server che mi interessa. Ma non ho ancora fatto alcuna richiesta DNS, come faccio a sapere il suo IP?\n\t- Anzitutto, il root nameserver non è uno solo. Ci sono ***13 indirizzi IP standard*** (10 in USA, 2 in Europa, 1 in Giappone), che vengono inclusi nelle distribuzioni dei SO. Possono variare, ma succede poco spesso. Ovviamente se variano sta a me distributore di SO starci attento;\n\t- Quindi a questi 13 IP standard trovo 13 copie del root nameserver? No! ***Ad ognuno di questi 13 indirizzi è associato un gran numero di copie del root nameserver*** (stavolta sono davvero server fisici), a ognuno dei quali corrisponde un IP. In pratica, i 13 IP standard fanno da \"switch\", e **reindirizzano la richiesta a una di queste copie fisiche** del root nameserver;\n\t\t- Il numero esatto di copie fisiche associato a ciascun IP standard è molto variabile, orientativamente si va **da poche decine a diverse centinaia**;\n\t- ... e ***non sono gli unici***, sono solo quelli standard! Copie del contenuto dei root nameserver standard lo si trova in vari server sparsi per il mondo, per ridurre la latenza e il carico sul singolo server.\n- ***Top Level Domain (TLD)*** -  Subito sotto al root troviamo il primo macro-raggruppamento (e.g. `.it.`, `.com.`, ...). In pratica ci sono (gruppi di) server che gestiscono principalmente (... lo vediamo dopo) `.it`, altri che gestiscono principalmente `.com`, e così via. Il root nameserver ha quindi il compito di indirizzare la richiesta al giusto TLD, il quale a sua volta reindirizza la richiesta al giusto server Autoritativo, oppure al giusto SLD;\n- ***Second-Level Domain (SLD)*** - I livelli di dominio sono la profondità dell'albero DNS. Una foglia può trovarsi a profondità 2, ma anche a profondità 3. In quest'ultimo caso troviamo anche gli SLD. E potenzialmente oltre, ma non è interessante a livello concettuale. In `it.wikipedia.org.` dopo il root `.` e il TLD `.org.`, `wikipedia.org.` è un SLD, ma manca ancora da risolvere il sottodominio `it.wikipedia.org.`. E chi lo risolve? L'Autoritativo!\n- ***Autoritativi*** - Server che hanno l'autorità di rispondere per un dato dominio, restituendone l'IP corretto. Sono in pratica le foglie dell'albero DNS.","x":-13980,"y":4737,"width":837,"height":842,"color":"4"},
		{"id":"2c547fef2c5dcf45","type":"text","text":"# Chi gestisce cosa?\n\n\nC'è tutta una questione di sicurezza, se si rompe il DNS si rompe tutto.\n\nICANN sono \"gentlemen agreement\" tra le varie nazioni. chi gestisce il TLD può fare quello che vuole (e.g. lo stato italiano può nazionalizzare il .it). Posso creare amazon.it e venderlo ad amazon.com? ... sì ma ci stanno le leggi sul copyright.\n\nogni organizzazione privata che mette a disposizione un server deve mettere a disposizione anche un dns server. in genere ce ne sono sempre due per protocollo (perché? boh!)\n","x":-13020,"y":4737,"width":460,"height":842},
		{"id":"ff62151f49666864","type":"text","text":"# Quanto conviene un proxy?\n\nDipende principalmente dal ***cache hit rate*** e ovviamente da quali sono i problemi da risolvere. In generale, è ottimo per la congestione di rete: sappiamo che se il traffico cresce troppo il ritardo medio in coda esplode, sgravare il server è sempre una buona idea.\n\nE perché non metto semplicemente dei cavi più grossi?\n\n- il proxy è *mediamente* più economico;\n- il proxy ha prestazioni *mediamente* migliori.\n\nMa *mediamente* è una roba teorica che in pratica significa \"sempre\"? No, **bisogna fare i conti**. Magari scopri che il cavo più grosso serve davvero. E comunque fare i conti non basta, perché sono una roba teorica e l'unico dato attendibile è la misura delle prestazioni. Il proxy è un'ottima soluzione ma non è la panacea di tutti i mali.\n\nSicuramente è indicativo che ISP come Netflix scelgano di hostare i film italiani su un proxy in Italia (\"magari non in Antartide\"). O magari su più proxy in Italia.\n\nUn buon proxy cerca di imparare cosa chiede la platea nella zona che deve servire.\n\n","x":-14838,"y":6882,"width":700,"height":560,"color":"4"},
		{"id":"0b031d2a05976038","type":"file","file":"5 - Applicazione/HTTP/proxy.png","x":-15490,"y":6935,"width":359,"height":454},
		{"id":"2a51de9d069e3b02","type":"file","file":"5 - Applicazione/DNS/GerarchiaDNS.png","x":-13980,"y":4497,"width":837,"height":191},
		{"id":"d9218fbe64e55603","type":"text","text":"# Prima query DNS\n\nIpotizziamo di cercare un sito appena creato (e.g. `gaia.cs.umass.edu.`), di cui nessuno sa niente se non l'Autoritativo corrispondente. Ho due modi di effettuare la ricerca.\n\n- ***Query Iterativa*** - Vado da `root`, il quale risponde \"ti dico dove sta `.edu`\". Vado da `.edu` (TLD), il quale risponde con l'indirizzo di `umass.edu`. Sicuramente è un SLD, se mi va bene è anche autoritativo. Dipende da cosa mi risponde. Nel peggiore dei casi mi risponde con l'IP di `cs.umass.edu`, il quale a questo punto dovrebbe essere Autoritativo, e in quanto tale avere gli indirizzi di tutti i sottodomini di tipo `*.cs.umass.edu.`;\n\t- Il **peso della ricerca** sta tutto **sul client**, o sul suo DNS locale;\n- ***Query Ricorsiva*** - Vado da `root`, chiedendogli con un'apposita flag di \"vedersela lui\" e darmi la risposta definitiva quando ha risolto. Lui prende in carico la mia richiesta e contatta il TLD, dicendogli la stessa cosa. In generale, ogni server contattato deve fare da sé, risolvendo personalmente la richiesta per conto di chi la fa.\n\t- Il **peso della ricerca** va **sulla rete**;\n\t- Sovraccarica `root`, motivo per cui non si dovrebbe fare;\n\t- Anche provandoci, ***probabilmente root risponderà iterativo***. Il protocollo **DNS non obbliga i nameserver a rispondere con la ricorsione**;\n\t- Se volevo la ricorsione e `root` mi risponde solo `.edu` allora la ricerca fallisce? No, semplicemente mi metto l'anima in pace e contatto `.edu`.","x":-14838,"y":3937,"width":700,"height":751,"color":"4"},
		{"id":"0bcac05d389026f2","type":"text","text":"# Query DNS","x":-14596,"y":5128,"width":216,"height":60,"color":"6"},
		{"id":"c2f115d30b383cd0","type":"text","text":"# Altri usi dei Proxy Server?\n\n- sicurezza\n- load balancing","x":-15661,"y":7418,"width":700,"height":320},
		{"id":"c242d9b28161dee6","type":"text","text":"localhost -> IP loopback solitamente `127.0.0.1`","x":-15911,"y":7003,"width":250,"height":171},
		{"id":"5b4a906a7f7134ec","type":"text","text":"\n***header***: insieme di campi che danno informazioni al destinatario. non fa parte dell'incapsulamento (leggo-distruggo-replace), ***payload*** del (parte del messaggio visto dal) livello sottostante, non cambia (resta leggibile","x":-18080,"y":6722,"width":250,"height":367},
		{"id":"807b9ea551e9eb4a","type":"text","text":"# DNS Locale\n\nIl client non si interfaccia direttamente con l'albero DNS, ma piuttosto usa un ***server DNS locale***.\n\nIn pratica, non serve partire ogni volta da `root`: il DNS locale potrebbe avere ciò che cerco in cache. Se così non è, si occupa di risolvere la ricerca al posto del client.\n\nPartendo da `root`? No, partendo dal basso! Non voglio sovraccaricarlo, quindi chiedo prima a SLD. Se non ne sa niente (ovvero, non ha quel valore in cache e non gestisce quei domini) risponde una roba tipo \"`boh!`\", e il DNS locale capisce che deve salire di livello, dal TLD. Se anche questo non sa niente ovviamente arrivo da `root`, dal quale sicuramente qualcosa trovo.\n\nBene, ma chi è il DNS locale?\n\n- La situazione più comune è che lo fornisca l'ISP tramite il primo accesso alla rete (hop). Nel caso domestico, il router (e.g. Fastweb `192.168.1.254`) reindirizza le richieste effettuate nella LAN al server DNS proprietario dell'ISP (e.g. Fastweb `85.18.200.200`);\n- In alternativa, posso impostarlo manualmente come parametro della connessione, specificando ad esempio `8.8.8.8` (nameserver offerto da Google);\n- Posso implementare un server DNS direttamente su `localhost`, ovvero il mio stesso computer (raggiungibile attraverso l'indirizzo IP loopback `127.0.0.1`)\n\nIl DNS locale ***non fa parte dell'albero gerarchico DNS***, piuttosto ***è un servizio*** per interagire con esso. Uno potrebbe allora chiedersi cosa ci guadagna ad avere un DNS locale.\n\n- Tu che lo usi hai una cache vicinissima, e ti fa comodo perché diminuisce la latenza. Inoltre, in sua assenza dovresti fare \"a mano\" con `localhost`, e scopriresti ti toccherebbe scrivere e runnare un sacco di roba;\n- La rete è contenta perché così decentralizza il DB DNS, sgravando i server \"standard\";\n- L'ISP che te lo offre apprende cosa cerchi, che nel dubbio male non le fa.\n","x":-16589,"y":3937,"width":806,"height":751,"color":"4"},
		{"id":"2cf0e73ceaebad33","type":"text","text":"# Cache DNS\n\nNel mondo reale i server hanno una ***cache***. Questo significa che già il root nameserver potrebbe rispondere subito con l'IP che mi interessa.\n\nLa garanzia che la risposta che mi arriva sia corretta me la dà solo l'Autoritativo associato a quell'IP. Un qualsiasi altro server che risponde al suo posto (e.g. `.com` mi restituisce l'IP di `uniroma.it`) è tenuto a specificare che non è l'Autoritativo per quell'IP (della serie, mette le mani avanti e ti dice che non è responsabile).\n\nQueste cache si aggiornano principalmente mediante ***TTL***, motivo per cui un server non-autoritativo può restituire una risposta obsoleta (anche ***DNS è best-effort***).\n\nLa durata dei TTL varia tipicamente tra i pochi minuti e i giorni/settimane, dipende molto dalle esigenze. Se ho fretta, esistono operazioni di *purge* (offerte dalla singola applicazione server e non incluse nel protocollo DNS) che permettono di svuotare manualmente le cache. Se mando un comando del genere lato client, i tempi tipici di propagazione di questa informazione sulla rete sono dell'ordine dei 5/10 minuti. Altrimenti, posso sempre settare un TTL molto breve (e.g. pochi secondi). In teoria potrebbe creare problemi all'intera rete, ma in genere regge bene.\n\nQuesto ovviamente senza contare che la cache potrebbe riempirsi, e gli oggetti al suo interno venire scartati prima della scadenza del TTL. Oppure potrebbe essere il server stesso ad avere come politica un timeout per gli oggetti in cache.\n\nAlla perdita di un dato cache, il DNS potrebbe richiederlo subito al livello superiore oppure attendere che venga richiesto lato client, dipende dall'implementazione.\n","x":-15659,"y":4825,"width":700,"height":667,"color":"#006400"},
		{"id":"84caca764ec7fb4e","type":"text","text":"# Server DNS","x":-15422,"y":5698,"width":223,"height":60,"color":"6"},
		{"id":"b99dcc266569a95d","type":"file","file":"5 - Applicazione/DNS/DNSRicorsivo.png","x":-15546,"y":4399,"width":475,"height":289},
		{"id":"4694cc6e9478ff73","type":"file","file":"5 - Applicazione/DNS/DNSIterativo.png","x":-15546,"y":3937,"width":475,"height":304},
		{"id":"d9194ed55437e184","type":"text","text":"# Registrar DNS\n\nSe voglio includere il mio sito (e.g. `cacciacapitale.it`) hostato sul mio personalissimo server nelle ricerche DNS devo fornire al ***registrar DNS*** gli indirizzi di due DNS Autoritativi per il mio dominio, detti **glue**, il quale li inserisce nel server TLD corrispondente (e.g. `.it`). Se il server non-autoritativo risponde con un oggetto in cache deve fornire anche i glue.\n\nIn alternativa posso pagare qualcuno che lo fa al posto mio. Spesso si fa per il mail server `MX` con un `CNAME` che punta a Cloudfare\n\n???????","x":-13980,"y":3937,"width":837,"height":391,"color":"3"},
		{"id":"a290001f0c2b618c","type":"text","text":"# PROVA NSLOOKUP!","x":-13771,"y":4357,"width":419,"height":90},
		{"id":"f10a4ae200557701","type":"text","text":"se voglio mat.uniroma1, phys.uniroma1, ... devo fornire diversi CNAME. se però faccio così mappo tutto su un unico server. utile perché se cambia cambio solo il canonico. ","x":-16600,"y":4857,"width":414,"height":257},
		{"id":"bbe47f0bdff82cd9","type":"text","text":"# Vedi ultime slides 08 NEW","x":-18080,"y":5397,"width":461,"height":163,"color":"1"},
		{"id":"a0476a2b8399dc67","type":"text","text":"# Cosa posso fare con DNS?\n\n- Aliasing -  hostname canonico è il \"vero\" nome, sotto al quale c'è l'ip, ma poi a questo collego gli alias. in questo modo se cambio ip lo cambio solo al nome canonico. Se cambio IP in teoria dovrei avvisare tutti i DB e cambiarlo, ma non succede. Ogni associazione ha un TTL che alla scadenza chiede al proprietario del dominio dove sta.\n- LOAD BALANCING: il sito viene sdoppiato su più server. Nel DNS li associo tutti e a chi lo chiede dò una lista random. qualunque metodo scelgo io richiedente resta random, a meno che non conosco il loro seed di randomizzazione.\n","x":-14838,"y":5897,"width":700,"height":405},
		{"id":"29e1d3a847d6212b","type":"file","file":"5 - Applicazione/DNS/RichiestaRispostaDNS.png","x":-14838,"y":6400,"width":699,"height":338},
		{"id":"06b8d6a48ee1e326","type":"text","text":"# Vincoli\n§ CNAME non può coesistere con altri record di altro tipo per lo stesso\ndominio: non posso avere un record A e un record CNAME per lo\nstesso (sub)dominio nella stessa tabella\n§ CNAME non può essere usato nei domini di root. Quindi il DNS\nserver di example.com NON può contenere:\nexample.com.\nCNAME\nalias.example.net.\n§ Se si tengono in cache valori di un server non di competenza,\nbisogna anche fornire il NS autoritativo quando rispondiamo a una\nquery\n§ Raccomandati\n• MX dovrebbe essere usato su un nome canonico e non un CNAME\n• quando si fornisce il NS di un server autoritativo, bisogna anche fornire il\nrecord A (glue) per evitare riferimenti circolari","x":-18940,"y":5237,"width":677,"height":530},
		{"id":"3c95ceb1f8d66d4b","type":"text","text":"# rappresentazione domini \n\nho due modi di rappresentare i domini\n- assoluti (rispetto alla root), in teoria terminano con un punto (e.g. google.com.)\n- relativi (alla locazione in cui sono), se sono connesso a di.uniroma1.it va a cercare in di.","x":-17161,"y":5198,"width":393,"height":354},
		{"id":"dadc08ce77ef0c49","type":"text","text":"dns potrebbe essere usato come controllo blocchi (dare not found per certi ip), però se chiedo a root bypassando il locale lo frego","x":-16932,"y":6077,"width":329,"height":144},
		{"id":"60429356d103493a","type":"text","text":"# DNS e Sicurezza\n\nIn genere a tutti conviene che DNS funzioni, motivo per cui gli attacchi (DDoS) diretti ai nameserver sono limitati. Anche provandoci, i `root` sono protetti dal filtraggio del traffico (gli altri server hanno la cache). Sui TLD è potenzialmente più pericoloso (?)\n\nQuello che si può invece fare è sfruttare DNS per azioni illecite. Come?\n\n- ***man-in-the-middle*** - intercetto le query DNS (e che ci faccio????);\n- ***poisoning*** - mando risposte sbagliate ai server DNS, che le mettono in cache. Questo potenzialmente mi permette di reindirizzare delle richieste safe sul mio sito malevolo;\n- ***DDoS***- posso inviare query DNS falsificando l'IP di origine (***spoofing***), indirizzando le risposte DNS a chi voglio io (***reflection***). Con una singola richiesta non risolvo niente, ma esiste l'opzione `ANY`, che fa rispondere il nameserver con tutti i record relativi al dominio richiesto (e.g. chiedo `example.com` e mi arrivano tutti i `.com` che ha????). Questi due ingredienti insieme mi permettono in linea di principio di cucinare un DDoS, ma\n\t- se un IP `100.x.x.x` manda una richiesta specificando come mittente `200.x.x.x`, la rete locale dovrebbe essere in grado di riconoscerlo (Chi??? Come???);\n\t- il nameserver può essere impostato per non rispondere a richieste di tipo `ANY`.","x":-16592,"y":5773,"width":806,"height":530,"color":"#4545ff"},
		{"id":"ad79665cff57c7f0","type":"text","text":"# UDP\n\ndns gira su udp perché evita il traffico e i vari handshaking di tcp.\n\nper dns non ha senso il concetto di connessione, perché è stateless.","x":-16036,"y":6378,"width":250,"height":383},
		{"id":"f4a58217f873b504","type":"text","text":"# Protocollo DNS\n\nQuery e risposte DNS hanno lo stesso formato.\n\n","x":-15659,"y":5897,"width":700,"height":532},
		{"id":"19dd5229975701ca","type":"text","text":"# User-friendliness?\n\nUna pagina web è composta da oggetti, ciascuno dei quali\npuò essere archiviato su un diverso server Web\n l'oggetto può essere un file HTML, un’immagine JPEG, applet\nJava, file audio,...\n la pagina web consiste in un file HTML di base che include\ndiversi oggetti referenziati, ciascuno indirizzabile da un URL,\nad es.\nwww.someschool.edu/someDept/pic.gif\n\nclient: browser che richiede, riceve\n(utilizzando il protocollo HTTP) e\n“visualizza” oggetti Web\n• server: il server Web invia\n(utilizzando il protocollo HTTP)\noggetti in risposta alle richieste","x":-10896,"y":5053,"width":700,"height":623},
		{"id":"2df2877d35b32cbf","type":"text","text":"# RDT 3.0 (Perdite)\n\nIn caso di perdita del pacchetto, il mittente aspetta un ACK che non arriverà mai. Come risolvo questo problema?\n\nAggiungo un ***timeout*** oltre il quale se non arriva risposta considero il pacchetto perso e ***reinvio il pacchetto***.\n\nOk, e se se il pacchetto non si fosse perso? Se l'ACK semplicemente arriva oltre il timeout, nessun problema: ho solo inviato un duplicato, che il destinatario scarterà in scioltezza grazie al numero di sequenza.\n\nQuesto mi consente di semplificare il protocollo: se assumo che il pacchetto è stato perso, posso ignorare il controllo degli errori $\\Rightarrow$ tratto stesso modo pacchetti persi e corrotti (\"se arriva un ACK corrotto lo ignoro, tanto scatterà il timer\"). Ci rimetto un po' in termini di tempo, ma è anche vero che riduco l'overhead sul mittente.\n\n\n","x":-3302,"y":10585,"width":520,"height":507,"color":"4"},
		{"id":"d336bdc958fc40a1","type":"file","file":"4 - Trasporto/RDT/RDT3.0.png","x":-3286,"y":11133,"width":488,"height":329},
		{"id":"133c092a1da3e3ae","type":"text","text":"# RDT 3.1 (Pipelining)\n\nL'unico problema di questa cosa è che ha prestazioni infime. Come risolvo? Faccio ***pipelining***, ovvero in pratica allargo il concetto di *stop-and-wait*: invece di mandare un pacchetto alla volta ne mando $N$.\n\nE il destinatario risponde con un ACK per ognuno? Ni. Posso anche usare il concetto di ***ACK cumulativo***. $ACK_n$ significa \"ho ricevuto tutti i pacchetti fino all'$n$-esimo\". Questo mi garantisce anche che siano ricevuti in ordine: se ricevo i pacchetti 1, 3, 4 rispondo sempre con $ACK_1$.\n\nSia mittente che destinatario hanno una ***finestra di buffer*** larga $N$. Se il mittente aveva una finestra larga 4 (diciamo pacchetti 1, 2, 3, 4) e riceve $ACK_1$, sposta la finestra di 1 più avanti (pacchetti 2, 3, 4, 5).","x":-2713,"y":10585,"width":519,"height":507,"color":"4"},
		{"id":"00cca53cff5a9684","type":"file","file":"4 - Trasporto/RDT/RDT2.2.png","x":-3914,"y":11133,"width":520,"height":329},
		{"id":"97af67201a182e72","type":"file","file":"4 - Trasporto/RDT/RDT2.0.png","x":-5094,"y":11297,"width":520,"height":165},
		{"id":"219387a67a5b2a86","type":"file","file":"4 - Trasporto/RDT/RDT2.1_Mittente.png","x":-4733,"y":10201,"width":444,"height":282},
		{"id":"2f558b72d21a3998","type":"file","file":"4 - Trasporto/RDT/RDT2.1_Destinatario.png","x":-4238,"y":10201,"width":494,"height":282},
		{"id":"2282be8cea1536dd","type":"text","text":"# RDT 2.0 (Bit Flip)\n\nRilassiamo la condizione di canale sottostante perfetto e assumiamo che possa flippare i bit del messaggio.\n\n**Se il pacchetto è danneggiato, il mittente deve inviarlo di nuovo**. Ma come fa a saperlo? In generale, le uniche informazioni in possesso degli host sono i pacchetti che ricevono, quindi ***assumendo che il destinatario sia in grado di rilevare gli errori*** (e.g. tramite un checksum) questo deve rispondere con l'esito del suo controllo.\n\n- ***Acknowledgement*** (***ACK***) - \"Non ho rilevato errori. Vai col prossimo\";\n- ***Negative Acknowledgement*** (***NAK***) - \"Ho rilevato errori. Puoi ripetere?\".\n\nPer il mittente serve un secondo stato: dopo aver mandato il pacchetto deve aspettare l'esito, e finché non lo riceve non può inviare altri pacchetti (***stop-and-wait***, $\\Lambda$ sta per \"nessuna azione da intraprendere se non il cambio di stato).\n\nOvviamente il NAK è una di quelle cose che potrebbe farmi entrare in un loop infinito, ma non posso farci niente!","x":-5094,"y":10585,"width":520,"height":667,"color":"4"},
		{"id":"10dba3310cd9aed8","type":"text","text":"# RDT 2.1 (ACK/NAK Corrotti)\n\nTutto questo ha un problema: ACK e NAK possono a loro volta essere corrotti. Se il mittente riceve un oggetto che non capisce potrebbe reinviare il pacchetto, ma così rischia di inviare un duplicato.\n\nCome risolvo? Ma chiaramente ***etichettando i pacchetti con un numero di sequenza***! E visto che faccio *stop-and-wait* (e che quindi devo solo distinguere \"quello prima\" da \"quello dopo\") mi basta un bit. In questo modo il destinatario che riceve due volte di fila un messaggio etichettato $1$ sa di doverlo scartare in quanto duplicato (\"*'sto scemo non ha capito che questo pacchetto mi è arrivato, mo je rimando l'$ACK_0$ e vediamo se stavolta capisce\"*).\n\nAspe, mando $ACK_0$ se voglio confermare la ricezione del pacchetto $1$? Sì. Per convenzione, **il numero dell'$ACK$ indica sempre il numero di sequenza del prossimo pacchetto atteso dal destinatario.**","x":-4511,"y":10585,"width":520,"height":667,"color":"4"},
		{"id":"976d5b3f569f713f","type":"text","text":"# RDT 2.2 (Solo con gli ACK)\n\nSe l'ACK ha un numero di sequenza esplicito il NAK è superfluo: se mando il pacchetto $n$ e mi arriva in risposta un $ACK_n$ (ovvero \"tutto chiaro! mandami il pacchetto $n$!\"), questo implicitamente significa $NAK_{n}$.\n\nQuando inviando il pacchetto $n$ riceverò in risposta $ACK_{n+1}$ saprò che il destinatario ha ricevuto correttamente il pacchetto $n$.\n\nNon avere i NAK complica leggermente la FSM ma semplifica concettualmente il protocollo (e.g. ***TCP***).","x":-3914,"y":10585,"width":520,"height":365,"color":"4"},
		{"id":"35bf718e7b0b1267","type":"text","text":"# Numeri di Porta\n\nNell'header di trasporto posso usare fino a 16bit per identificare il numero di porta, motivo per cui TCP e UDP possono usare valori nel range $[0, 65535]$.\n\n- ***Porte privilegiate*** ($[0, 1023]$) - riservate ai servizi di rete standard (e.g. 80 per HTTP, 22 per SSH, ...);\n- ***Porte registrate*** ($[1024, 49151]$) - possono essere utilizzate da applicazioni registrate presso l'Internet Assigned Numbers Authority (IANA).\n\t- Skype utilizza principalmente la porta 3478 con protocollo UDP;\n\t- MySQL usa la porta 3306 per connettersi al server in remoto;\n- ***Porte non registrate*** ($[49152, 65535]$) - hanno due utilizzi principali:\n\t- ***porte dinamiche*** - quando un processo client stabilisce una connessione TCP, questa viene identificata con un socket a quattro componenti: IP sorgente, porta sorgente, IP destinazione e porta destinazione. Visto che il mio interesse principale è identificare univocamente il canale, il SO assegna alla porta sorgente una porta dinamica casuale. Questo consente di creare più connessioni distinte alla stessa porta dello stesso server;\n\t- ***porte private*** - utilizzabili da applicazioni non registrate.\n\n... tutto questo è solo una ***convenzione***. Nulla mi vieta di configurare il mio server in modo che sulla porta 22 o 3306 ci sia il protocollo che voglio io.","x":-6122,"y":9760,"width":668,"height":623,"color":"4"},
		{"id":"1a7e522c18045e6d","type":"text","text":"# (De)multiplexing Protocollare\n\nSe al TCP del destinatario arriva un segmento, come fa a sapere a quale protocollo dell'Applicazione (e.g. HTTP, FTP, DNS, ...) consegnarlo?\n\nServe un codice identificativo standard da associare al messaggio. Potrei ad esempio dire che se nell'header TCP scrivo 80, allora il destinatario interpreterà di default il payload in arrivo come HTTP.\n\nQuesto numero, detto numero di ***porta***, consente di effettuare il ***multiplexing*** lato mittente: qualsiasi protocollo Applicazione può consegnare il proprio payload a TCP, e il segmento che quest'ultimo genera è sempre uguale ad eccezione del numero di porta. In pratica, TCP riunisce i diversi protocolli Applicazione in un'unica entità logica: il segmento TCP (e.g. non esistono il *segmento HTTP*, il *segmento DNS*, ...).\n\nA destinazione avviene il **_demultiplexing_**, ovvero a seconda del numero di porta il messaggio viene consegnato al giusto protocollo Applicazione (un'unica entità logica viene divisa in più canali, corrispondenti ai vari protocolli Applicazione).\n Il SO ha in genere una lista delle porte standard, ma posso creare un canale di comunicazione usando la porta che preferisco.\n \nNel caso di TCP si parla di **_(de)multiplexing protocollare_** (potremmo dire _logico_ o *virtuale*, in quanto avviene a livello software: le porte non sono entità fisiche, ma concetti virtuali), ed è associato principalmente al livello di Trasporto.","x":-6947,"y":9760,"width":700,"height":623,"color":"4"},
		{"id":"51014418878ce34a","type":"file","file":"4 - Trasporto/RDT/SchemaRDT.png","x":-6472,"y":10483,"width":451,"height":292},
		{"id":"fd5376187828d385","type":"text","text":"# Definizioni di RFC 2460 (IPv6)\n\n- node - a device that implements IPv6;\n- router - a node that forwards IPv6 packets not explicitly addressed to itself;\n- host - any node that is not a router.","x":-5752,"y":769,"width":716,"height":186,"color":"4"},
		{"id":"bd9ffece9b4d9aa9","type":"text","text":"# Record DNS\n\nCome ogni DB, anche DNS ha un formato standard per i record: `(name, value, type, ttl)`.\nIl valore dominante è `type`, al variare del quale gli altri valori cambiano di significato.\n\n- `type = A` - un record di tipo ***address*** associa il campo `A_name` all'IP corrispondente (nel campo `A_value`). Intuitivamente, è lo step finale della ricerca DNS: se trovo questo ho vinto;\n- `type = NS` - un record di tipo ***name server*** è un reindirizzamento ad un altro server DNS. Se trovo questo, il server mi sta dicendo una cosa del tipo \"se stai cercando il dominio `NS_name`, dovresti chiedere al nameserver `NS_value`\". Verosimilmente, oltre a questo mi darà anche un record di tipo address il cui campo `A_name` è il nameserver a cui chiedere (`NS_value`) e il cui campo `A_value` è il suo indirizzo IP;\n- `type = CNAME` - un record di tipo ***alias*** mi dice che \"in nome `CNAME_value` che mi hai dato è un nickname, quello che cerchi in realtà si chiama `CNAME_value`\";\n\t- Il \"vero\" nome del server è detto ***nome canonico***; \n\t- Un alias fa puntare più sottodomini allo stesso server (gestisco solo il nome canonico);\n\t- Un `CNAME` può puntare ad un altro `CNAME`, ma sarebbe buona norma evitarlo;\n- `type = MX` - un record che associa un dominio al ***mail server*** associato ($\\Rightarrow$ il server che gestisce SMTP). Dovrebbe essere sempre usato su un nome canonico (??????????)","x":-16592,"y":5200,"width":806,"height":530,"color":"3"},
		{"id":"587ced46e42595c9","type":"text","text":"# RDT 1.0 (Canale Perfetto)\n\nPartiamo dall'ipotesi ideale che il canale fisico sottostante sia completamente affidabile: il mittente invia il messaggio con una primitiva del protocollo RDT 1.0, e il destinatario lo riceve con un'altra primitiva.\n\nPossiamo descrivere mittente e destinatario tramite ***macchina a stati finiti*** (***FSM***, utile anche per dimostrare matematicamente proprietà e teoremi). In questo caso, per entrambi esiste solo lo stato di attesa:\n\n- per il mittente, che l'Applicazione gli consegni un messaggio da inviare;\n- per il destinatario, che la Rete gli consegni un datagramma da consegnare all'Applicazione.\n\nSegue che il protocollo è sostanzialmente diviso in due, in modo ***asimmetrico*** (invio e ricezione) $\\Rightarrow$ il canale perfetto è di per sé ***unidirezionale***: se lo voglio bidirezionale sono costretto ad implementare due (oppure a fare [Piggybacking](https://it.wikipedia.org/wiki/Piggybacking)).","x":-5731,"y":10740,"width":551,"height":557,"color":"4"},
		{"id":"fb29b2016fb66f0d","type":"text","text":"# Trasferimento Affidabile\n\nOvvero, come implementare un protocollo affidabile (cioè in grado di rimediare a perdita, disordinamento e corruzione dei pacchetti) su un canale fisico inaffidabile.\n\nUtilizzando un ***UDT*** (***Unreliable Data Transfer***), si prova a costruire un ***Reliable Data Transfer*** (***RDT***).","x":-6472,"y":10883,"width":451,"height":272,"color":"6"},
		{"id":"80ad7be144c324b7","type":"file","file":"4 - Trasporto/RDT/RecapRDT.png","x":-3242,"y":10111,"width":400,"height":120},
		{"id":"ea742b05a7119ace","type":"file","file":"4 - Trasporto/TCP/Congestione/ScenarioCongestione.png","x":-5090,"y":11700,"width":520,"height":222},
		{"id":"0b291757625d92c0","type":"text","text":"# Throughput effettivo\n\nRispetto ad una situazione priva di congestione, più gli host vanno veloci più $\\lambda_{out}$ cala rispetto a $\\lambda_{in}$.\n\n- Un primo calo rispetto a $\\lambda_{out} = \\lambda_{in}$ è dovuto al fatto che si aggiungono i dati ritrasmessi perché effettivamente persi;\n- Un secondo calo è dovuto al reinvio di dati che non si erano persi (e.g. l'ACK ci ha messo più tempo del timer);\n- In una situazione realistica in cui tutti gli host della rete possono sia ricevere che trasmettere, il throughput effettivo crolla drasticamente molto prima di $R/2$.","x":-5727,"y":11700,"width":551,"height":340,"color":"4"},
		{"id":"968f90c621f36328","type":"text","text":"# Controllo della Congestione\n\nPiù *hop* attraversa un pacchetto, maggiore è la probabilità di essere scartato. Se ciò accade il mittente ritrasmette, appesantendo la rete.\n\nTroppi host che inviano troppo velocemente saturano il throughput, aumentando il numero di pacchetti persi e quindi ritrasmessi. Nello scenario peggiore, l'intera rete è piena di ritrasmissioni destinate a perdersi di nuovo.\n\nLa soluzione a questo problema è una ***gestione dinamica della velocità di trasmissione***. Per poterla attuare ($\\Rightarrow$ per poter rallentare), l'host deve sapere che c'è congestione. Chi glielo dice?\n\n- ***end-to-end*** - Se lo dice da solo. Quando vede che non arrivano gli ACK deduce la presenza di congestione (e.g. TCP);\n- ***rete*** - I router sono in grado di vedere se sono sovraccarichi, basta che lo comunichino agli host. Non è banale, perché\n\t- se il buffer è pieno, il router non lo vede nemmeno;\n\t- se la rete è congestionata, l'informazione del router potrebbe non arrivare a destinazione;\n\t- può portare a leak della struttura di rete.","x":-6541,"y":11700,"width":592,"height":579,"color":"6"},
		{"id":"7eac4e5422d7b896","type":"text","text":"# MSS\n\nI protocolli del livello di Collegamento prevedono una dimensione massima del frame, oltre la quale è necessario \"spezzarlo\" in due $\\Rightarrow$ ***Maximum Transmission Unit*** $$MTU = 1500 byte$$TCP cerca di evitare che i pacchetti vengano spezzati.\nDi default mette in conto che prima del Collegamento verranno aggiunti $20byte$ di header IP e altrettanti del suo, quindi definisce una ***Maximum Segment Size*** $$MSS = 1460byte$$In pratica, $MSS$ è la dimensione massima del **payload** TCP.\n\nQueste informazioni vengono acquisite da TCP in fase di handshaking (tramite un processo detto **Path MTU Discovery**, che sostanzialmente cerca il minimo $MTU$ sul percorso tra i due IP), perché $MTU$ non ha un valore fisso (è quasi sempre $1500byte$, che discende dal protocollo ***Ethernet***).\n\nInteressante notare come esista anche una $MSS$ minima di $536byte$ (che deriva da una $MTU$ minima di $576byte$). Questo significa che se mando un frame di $500byte$ sono sicuro che nessun elemento di rete potrà mai spezzarlo in due. Non ne sarei invece sicuro con $600byte$, perché qualcuno lungo il percorso potrebbe aver settato $MTU = 576byte$).\n\n","x":-4511,"y":12320,"width":520,"height":860,"color":"4"},
		{"id":"b2c8e74231cf5ae9","type":"text","text":"# TCP (Transmission Control Protocol)\n## RFC 793, 1122, 2018, 5681, 7323\n\nProtocollo che crea un ***canale di comunicazione virtuale end-to-end*** tramite un ***handshaking a tre vie***, implementando meccanismi di ***controllo di flusso*** (non sovraccarica il destinatario) e ***controllo di congestione*** (non sovraccarica la rete).\n\nOgni canale TCP è ***affidabile***, ***full-duplex*** e ***bidirezionale***.","x":-6541,"y":12455,"width":592,"height":290,"color":"6"},
		{"id":"78a5ab219227020b","type":"text","text":"# Protocolli del Trasporto","x":-7662,"y":11960,"width":388,"height":60,"color":"6"},
		{"id":"74887c9278678a80","type":"file","file":"4 - Trasporto/TCP/Congestione/RenoTCP.png","x":-5054,"y":13298,"width":484,"height":340},
		{"id":"3e3d13c4f8b98712","type":"text","text":"# TCP Cubic\n\nVariante in cui l'*Additive Increase* (regime lineare) è sostituito da una cubica. In questo modo il throughput viene incrementato maggiormente all'inizio, per poi rallentare quando si approccia il tempo $K$ in cui avviene una perdita.\n\nNaturalmente $K$ va stimato ([RFC 8312](https://www.rfc-editor.org/rfc/rfc8312.txt)).\n\nCubic è la versione TCP standard adottata da SO come Linux.","x":-5727,"y":13298,"width":484,"height":340,"color":"4"},
		{"id":"d0bf911b53869b69","type":"file","file":"4 - Trasporto/TCP/Congestione/TahoeRenoTCP.png","x":-4511,"y":13315,"width":520,"height":306},
		{"id":"47339376d0be509e","type":"text","text":"# Controllo di congestione TCP (Tahoe, Reno)\n\nTCP si basa sul recuperare dalle perdite, non sull'evitarle.\n\nPer prima cosa devo trovare una misura per la velocità di invio, perché è quella che devo diminuire se c'è congestione.\n\n- \"Quantizzo\" il tempo. Ogni slot è pari a 1 RTT;\n- La dimensione del singolo pacchetto è 1 MSS, ma posso voler mandare più pacchetti alla volta. Definisco allora la ***congestion window*** `cwnd`, che definisce quanti MSS non ancora ACK'd posso inviare contemporaneamente.\n\nIn questo modo il rate di invio è dato da $Rate \\simeq \\frac{\\text{cwnd}}{RTT}\\,byte/s$. Bene, ora che ho la velocità come la gestisco?\n\n- ***Slow Start*** - nel primo slot temporale, `cwnd` = 1 MSS. Se non ci sono perdite, raddoppio il rate. Vado avanti così (crescita ***esponenziale***) fino ad un valore di soglia (***ssthresh***, *slow start threshold*). Inizialmente, questo valore è inizializzato come parametro di connessione (e.g. `ssthresh = 8`);\n- ***Additive Increase*** - superato il valore di `ssthresh` mi sposto in regime ***lineare***, aumentando di 1 MSS ogni RTT;\n- ***Perdita*** - quando rilevo una perdita faccio due cose:\n\t- Aggiorno il valore di `ssthresh`, che diventa $\\frac{1}{2}$`cwnd` (***Multiplicative Decrease***);\n\t- Riduco `cwnd`. Come? Ci sono due modi di rendersi conto della perdita di un pacchetto.\n\t\t- ***timeout*** - la congestione è probabilmente grave. Ricomincio dalla fase di *Slow Start* (`cwnd = 1`);\n\t\t- ***triplo ACK duplicato*** - se osservo una cosa del genere è probabile che si sia perso un solo pacchetto (e.g. ho inviato `1 2 3 4 5` e sono stati ricevuti `1 3 4 5`, mi arriva `ACK 2` tre volte più del dovuto). La situazione non è così grave. Il ***Fast Retransmit*** prevede il reinvio del presunto pacchetto perso.\n\t\t\t- Se uso ***TCP Reno*** riparto con l'*Additive Increase* a partire dal nuovo valore di `ssthresh` (***Fast Recovery***).\n\t\t\t- Il \"vecchio\" ***TCP Tahoe*** non fa distinzione tra il triplo ACK duplicato e il timeout, in entrambi i casi riparte con Slow Start.\n\nRiassumendo:\n\n1. Parto esponenziale dal valore `cwnd` = 1 MSS, e continuo fino a `cwnd` = `ssthresh` (*Slow Start*);\n2. Dopo `ssthresh` vado in regime ***AIMD*** (*Additive Increase Multiplicative Decrease*);\n3. Quando intercetto una perdita aggiorno `ssthresh` con *MD*, poi\n\t- se sono Tahoe ricomincio dal punto 1, inviando selettivamente solo il segmento perso come previsto dal *Fast Retransmit*;\n\t- se sono Reno e la perdita è di tipo triplo ACK duplicato rallento un po', ma non troppo. Ricomincio dal punto 2 (*Fast Recovery*), ovvero rimando il segmento perso (*Fast Retransmit*) ma non solo quello (lascio la finestra un po' più larga).","x":-5727,"y":12320,"width":1157,"height":860,"color":"4"},
		{"id":"f5cc794be48592b2","type":"text","text":"\nAIMD algoritmo distribuito asincrono, non facile farlo meglio. così c'è fairness. dimezzare rate di invio -> dimezzare la finestra.\n\nin genere mando un pacchettone grande quanto la congestion window (cwnd). all'inizio è 1MSS, poi 2, poi 3, ... Poi perdo qualcosa e\n- dimezzo se è un fast recovery\n- riduco a 1 se è un timeout\n\nin realtà non si aumenta linearmente all'inizio, ma esponenzialmente.\n\n- anni 70 - TCP partiva al massimo (throughput = bitrate), e poi crashava tutto;\n- slow start è perché esponenziale all'inizio è basso\n\na un certo punto però devo smettere di crescere esponenziale e passare in AIMD. esiste una soglia di andamento variabile chiamata ssthresh.\n\ncome determino ssthresh? la inizializzo a un certo valore (tipo 8, parametro TCP che probabilmente dipende pure dalla versione), poi la aggiorno. Come? Dipende dalla versione. in genere è la metà della grandezza della finestra prima dell'ultimo salto catastrofico. Tahoe riparte esponenziale da 1, Reno riparte lineare dalla threshold.\n\novviamente i grafici sono campionati a ogni RTT\n\n\"è la fairness che non esiste nel nostro sistema economico\"\n\nfast recovery aumenta grandezza finestra di 1 a ogni ack duplicato (altrimenti resto bloccato): se perdo il primo pacchetto ma arrivano gli altri dovrei mandare solo il primo e aspettare l'ack, invece oltre a rimandarlo allargo la finestra\n\nvedi kurose per dettagli (e.g. se tolgo fast recovery e metto un or diventa tahoe)\n\nvedi nuove slides 14...... c'è un link\n\ni tcp \"classici\" sono tahoe reno cube","x":-5304,"y":15640,"width":640,"height":964},
		{"id":"cb01800e5666feb6","type":"text","text":"# controllo congestione TCP 2\n\ninvece di cercare perdite tracciamo l'aumento del ritardo. se aumentando il rate di invio invece del throughput aumenta il ritardo, prima ancora di avere perdite, sto saturando le code (delay based)\n\nECN non è ancora implementato\npacchetto arriva al router (IP), quello aggiunge un bit di coda piena, il destinatario lo legge e gira l'info al mittente (a livello tcp)\n\n","x":-4614,"y":15815,"width":467,"height":354},
		{"id":"d2bed5e555c3844b","type":"text","text":"# Trasferimento Affidabile TCP\n\nTCP implementa una via di mezzo tra\n\n- **Go-Back-N**, da cui prende l'ACK cumulativo e la finestra implementata solo dal mittente. Il timer è associato al primo elemento non ACK'd (primo elemento della finestra);\n\t- Nessuna specifica di TCP obbliga il destinatario ad avere un buffer, ma in pratica è uno standard *de facto* perché migliora efficienza e prestazioni.\n- **Selective Repeat**, se scade il timer non mando l'intera finestra.\n\nIn più, aggiunge un paio di idee originali:\n\n- ***Piggybacking*** - Ogni messaggio inviato contiene anche l'ACK dei messaggi ricevuti, implementando la bidirezionalità.\n- ***Delayed ACK*** - idealmente dimezza gli ACK inviati dal destinatario. Quando gli arriva il primo segmento in ordine atteso, aspetta fino a $500ms$ (parametro configurabile e spesso disattivato) che arrivi il successivo.\n\t- Se arriva, invio un solo ACK che conferma entrambi;\n\t- Se non arriva, amen. Invio l'ACK normalmente.\n- ***Fast Retransmit*** - posso accorgermi della perdita di un singolo pacchetto prima che scada il timer? Se ho inviato `1 2 3 4 5` e sono stati ricevuti `1 3 4 5`, mi arriva `ACK 2` tre volte più del dovuto. Questo ***triplo ACK duplicato*** indica la ricezione di tre segmenti ricevuti dopo un segmento mancante. Senza aspettare che scada il timer di `2`, lo reinvio subito;\n","x":-6541,"y":13298,"width":592,"height":722,"color":"4"},
		{"id":"65291f3a25033246","type":"file","file":"4 - Trasporto/TCP/Congestione/CubicTCP.png","x":-5727,"y":13756,"width":484,"height":171},
		{"id":"0436be9329309ad0","type":"text","text":"# Scelta del Timeout\n\nIl timeout deve essere $> \\langle RTT\\rangle$, altrimenti ritrasmetto senza dare il tempo all'ACK di arrivare. Allora metto un timeout enorme? No, sarei lentissimo a reagire alle perdite.\n\nIl compromesso comunemente accettato è$$timer = \\langle RTT\\rangle + 4\\,\\langle\\sigma_{RTT}\\rangle$$\nTipicamente, in pratica il timer è circa $2\\div 3$ volte l'RTT.\n\nPer evitare un valore di $timer$ troppo piccolo, alcune versioni di TCP prevedono un timeout minimo (tra i $200$ e i $500ms$).","x":-6541,"y":14680,"width":592,"height":360,"color":"4"},
		{"id":"d1472b8d646b14ad","type":"text","text":"# Stima di RTT\n\n$\\langle RTT\\rangle$ viene stimato tramite una **Exponential Weighted Moving Average** (***EWMA***).$$\\langle RTT\\rangle_t = (1 - \\alpha)\\,\\langle RTT\\rangle_{t-1} + \\alpha\\,RTT$$\nIn pratica tengo in conto due cose:\n\n- la stima precedente $\\langle RTT\\rangle_{t-1}$, che al suo interno avrà la stima $\\langle RTT\\rangle_{t-2}$, e via dicendo. Se spacchetto questo termine, mi accorgo che ogni stima vecchia $n$ contribuisce alla stima attuale con un peso $(1-\\alpha)^n$. La dipendenza dal passato, quindi, diminuisce esponenzialmente;\n- l'ultima misura di $RTT$ data dall'ultimo pacchetto.\n\nIn modo analogo si stima la deviazione standard (\"*chi ha inventato TCP non conosceva la statistica*\"). $$\\langle\\sigma_{RTT}\\rangle_t = (1-\\beta)\\langle\\sigma_{RTT}\\rangle_{t-1} + \\beta |RTT - \\langle RTT\\rangle_t|$$\nTipicamente $\\alpha \\simeq 0.125$ e $\\beta \\simeq 0.25$. ","x":-5727,"y":14070,"width":484,"height":560,"color":"4"},
		{"id":"ca345537eca5f999","type":"file","file":"4 - Trasporto/RDT/FormalismoFSM.png","x":-5731,"y":10483,"width":551,"height":216},
		{"id":"cfd8a6577c228df0","type":"text","text":"# UDP (User Datagram Protocol)\n\nUDP è il servizio \"base\" del livello di Trasporto. Fa solo il (de)multiplexing, e lo fa senza connessione. Gli basta sapere IP e numero di porta di destinazione (e.g. $\\delta$ per \"destinatario\"), dopodiché invia il segmento e se ne lava le mani.\n\nSe l'IP di destinazione è in ascolto sulla porta $\\delta$, si vede arrivare un pacchetto UDP in cui è specificato l'IP di chi lo manda e la porta dinamica (e.g. $\\mu$ per \"mittente\") che identifica il processo client che l'ha generato.\n\nOvviamente più client e più processi dello stesso client possono mandare segmenti alla porta $\\delta$, quindi chi è in ascolto si vede arrivare un unico flusso (stream) di dati, ma grazie alla coppia ($IP_\\mu, \\mu$) effettua il demultiplexing.\n\nCon UDP chiunque può parlare quando vuole dicendo una parola alla volta\n\nC'è un minimo controllo degli errori dato da un checksum molto rudimentale (una somma in complemento a 1). Se a destinazione trovo un errore, scarto il pacchetto (e lo richiedo? dipende dal protocollo Applicazione).\n\nIn realtà c'è più di un checksum, il che rende vagamente più sensato il fatto che sia molto grezzo\n\n\nad ogni messaggio corrisponde un segmento (contrariamente a TCP, che vede un bytestream \"continuo\" che racchiude in pacchetti)","x":-8593,"y":12105,"width":655,"height":640,"color":"3"},
		{"id":"9c002ace9319f7e3","type":"file","file":"4 - Trasporto/TCP/SegmentoTCP.png","x":-7426,"y":12455,"width":605,"height":290},
		{"id":"bc22bb5d7b6798d3","type":"text","text":"\nil socket TCP vuole stabilire una connessione, quindi gli servono \n\n- indirizzo IP di origine\n- numero di porta di origine\n- indirizzo IP di destinazione\n- numero di porta di destinazione\n\nregola per mappare i pacchetti al processo.\nperché metto anche l'IP? anche per aumentare lo spazio dei socket (avere più scelte per demultiplare).\n\nPosso mentire sul mio IP sorgente? (direi in UDP sì e sta alla rete controllare che io non faccia cose strane) ma non lo mette UDP nell'header mi sa, sta alla rete temo\nPiù processi che si aspettano HTTP (e.g. firefox e chrome) lo fanno sullo stesso socket? c'è un ulteriore demux? uno dei due è forzato a cambiare porta (tanto è TCP)? (secondo me ognuno apre un socket)\n","x":-7861,"y":16386,"width":871,"height":436},
		{"id":"b81367aa9de6afb4","type":"text","text":"# Garanzie di Comunicazione\n\nSe invio un messaggio voglio anzitutto **_che arrivi a destinazione_** (... e no, su Internet non è scontato), dopodiché se possibile vorrei lo facesse\n\n- ***integro***, ovvero che non subisca corruzione (e.g. se faccio una chiamata non voglio pacchetti in disordine o fenomeni di *bit-flip*), che naturalmente può essere anche volontaria;\n- **_in tempi ragionevoli_** (e.g. nell'esempio della chiamata, non voglio un ritardo di minuti tra l'invio e la ricezione)\n\nSe ho tanti messaggi di grandi dimensioni (e.g. straming video) sarebbe carino avere un **_throughput minimo garantito_**.\n\nOra, chi è che si occupa di fornire tali garanzie?\n\n- Il layer di **_Trasporto_**, se si usa un servizio affidabile come TCP. Questi protocolli sono distribuiti come API e implementati a livello di SO;\n- Il layer di **_Applicazione_** stesso, rimediando ad alto livello alle non-garanzie di servizi inaffidabili come UDP (il quale non garantisce neanche che il messaggio arrivi, in caso sta all'Applicazione programmare il suo reinvio). I protocolli dell'Applicazione sono implementabili direttamente (appunto) sulle applicazioni (e.g. un browser), senza necessità di API standardizzate e distribuite su SO. Questo li rende generalmente più rapidi nello sviluppo.\n","x":-8594,"y":9040,"width":656,"height":640,"color":"4"},
		{"id":"42184aaeeadc6b30","type":"file","file":"4 - Trasporto/RDT/RDT1.0.png","x":-5731,"y":11377,"width":548,"height":85},
		{"id":"ebaaa4d935ae2768","type":"text","text":"# Handshaking TCP\n\nIl server configura un ***welcome socket*** su una coppia `(IP, porta)` predefinita per eseguire l'handshaking.\n\nQuando il client manda una richiesta di connessione al welcome socket, vengono concordati i ***parametri di connessione***.\n\nSe va tutto bene, la connessione viene spostata su un altro server socket *ad-hoc*, e il welcome socket torna in ascolto.","x":-7426,"y":13100,"width":605,"height":280,"color":"4"},
		{"id":"682e6c2a4010ca8d","type":"text","text":"# Campi di un header TCP (Wikipedia)\n\n- **Source port** [16 bit] - Identifica il _numero di porta sull'host mittente_ associato alla connessione TCP.\n- **Destination port** [16 bit] - Identifica il _numero di porta sull'host destinatario_ associato alla connessione TCP.\n- **Sequence number** [32 bit] - Numero di sequenza, indica lo scostamento (espresso in byte) dell'inizio del segmento TCP all'interno del flusso completo, a partire dall'Initial Sequence Number (_ISN_), deciso all'apertura della connessione (Un campo a 32 bit utilizzato per il riassemblaggio dei dati).\n- **Acknowledgment number** [32 bit] - Numero di riscontro, ha significato solo se il flag [ACK](https://it.wikipedia.org/wiki/ACK_(informatica) \"ACK (informatica)\") è impostato a 1, e conferma la ricezione di una parte del flusso di dati nella direzione opposta, indicando il valore del prossimo _Sequence number_ che l'host mittente del segmento TCP si aspetta di ricevere.\n- **Data offset** [4 bit] - Indica la lunghezza (in [dword](https://it.wikipedia.org/wiki/Dword \"Dword\") da 32 bit) dell'header del segmento TCP; tale lunghezza può variare da 5 dword (20 byte) a 15 dword (60 byte) a seconda della presenza e della lunghezza del campo facoltativo _Options_.\n- **Reserved** [4 bit] - Bit non utilizzati e predisposti per sviluppi futuri del protocollo; dovrebbero essere impostati a zero.\n- **Flags** [8 bit] - Bit utilizzati per il controllo del protocollo:\n    - **CWR** (Congestion Window Reduced) - se impostato a 1 indica che l'host sorgente ha ricevuto un segmento TCP con il flag ECE impostato a 1 (aggiunto all'header in [RFC 3168](https://tools.ietf.org/html/rfc3168)).\n    - **ECE** [ECN (Explicit Congestion Notification) -Echo] - se impostato a 1 indica che l'host supporta ECN durante il 3-way handshake (aggiunto all'header in [RFC 3168](https://tools.ietf.org/html/rfc3168)).\n    - **URG** - se impostato a 1 indica che nel flusso sono presenti _dati urgenti_ alla posizione (offset) indicata dal campo _Urgent pointer_. _Urgent Pointer_ punta alla fine dei dati urgenti;\n    - **[ACK](https://it.wikipedia.org/wiki/ACK_(informatica) \"ACK (informatica)\")** - se impostato a 1 indica che il campo _Acknowledgment number_ è valido;\n    - **PSH** - se impostato a 1 indica che i dati in arrivo non devono essere bufferizzati ma passati subito ai livelli superiori dell'applicazione;\n    - **[RST](https://it.wikipedia.org/wiki/RST_(TCP) \"RST (TCP)\")** - se impostato a 1 indica che la connessione non è valida; viene utilizzato in caso di grave errore; a volte utilizzato insieme al flag ACK per la chiusura di una connessione.\n    - **SYN** - se impostato a 1 indica che l'host mittente del segmento vuole _aprire una connessione TCP_ con l'host destinatario e specifica nel campo _Sequence number_ il valore dell'Initial Sequence Number (_ISN_); ha lo scopo di sincronizzare i numeri di sequenza dei due host. L'host che ha inviato il SYN deve attendere dall'host remoto un pacchetto SYN/[ACK](https://it.wikipedia.org/wiki/ACK_(informatica) \"ACK (informatica)\").\n    - **FIN** - se impostato a 1 indica che l'host mittente del segmento vuole _chiudere la connessione TCP_ aperta con l'host destinatario. Il mittente attende la conferma dal ricevente (con un FIN-ACK). A questo punto la connessione è ritenuta chiusa per metà: l'host che ha inviato FIN non potrà più inviare dati, mentre l'altro host ha il canale di comunicazione ancora disponibile. Quando anche l'altro host invierà il pacchetto con FIN impostato, la connessione, dopo il relativo FIN-ACK, sarà considerata completamente chiusa.\n- **Window size** [16 bit] - Indica la dimensione della _finestra di ricezione_ dell'host mittente, cioè il numero di byte che il mittente è in grado di accettare a partire da quello specificato dall'acknowledgment number.\n- **[Checksum](https://it.wikipedia.org/wiki/Checksum \"Checksum\")** [16 bit] - Campo di controllo utilizzato per la verifica della validità del segmento. È ottenuto facendo il complemento a 1 della somma [complemento a uno](https://it.wikipedia.org/wiki/Complemento_a_uno \"Complemento a uno\") a 16 bit dell'intero header TCP (con il campo checksum messo a zero), dell'intero payload, con l'aggiunta di uno pseudo header composto da: indirizzo IP sorgente (32bit),indirizzo IP destinazione (32bit), un byte di zeri, un byte che indica il protocollo e due byte che indicano la lunghezza del pacchetto TCP (header + dati).\n- **Urgent pointer** [16 bit] - Puntatore a dato urgente, ha significato solo se il flag URG è impostato a 1 ed indica lo scostamento in byte a partire dal _Sequence number_ del byte di dati urgenti all'interno del flusso.\n- **Options** - Opzioni (facoltative) per usi del protocollo avanzati.\n- **Data** - rappresenta il carico utile o _payload_ da trasmettere cioè la [PDU](https://it.wikipedia.org/wiki/Protocol_Data_Unit \"Protocol Data Unit\") proveniente dal livello superiore.","x":-10800,"y":13720,"width":1020,"height":1240},
		{"id":"a731af0c58730b68","type":"text","text":"# Creare un socket\n\n`bind()` è la syscall che associa un indirizzo IP ad una porta\n\n`listen()` è tipicamente usata dal welcome socket di un server per ascoltare le richieste di connessione in ingresso\n\n`connect(servername, serverport)` usata dal client per mandare una richiesta di connessione (handshaking) ad un welcome socket del server\n\n`accept()` è chiamata dal welcome socket per accettare la connessione alla fine dell'handshaking riuscito. in pratica crea un altro socket server che si collega al socket client creando il canale TCP.","x":-9151,"y":14790,"width":551,"height":500},
		{"id":"ba959693f76625dc","type":"text","text":"# 3-Way TCP Handshaking\n\n- Il client sceglie un proprio numero di sequenza casuale `x` da cui partire e invia un segmento con il bit `SYN = 1` (sincronizzazione, ovvero \"`voglio stabilire una connessione`\");\n\t- Il client entra in uno stato `SYNSENT` (richiesta inviata);\n- Il server sceglie un proprio numero di sequenza casuale `y` da cui partire e risponde con un messaggio di tipo `SYNACK` (`SYN = 1`, sono in fase di handshaking, `ACK = 1`, sto mandando un ACK, `ACK# = x+1`, mandami il numero di sequenza `x+1`);\n\t- Il server entra in uno stato `SYNRCVD` (richiesta ricevuta);\n- Il client riceve `SYNACK`, sa che il server c'è. Invia un `ACK` chiedendo `y+1` e può contestualmente iniziare a trasmettere;\n\t- Per il client la connessione è `ESTAB` (established);\n- Il server riceve l'`ACK`, sa che il client c'è;\n\t- Anche per il server la connessione è `ESTAB`;\n\t- Il welcoming socket procede a chiamare `accept()`.","x":-7426,"y":13515,"width":605,"height":505,"color":"4"},
		{"id":"5208deabb50423e0","type":"text","text":"## Problemi di un Handshaking a due vie\n\nSi potrebbe pensare all'handshaking come una cosa del tipo\n\n- Client - \"`posso connettermi?`\" \n- Server - \"`certo, connessione stabilita!`\"\n\nQuesto però porta a situazioni spiacevoli.\n\n- Il client invia una richiesta di connessione duplicata, nel frattempo arriva la risposta \"`ok`\" del server. Il client non ci fa caso e, spazientito, va offline (chiudendo la connessione). Poi però arriva la richiesta duplicata, che il server accetta rispondendo \"`ok`\" a... nessuno, perché non c'è ***nessun client dall'altra parte*** (connessione aperta a metà);\n- Come la situazione precedente, ma il client ha mandato duplicati anche di altre richieste. Quindi non solo c'è una connessione aperta a metà, ma arrivano ***comandi duplicati***.","x":-8218,"y":13515,"width":560,"height":505,"color":"4"},
		{"id":"69681b71ef1b737f","type":"file","file":"4 - Trasporto/TCP/HandshakingErrorDuplicateData.png","x":-8973,"y":13568,"width":326,"height":399},
		{"id":"98896a420c7686db","type":"file","file":"4 - Trasporto/TCP/HandshakingErrorNoClient.png","x":-8593,"y":13568,"width":300,"height":400},
		{"id":"7d6b28e899228bae","type":"text","text":"# Chiusura di una connessione TCP\n\nChi vuole chiudere una connessione TCP invia un segmento con il flag `FIN = 1`. Dall'altra parte bisogna rispondere con un `ACK`, che sancisce la chiusura di \"mezza\" connessione. L'altra mezza verrà chiusa una volta ricevuto l'`ACK`.","x":-7426,"y":14170,"width":605,"height":181,"color":"4"},
		{"id":"567c76ad9244562d","type":"text","text":"# Attacchi ad una connessione TCP","x":-8218,"y":14170,"width":560,"height":360,"color":"#4545ff"},
		{"id":"e47fac0c91452bb7","type":"text","text":"# Da Applicazione a Trasporto","x":-9520,"y":8720,"width":455,"height":80,"color":"6"},
		{"id":"ba32fe7205e2606f","type":"text","text":"# Guida rapida alla scelta tra TCP e UDP\n\n- **_TCP_** - è il *lawful good* della situazione. \"Prima creiamo una connessione, dichiarando chi parla e chi ascolta (paradigma mittente-destinatario) ognuno con le rispettive informazioni (***handshaking***), poi parliamo\"\n\t- ***Garantisce l'arrivo dei pacchetti in ordine***;\n\t- Implementa dei controlli di non-congestione sull'utente (***controllo di flusso***) e sulla rete (***controllo della congestione***). In pratica evita il sovraccarico di rete aggiustando le velocità delle singole connessioni a seconda del livello di riempimento dei router, evitando che si blocchi tutto e che le informazioni si perdano;\n\t- NON dà garanzie di velocità (da bravo *lawful good*, \"chi va piano...\"). In ogni caso, se uso commutazione di pacchetto dovrei già sapere che latenza e throughput non possono mai essere garantiti;\n\t- Ogni servizio offerto da TCP aggiunge complessità, ritardi e overhead computazionale.\n\t- Utile in situazioni in cui mi interessa l'affidabilità piuttosto che la velocità (e.g. caricamento di pagine web, transazioni bancarie).\n\n- **_UDP_** - è ovviamente *chaotic neutral*. \"Io ci provo a trasmettere i dati, poi se succede qualcosa non guardare me... da parte mia best effort fratello\".\n\t- Non crea alcuna connessione, non c'è nessun paradigma: se il destinatario è in ascolto sulla giusta porta si vede semplicemente recapitare un pacchetto UDP;\n\t- Visto che non perdo tempo a creare la connessione, UDP può essere molto veloce... se il pacchetto arriva a destinazione. Già, perché questo protocollo non offre nessuna garanzia in tal senso;\n\t- Perché mai dovrei usare UDP se non garantisce niente?\n\t\t- Se non mi interessa che ogni tanto si perdano dei dati (e.g. streaming) sfrutto un servizio ***statisticamente più veloce***;\n\t\t- Se mi interessa posso sempre costruire il mio trasporto affidabile a livello di Applicazione e poi usare UDP perché è più veloce di TCP. Questa è in generale una tendenza degli ultimi anni: implementare regole a livello applicazione senza cambiare i protocolli più bassi (e.g. ***QUIC***, 2013).","x":-9620,"y":11521,"width":656,"height":938,"color":"4"},
		{"id":"dff88af00a536f81","type":"text","text":"# Di cosa ha bisogno l'Applicazione?","x":-8545,"y":10034,"width":559,"height":77,"color":"6"},
		{"id":"6f3226cdbb9850aa","type":"text","text":"# Servizi del Trasporto\n\nOffrono all'Applicazione un canale di comunicazione logico.\n\nDal punto di vista dell'Applicazione è come se i vari livelli di Trasporto siano connessi, il *come* non è affar suo.\n\nDal punto di vista del Trasporto, è sufficiente sapere dove e come inviare i messaggi, sfruttando i propri protocolli e quelli del livello di Rete (IP).\n\nSe uso TCP, il Trasporto si preoccupa anche di garantire che in qualche modo i messaggi arrivino a destinazione, avendo cura di informarmi se ciò non succede.\n\n","x":-7811,"y":10854,"width":688,"height":331,"color":"4"},
		{"id":"84d5d9e7cf116171","type":"text","text":"network time protocol\n","x":-10675,"y":6820,"width":250,"height":60},
		{"id":"179ce6b66f1a29fe","type":"text","text":"# Livello di Applicazione","x":-9520,"y":5200,"width":455,"height":60,"color":"6"},
		{"id":"35235b872aeaab53","type":"text","text":"# Stack Protocollare ISO/OSI\n\nNel 1984 l'_International Organization for Standardization_ (ISO) ufficializza uno standard architetturale chiamato _Open Systems Interconnection_ (OSI).\n\nLa stack protocollare prevede 7 livelli. Rispetto a TCP/IP (di cui è predecessore spirituale) vi sono due layer aggiuntivi:\n\n- Layer di Presentazione (anche detto livello 6, partendo dal basso) - si pone subito sotto al livello di Applicazione, il quale lo assorbe completamente in TCP/IP. Si occupa esplicitamente della codifica e della crittografia dei dati;\n- Layer di Sessione (livello 5) - definisce alcuni dettagli della comunicazione inter-host, come la gestione degli errori nell'invio dei pacchetti E ALTRO???? Nel modello TCP/IP, i suoi compiti sono stati divisi tra l'Applicazione e il Trasporto.\n\n","x":-4940,"y":4222,"width":700,"height":586,"color":"3"},
		{"id":"0719791a80c12eb2","type":"text","text":"# Chi fa cosa?\n\nMittente e destinatario devono implementare tutti gli step dell'incapsulamento o decapsulamento, naturalmente mediante dispositivi diversi.\n\nUn router vede solo dal livello di Rete in giù. Una sua azione tipica è **distruggere l'header di Rete** del pacchetto in ingresso **e crearne uno nuovo** ($\\Rightarrow$ così realizza il **reindirizzamento**).\n\nNon ha bisogno di avere i protocolli software di Trasporto e Applicazione (tipicamente implementati solo a livello di SO), perché non arriva a vederli. Si limita a collegare $N$ sottoreti tramite $N$ strutture diverse sottostanti.\n\nUno switch si ferma al Collegamento. Non dovendo reindirizzare (si limita ad inoltrare i frame in ingresso), non distrugge/crea alcun header.","x":-5736,"y":4368,"width":700,"height":440,"color":"3"},
		{"id":"d0bc31a12d2847f8","type":"file","file":"0 - Stack Protocollare/chifacosa.png","x":-5736,"y":4118,"width":700,"height":209},
		{"id":"3fd6f7170699d719","type":"text","text":"# Controllo di Flusso TCP\n\nQuando ricevo dati ho un buffer che deve essere letto (e quindi svuotato) dall'Applicazione.\n\nSe però ricevo più dati di quanti riesco a leggerne? Sarei costretto a scartare i pacchetti. Devo dire al mittente di non esagerare. In fase di handshaking, il destinatario comunica al mittente la dimensione della sua *receiver window* tramite il parametro `rwnd`. Tipicamente, il buffer è di 4096 byte?","x":-8218,"y":13100,"width":560,"height":280,"color":"3"},
		{"id":"b5e970d69276ee2b","type":"text","text":"In questo caso il significato della risposta è chiaro, ma ci sono situazioni in cui ai messaggi che ricevo possono corrispondere più stati nel resto della rete. L'obiettivo è quello di massimizzare la probabilità di comprendere cosa accade dove non si può vedere.\n\n in situazioni complicate potrei andare fuori sync perché non so cosa si aspettano gli altri.","x":-3744,"y":9768,"width":460,"height":289},
		{"id":"bc91687bf97c4515","type":"file","file":"4 - Trasporto/RDT/SenderWindow.png","x":-2713,"y":10216,"width":519,"height":113},
		{"id":"73ccf1e79df95ce8","type":"file","file":"4 - Trasporto/RDT/ReceiverWindow.png","x":-2713,"y":10356,"width":520,"height":127},
		{"id":"621da05b43f27ecc","type":"text","text":"# Varie\n\nPosso manovrare ad hoc il checksum per far apparire un pacchetto autentico e fare injection\n\nper evitare gli attacchi, si evita di mandare davvero i pacchetti in sequenza lineare, li si randomizza","x":-3302,"y":10250,"width":520,"height":233,"color":"2"},
		{"id":"f55770ab8bdeed44","type":"text","text":"# Go-Back-N (ACK Cumulativo)\n\nDi default, ***il destinatario non ha una finestra***. Manda un ACK cumulativo ogni volta che riceve un qualsiasi pacchetto. Questo semplifica la sua implementazione, in quanto deve solo tenere traccia di dove è arrivato, ma di contro scarta tutti i pacchetti fuori ordine. Posso ovviamente implementare una variante con buffer, ma mi perdo per strada il suo punto forte (semplicità implementativa).\n\nLato mittente, quando arriva l'ACK cumulativo scorro la finestra. Al primo pacchetto senza ACK ($\\Rightarrow$ il primo della finestra) è associato un timer, alla scadenza del quale il mittente nel dubbio reinvia tutta la finestra.\n\nPerché dovrei usare questo protocollo?\n\n- Rimandando tutta la finestra in pratica faccio un refresh, quindi evito situazioni convolute;\n- Robusto rispetto alla perdita degli ACK che manda il destinatario.\n\nDi contro,\n- spreca un sacco di banda e rischia di congestionare la rete;\n- non esiste un chip che lo implementa in modo rapido.","x":-3184,"y":11900,"width":577,"height":641,"color":"3"},
		{"id":"aafdfc81117b9e28","type":"text","text":"# Due possibili implementazioni","x":-2694,"y":11580,"width":481,"height":60,"color":"6"},
		{"id":"be538ff257591a0a","type":"file","file":"4 - Trasporto/RDT/Receiver_GoBackN.png","x":-3680,"y":12280,"width":399,"height":158},
		{"id":"991d5b508f22877f","type":"file","file":"4 - Trasporto/RDT/Sender_GoBackN.png","x":-3680,"y":12000,"width":400,"height":199},
		{"id":"c985195098f59000","type":"file","file":"4 - Trasporto/RDT/Compare_GBN-SR.png","x":-2726,"y":12720,"width":545,"height":225},
		{"id":"f1a7cba73c578431","type":"text","text":"# Approcci alternativi","x":-4981,"y":13960,"width":339,"height":60,"color":"6"},
		{"id":"4fbfe23af23d71e0","type":"text","text":"# Approccio a Feedback di Rete\n\nIn questo approccio non cerco di dedurre la congestione con le mie sole forze da host, ma delego i router.\n\nCostoro sanno se i loro buffer sono pieni, e possono inserire questa informazione all'interno degli header ***IP*** (campo `ECN`) e TCP (cambi `C`, `E`) dei pacchetti che inoltrano.","x":-4511,"y":13667,"width":520,"height":293,"color":"4"},
		{"id":"9764b381a2329f2a","type":"file","file":"4 - Trasporto/TCP/Congestione/ThroughputEffettivoCongestione.png","x":-4511,"y":11700,"width":236,"height":222},
		{"id":"37b58e88f2ef363d","type":"file","file":"4 - Trasporto/TCP/Congestione/ThroughputEffettivoCongestioneTantiHost.png","x":-4251,"y":11700,"width":260,"height":219},
		{"id":"e237cbb67555c043","type":"text","text":"# Fairness\n\nSe ci stanno due polli ne prendiamo uno a testa o te li prendi entrambi tu?\n\nIl regime AIMD riesce più o meno a far avere un pollo a testa, è abbastanza equo sotto certe ipotesi (e.g. tutti stimano lo stesso RTT, ogni client apre lo stesso numero di sessioni, ...).","x":-5090,"y":11999,"width":520,"height":261,"color":"4"},
		{"id":"d29333aec77d471c","type":"file","file":"4 - Trasporto/TCP/Congestione/FairnessAIMD.png","x":-4451,"y":12018,"width":400,"height":223},
		{"id":"a122bc5c3c127d03","type":"text","text":"# QUIC\n\nIn realtà è un protocollo Applicazione, si basa su UDP a livello di trasporto ma implementa tutte le garanzie di TCP e di TLS, con diversi vantaggi.\n\nMentre TCP/TLS ha bisogno di due handshaking, QUIC fa tutto con uno.\n\nMultiplexa internamente più sessioni del browser in una singola connessione a livello di trasporto. In pratica, prova ad impedire di aprire tante connessioni in parallelo per monopolizzare la banda (poi forse in pratica un modo per fregarlo c'è, \"l'importante è che non lo facciano tutti involontariamente\").","x":-9620,"y":12565,"width":656,"height":360,"color":"3"},
		{"id":"71a58d9affac5b95","type":"text","text":"# Approccio Delay-Based (BBR)\n\nTutto questo funziona, ma stiamo ignorando RTT ($\\Rightarrow$ assumendo che sia noto e fisso). Ovviamente non è così, e ci si può costruire sopra un metodo alternativo (***delay-based***) per stimare la congestione di rete.\n\nSe la rete è congestionata, l'aumento di `cwnd` non aumenterà il throughput, ma osserverò un aumento nelle misure di RTT.\n\n- Assumo che quando mando il primo pacchetto non ci sia congestione. Il suo RTT sarà minimo, quindi massimo throughput $T_{max}$;\n- Finché misuro $RTT \\simeq RTT_{min}$ ($\\Rightarrow T \\simeq T_{max}$) va tutto bene, quindi aumento `cwnd` linearmente;\n- Se misuro $RTT >> RTT_{min}$ ($\\Rightarrow T << T_{max}$) significa che inizia ad esserci congestione, quindi decremento `cwnd` linearmente;\n\t- I valori di soglia tra questi due regimi sono molto fenomenologici.\n\nL'enorme vantaggio di questo approccio è che non basa la gestione della velocità sulle perdite (che sono solo una stima della congestione), ma su una misura effettiva del throughput. L'obiettivo è monitorare i colli di bottiglia per ottimizzare il throughput in quei punti, evitando la perdita di pacchetti (cosa che invece TCP Cubic accetta).\n\nQuesto approccio nasce nel 2016 da Google (**Bottleneck Bandwidth and Round-trip-time**, ***BBR***), ma non è compatibile con Reno o Cubic, perché ottimizzando il throughput tende a \"mangiarsi\" tutta la bandwidth disponibile, uccidendo di fatto i TCP classici. In questo senso, se nella stessa subnet esistono altri protocolli oltre a BBR, questo risulta essere ***unfair***.\n\nPer questo motivo può essere implementato solo in una sottorete in cui lo usano tutti. Google fa proprio questo nella sua backbone interna, in cui è certo di non distruggere le prestazioni di nessuno. I browser basati su Chromium supportano BBR, ma in pratica non lo usano (credo).","x":-5054,"y":14454,"width":1063,"height":586,"color":"4"},
		{"id":"3881465ee755981e","type":"text","text":"# Stack Protocollare TCP/IP\n\nLo standard *de facto* di Internet. **_TCP/IP_** prevede **_5 livelli_**, che descriverò in approccio _down-top_ (si dice? chissà), partendo quindi dalla realtà fisica per arrivare alla virtualizzazione di più alto livello.\n\n- **_Livello Fisico (Physical Layer)_** - Qualunque oggetto che abbia come risultato quello di trasferire fisicamente dei bit da un punto A ad un punto B è una *layer-1 technology* (e.g. cavi, frequenze). \n- **_Livello di Collegamento (Data Link Layer)_** - Tutto ciò che, interagendo con il livello fisico, mette i bit nel cavo o li preleva da esso (e.g. Network Interface Cards, Wi-Fi Access Cards, Switches). Ogni oggetto che implementa il *layer-2* ha un codice identificativo unico a 48bit (spesso rappresentato come 12 cifre esadecimali) detto ***MAC Address***. L'obiettivo del Data Link Layer è quello di spostare i dati \"**hop-to-hop**\" (l'obiettivo dell'header di collegamento è quello di spostare i dati da un dispositivo fisico identificato da un certo MAC ad un altro \"adiacente\");\n- **_Livello di Rete (Network Layer)_** - Si occupa della comunicazione **end-to-end**, identificando mittente e destinatario con un indirizzo ***IP***. Ogni router intermedio legge l'IP del destinatario e reindirizza il pacchetto al prossimo *hop* tramite il MAC Address, usando le funzioni del layer precedente. Lo scopo dell'header di Rete è quello di spostare i dati da un dispositivo fisico identificato da un certo IP ad un altro arbitrariamente lontano).\n\t- ***Address Resolution Protocol (ARP)*** - Intuitivamente, l'IP è un indirizzo logico, mentre per farmi arrivare i pacchetti serve il MAC. Se conosco un IP posso provare a scoprire il MAC sottostante tramite richiesta ARP.\n- **_Livello di Trasporto_** - Primo layer interamente SW. Si assicura che i giusti messaggi siano consegnati alle giuste applicazioni. In pratica, contiene il protocollo usato (e.g. TCP, UDP, ...) e le ***porte*** di invio e destinazione.\n\t- ***(SSL/TLS)*** - non incluso nel modello TCP/IP, ma di fatto è il layer di Presentazione del modello ISO/OSI. Si occupa esplicitamente della sicurezza.\n- **_Livello di Applicazione_** - è la vista di più alto livello (e.g. HTTP, FTP, DNS).\n\nOra però passiamo all'approccio *top-down* per seguire l'evoluzione di un messaggio.\n\n- ciò che comanda l'utente è trasformato dall'Applicazione in un **_messaggio_**, costituito da\n\t- ***header*** - qui si inseriscono istruzioni comprensibili al trasporto (e.g. \"devi raggiungere `www.example.com`, e questo è il il quarto di sei messaggi\") e all'Applicazione di chi lo riceverà, che deve parlare la stessa lingua (ovvero usare lo stesso protocollo) per poter decodificare correttamente;\n\t- ***corpo*** - i dati veri e propri, anche detti ***payload*** (un po' come se il vero messaggio ai fini della comunicazione sia una zavorra, uno sforzo).\n- L'Applicazione invoca le API del Trasporto, che riceve il messaggio e gli aggiunge le proprie informazioni (**header di trasporto**), portando a termine il secondo **_incapsulamento_** e rendendo il messaggio un **_segmento_** (o **_datagramma utente_**). Notare che il payload del segmento è il messaggio. Come per l'Applicazione, l'header del Trasporto è comprensibile per il trasporto stesso e per la Rete, che saprà cosa farci;\n- Il Trasporto passa il segmento alla Rete, che aggiunge il proprio header e crea un **_datagramma_** contenente IP di mittente e destinatario;\n- Si passa quindi al Collegamento, che aggiungendo il proprio header rende il pacchetto un **_frame_**, che viene poi modulato nel mezzo Fisico.\n\nA questo punto il pacchetto ha completamente disceso la stack. Può avvenire il trasferimento fisico attraverso la rete e un altro dispositivo può applicare le trasformazioni inverse per risalire prima al datagramma, poi al segmento e infine al messaggio.","x":-4183,"y":4997,"width":778,"height":1431,"color":"4"},
		{"id":"44ce1eef2a1a2afa","type":"text","text":"### Esempio di Risposta\n\n```\nHTTP/1.1 200 OK\\r\\n\nDate: Sun, 26 Sep 2010 20:09:20 GMT\\r\\n\nServer: Apache/2.0.52 (CentOS)\\r\\n\nLast-Modified: Tue, 30 Oct 2007 17:00:02 GMT\\r\\n\nETag: \"17dc6-a5c-bf716880\"\\r\\n\nAccept-Ranges: bytes\\r\\n\nContent-Length: 2652\\r\\n\nKeep-Alive: timeout=10, max=100\\r\\n\nConnection: Keep-Alive\\r\\n\nContent-Type: text/html; charset=ISO-8859-1\\r\\n\n\\r\\n\n[... document content ...]\n```","x":-11472,"y":10000,"width":511,"height":410,"color":"4"},
		{"id":"16f174d47e0dd2b5","type":"text","text":"### Esempio di richiesta\n```\nGET /index.html HTTP/1.1\\r\\n\nHost: www-net.cs.umass.edu\\r\\n\nUser-Agent: Firefox/3.6.10\\r\\n\nAccept: text/html,application/xhtml+xml\\r\\n\nAccept-Language: en-us,en;q=0.5\\r\\n\nAccept-Encoding: gzip,deflate\\r\\n\nAccept-Charset: ISO-8859-1,utf-8;q=0.7\\r\\n\nKeep-Alive: 115\\r\\n\nConnection: keep-alive\\r\\n\n\\r\\n\n```","x":-11982,"y":10000,"width":473,"height":410,"color":"4"},
		{"id":"9b35587f0d6f95ff","type":"text","text":"# Selective Repeat (ACK Individuale)\n\nIl destinatario conferma individualmente tutti i pacchetti ricevuti\ncorrettamente $\\Rightarrow$ ***niente ACK cumulativi***. Ha una finestra di buffer che avanza con il più vecchio pacchetto in ordine ricevuto (più pesante a livello implementativo rispetto a Go-Back-N).\n\nLato mittente, ogni pacchetto ha un timeout e viene reinviato singolarmente alla scadenza di esso. Per il resto, la finestra avanza esattamente come in Go-Back-N.\n\nMa le due finestre si spostano in modo asimmetrico...? Sì. Infatti se si perde un ACK rischio di perdere la sincronizzazione, portando al blocco (irreversibile??) del protocollo. \n\nMolto più leggero sul traffico di rete.\n\nse la sequenza è in base 2m,la\nfinestra può essere al più grande 2m-1","x":-2360,"y":11900,"width":577,"height":641,"color":"3"},
		{"id":"21c89f14ccde6dc6","type":"file","file":"4 - Trasporto/RDT/SelectiveRepeat.png","x":-1680,"y":12110,"width":399,"height":222},
		{"id":"34401d45639b449d","type":"text","text":"# Livello di Trasporto\n\nGestisce il ***trasferimento end-to-end*** dei segmenti","x":-7637,"y":10012,"width":341,"height":120,"color":"6"},
		{"id":"e02622616641968a","type":"text","text":"# Switch\n\nReindirizza i frame tra IP della stessa LAN tramite una tabella che associa gli indirizzi MAC dei dispositivi ad esso connessi con la relativa porta fisica, e amplifica il segnale. È un elemento **trasparente** (gli host ignorano la sua presenza) che implementa tre azioni:\n\n- ***Learn*** - Riempire la propria ***Content Addressable Memory*** (***CAM***). Immaginiamola inizialmente vuota. Quando da una porta fisica arriva un frame questo contiene il MAC Address del mittente, permettendo allo switch di aggiungere l'associazione tra quel MAC e la porta da cui è arrivato come riga di una tabella di corrispondenze;\n\t- Nota che il frame potrebbe essere passato per altri switch, quindi non c'è la certezza che alla fine del proprio cavo ci sia proprio la NIC con quel MAC. La corrispondenza è un \"dove inoltrare per andare verso quel MAC\";\n- ***Flood*** - Se lo switch non conosce il MAC Address di destinazione si comporterà da ***hub***, inoltrando il frame in broadcast su tutte le altre porte. Solo il diretto interessato risponderà, di fatto passando per lo switch e facendogli imparare la sua associazione;\n- ***Forward*** - Se so già tutto, reindirizzo in scioltezza. Mentre il router legge l'header di rete e sostituisce l'header di link, lo switch si limita a reindirizzare.\n\nOpera all'interno delle reti locali, e comprende il compito di inoltrare i frame al gateway router, il quale poi se la vede con Internet.\n\nAnche lo switch ha un MAC e un IP, in caso serva configurarlo (e.g. con Telnet, o SSH). Fintantoché il traffico non è rivolto esattamente a lui, questi restano inutilizzati.\n\nRiassumendo, il compito dello switch è apprendere gli indirizzi MAC per reindirizzare correttamente i messaggi rivolti a quei MAC. Ma se non conosco il MAC?","x":3,"y":4240,"width":752,"height":696,"color":"4"},
		{"id":"c3187d1caf5835bf","type":"text","text":"# Quindi cosa serve per comunicare?\n\nSe voglio comunicare ***in locale***, mi bastano due informazioni:\n\n- il mio ***IP***;\n- la ***maschera di sottorete***.\n\nAl resto pensa ARP.\n\nSe voglio comunicare ***al di fuori della mia sottorete***, mi servono ***anche***\n- ***IP del router*** (default gateway)\n- ***IP di un server DNS***.\n\nTutto questo viene configurato automaticamente al momento della creazione della connessione dal DHCP.","x":3,"y":5580,"width":752,"height":408,"color":"4"},
		{"id":"f537b296b73bc81b","type":"text","text":"# Protocollo ARP\n\nPer comunicare il LAN devo conoscere l'indirizzo MAC del destinatario. Assumiamo di conoscerne già l'IP. Verifico prima di tutto che sia dentro la LAN (altrimenti devo passare dal router). Come? Confrontando il mio IP col suo attraverso la subnet mask.\n\n- Se l'IP che voglio raggiungere è in locale ma non so il suo MAC Address mando broadcast una ***richiesta ARP*** (RFC 826), includendo la mia coppia (IP, MAC) (una cosa del tipo `se hai IP 192.168.1.10, manda il tuo MAC alla coppia IP = 192.168.1.20 e MAC = AB:AD:DE:AD:CA:FE`. Chi non ha questo IP semplicemente ignora il messaggio). L'interessato riceve la richiesta, si segna la mia coppia (IP, MAC) nella ***cache ARP*** (associando un `TTL` tipicamente e procede a rispondermi unicast (perché a questo punto sa il mio MAC) con la sua coppia;\n- Se l'IP che voglio raggiungere NON è in locale devo passare dal gateway router. Faccio ARP sul gateway router (il cui IP è impostato di default come parametro di connessione), dopodiché se la vede lui con le proprie tabelle di routing. Questo ovviamente avviene solo la prima volta. Preso il MAC del gateway, se la vede lui.\n\t- Nota che alla stessa porta possono corrispondere diversi MAC. La porta fisica è \"dove andare per raggiungere questo MAC\", non \"SOLO questo MAC\"!","x":3,"y":4992,"width":752,"height":510,"color":"4"},
		{"id":"0276409902e40e9c","type":"text","text":"## Tradurre \"bursty\" in matematica\n\nCi sono $n$ utenti, ognuno dei quali ha una (bassa) probabilità $p$ di essere attivo in un dato istante. Quanti utenti sono attivi contemporaneamente?\nOvviamente problema binomiale.\n\n$$\nP(x) = \\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$\nda cui segue la cumulativa (qui nel caso $x > k$)\n\n$$\nP(x > k) = \\sum^n_{i = k}\\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$","x":-5736,"y":1988,"width":700,"height":326,"color":"4"},
		{"id":"8ca68ef0d9cba75a","type":"text","text":"# Where stack protocollare?\n\nOvunque sia necessario far comunicare più elaboratori, in un range che spazia da una semplice LAN fino all'Internet.\n\nSu **LAN** si possono trovare diversi esempi di stack protocollari proprietarie nate tra gli anni '70 e '90, come **NetBIOS** (**Microsoft**) o **AppleTalk**.\n\nCon l'avvento di **_Internet_** si è però tutto uniformato a **_TCP/IP_**, rimasto praticamente l'unico ad oggi in uso.","x":-5736,"y":3682,"width":700,"height":278,"color":"4"},
		{"id":"f6c22dc935238119","type":"text","text":"# Protocolli e Servizi\n\nIl servizio è il **_cosa_** garantisco (e.g. in questo caso un insieme di primitive che uno strato offre a quello superiore), il protocollo è **_come_** implemento il servizio.\n\n```\nServizio del livello di trasporto: \"Usa la mia primitiva INVIA. Ti garantisco che i tuoi pacchetti arriveranno a destinazione tutti e in ordine, se si disordinano ci penso io a rimetterli a posto\"\nProtocollo del livello di trasporto: TCP\n```\n\nOgni layer, secondo il proprio protocollo, implementa dei servizi usando le proprie risorse e i servizi forniti dal livello sottostante.\n\n Tramite i servizi si possono vedere i layer come delle **_black box_** $\\Rightarrow$ ci si può dimenticare dell'implementazione (protocollo) sottostante in favore di una vista di più alto livello che consta di input e output (servizi e/o informazioni).","x":-5736,"y":3190,"width":700,"height":440,"color":"4"},
		{"id":"1bd86960d6e5a8e2","type":"text","text":"# Stack protocollare","x":-3960,"y":3643,"width":336,"height":50,"color":"6"},
		{"id":"f528096ce03bdf37","type":"text","text":"# Errori da Interferenza\n\nIl rumore esterno può distorcere il segnale che transita sul cavo, flippando i bit.\n\nGli errori da interferenza sono spesso ***bursty***: il segnale distorcente capita \"ogni tanto\" ed è \"lento\" rispetto alla velocità del segnale, quindi è più probabile avere un errore su tanti bit consecutivi (***finestra di interferenza***) piuttosto che su uno solo (e.g. se trasferisco a $1\\,Kbps$, un rumore che dura $1\\,ms$ influisce su $10\\,bit$).\n\nIn generale, per rilevare questi errori vengono aggiunti in coda al frame degli ***Error Detection and Correction bits*** (***EDC***). E cosa ci faccio?\n\n- ***Parity Checking*** - Aggiungo un solo EDC in coda, in modo che la somma tra esso e tutti i bit del messaggio sia pari. Se a destinazione non lo è, vuol dire che c'è stato un errore. Naturalmente questo ***non garantisce di individuare gli errori***:\n\t- Un numero pari di errori conserva la parità;\n\t- Se il check non torna posso solo dire che c'è stato un numero dispari di errori.\n\t- Non ho informazioni su dov'è l'errore, quindi non posso recuperarlo;\n- ***Parity Checking Bidimensionale*** - Metto i bit del frame su una matrice e faccio checksum su ogni riga e ogni colonna. Se so che c'è un solo errore lo trovo facilmente (sono sbagliati i checksum di una sola riga ed una sola colonna), ma restano i problemi del numero pari di errori. Ci si può divertire a ideare esempi in cui questo checksum funziona o meno;\n- ***Cyclic Redundancy Check*** (***CRC***) - Mittente e destinatario concordano una sequenza di bit detta **divisore** (o **generatore**, indicato con $G$) per generare una sorta di **digest hash** $R$ a partire dai bit del frame ($D$). Segue procedura:\n\t- Se $G$ consta di $n$ bit, aggiungo a $D$ $n-1$ zeri a destra creando $D'$; \n\t- Svolgo $D'\\,\\%\\,G = R$. Il resto della divisione intera modulo 2 ha un bit in meno del divisore, quindi $R$ ha $n-1$ bit;\n\t- Al posto degli $n-1$ zeri che ho aggiunto a $D$ per creare $D'$ metto gli $n-1$ bit di $R$, creando il messaggio $D''$ (in cui i bit di $R$ sono gli EDC);\n\t- A destinazione svolgo $D''\\,\\%\\,G$, che a questo punto deve darmi esattamente $0$, altrimenti sono certo di aver individuato un errore.\n\nCRC è ottimo se si vuole essere certi di identificare la presenza di un errore, ma non dice niente su dove si è verificato o su come recuperarlo.\n\n Per recuperare dagli errori (utile se ho un canale con altissima latenza come un satellite) si usano gli ***Error Correction Codes*** come ***Hamming***, ***Reed-Solomon***, ***BCH*** ed ***LDPC*** (sui quali non mi azzardo a dire altro se non che esistono).","x":3,"y":2600,"width":752,"height":1000,"color":"4"},
		{"id":"93755965c6d5798d","type":"text","text":"# LAN","x":318,"y":4060,"width":123,"height":41,"color":"6"},
		{"id":"fb762a569bae98d0","type":"text","text":"\nQualunque oggetto in grado di comunicare su internet scambiando traffico dati è detto ***Host***.\n\nTipicamente, quando si avvia una comunicazione tra host, questi si distinguono in ***client***, che avvia la richiesta di comunicazione, e ***server***, che risponde a tale richiesta.\n\nUn server è un host su cui gira un processo server in grado di rispondere alle richieste esterne.\n","x":-9959,"y":4292,"width":559,"height":328},
		{"id":"c9c9037d39594e6d","type":"text","text":"# Dataflow\n\nComplessivamente, tutto il traffico di Internet è interamente determinato da tre oggetti:\n\n- MAC Address Table - Mappa gli indirizzi MAC in porte fisiche (switchports);\n- ARP Table/Cache - Mappa gli indirizzi IP in indirizzi MAC;\n- Routing Table - Indirizza i datagrammi (contenenti gli indirizzi IP) al prossimo router.\n\nPercHé avvenga il flusso di informazioni, se uso la RT poi userò anche la ARP.","x":-788,"y":5907,"width":619,"height":358},
		{"id":"82a06f2b58f08c38","type":"file","file":"0 - Stack Protocollare/Screenshot from 2024-05-01 16-10-50.png","x":-788,"y":5680,"width":390,"height":126},
		{"id":"9d135ba1fbe86052","type":"text","text":"# VLAN (Virtual LAN)\n\nSe volessi dividere una rete in due sottoreti? Posso mettere un router e creare una nuova LAN, certo, ma introduco complessità (nonché il livello di Rete, qua stiamo in DLL!).\n\nPosso invece dividere le porte di un singolo switch fisico in due gruppi distinti, e costruire le tabelle MAC come se ogni gruppo fosse uno switch fisico separato dall'altro. Proprio come fossero fisicamente separati, questi ***switch virtuali*** così costruiti sono indipendenti l'uno dall'altro, e ad ognuno di essi corrisponde una ***LAN Virtuale*** (***VLAN***).\n\nSi sa, virtualizzare apre sempre le porte alle magie perché introduce il SW. Inoltre, la topologia virtuale non è vincolata alla topologia fisica.\n\nPosso assegnare ad ogni VLAN un codice identificativo (***VLAN Tag***) e collegare la `VLAN 10` di uno switch fisico con la `VLAN 10` di un altro tramite cavo (***Access***), creando un singolo switch virtuale fisicamente delocalizzato.\n\nSe voglio collegare diverse VLAN di uno switch fisico ad un altro switch fisico devo usare un cavo Access per ciascuna? No, esistono cavi che collegano in blocco più VLAN (detti ***Trunk***). C'è un campo dell'header per il VLAN Tag (`ID`, impostato dallo switch quando invia il frame su un Trunk) che serve allo switch fisico di destinazione per demultiplexare.\n\n- E se mi arriva un frame senza VLAN Tag? Definisco una ***Native VLAN*** a cui indirizzare di default i frame senza Tag.\n\t- Non serve solo a questo! Ipotizziamo la Native sia `ID = 10`. Se arriva una frame da un Access della VLAN `30`, lo switch controlla se `30` è la Native. Non lo è, allora mette il tag `30` e invia. Se invece arriva un frame da un Access della Native (`10` in questo esempio), lo switch non mette alcun tag!\n\t- I ***Trunk*** sono connessi alle ***Tagged Ports***, gli ***Access*** alle ***Untagged Ports***. La Native VLAN è l'unica che attraversa un Tagged Link senza Tag.\n- ***802.1q*** è la variante del protocollo Ethernet che include i VLAN Tag;","x":960,"y":4240,"width":780,"height":769,"color":"4"},
		{"id":"e1a9fb50e854767d","type":"text","text":"# Indirizzi MAC\n\nOgni scheda di rete (***Network Interface Card, NIC***) è identificata univocamente da un codice a $48\\,bit$, divisi in 6 gruppi da 8 e rappresentati ciascuno con due cifre esadecimali (e.g. `01:00:00:0F.A1.0A` corrisponde a `1:0:0:15:161:15`). Ogni numero decimale separato dai `:` va da `0` a `255`.\n\nIn cima alla catena alimentare dell'assegnazione dei MAC c'è la IEEE, che assegna ai produttori di NIC un ***Organizationally Unique Identifier*** (***OUI***). Questo codice a $24\\,bit$ diventerà l'incipit dei MAC Address prodotti da quel vendor. Ma non solo: si possono ricavare informazioni sul NIC a partire da alcuni bit di questo codice. Poniamo che sia  `xxxxxxBA:yyyyyyyy:zzzzzzzz`.\n\n- Se `A = 0` significa che il NIC è abilitato alle sole trasmissioni ***unicast***, ovvero i NIC che ricevono il frame confrontano il MAC di destinazione con il proprio e lo buttano se i due non coincidono (a meno di attivare la **promiscuous mode**). `A = 1`, viceversa, consente il ***multicast***. Il NIC ricevente (che pure deve avere `A = 1`) confronta il MAC di destinazione con un elenco di indirizzi multicast per decidere se accettare o meno il frame;\n- `B = 0` indica che l'indirizzo MAC è proprio quello assegnato dal vendor (***Universally Administrated***). Perché, ce ne possono essere altri? Già. Questo MAC è *hard-coded* dal vendor, ma io localmente posso scegliere di cambiarlo a patto di mettere `B = 1` (***Locally Administrated***). Quindi, ogni OUI ha `B = 0`;\n- Per altre informazioni prendi un MAC Address e mettilo su [questo sito](https://macaddress.io/mac-address-lookup/wkWqJz7E2K).\n\nOltre al MAC esistono altri formati per gli indirizzi fisici (e.g. **EUI**, **Extended Unique Identifier**), così come diverse lunghezze (e.g. 64 bit).","x":-980,"y":4240,"width":791,"height":696,"color":"4"},
		{"id":"05c3b8792f604a34","type":"text","text":"# Glossario del Data Link Layer\n\n- ***Data Link Control (DLC)*** - protocollo che definisce la comunicazione hop-to-hop (unicast e non) sul canale condiviso da due host (e.g. incapsulamento, checksum);\n- ***Media Access Control (MAC)*** - protocollo che definisce la comunicazione broadcast;\n\t- Diverso è l'***indirizzo MAC***, che identifica univocamente una ***Network Interface Card*** (***NIC***, e.g. Ethernet, scheda Wi-Fi).\n- ***Flooding*** - Azione di uno switch. Inoltra un frame proveniente da una porta a tutte le altre porte;\n- ***Unicast*** - Un tipo di frame in cui il MAC di destinazione identifica un singolo host. Uno switch può eseguire un'azione di flooding se non conosce il MAC di destinazione;\n- ***Broadcast*** - Un tipo di frame in cui il MAC (i.e. `FF:FF:FF:FF:FF:FF`) indica allo switch di fare flooding. Un host che si vede recapitare un broadcast può decidere se accettarlo o meno, a seconda della configurazione;\n- Un ***canale di comunicazione*** (e.g. cavo Ethernet) può essere\n\t- ***Half-Duplex*** - Supporta trasmissione bidirezionale non contemporanea;\n\t- ***Full-Duplex*** - Supporta trasmissione bidirezionale contemporanea.\n- ***Network Interface Card (NIC)*** - Scheda di rete associata ad un canale di comunicazione ed identificata univocamente da un MAC Address. Collegata all'HW del computer attraverso il BUS, avente un firmware e gestita da un controller SW. Insomma, una periferica.","x":-980,"y":2897,"width":791,"height":703,"color":"4"},
		{"id":"7d6a530421499f12","type":"file","file":"ARPFormat.png","x":-854,"y":5133,"width":540,"height":228},
		{"id":"9f731eac72823c6c","type":"text","text":"# Livello di Collegamento\n\nGestisce il ***trasferimento hop-to-hop*** dei frame.","x":163,"y":3840,"width":432,"height":100,"color":"6"},
		{"id":"2f11157c3ad03b20","type":"text","text":"# Wireless LAN (WLAN)\n\nSi basa sulla presenza di ripetitori (***base station*** per i dati mobili, ***access point*** per le WLAN domestiche) collegati alla rete cablata che propagano onde sferiche. È una trasmissione ***broadcast*** in cui il mezzo condiviso è l'aria.\n\nEsiste anche un paradigma non centralizzato in cui ogni host può comunicare direttamente con ogni altro (***rete ad-hoc*** o ***standalone***, protocolli ***WiFi Direct***) in cui il routing non è centralizzato (***rete mesh***).\n\nSembra semplice: arrivano onde EM e le ricevo. In realtà ci sono tre problemi principali:\n\n- ***Propagazione multi-path*** - quando il segnale sbatte contro una parete, questo viene in gran parte riflesso. Questo significa che l'host riceve una fauna di onde casualmente sfasate da tutte le direzioni (la distribuzione del segnale data dalle pareti di una stanza è un sistema caotico). Quando arrivano segnali sfasati in teoria ci sarebbero i battimenti (disastro a livello di segnale), ma gli access point sono intelligenti. Hanno più antenne e sono abbastanza in grado di ***ricostruire l'informazione di partenza***, a volte anche a potenziarla sommando in fase le due onde;\n\t- Quindi all'esterno questo problema non c'è? Purtroppo c'è, parte del segnale su grandi distanze rimbalza sulla ionosfera, ma un cellulare può ricostruire il segnale a partire da questi rimbalzi;\n- ***Attenuazione del segnale*** - La potenza si conserva sulla sfera, quindi cala come $1/r^2$;\n\t- Come conseguenza, è difficile rilevare una collisione come previsto da CSMA/CD, perché quando parlo la mia voce è molto più forte del segnale che ricevo (lo chiameremo simpaticamente ***problema dell'uomo sulla montagna***);\n\t\t- Le soluzioni richiedono o troppo effort energetico o HW troppo complicato;\n\t\t- Anche se fosse, A che parla con B può sottrarre il proprio rumore ma non può sottrarre il rumore di terminali che non conosce, ad esempio C, mentre quest'ultimo nemmeno se ne accorge (***hidden terminal problem***);\n\t- Se il segnale si attenua troppo può confondersi col ***rumore***, per cui si definisce un ***Signal to Noise Ratio*** (***SNR***);\n- ***Interferenze*** - Più ripetitori che usano le stesse frequenze possono interferire a destinazione. Anche il multi-path è considerabile un'interferenza\n\nLa IEEE stabilisce come standard ***802.11*** (cui segue una lettera ad indicare le specifiche tecniche, come frequenze utilizzate e larghezza di banda). L'equivalente di una LAN in cui l'access point fa le veci di uno switch è detto ***Basic Service Set*** (***BSS***). Più BSS organizzati in modo gerarchico formano un ***Extended Service Set*** (***ESS***).","x":960,"y":2600,"width":780,"height":1000,"color":"4"},
		{"id":"bf64a19397872fe0","type":"text","text":"# CSMA/CA\n\nIn virtù del **problema dell'uomo sulla montagna** e dell'**hidden terminal problem** non posso usare Collision Detection. Allora implemento una ***Collision Avoidance*** (***CA***), cioè evito a priori che si possano mai verificare collisioni. Come?\n\nPer ovviare al problema dell'uomo sulla montagna:\n\n- Introduco degli intervalli tra un frame e l'altro, detti ***InterFrame Space*** (***IFS***);\n\t- Il mittente ascolta il canale per un tempo ***DIFS*** (***Distributed IFS***). Se Carrier Sense non rileva segnali in ingresso, al termine del DIFS manda il frame;\n\t- Se il destinatario riceve il frame senza interferenze, aspetta un tempo ***SIFS*** (***Short IFS***, di durata $SIFS < DIFS$) e manda un ***ACK*** di conferma;\n- Introduco una ***finestra di contesa*** per stabilire la durata del DIFS;\n\t- La grandezza della finestra segue il [[Backoff Esponenziale]];\n\nPer ovviare al problema del terminale nascosto:\n\n- Introduco un meccanismo di ***prenotazione del canale***:\n\t- La sorgente (A) aspetta un DIFS e manda una ***Request To Send*** (***RTS***), con cui comunica alla destinazione (B) quanti dati vuole mandare e per quanto tempo serve prenotare il canale. Tale tempo è detto ***NAV*** (***Network Allocation Vector***);\n\t- Se B riceve RTS senza interferenze, attende un SIFS e manda a tutti un messaggio ***Clear To Send*** (***CTS***) con cui \n\t\t- avvisa la sorgente che può procedere a inviare;\n\t\t\t- Se A non riceve il CTS assume che il canale non sia libero, aggiorna il backoff esponenziale e riprova dopo un tempo estratto casualmente;\n\t\t- invita tutti gli altri (compresi gli hidden terminal C) a starsi zitti finché non finisce il NAV;\n\t\t\t- Se C sta già ricevendo qualcos'altro potrebbe non sentire il CTS;\n\t\t\t- Questo potrebbe bloccare anche comunicazioni che non avrebbero interferito con A e B (B urla a tutti di fare silenzio anche quando non è strettamente necessario);\n\t- Una volta che il canale è prenotato, A aspetta solo un SIFS piuttosto che un DIFS;\n\t- Questo meccanismo viene usato solo per pacchetti \"grandi\".\n","x":1934,"y":2600,"width":760,"height":1000,"color":"4"},
		{"id":"a748d731a69642c5","type":"text","text":"# Aloha\n\nInvia subito il frame, dopodiché se c'è stata una collisione aspetta un tempo estratto casualmente e riprova. Questo **assume che tutti i nodi siano in grado di rilevare le collisioni**. Ci sono due possibili implementazioni:\n\n- ***Slotted Aloha*** - Il più usato. Divide il tempo in slot, assumendo che tutti i frame abbiano la stessa dimensione e che tutti i nodi siano sincronizzati. Se avviene una collisione, a partire dallo slot successivo ogni nodo ha una probabilità $p$ di ritrasmettere. $p$ è estratta casualmente, altrimenti sarebbe molto probabile generare altre collisioni;\n\t- Abbastanza semplice: l'unica sincronizzazione è sugli slot;\n\t- Se c'è un solo nodo a trasmettere, può usare tutta la banda;\n\t- Per $N \\to \\infty$ nodi, la binomiale restituisce un'efficienza massima $1/e \\simeq 37\\%$;\n\t- Di contro, a seguito di collisioni potrebbero esserci slot inutilizzati;\n- ***Pure Aloha*** - Più semplice, ma meno efficiente. Non richiede nemmeno quel minimo di sincronizzazione degli slot, ma di contro aumenta la probabilità di collisione;\n\t- Ogni frame ha un ***tempo di vulnerabilità*** di $2\\,t_T$ (tempo di trasmissione), perché può fare overlap con un altro frame\n\t\t- che è partito fino a $1\\,t_T$ prima di lui;\n\t\t- che parte prima che sia stato trasmesso completamente ($1\\,t_T$);\n\t- Efficienza misurata $\\simeq 18\\%$.","x":4480,"y":4240,"width":700,"height":623,"color":"4"},
		{"id":"5d7e25930cb4c399","type":"file","file":"2 - Data Link Layer/SlottedAloha.png","x":4480,"y":4920,"width":700,"height":181},
		{"id":"c1b511e910f4bc8e","type":"text","text":"## ... e il principio di sovrapposizione?!\n\nSe la collisione non avviene a destinazione, che mi importa? Vale il principio di sovrapposizione, per cui due onde dopo aver fatto interferenza tornano esattamente come prima, no?\n\n... no. Siamo in un cavo, non nel vuoto. La propagazione sfrutta le proprietà elettriche del mezzo, motivo per cui una sovrapposizione può indurre fenomeni non lineari o interferenze distruttive che non propagano il segnale.","x":4480,"y":2470,"width":700,"height":260,"color":"4"},
		{"id":"68a80636908ff1d0","type":"text","text":"# CSMA/CD\n\n***Carrier Sense Multiple Access*** (***CSMA***) stabilisce delle regole per evitare che ci siano collisioni:\n\n- Se il canale è libero, invia l'intero frame;\n- Se il canale è occupato riprova più tardi.\n\nQuesto però non evita di per sé le collisioni: dal momento che la velocità di propagazione del segnale è finita, mentre A osserva che il canale è libero ed inizia a trasmettere, dall'altro lato del cavo B può aver già iniziato la trasmissione. Questo significa che da quando B inizia a trasmettere c'è un ***tempo di vulnerabilità*** pari ad un tempo di propagazione $t_P$ entro il quale A non dovrebbe mandare messaggi, pena la loro sovrapposizione.\n\nE se li manda lo stesso? Nel momento in cui rilevo una collisione (ovvero, mi rendo conto che arrivano dati mentre io sto trasmettendo) introduco un meccanismo di ***Collision Detection*** (***CD***) che interrompe la mia trasmissione.\n\nLa cosa importante, insomma, è essere in grado di rilevare la collisione. La chiave sta nella dimensione minima del frame che viene inviato. Perché il CD funzioni, il mittente deve poter rilevare la trasmissione in ingresso mentre sta trasmettendo, ovvero prima di inviare l’ultimo bit del proprio frame. Il caso peggiore è quello in cui B inizia a trasmettere un attimo prima di ricevere i primi bit da A, per cui prima che A si renda conto di questa collisione passerà $\\sim 2t_P$. \n\nQuindi è sufficiente porre per ogni frame un ***tempo di trasmissione minimo di ***$2t_P$.","x":4480,"y":2860,"width":700,"height":740,"color":"3"},
		{"id":"cfe34563fe1c4a2e","type":"text","text":"# Tipi di frame 802.11\n\nLe informazioni sul tipo di messaggio sono contenute nei primi $2\\,byte$ dell'header 802.11.\n\nIn particolare si hanno\n\n- Due bit che identificano la categoria del messaggio (e.g. `00` è un frame di gestione, `10` un frame di dati);\n- Quattro bit che specificano un tipo entro la categoria. Entro i frame di controllo `01` troviamo RTS (`1011`), CTS (`1100`) e ACK (`1101`);\n- Due bit (`To DS` e `From DS`) che spiegano come leggere i quattro indirizzi MAC che seguono all'interno dell'header, ovvero\n\t- `00` - Comunicazione ad-hoc (p2p);\n\t- `01`, `10` - Voglio parlare ad un altro nodo tramite AP (come comunicare in LAN tramite uno switch);\n\t- `11` - Devo passare per diversi AP per raggiungere la mia destinazione (e.g. in aeroporto ci sono tanti AP diversi ma con lo stesso SSID che comunicano tra loro)\n\nIl formato del frame 802.11 è convertibile in Ethernet in modo semplice.","x":2820,"y":2600,"width":780,"height":540,"color":"4"},
		{"id":"e658737db3a8ad38","type":"text","text":"# Accesso Casuale\n\nSi basano su due possibili approcci:\n\n- Cerco di impedire le collisioni (e.g. ***CSMA/CD***);\n- Cerco di recuperare dalle collisioni (e.g. ***Aloha***)","x":4603,"y":3802,"width":455,"height":177,"color":"6"},
		{"id":"bd21e4f69b2002f0","type":"file","file":"PrenotazioneCanale.png","x":3200,"y":3261,"width":400,"height":279},
		{"id":"e8c2c4b82c00f3af","type":"text","text":"# Ethernet CSMA/CD\n\nProtocollo per regolamentare il \"vecchio\" Ethernet a cavo condiviso (adesso è punto-punto, si collega direttamente ad una porta fisica dello switch o del router.\n\nSi articola in diversi passaggi, in cui la scheda di rete (NIC)\n\n1. riceve il datagramma dal livello di rete e crea il frame;\n2. ascolta (*sense*) il canale:\n\t- se è inattivo avvia la trasmissione;\n\t- se è occupato attende che si liberi, quindi trasmette (1-persistente);\n3. trasmette il frame, restando in ascolto per eventuali collisioni;\n\t- Se non avvengono collisioni, tutto ok;\n\t- Altrimenti, interrompe la trasmissione e invia un segnale di `jam` ($48\\,bit$, avvisa tutti gli altri NIC);\n\t\t- Dopo questa comunicazione, il NIC entra in fase di ***backoff binario***:\n\t\t\t- dopo l'$n$-esima collisione, il NIC estrae a caso un valore $k$ nell'intervallo $[0, 2^n-1]$, attende $k$ slot ($\\Rightarrow$ tempo per tramettere un frame di $512\\,bit$) e torna al punto 2;\n\t\t\t- più collisioni allungano l'intervallo di backoff;\n\t\t\t- I tempi si aggiornano in modo un po' caotico, non è ovvio prevederne il comportamento a livello teorico.\n\nEmpiricamente, l'efficienza di questo algoritmo in condizioni ragionevoli è $\\simeq 50\\%$. Facendo probabilmente dei calcoli che non mi va di fare si può arrivare all'espressione$$\\eta = \\frac{1}{1 + 5\\frac{t_{P}}{t_{T}}}$$","x":5820,"y":2860,"width":700,"height":740,"color":"4"},
		{"id":"3157cc90e4c3c62e","type":"text","text":"# Ethernet\n\nSe in origine la tecnologia Ethernet usava un cavo condiviso o un ***hub*** (che prendeva più cavi e li rendeva di fatto un cavo condiviso), oggi è sostanzialmente sempre punto-punto (**full-duplex**) con l'ausilio degli ***switch***.\n\nUn frame Ethernet si suddivide nel seguente modo:\n\n- ***Preambolo*** - Serve a sincronizzare la frequenza di invio dei dati con quella di lettura. A sua volta diviso in due parti:\n\t- i primi 7 byte (`10101010`) servono a dare il tempo a chi ascolta di adattarsi alla frequenza;\n\t- l'ultimo, detto **Start Frame Delimiter** (**SFD**, `10101011`) segna l'inizio del messaggio;\n- **Indirizzi di destinazione e sorgente**;\n- ***Type*** - Identificativo del protocollo di rete da usare per demultiplexare (tipicamente è IP);\n- ***Dati*** - C'è una ***lunghezza minima*** (**46 byte**) che insieme alla lunghezza massima del cavo garantisce che CSMA/CD sia in grado di identificare le collisioni. Se non li raggiungo faccio ***padding***;\n- ***CRC*** - Controllo degli errori.\n\nEsistono diverse implementazioni di Ethernet per adattarsi al tipo di canale (i.e. full-duplex o half-duplex) e al tipo di mezzo (e.g. doppino intrecciato, fibra ottica).","x":6708,"y":2860,"width":612,"height":740,"color":"4"},
		{"id":"bbae9deb840c71de","type":"file","file":"2 - Data Link Layer/CSMA_CD.png","x":5347,"y":3337,"width":306,"height":263},
		{"id":"0a4f8fcdbbf562f6","type":"text","text":"# CDMA\n\n***Code Division Multiple Access*** (***CDMA***) è un metodo per consentire la trasmissione simultanea di diverse sorgenti su un singolo canale, utilizzando dei ***codici personali per demultiplexare le informazioni***.\n\nI codici sono sequenze ortogonali (***chip***) tali che\n- $\\langle i|j\\rangle$ = $\\delta_{ij}$\n- $|i|^2 = N$, dove N è il numero di stazioni che comunicano sul canale condiviso;\n\t- Per come vengono generati i codici ortogonali (tabelle di Walsh), ne escono fuori sempre $2^n$. Scegliere $N = 2^n$ significa ottimizzare il numero di stazioni che sfruttano quei codici (sicuramente deve essere $N\\leq2^n$);\n\nQuesti chip si accompagnano ad ogni bit inviato. `1` resta `1`, mentre `0` ***viene mappato nel segnale*** `-1`. Questo perché il silenzio (`0`) non è un segnale!\n\nCDMA viene usato nella telefonia mobile. I codici vengono assegnati agli host dalla cella, che\n\n- è l'unica a conoscerli tutti;\n- deve usare codici ortogonali alle celle vicine.\n\nIn realtà ci sono dei codici hard-coded nel telefono, il quale li testa per trovare il match migliore con la cella più veloce.\n\nIn passato CDMA è stato usato anche come codice di crittografia, ma i segnali non sono veramente casuali e un attaccante bravo può risalire al messaggio.","x":3720,"y":2603,"width":535,"height":997,"color":"4"},
		{"id":"38f42aa977e02595","type":"text","text":"# (\"... comunque lo vedremo meglio\")\n\nnon ci sono computer, solo router che fanno commutazione di pacchetto (= forwarding = switching: qualcosa entra da una porta, lo faccio uscire da un'altra, ognuno ha una tabella di corrispondenze, è na roba LOCALE). NON sa che percorso farà. Ma chi le scrive le tabelle? Serve sapere i percorsi -> serve Algoritmo di Instradamento. Il ROUTING è un'azione GLOBALE.\n\nforwarding: come mi devo mettere; routing: coreografia\n\nstore and forward: prima ricevo tutto, poi mando. na specie de buffering. Pushare il pacchetto nel cavo = trasmettere, ergo se devo mettere L bit di pacchetto a velocità R bit/s ci metto L/R secondi ed è detto ritardo di trasmissione (trasmissione è solo l'uploat del pacchetto nel collegamento (cavo), poi c'è delay di trasporto ma spesso è trascurabile). \"modulare il segnale nel cavo\". ogni router che trasmette (HOP) porta un ritardo +L/R. Se poi mi interessa il delay del segnale totale trasportato da N pacchetti moltiplico per N. Poi c'è ritardo di accodamento (vedi slides).\n\nTEORIA DELLE CODE???\n\nA - algoritmo per ottimizzare commutaizone di circuito?\n\nSe multiplexo sulle frequenze (costo alto) mitigo il problema delle code. Posso farlo anche sul tempo (costo minore, eg bluetooth), ma sono a rischio latenza. Qual è meglio? Dipende da che ci devo fare. Comm di circuito però non si usa su Internet. cellulari usano entrambi. pacchetto consente a più utenti di usare la rete. Internet è _bursty_, impulsiva, dati inframezzati da lunghi silenzi. Mi baso sul fatto che molti stanno zitti per permettere a più persone di parlare (e.g. se ho 35 utenti P(attivi>20) $\\sim$ poco, conto con binomiale). se uso comm circuito dedico una linea fissa e non sfrutto le \"caratteristiche\" degli utenti (che stanno spesso zitti).\n\nSe mando un pacchetto su Internet non ho garanzie che arrivi a destinazione. Tutti i tentativi per dare garanzie (ovvero strutturare diversamente i protocolli) hanno fallito miseramente. Comm di circuito garantisce, ma se non comunico spreco risorse. \"Internet è accettare che tutti provano e provare a risolvere quando si creano problemi\".\n\nISP punto debole di interet, in mano ai grandi fornitori. interconnessi, guidati dagli interessi aziendali più che geografici. Abbiamo milioni di ISP di accesso. Li collego tutti tra loro? No, è $O(n^2)$. Inizialmente: ISP di transito globale a fare da centralino (pagato da ISP locali). Ora ci sono tanti ISP globali collegati da IXP (internet exchange point, collegamento di peering). La rete degli IXP ha una rete dei content provider.\n\nSegue discorso sulla legislazione perché sta roba dà un sacco di potere\n\n","x":1900,"y":-2341,"width":640,"height":1120,"color":"1"},
		{"id":"45b932caa35cd5e2","type":"text","text":"# Rete (guarda slides) tipo intro ai termini\n\nrete = nodi (computer) collegati da collegamenti (link). Distinguo i nodi estremali (host (vuole usare il servizio) o server (lo fornisce), non è una distinzione rigida) e quelli di interconnessione (router collega due reti o switch collegano terminali in locale). Dispositivi che possono scambiarsi info. Durante i passaggi di info queste spesso si modificano (fisico, quindi amplificazione, o tenere traccia del passaggio. esistono anche trasmissioni trasparenti).\n\nperiferia della rete -> host e server\nrete di accesso: utenti (problemi: max utenti per antenna)\nnucleo di rete: router interconnessi che fanno interagire sottoreti indirizzando il traffico\n\n(guarda slides)\n\nreti via cavo: tutto collegato allo stesso cavo condiviso. ogni casa ha splitter e modem.\n\nasimmetria: ci si aspetta che l'host scarichi più di quanto carica\n\na casa modem, router e access point sono integrati nello stesso coso.\n\n\"half duplex\" -> mentre trasmetto non posso ricevere. Questo perché la potenza del segnale scende come 1/r^2, e chi riceve vede un segnale debole -> non può trasmettere a sua volta, perché copro il segnale debole. Questo per il wifi e simili, su cavo faccio come voglio.\n\nsplitting di frequenze (anche su stesso cavo) ha costo (multiplexing?), nell'esempio del cavo sopra (credo) sia tutto su stessa frequenza.\n\n\n","x":1210,"y":-2260,"width":640,"height":860,"color":"1"},
		{"id":"435d7ec357e56abd","type":"text","text":"# prestazioni slides 3\n\nthroughput è una misura a regime (un po' una misura del bitrate effettivo, ed è sistematicamente minore o uguale). è il flusso/portata della fluidodinamica. Non basta un ping (singolo bit, quello misura la latenza).\ncolli di bottiglia creano grossi problemi su internet, ma non nelle dorsali (backbone, sono enormi), quanto quelli che si collegano.\ntutto questo comunque resta molto teorico perché non considero perdite e ritardi, all'atto pratico misuro per sapere quant'è.\nSeguono i ritardi che sommati fanno la latenza\n- processamento (elaborazione del pacchetto: controllo errori, switching, ... tipicamente svariati odg meno degli altri)\n- Trasmissione (tutta  la dipendenza dalla grandezza del pacchetto è qua)\n- Accodamento (queuing delay, dipende dal traffico, difficile da calcolare, c'è teoria delle code)\n- propagazione (SOLO lunghezza del cavo, satellite 300ms, cavo oceanico 30ms)\n\ni primi bit caricati in trasmissione non devono aspettare gli ultimi. Infatti, se ho n bit e ognuno ci mette m secondi, l'ultimo verrà processato dopo nxm secondi. Ma intanto il primo è partito. Magari è pure arrivato all'altro router, il quale però deve aspettare di ricevere tutto il pacchetto per inoltrarlo.\nAttenzione a fare pacchetti troppo grossi, il ritardo di trasmissione schizza alle stelle. (posso cambiarlo su pc con la mia connessione???)\n\nSe sto trasmettendo un pacchetto enorme con bassa velocità ci metto un botto, il che blocca la rete per tutti!\n\n","x":2560,"y":-2200,"width":640,"height":740,"color":"1"},
		{"id":"187dc42cfef0546d","type":"text","text":"# Appunti lezioni raw in rosso - magari poi ci faccio un txt","x":1988,"y":-2560,"width":465,"height":102,"color":"1"},
		{"id":"c3e8022233e42700","type":"text","text":"# Ritardi\n\n- accodamento (\"quando siamo fortunati non possiamo portarci avanti col lavoro) rivedilo che non ho capito cosa vuole dire (vedi animazione di due slides dopo, perdita di pacchetti, mettendo stesso rate di emission e transmission) --> se si riempie la coda perdo pacchetti --> un pacchetto perso ha tempo di attesa infinito\n\nse ci stanno dei loop nel percorso router i pacchetti intrappolati restano all'infinito? Devo metterci un cut-off -> tempo di vita (TTL time to live), spesso espresso in \"quanti altri router possono inoltrarlo\". Se il pacchetto muore in genere il router manda un feedback a chi glielo ha inviato (\"hey, il tuo pacchetto è morto). Se mando TTL sempre crescenti stimo il percorso (non proprio, nessuno mi dice che faccio sempre lo stesso $\\forall$ invio).\nPer vari motivi i router possono non rispondere quando muore il pacchetto. Se accetto i TTL potrei far leakare la struttura interna della rete. Se il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). TCP/IP capisce se è una perdita per traffico o casuale. Importante perché se perdo per traffico dovrei rallentare, altrimenti scialla.\n\n- rate\\*ritardo = numero massimo di bit nel buffer (-> definisce grandezza del buffer). volume del \"tubo\" di trasmissione. non utilissimo perché a me interessa il throughput, cioè la sezione\n\n","x":3220,"y":-2190,"width":640,"height":720,"color":"1"},
		{"id":"56958c816f8128f6","type":"text","text":"# Cenni sul macroargomento Sicurezza\n\nLa Sicurezza si occupa principalmente di garantire\n\n- ***Riservatezza*** - Solo il mittente e il destinatario devono essere a conoscenza del messaggio. Si può usare la ***crittografia***;\n- ***Autenticazione*** - Mittente e destinatario devono essere certi della rispettiva identità. Si possono usano le ***chiavi di RSA***;\n- ***Integrità*** - Bisogna poter garantire che il messaggio non sia stato danneggiato o manomesso, o rilevare questo evento se si verifica. Si può usare una ***funzione di hash***;\n- ***Disponibilità*** - Bisogna garantire l'accesso ai servizi.\n\nDa qui in poi Alice (A) e Bob (B) vorranno queste garanzie mentre comunicano, mentre la malvagia Trudy (T) proverà a fare qualcosa di cattivo (e.g. origliare o manomettere i messaggi).","x":-3213,"y":-1720,"width":583,"height":432,"color":"6"},
		{"id":"1c8430c176f6a96d","type":"file","file":"CSMA_CA.png","x":2820,"y":3200,"width":332,"height":400},
		{"id":"2c9a45f1836182ef","type":"file","file":"2 - Data Link Layer/PureAloha.png","x":4480,"y":5158,"width":700,"height":181},
		{"id":"33bc035ceb738a9a","type":"text","text":"\"sintonizzarsi\" su una frequenza significa campionare ad una certa frequenza con l'idea che le altre risultino \"rumore\" o medino a zero.","x":5530,"y":4321,"width":640,"height":198},
		{"id":"3b6b15d9eb09a426","type":"text","text":"# Protocolli MAC\n\nPrincìpi di non-collisione.\nFai CSMA+ prima di aloha\n\ncosa serve per un MAC -> CSMA\npoi ci sono protocolli basati su\n- partizionamenti\n- accesso casuale\n\t- aloha\n\t- ethernet\n- vie di mezzo (rotazione)","x":5610,"y":4646,"width":480,"height":440},
		{"id":"14824fb9cdf03d9f","type":"text","text":"# Reti punto-punto? Slides 22","x":5670,"y":5279,"width":412,"height":123},
		{"id":"6e77aa4e9440b128","type":"text","text":"# Persistenza\n\nI protocolli di accesso multiplo si possono dividere in tre categorie, a seconda del tipo di comportamento.\n\n- ***Non-Persistente*** - **CSMA** senza CD:\n\t- Se trova il canale libero trasmette subito;\n\t- Se trova il canale occupato desiste (riprova ad ascoltare dopo un tempo casuale);\n- ***p-Persistente*** - Se trova il canale occupato resta in ascolto (*persiste*) in attesa che si liberi. Quando il canale è libero trasmette con probabilità $p$ (e.g. **Slotted Aloha**);\n\t- ***1-Persistente*** - Un sottocaso di *p-persistenza* in cui $p = 1$, cioè se trova il canale libero trasmette subito (e.g. **Ethernet CSMA/CD**).\n\n\n","x":5233,"y":3681,"width":535,"height":419,"color":"4"},
		{"id":"d6095c8e59ae3f07","type":"text","text":"# aggiunte VLAN\n\nse voglio dividere due sottoreti posso mettere un router. problema: riduco flessibilità, introduco struttura gerarchica al posto di topologia piatta degli switch (è come se tutti fossero connessi a tutti)\n\nse un computer di una rete si sposta in un altra, con i router è un casino, dovrei spostare il cavo da una rete all'altra.\n\ncon la VLAN si fa tutto tramite SW. se qualcuno si sposta lo metto sull'altra VLAN (modo SW di ricablare la rete). broadcast solo tra stesso tag\n\nper passare da una VLAN all'altra devo passare per un router, oppure uso le porte trunk (modifico il protocollo! 802.1q, ma solo sui trunk)","x":1900,"y":4992,"width":508,"height":520},
		{"id":"f0c161be25e73aa9","type":"file","file":"2 - Data Link Layer/Confronto_VLAN_Header.png","x":975,"y":5407,"width":750,"height":173},
		{"id":"ea6978e20c848100","type":"file","file":"2 - Data Link Layer/802.1q.png","x":1068,"y":5100,"width":564,"height":220},
		{"id":"9782d3812a907a46","type":"file","file":"2 - Data Link Layer/VLAN_1.png","x":1854,"y":4336,"width":400,"height":223},
		{"id":"5c698a4734fe88d7","type":"text","text":"# Panoramica dei Primi Layer OSI\n\nUn ***hub*** è un ripetitore con più porte. Quando un segnale entra da una di esse, viene ripetuto in uscita su tutte le altre. Se ci sono host a cui questo segnale non interessa posso mettere un ***bridge***, ovvero un filtro. Il bridge impara quali host sono alla sua sinistra e alla sua destra, e se la comunicazione avviene solo da un lato impedisce al segnale di propagarsi nell'altra sottorete.\n\nSe unisco questi due concetti ottengo uno ***switch***, il quale associa ogni host connesso a una porta e reindirizza il messaggio solo al destinatario, senza fare broadcast su tutta la rete.\n\nFare **switching** significa reindirizzare dati all'interno di una rete, lo switch è un oggetto il cui scopo *principale* è lo switching.\n\nGli switch sono in genere il nodo radice di una sottorete contenente host con necessità simili (e.g. una LAN domestica). Diverse LAN con uno switch come nodo radice comunicano tra loro tramite un ***router***. Ogni LAN ha un diverso indirizzo IP per il router, detto di ***gateway*** (ovvero, l'indirizzo a cui devo chiedere se voglio comunicare al di fuori della LAN). Mentre nella LAN con lo switch non ci sono implementazioni di sicurezza, il router può implementare un ***firewall***.\n\nFare **routing** significa reindirizzare dati tra reti diverse, il router è un oggetto il cui scopo *principale* è il routing.\n\nTutti gli altri dispositivi di rete (Access Points, Firewall, Load Balancers, Proxies, ...) in qualche modo implementano anche routing e/o switching.","x":-2000,"y":6608,"width":780,"height":759,"color":"5"},
		{"id":"6a2f9951f496a69f","type":"text","text":"Ad esempio, un **_modem_** trasforma la codifica dei dati per l'invio dell'informazione (**trasmissione**, da digitale ad analogico) e viceversa (**ricezione**);","x":-3398,"y":4107,"width":250,"height":408},
		{"id":"eceff6dd26730572","type":"text","text":"# Premesse al mondo degli Standard di Internet\n\nIl protagonista assoluto delle standardizzazioni dei protocolli usati su Internet è prevedibilmente la ***Internet Engineering Task Force*** (***IETF***), che pubblica dei documenti detti ***Request for Comments*** (***RFC***). Questi, nati come effettive richieste di *peer review* da parte dei ricercatori nei primi anni di Internet, si occupano di\n\n- Definire gli standard per i protocolli usati in rete (e.g. HTTP, UDP, ICMP);\n- Divulgare *buone pratiche* (e.g. come calcolare RTT);\n- Proporre nuovi protocolli o aggiornare quelli esistenti.\n\nEssendo focalizzata su SW e pratiche di alto livello, opera tendenzialmente sui livelli di Applicazione, Trasporto e Rete. Ovviamente l'IETF non fa solo RFC, e gli RFC non sono pubblicati solo dall'IETF.\n\n- L'IETF contribuisce a supervisionare l'architettura di Internet, lavora su protocolli di sicurezza e compie sforzi di formazione del personale;\n- Gli RFC sono pubblicati anche da associazioni quali **Internet Research Task Force** (**IRTF**, per la ricerca a lungo termine), **Internet Architecture Board** (**IAB**, per la struttura di Internet) e **Internet Society** (**ISOC**, si occupa di divulgare *buone pratiche*).\n\t- Perché venga pubblicato, ogni RFC deve passare per un'associazione che si occupa sostanzialmente di tenerli in ordine, chiamata **RFC Editor**.\n\nScendendo più in basso (quindi verso l'HW), entra in gioco l'***Institute of Electrical and Electronics Engineers*** (***IEEE***), il cui ***comitato 802*** si occupa di standard sulle reti. Alcuni esempi sono **Ethernet** (**802.3**), **Wi-Fi** (**802.11**) e **WPAN** (**802.15**, e.g. **Bluetooth**). Esistono anche altri comitati, come **IEEE 2413** che si occupa di definire l'architettura dell'**Internet of Things** (**IoT**). Questo per dire che fanno anche altro.","x":-3273,"y":3302,"width":700,"height":733,"color":"5"},
		{"id":"1b501ca1023c98e0","type":"text","text":"# Perdite\n\nInternet di base è non affidabile (\"best effort\"), il che significa che i pacchetti possono essere persi o consegnati in ordine casuale.\n\nSe il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). ","x":-2020,"y":2040,"width":680,"height":276,"color":"1"},
		{"id":"b32953fe59134813","type":"text","text":"# Non sapevo di essere in fase\n\nProssimamente, su DMAX.\n\nNo, seriamente: come faccio a sapere di essere in fase? Perché se non sono tutti perfettamente sincronizzati CDMA esplode malamente, e ho evitato ogni commento a riguardo.\n\nPare che esistano dei codici che restano ortogonali a tutti gli altri anche se sono sfasati (sprecando un po' di bit). Non entrerò nel dettaglio finché non finirò a lavorarci.","x":3720,"y":1887,"width":535,"height":303,"color":"4"},
		{"id":"c53cd443f866e734","type":"text","text":"# Protocolli di Accesso Multiplo (WLAN)\n\nDue AP possono scegliere canali troppo vicini, rischiando quindi di fare interferenza. Se succede, si torna al problema del canale condiviso. Lo standard ***802.11*** implementa un controllo detto ***Distributed Coordination Function*** (***DCF***), che si basa su ***CSMA/CA***.","x":2000,"y":1980,"width":628,"height":180,"color":"6"},
		{"id":"10c1d2a569e26cca","type":"text","text":"# Connettersi ad un AP\n\nLo standard 802.11 assegna dei range di frequenze per il protocollo ***Wireless Fidelity*** (***Wi-Fi***).\n\nLo spettro di frequenze $[2.4, 2.485]\\,GHz$  è diviso in 11 canali parzialmente sovrapposti numerati da $1$ a $11$. Spetta all'admin scegliere quali usare, tenendo conto che segnali distanti $3$ o meno canali possono fare interferenza tra loro. A questo punto:\n\n- L'AP invia segnali periodici, detti ***beacon***, che includono il suo identificatore univoco (Service Set Identifier, SSID) ed indirizzo MAC sui propri canali attivi;\n- I dispositivi in ascolto fanno un check su tutti i canali, intercettando eventuali beacon;\n\t- Inizialmente richiedeva minuti perché l'HW era lento;\n- Ogni dispositivo sceglie uno ed un solo AP, inviando una ***richiesta di associazione***;\n\t- Nel caso delle celle telefoniche, sceglierà l'AP il cui segnale è più forte;\n- L'AP risponde con una ***risposta di associazione*** che permette al dispositivo di effettuare la richiesta DHCP e tornare sostanzialmente al caso di LAN cablata.\n\nTutto questo vale su un singolo AP. Se ce ne sono diversi in contrasto con protocolli diversi, magari uno è molto più aggressivo degli altri e domina\n\n\n\"se sono sintonizzato su una frequenza, tutto il resto è rumore\"\n","x":960,"y":1692,"width":780,"height":760,"color":"3"},
		{"id":"9b77bd85f7310032","type":"text","text":"# Rete Mobile\n\n\n\"c'è stata una spinta commerciale per la rete mobile vs la rete di casa\n\nLa copertura dall'antenna era detta cella (da cui cellulari?) in ogni punto arrivano più segnali, devo scegliere il più forte. prima c'erano addetti che misuravano, ma si può demandare ai singoli clienti della rete (misurano già in loco quanto forte vedono una certa antenna)\n\nin teoria ormai linea mobile ed internet hanno la stessa cella, in pratica c'è una virtualizzazione che rende il canale telefonico un po' più affidabile \n\nvedi GSM, VOIP, ...\n\nSe mi sposto tra diversi AP della rete mobile (***roaming***), questa deve essere in grado di non far crollare tutte le connessioni TCP che avevo.\n\n- H1 sente che il segnale da AP1 si affievolisce e avvia una scansione per un segnale più forte\n- H1 rileva AP2, si disassocia da AP1 e si associa a AP2, mantenendo lo stesso IP e sessioni TCP\n- AP2 invia un frame broadcast allo switch con indirizzo mittente H1 e lo switch capisce che H1 è ora nel BSS2","x":2000,"y":1160,"width":628,"height":680},
		{"id":"e7cf91833015bcfd","type":"file","file":"Screenshot from 2024-06-12 12-02-06.png","x":1240,"y":1320,"width":400,"height":214},
		{"id":"e46fb428ba8d5134","type":"text","text":"# Ma perché sta tutto a 2.4 GHz?\n\nEsistono bande di frequenza a pagamento, spesso gestite e assegnate dagli stati o dalle autorità di regolamentazione delle telecomunicazioni. Queste bande sono tipicamente utilizzate per applicazioni commerciali, come le comunicazioni mobili, le trasmissioni televisive e radiofoniche, e altri servizi wireless. Ecco un resoconto esaustivo delle principali bande di frequenza a pagamento e dei loro utilizzi:\n\n### Bande di Frequenza e i loro Utilizzi\n\n1. **Comunicazioni Mobili**\n   - **GSM (2G)**: 900 MHz e 1800 MHz\n   - **3G (UMTS)**: 2100 MHz\n   - **4G (LTE)**: Diverse bande, tra cui 700 MHz, 800 MHz, 1800 MHz, 2100 MHz, 2600 MHz\n   - **5G**: Bande sotto i 6 GHz (sub-6), come 700 MHz, 3.5 GHz e bande millimetriche (mmWave) come 24 GHz, 28 GHz, e 39 GHz\n\n2. **Trasmissioni Televisive e Radiofoniche**\n   - **TV Broadcast**: VHF (30 MHz - 300 MHz) e UHF (300 MHz - 3 GHz)\n   - **Radio AM**: 535 kHz - 1605 kHz\n   - **Radio FM**: 88 MHz - 108 MHz\n\n3. **Servizi Satellitari**\n   - **Satelliti di Comunicazione**: C-band (4 GHz - 8 GHz), Ku-band (12 GHz - 18 GHz), Ka-band (26 GHz - 40 GHz)\n   - **GPS**: 1.227 GHz e 1.575 GHz\n\n4. **Servizi Pubblici e di Sicurezza**\n   - **Bande per la Sicurezza Pubblica**: 700 MHz, 800 MHz\n   - **Servizi Aeronautici**: 108 MHz - 137 MHz (comunicazioni di aviazione civile)\n\n5. **Servizi per le Reti Wireless a Larga Banda**\n   - **WiMAX**: 2.3 GHz, 2.5 GHz, 3.5 GHz\n\n### Assegnazione e Regolamentazione delle Frequenze\n\n1. **Regolamentazione Nazionale**\n   - **FCC (Federal Communications Commission)** negli Stati Uniti\n   - **Ofcom** nel Regno Unito\n   - **ARCEP** in Francia\n   - **AGCOM** in Italia\n\n2. **Regolamentazione Internazionale**\n   - **ITU (International Telecommunication Union)**: Un'agenzia specializzata delle Nazioni Unite che coordina l'uso globale dello spettro radio e delle orbite satellitari.\n\n### Modalità di Assegnazione delle Frequenze\n\n1. **Aste di Spettro**\n   - Le bande di frequenza sono spesso vendute tramite aste in cui le compagnie di telecomunicazioni competono per ottenere licenze per l'uso di determinate bande di frequenza.\n\n2. **Licenze di Spettro**\n   - Le licenze possono essere assegnate tramite concessioni dirette o procedure competitive, e le aziende pagano per l'uso esclusivo delle bande assegnate per un determinato periodo.\n\n3. **Canoni di Utilizzo**\n   - Oltre al costo iniziale dell'assegnazione, le licenze possono comportare canoni annuali per l'uso continuo dello spettro.\n\n### Esempi di Bande di Frequenza a Pagamento e le loro Utilizzazioni Specifiche\n\n1. **700 MHz**\n   - Utilizzata per LTE e 5G.\n   - Favorita per la sua capacità di coprire grandi aree e penetrare edifici.\n\n2. **3.5 GHz**\n   - Una delle bande principali per il 5G, offrendo un buon equilibrio tra copertura e capacità.\n\n3. **24 GHz e 28 GHz (mmWave)**\n   - Utilizzate per il 5G per offrire velocità molto elevate, sebbene con una copertura limitata.\n\n### Bande di Frequenza Gratuita\n\n1. **Bande ISM**\n   - **2.4 GHz**: Utilizzata da Wi-Fi, Bluetooth, e altri dispositivi senza fili.\n   - **5 GHz**: Utilizzata da Wi-Fi (802.11a/n/ac/ax).\n   - **13.56 MHz**: Utilizzata da NFC.\n\n2. **Bande di Frequenza non Licenziate**\n   - Utilizzate per applicazioni come le reti wireless locali, i dispositivi a corto raggio, e le comunicazioni industriali.\n\n### Conclusione\n\nLe bande di frequenza a pagamento sono cruciali per molte applicazioni commerciali e pubbliche, e la loro assegnazione è rigorosamente regolamentata per garantire un uso efficiente e coordinato dello spettro. Le aste e le licenze di spettro permettono di gestire l'accesso a queste risorse preziose, assicurando che vengano utilizzate per servizi che portano valore economico e sociale.","x":3,"y":1692,"width":752,"height":760,"color":"#641e32"},
		{"id":"0202ebbf2e1ec94d","type":"text","text":"# Protocolli di Accesso Multiplo (LAN)\n\nSu canale ***half-duplex***, due host non possono parlare insieme.\n\nSe un nodo ascolta più segnali contemporaneamente si verifica una ***collisione***.\n\nI protocolli provano ad impedire o a recuperare dalle collisioni sapendo che non esiste un canale di controllo out-of-band e cercando di garantire **fairness** sulla banda pro-capite.","x":3239,"y":3751,"width":624,"height":279,"color":"6"},
		{"id":"2fd35aa9629d9192","type":"text","text":"# Protocolli \"Semplici\"\n\nQuando l'HW si fa semplice, i protocolli efficienti smettono di giocare.\n\nSe ho un HW semplice non posso implementare algoritmi complessi.","x":3239,"y":4180,"width":624,"height":150,"color":"6"},
		{"id":"514018efb59d3dd5","type":"text","text":"# Radio Frequency Identification (RFID)\n\nÈ un sistema che consta di tre componenti:\n\n- ***Tag*** - Circuiti molto semplici, al punto che spesso sono integrati in uno sticker. Identificati da un codice univoco tipicamente a 96 bit, possono essere alimentati (attivi) e non (passivi). Il loro ruolo è rispondere ad uno stimolo EM esterno;\n- ***Reader*** - Dispositivi che emettendo un segnale EM forniscono ai Tag la potenza necessaria a rispondere;\n- ***Server*** - Riceve e processa i dati ricevuti dal Reader.\n\nI Tag passivi sono spesso utilizzati per l'identificazione (e.g. come alternativa al codice a barre), in quanto sono low cost, battery free e non necessitano line of sight.\n\nQuando un'antenna richiede gli ID di un gruppo di Tag, questi rispondono simultaneamente. Serve un protocollo semplice per evitare le collisioni, e viene rispolverato ***Aloha*** in versione un po' più semplice: il reader dice a tutti `generate un numero casuale da 1 a N, a ogni slot temporale decrementatelo e rispondete quando arriva a 0`. L'efficienza di questa roba è $\\sim 37\\%$, altrimenti c'è la sua variante ***Tree Slotted Aloha***: ogni slot in cui c'è collisione di $N$ Tag diventa la radice di un albero che iterativamente si occupa di risolvere solo quegli $N$ Tag (più facile a farsi che a dirsi).","x":3701,"y":4863,"width":581,"height":637,"color":"4"},
		{"id":"d1e8b6fe9e5d399f","type":"text","text":"# Rotazione\n\nRound Robin con i dispositivi che devono trasmettere. Due modi principali di implementarlo:\n\n- ***Polling*** - Un ***nodo master*** invita a turno (con un messaggio di `poll`) i ***nodi slave*** a trasmettere. Tipicamente usato se questi nodi slave non hanno un HW/SW in grado di gestire protocolli complessi. Creare e inviare ogni volta il `poll` crea overhead, aspettarlo per inviare crea latenza, e infine c'è un unico *point-of-failure* (il nodo master);\n- ***Token Passing*** - Ci si mette in cerchio e si gioca a passarsi un ***token di controllo***. Chi ha il token trasmette. E se si perde il token? Non possiamo più giocare!","x":3701,"y":4379,"width":581,"height":412,"color":"4"},
		{"id":"e453784f6e09b6f7","type":"text","text":"# Partizionamento del Canale\n\nUn protocollo del genere divide il canale in slot più piccoli, dando l'esclusiva ad un solo host per ogni slot.\n\n- **Time Division Multiple Access** (***TDMA***) è un Time Division Multiplexing;\n- **Frequency Division Multiple Access** (***FDMA***) è un Frequency Division Multiplexing;\n\nSi possono usare in combinazione con i protocolli ad accesso casuale ad esempio riservare alcuni slot ad un certo NIC con TDMA lasciando uno Slotted Aloha sugli altri (e.g. DOCSIS, che non credo funzioni esattamente così ma idgaf).","x":2820,"y":4379,"width":581,"height":412,"color":"4"},
		{"id":"cf1f7e0084f469af","type":"text","text":"# Bluetooth\n\nBluetooth (***IEEE 802.15***) è una rete a corto raggio ($10\\,\\text{m}$) che trasmette a velocità moderate ($1\\text{Mbps}$). Definisce due tipi di reti:\n\n- ***Piconet***, in cui vi possono essere 8 dispositivi al massimo, di cui uno primario (e.g. smartphone) e 7 secondari (e.g. cuffie, tastiera);\n- ***Scatternet***, in cui un dispositivo secondario di una Piconet diventa il primario di un'altra.\n\nUsa anch'esso la banda $2.4\\,\\text{GHz}$ (come Wi-Fi), ma la divide in 79 canali da $1\\,\\text{MHz}$ ciascuno. Questo significa che il protocollo deve evitare interferenze con 802.11b. E cosa fa il bimbo speciale? Si inventa un complesso sistema di specchi e leve che usa ***TDMA***.\n\nAnzitutto slottizza il tempo ($625 \\mu s$), alternando i ruoli di mittente e destinatario tra dispositivo primario e secondario (**half-duplex**). Ma ad ogni slot cambia anche frequenza, tra le 79 disponibili. Poco male se qualcuna di queste non funziona perché forse c'è anche il Wi-Fi, ne abbiamo altre! Inoltre, se ci sono più device connessi spetta al primario dire a chi tocca nel prossimo slot.\n\nCome se non bastasse, definisce una propria stack protocollare della quale non mi azzardo a parlare.","x":2820,"y":4863,"width":581,"height":637,"color":"4"},
		{"id":"cb8b6e91609f50e1","type":"file","file":"2 - Data Link Layer/VLAN_2.png","x":1854,"y":4720,"width":400,"height":142},
		{"id":"89b32e604650897b","type":"text","text":"## CDMA vs FDMA\n\nConcettualmente CDMA è simile a FDMA (volendo, sono gli 11 canali del Wi-Fi), nel senso che entrambi permettono l'accesso senza latenza al canale condiviso.\n\n- CDMA richiede hardware e software dedicato, ma può essere modificato più velocemente per adattarsi al numero di nodi nella rete (basta generare e assegnare nuovi codici);\n- FDMA può richiedere hardware costoso per gestire i filtri per gestire le diverse bande.","x":2820,"y":2238,"width":780,"height":232,"color":"4"},
		{"id":"29e96eab29abd54f","type":"text","text":"# Glossario dei Protocolli di alto livello\n\n- ***Stateless*** - protocollo che non conserva informazioni sulle interazioni passate;\n- ***Stateful*** - Intuitivamente, il contrario di stateless;\n- **_Handshaking_** - La danza rituale per aprire una connessione TCP. Tipicamente il client manda al server una richiesta di connessione, il quale tipicamente risponde con un OK. Il canale di comunicazione è nato, evviva! Tutto questo impiega almeno un RTT; \n- ***Round Trip Time (RTT)*** - tempo impiegato da un pacchetto di \"piccole dimensioni\" (idealmente un solo bit, in modo tale che $D_t \\sim 0$) per compiere il percorso client-server-client;\n- ***Request For Comments (RFC)*** - quando i primi sviluppatori ideavano un protocollo in ambito accademico, lo condividevano in cerca di feedback. Questa etichetta nel tempo è diventata il nome dei documenti definitivi che standardizzano i protocolli;\n- ***Uniform Resource Identifier (URI)*** - convenzione standard per identificare univocamente le risorse su Internet. Può essere di diversi tipi:\n\t- ***Uniform Resource Locator (URL)*** - Specifica sia l'indirizzo della risorsa sia le istruzioni per accedervi. Consta di tre parti:\n\t\t- Il protocollo da utilizzare per stabilire una comunicazione con l'host della risorsa (HTTP, FTP, SSH, SMTP, ...);\n\t\t- Il nome dell'host, eventualmente da risolvere tramite ricerca DNS per trovare l'IP corrispondente;\n\t\t- Il percorso della risorsa all'interno dell'host.\n\t- ***Uniform Resource Name (URN)*** - Associa ad una risorsa un identificatore persistente e univoco, indipendentemente dalla sua posizione o raggiungibilità tramite URL, esattamente come un libro è identificato univocamente dal suo codice *ISBN (International Standard Book Number)* $\\Rightarrow$ `urn:isbn:0451450525313`. Va registrato presso l'altisonante *Internet Engineering Task Force (IETF)*, e immagino uno debba avere un buon motivo per farlo (?)\n\t- Se so per certo di essere, ad esempio, all'interno di un server, anche un **_path relativo_** è considerabile un URI. In questo senso, un URL è un path assoluto;\n\t- Contesti più specifici possono definire dei propri URI (e.g. il **_File URI_** viene usato dai browser per accedere ai file locali dell'utente);","x":-7845,"y":6329,"width":758,"height":871,"color":"4"},
		{"id":"21d7fd3fb678e357","type":"file","file":"Bluetooth.png","x":2911,"y":5540,"width":400,"height":164},
		{"id":"cbc26214a019c6f0","type":"file","file":"RFID.png","x":3792,"y":5554,"width":400,"height":301},
		{"id":"db883eebaaa5c410","type":"text","text":"# Threat Model\n\nTutto ciò che può fare l'agente malevolo T prende il nome di ***threat model***.\n\nEsempi di ***attacchi*** previsti da un threat model possono essere\n\n- ***Intercettazione*** - Semplicemente ascolto quello che si dicono A e B;\n\t- ***Decrittazione*** - Se i messaggi sono protetti posso provare a rompere la crittografia facendo ***bruteforce*** o ***crittoanalisi***;\n- ***Impersonificazione*** - Modifico gli header in modo da falsificare l'origine del pacchetto (o qualsiasi altro campo);\n\t- ***Hijacking*** - Mi sostituisco ad A o B e continuo la conversazione. Ne sono esempi attacchi come ***replay*** (o ***playback***) o un più complesso ***man in the middle***;\n- ***Denial of Service*** - Nego la disponibilità di un servizio;\n","x":-2380,"y":-1720,"width":626,"height":432,"color":"#4545ff"},
		{"id":"09b6578ece5bef37","type":"text","text":"# Crittografia\n\nSi può dividere in due grandi mondi\n\n- ***Simmetrica*** - se conosco la chiave di Alice $K_A$ conosco anche la chiave di Bob $K_B$ (e viceversa), perché $K_A = K_B$;\n- ***Asimmetrica*** -  $K_A \\neq K_B$, e conoscerne una non mi garantisce di poter ricavare informazioni sull'altra.","x":-2310,"y":-2160,"width":487,"height":280,"color":"6"},
		{"id":"9446a50b389809a0","type":"text","text":"ci sono anche delle vie di mezzo tipo TLS (sicurezza). prima se mandavo una password era in chiaro, chi trovava il pacchetto (non facilissimo) aveva vinto. Transport Layer Security usa TCP ma sta sotto l'applicazione. Quindi io scrivo la phrase in chiaro, tls la critta e la passa a tcp. non lo faccio a livello tcp perché è un casino cambiare un protocollo così lento ad evolversi (super diffuso).","x":-314,"y":-4152,"width":656,"height":200},
		{"id":"5b4bbd10c0ed915d","type":"text","text":"# Sicurezza\n\nQuasi tutti i governi fanno sniffing, anche se il traffico è crittografato. Banalmente ho i metadati, quindi posso risalire a chi parla (magari senza sapere cosa), ma posso mettermi ad ascoltare più \"vicino\" ai due che parlano. Se sei un governo puoi fare la qualunque, compreso con le crittografie. Tecnicamente sniffing era attaccarmi col cavo (quando c'era un cavo per tutti) ma oggi dipende dalla tecnologia usata ed è un concetto astratto.\n\nPosso fare cose illegali in N (con N enorme) modi. Tipo, posso inviare pacchetti mettendo un mittente che non sono io (se mando la droga e metto come mittente qualcun altro quello non va in galera perché non è dimostrabile che l'ha mandato lui), oppure da router posso tenermi i pacchetti e leggerli, o inoltrarli a una macchina a mia scelta.\n\nContro queste cose c'è roba tipo\n- l'autenticazione\n- confidenzialità (crittografia)\n- autenticità\n- restrizioni di accesso (e.g. VPN protetta da password)\n- firewall (a livello di rete)\n\nCi sono attacchi diversi a seconda di\n- come reagisco alle richieste\n- come creo la connessione (e.g. TCP)\n- ...\n\nDi base si può fare tutto, è una giungla!\nSe mi fingo un altro comunque l'altro può trasmettere, a rigore dovrei anche preoccuparmi di bloccare quello che interpreto (man-in-the-middle).\n\n","x":-287,"y":-3792,"width":739,"height":853,"color":"1"},
		{"id":"7684347bd7b8066c","type":"text","text":"# Autenticazione\n\nCome fa B ad essere certo di star parlando davvero con A?\n\n- T può tranquillamente dichiararsi A;\n- Può anche fare ***spoofing*** e aggiungere come prova l'IP di A;\n\t- Assumiamo che il *vero* A sia quello con un certo IP$_A$;\n- B può allora richiedere ad A di mandare una password segreta concordata in precedenza, ma T può intercettare il messaggio di A (che include la password) per replicarlo a B **in un secondo momento**, quando A è offline (attacco di ***playback*** o ***replay***);\n\t- Che la password sia crittografata o meno non cambia niente;\n\t- Si noti che **questo attacco non impedisce che il messaggio di A arrivi a B**. Semplicemente, T ne fa una copia. Da cui la domanda: ma posso fare replay se A è ancora online?\n\t\t- Se ci si appoggia su TCP è difficile, B si ritroverebbe con due connessioni aperte da parte di A;\n\t\t- Se si usa UDP è più semplice, essendo stateless;\n- Per evitare il *playback attack* si usa un ***nonce*** (**n**umber used **once**).\n\t1. A invia a B un'autodichiarazione che include il suo IP;\n\t2. B sa benissimo che potrebbe essere T, quindi chiede ad A una **sfida** (**challenge**) **d'identità** e invia il nonce;\n\t3. A utilizza la chiave simmetrica condivisa per crittare il nonce e invia il risultato a B;\n\t4. B decritta con la chiave condivisa ed è certo di parlare con A.\n\nSe A e B non hanno già concordato una chiave simmetrica, il nonce può essere crittato con la chiave privata di A. B a questo punto chiede ad A la sua chiave pubblica e decritta con quella.\n\nMa c'è un problema. Non posso chiedere alla stessa persona a cui faccio il test di identità la sua chiave pubblica (è tipo un'autocertificazione, \"`sono Alice sisi`\"). Per impedire un ***man in the middle*** (in cui T si mette in mezzo impersonando B nella comunicazione con A e A nella comunicazione con B) devo essere certo che quella chiave pubblica sia ufficialmente di A.\n\nProprio per questo esistono le ***Public key Certification Authorities*** (***CA***), che rilasciano dei certificati con la propria ***firma digitale*** che associano la persona fisica alla chiave pubblica.","x":-4580,"y":-1941,"width":792,"height":875,"color":"#4545ff"},
		{"id":"ffec127414d8e871","type":"text","text":"# Crittografia Simmetrica\n\nEvitiamo i commenti sulla storia della crittografia e sui cifrari alfabetici o a trasposizione.\n\n- Il primo cifrario simmetrico utile è il ***Data Encryption Standard*** (***DES***, 1993), un cifrario a blocchi che cifra secondo lo schema in figura con una chiave a 56 bit. Con una sola iterazione lo si rompe di forza bruta in un giorno (non si conoscono invece buoni attacchi che usano crittanalisi), e lo si può rendere più sicuro con 3 iterazioni che usano 3 chiavi diverse (***3DES***);\n- Nel 2001 ci si è resi conto che forse era un po' troppo debole, così è nato l'***Advanced Encryption Standard*** (***AES***), che manipola input a 128 bit e supporta chiavi a 128, 192 o 256 bit.\n\n\t- Un attacco a forza bruta che impiega 1 secondo per DES, impiega invece 149 trilioni di anni per AES.\n\t- Efficiente sia a livello HW che SW;\n\t- Non esistono vulnerabilità note;\n\nNel complesso, AES è lo standard per la crittografia simmetrica. L'unico punto debole sta nello ***scambio della chiave***. Come si risolve?\n\nSi usa uno schema di ***cifratura asimmetrica per scambiare la chiave simmetrica***, dopodiché si utilizza quest'ultima per cifrare i dati.","x":-2765,"y":-2939,"width":597,"height":620,"color":"#4545ff"},
		{"id":"f41363e3c1079edd","type":"text","text":"# Crittografia Asimmetrica\n\nLa crittografia asimmetrica di basa su due concetti fondamentali:\n\n- ***Chiave Pubblica*** ($K^+$)- È più comodo vederla come un ***lucchetto***. B pubblica il modo per ***chiudere un messaggio a lui indirizzato***, assumendo che nessuno da questo sia in grado di dedurre la chiave per aprirlo ($\\Rightarrow$ la sua ***chiave privata***);\n- ***Chiave Privata*** ($K^-$) - È la chiave per ***decrittare i messaggi chiusi con la chiave pubblica***.\n\nTipicamente si usano algoritmi molto costosi, quindi si usa per creare un canale sicuro su cui trasferire le chiavi simmetriche. Esempio tipico di comunicazione asimmetrica su Internet è il seguente:\n\n- B genera la sua coppia di chiavi, divulgando quella pubblica e tenendo ben nascosta quella privata;\n- A riceve il lucchetto (chiave pubblica di B), lo usa per crittare il messaggio \"Ciao, sono Alice, questa è la mia chiave simmetrica\";\n- Solo B può aprire questo messaggio, ricavando la chiave simmetrica di A;\n- A questo punto si passa ad una cifratura simmetrica (AES).\n","x":-1965,"y":-2939,"width":600,"height":620,"color":"#4545ff"},
		{"id":"9622da6072e60568","type":"text","text":"# Integrità\n\nSe B critta un messaggio con la propria ***chiave privata*** (meglio ancora se certificata da una CA) garantisce a tutti che l'autore sia proprio lui.\nAssicura anche che nessun altro può aver modificato il messaggio (che quindi è integro). Anche legalmente, B non può negare di aver scritto il messaggio (garantisce il ***non-ripudio***).\n\nTutto questo è molto bello, ma crittare interi messaggi con RSA è\ncomputazionalmente troppo costoso. Allora mi invento una funzione $H$ (detta di ***hash***) in grado di fare un riassunto del messaggio (***digest***).\n\nB calcola il digest sul messaggio originale, dopodiché lo critta con la chiave privata. Chi riceve il documento decritta il digest con la chiave pubblica e lo confronta con quello calcolato da B.\n\nIl digest crittato con la chiave privata è detto ***firma digitale***. $H$ deve essere tale che sia quasi impossibile modificare il messaggio senza di riflesso modificare il digest (i.e. dato un digest $x$ è molto costoso a livello computazionale trovare un messaggio $m$ tale che $H(m) = x$) di , nonostante sia previsto che più messaggi vengano riassunti nello stesso digest.\n\nFunzioni di hash tipicamente utilizzate sono ***MD5*** (RFC 1321) e ***SHA-1***.","x":-3565,"y":-2939,"width":597,"height":620,"color":"#4545ff"},
		{"id":"5aa7116653d29b37","type":"text","text":"# RSA (Rivest Shamir Adleman)\n\nAlgoritmo per costruire il lucchetto in modo che sia (statisticamente) impossibile da invertire per risalire alla chiave.\n\n- Scelgo due numeri primi $p$ e $q$ **grandi** (e.g. 1024 bit). Calcolo\n\t- $n = pq$\n\t- $z = (p-1)(q-1)$\n- Scelgo $e < n$ tale che non abbia fattori comuni a $z$\n- Scelgo $d$ tale che $e\\cdot d - 1$ sia esattamente divisibile per $z$ \n\t- $(e\\cdot d)\\,\\%\\, z = 1$\n- La chiave pubblica è $(n, e)$\n\t- Posso (de)cifrare un messaggio eseguendo $c = m^e\\mod n$\n- La chiave privata è $(n, d)$\n\t- Posso (de)cifrare un messaggio eseguendo $m = c^d\\mod n$","x":-1980,"y":-3480,"width":630,"height":440,"color":"#4545ff"},
		{"id":"d2710649599d3e60","type":"text","text":"# Applicazioni\n\nDato un messaggio $m$, una chiave pubblica $K^+$ e una chiave privata $K^-$ si ha che\n$$m = K^-(K^+(m)) = K^+(K^-(m))$$\nQuesto apre a due applicazioni principali:\n\n- Critto con la pubblica se mi interessa che solo chi ha la privata legga il mio messaggio;\n- Critto con la privata se mi interessa che là fuori siano certi che sono io l'autore del messaggio (***firma digitale***);\n\t- ***Identity Challenge*** - Una roba del tipo \"scrivi un messaggio che decrittato con la chiave pubblica contiene esattamente quello che ti dico\"","x":-1162,"y":-2939,"width":540,"height":620,"color":"#4545ff"},
		{"id":"37bf791ca3d98663","type":"file","file":"DES.png","x":-2666,"y":-3257,"width":400,"height":217},
		{"id":"d45579c34fc613d5","type":"file","file":"FirmaDigitale.png","x":-3466,"y":-3239,"width":400,"height":182},
		{"id":"e29cb1b11175b1c4","type":"file","file":"AutenticazioneCompleta.png","x":-5340,"y":-2781,"width":566,"height":304},
		{"id":"56555adae1f2d043","type":"text","text":"# Integrità dei Certificati di Autenticazione\n\nLe persone fisiche si recano all'***Autorità di Certificazione*** (***CA***) registrando la propria chiave pubblica e fornendo una prova d'identità diretta.\n\nQuesta crea un documento (***certificato***) contenente i dati di A, la sua $K^+_A$ e la ***firma digitale della CA*** su quel documento (anche la CA ha una propria coppia $K^-_{CA}, K^+_{CA}$, e quest'ultima viene pubblicata e verificata da tutti).\n\nIn questo modo dopo che B manda il nonce $R$ ad A e dopo che questa risponde con $K^-_A(R)$ e con il proprio certificato per $K^+_A$, B può verificare la firma digitale della CA applicando $K_{CA}^+$.\n\nA questo punto ci sono solo due possibili casi di fallimento:\n\n- La CA è compromessa (amen, B non sarà l'unico a piangere);\n- Qualcuno riesce a fare ***contemporaneamente*** un ***man in the middle*** tra A e B (con cui fornisce a B un certificato falso) e un altro tra B e la CA (con cui fornisce a B una $K_{CA}^+$ falsa). Intuitivamente, è ***realizzabile solo da enti governativi o di potenza computazionale e politica paragonabile***.","x":-4524,"y":-2889,"width":681,"height":521,"color":"#4545ff"},
		{"id":"6958668a930e7c2f","type":"text","text":"# Autenticazione Zero-Knowledge\n\n[Riassumibile](https://it.wikipedia.org/wiki/Dimostrazione_a_conoscenza_zero) con la frase \"dimostrami che sai il segreto, ma non dirmi il segreto\".\n\nSi traduce in una ***sfida statistica*** che consta di $N$ prove. La probabilità di superarle tutte scala come $\\exp^{-N}$, per cui è verosimile superarle tutte solo se conosco il segreto.\n\nÈ impossibile tuttavia ricavare informazioni sulla natura del segreto, poiché l'unica informazione è il buon esito della prova.\n\nCon questo metodo si possono implementare cose come login senza password, verifiche sulle criptovalute e [Federated Learning](https://en.wikipedia.org/wiki/Federated_learning).","x":-5752,"y":-1385,"width":716,"height":319,"color":"#4545ff"},
		{"id":"de2d85d4a92d84bc","type":"text","text":"# Protezione Messaggi di Posta Elettronica\n\nEsiste un SW che implementa tutto questo a livello Applicazione, detto ***Pretty Good Privacy*** (***PGP***). È possibile inviare un messaggio allegando la propria firma PGP, così come è possibile crittare l'intero contenuto della mail.","x":-5752,"y":-1579,"width":716,"height":151,"color":"#4545ff"},
		{"id":"e2750b6b7a2c01af","type":"text","text":"# SSL/TLS\n\nSono protocolli di sicurezza che agiscono su un canale di comunicazione. \nSi occupano sia di crittare i dati (previene i leak di dati da **eavesdropping**) che di generare e verificare i ***certificati di autenticità***, ovvero delle firme digitali in grado di attestare che il server con cui si è stabilita la connessione è effettivamente chi dice di essere (previene attacchi di tipo **man-in-the-middle**). Seguono concettualmente uno schema del tipo\n\n- ***Handshaking*** - quando si crea la connessione con il server che supporta SSL/TLS:\n\t- Vengono scambiate le chiavi pubbliche $K^+$ di uno schema di cifratura asimmetrica (e.g. Diffie-Hellman). Il server fornisce il suo certificato di autenticità al client, il quale lo inoltra al server di un'***Autorità di Certificazione*** (***CA***) in grado di validare il certificato tramite il proprio DB (e viceversa, se necessario);\n\t- Accertata l'autenticità dell'interlocutore, il client invia al server un ***Master Secret*** (***MS***) crittato con $K^+_S$, il quale applica $K^-_S$ e usa il MS per generare tutte le ***chiavi simmetriche per la sessione***;\n\t\t- Perché non una sola? Per minimizzare i dati a disposizione degli attaccanti si usano chiavi distinte per la comunicazione client $\\to$ server ($K_{CS}$) e server $\\to$ client ($K_{SC}$). Seguendo questa separazione, esistono altre due chiavi per generare i codici MAC  client $\\to$ server ($M_{CS}$) e server $\\to$ client ($M_{SC}$);\n- ***Message Authentication Code (MAC)*** - ad ogni messaggio inviato viene allegato un codice generato da una ***funzione di hash*** che prende in input una delle chiavi simmetriche segrete $M_{CS}$ ed $M_{SC}$ (a seconda del verso della comunicazione), consentendo di autenticare ogni pacchetto;\n\t- TCP tratta i dati come flusso piuttosto che come messaggi, ma è sufficiente spezzettare il *bytestream* in record;\n\t- Onde evitare attacchi replay, tra gli input per generare il MAC vi è anche il nonce (generato da MS durante l'handshaking);\n\t- Previene anche la chiusura prematura della connessione (l'header TCP è in chiaro). Nel payload di ogni messaggio `FIN` si include allora un bit per confermarne la validità, che chiaramente contribuisce alla creazione del MAC.\n\nOvviamente c'è molto altro da dire, tipo che se cade la connessione e poi riprende non posso sapere se qualcuno si è messo a fare man in the middle, quindi se dovevo scambiare dati importanti (e.g. sessione bancaria) lascio cadere la connessione e la ricreo con un nuovo handshaking.\n\nLa redazione rimanda a specifici corsi sulla sicurezza una ulteriore trattazione.","x":-8593,"y":10854,"width":656,"height":1086,"color":"#4545ff"},
		{"id":"a040ad793f9beeac","type":"text","text":"# Garanzie di Sicurezza\n\nPosso aver bisogno di comunicare informazioni riservate, e avere necessità di **_sicurezza_** nei confronti di ascoltatori indesiderati. Questo può essere implementato tramite schemi di **_crittografia_**\n\n- nel layer di Applicazione, e quindi a livello di browser (nel modello OSI se ne occupava esplicitamente il layer di Presentazione);\n- nel **_TLS (Transport Layer Security)_**, e prima nel suo predecessore **SSL (Secure Sockets Layer)**. Sebbene non sia ufficialmente parte di TCP/IP, è diventato uno standard *de facto* (e.g. **HTTP + TLS = HTTPS**). Viene diffuso insieme alle API di TCP, e critta i messaggi prima di passarli a quest'ultimo. Si noti che aggiungere un layer è molto più semplice rispetto ad aggiornare esplicitamente un protocollo come TCP.\n\nA seconda di che applicazione sto usando posso avere necessità diverse.\nSe mando una mail non voglio perdite ma non ho particolari necessità di velocità o di throughput, mentre se faccio live streaming posso accettare di perdere qualche frame purché il ritardo sia minimo (e se non ho un thoughput minimo garantito... non faccio live streaming).\n","x":-8593,"y":10220,"width":656,"height":523,"color":"#4545ff"},
		{"id":"89fc4a871c42ed61","type":"text","text":"\nPuò capitare di trovare una chiave pubblica in coda alle mail.\n\n\n","x":-5628,"y":-1680,"width":469,"height":58},
		{"id":"5c7cb3e9b597a877","type":"text","text":"# Telnet\n\ntelnet?? interfaccia con tcp a livello testuale, devo mandare a capo due volte. una volta che si apre una connessione ogni carattere fa un roundtrip, ma di default non vedo l'echo di quello che ho scritto su terminale.\nbrowser fa questo ma in automatico con le librerie TCP.\nwireshark???\n","x":-8760,"y":8079,"width":577,"height":334},
		{"id":"1edf7a2ed1d99849","type":"text","text":"# IRC","x":-12260,"y":5365,"width":250,"height":60},
		{"id":"84260917d7aeb08b","type":"text","text":"# Aggiunte ARP\n\n\"chi ha questo IP mi dica il suo MAC\"\nse arrivano due risposte?\ndipende dall'implementazione, alcune tengono solo la risposta più recente, altre restituiscono un errore (ARP conflict)\nesistono attacchi ARP spoofing in cui mi fingo un'altra interfaccia, ma poco interessante perché dovrei già trovarmi sulla LAN.\n\nswitch in cascata funzionano esattamente come un singolo switch\n\n","x":79,"y":6020,"width":600,"height":287},
		{"id":"58d2afa4103e892d","type":"text","text":"# Bottleneck? No, grazie!\n\nQuanto deve essere veloce tutto questo? Il router non deve diventare un bottleneck!\n\nOgni porta fisica ha un ***rate R*** di trasmissione dati. Perché non si creino code in ingresso, lo switching deve un rate complessivo $$R_{SF} \\geq \\sum_{i\\in\\text{ingresso}} R_i$$\nSe $R_{SF}$ rispetta questa condizione, il router è ***non-blocking***. Può succedere che, al contrario, il router sia talmente veloce da creare code in uscita (il bottleneck è il cavo).\n\n","x":3736,"y":9979,"width":780,"height":308,"color":"4"},
		{"id":"c557cc541ff260c7","type":"text","text":"\n\n\nTramite una tabella ARP, il router ricava `IP -> MAC`, `MAC -> PORTA_FISICA`\nI router hanno anche una tabella ARP per associare l'IP alla porta fisica. Questa, al contrario, viene popolata \"as traffic flows\".\n\npotrei garantire una bandwidth per una certa classe (e.g. voice over IP)\n","x":5076,"y":10303,"width":345,"height":381},
		{"id":"2434ffd16440ef70","type":"text","text":"# Quanto è grande il tuo buffer?\n\nUno potrebbe dire \"vabbè, nel dubbio metti un buffer enorme, così non butti i pacchetti\".\n\nEh no, significa solo creare una coda più lunga, il che aumenta il tempo medio di attesa in coda. Risultato? Al mittente scade il timeout, pensa di aver perso il pacchetto e ritrasmette.\n\nIn teoria **il buffer servirebbe soltanto ad assorbire le fluttuazioni statistiche dell'intensità del traffico di rete**, in pratica anche qui **se c'è congestione devo accettare le perdite**.\n\nUn valore empirico per la grandezza del buffer è definito in [RFC 3439](https://datatracker.ietf.org/doc/html/rfc3439) come$$\\text{Grandezza Buffer} = \\frac{RTT}{\\sqrt{N}}\\cdot C$$dove il router vede $N$ flussi di dati (collegamenti) di capacità $C$.\n\ncome li gestisco? se lo costruisco ho un po' di gioco su chi favorire, ma rischio congestione e/o non-neutralità della rete.\n\n","x":3736,"y":10408,"width":780,"height":472,"color":"4"},
		{"id":"c62a7105409a6a47","type":"text","text":"# \\#CheccoRacconta\n\nIn Africa, Facebook pagava i provider per offrire internet veloce solo se si usavano i suoi servizi (era lentissimo e costosissimo altrimenti)\n\ndifficile provvedere legalmente, le aziende vanno molto più veloci delle leggi. grande gap culturale tra tecnologia e legislatore. i colossi sono troppo grandi per essere regolamentati/multati.","x":4789,"y":10865,"width":460,"height":440},
		{"id":"18797cfbb25b2f9c","type":"text","text":"# Scheduling e Neutralità della Rete\n\nAccettare le perdite significa poter scegliere quali pacchetti buttare.\n\nSe una scelta banale è fare ***tail drop*** (in pratica *FCFS*), posso anche implementare un ***priority scheduling*** sulla base dei campi degli header che preferisco.\n\nPosso dividere la coda in più code virtuali e fare *MLQ* con un *RR* semplice o pesato, insomma, diciamo che più mi pagano più posso ingegnarmi.\n\nSì, perché è cosa nota che la gente (e.g. multinazionali come Facebook) corrompe i gestori dei router per dare priorità ai propri pacchetti, di fatto monopolizzando la banda.\n\nOppure il contrario, posso penalizzare un certo tipo di pacchetto (e.g. di un certo mittente).\n\nDiversi paesi e legislatori hanno diversi approcci al ***principio di neutralità della rete*** che sostanzialmente si può riassumere in\n\n- ***no-blocking*** - è illegale bloccare contenuti leciti e non dannosi;\n- ***no-throttling*** - è illegale degradare il traffico internet;\n- ***no-paid-priority*** - è illegale pagare per ottenere priorità.","x":3736,"y":11000,"width":780,"height":609,"color":"4"},
		{"id":"7f27ffe9c326e924","type":"text","text":"# Switching Fabrics\n\nCome fa il router ad inoltrare i pacchetti a livello HW dalla porta fisica d'ingresso a quella di uscita? Ovvero, come implementa lo ***switching***? Ci sono tre modi possibili.\n\n- ***Software***- Il pacchetto viene processato a livello software da un SO Linux scritto direttamente in Assembly (e.g. OpenWrt). Dovendo passare per una memoria è lento e non può essere usato per le *backbone* di Internet, ma può essere una soluzione intuitiva e flessibile nella periferia della rete, o comunque dove c'è poca esigenza di throughput;\n- ***BUS*** - il pacchetto viene reindirizzato tramite una singola linea condivisa. Il traffico è limitato dalla larghezza di banda del BUS conteso. Tecnica ad oggi obsoleta;\n- ***Crossbar*** - una sorta di commutazione di circuito bidimensionale in cui ogni ingresso è collegato ad ogni uscita. Su questo ***fabric plane*** è possibile frammentare il pacchetto in ingresso e spostarlo in parallelo sfruttando un ***interruttore multistadio (?)***, per poi ricomporlo in uscita. Si possono pensare anche strutture topologicamente più complesse in cui più *fabric planes* paralleli interagiscono (***Interconnection Networks***).\n\t- Piuttosto che creare matrici $N\\times N$ che scalano $O(N^2)$ si sceglie di implementare una struttura gerarchica. Mi rifiuto anche solo di provare a cercare mezza informazione in più a riguardo, l'ha detto lui, mi fido e lo riporto per completezza.\n\n","x":2726,"y":9979,"width":780,"height":513,"color":"3"},
		{"id":"f51086f517d2e458","type":"text","text":"# Forwarding Generalizzato\n\nDi base, un router guarda l'IP e sceglie un'uscita guardando la forwarding table. Ma si può fare di più, ad esempio guardare anche gli header di Trasporto e Collegamento.\n\nPosso costruire una tabella in cui ogni riga è una cosa del tipo \"se sono soddisfatte queste condizioni, allora esegui questa azione\" (***match plus action***). Una ***flow table*** può eseguire\n\n- ***Forwarding*** - Si ricade nel tipico funzionamento di un ***router***;\n\t- Ma posso fare forwarding anche sulla base di un indirizzo MAC, che di norma sarebbe compito di uno ***switch***;\n- ***Drop*** - Butta il pacchetto. Si comporta quindi da ***Firewall***, ma anche a livello di Collegamento (si può bannare un indirizzo MAC);\n- ***Modify*** - è un ***NAPT***, cambio l'indirizzo IP e la porta a livello di Rete e Trasporto.\n\nSi nota come il router inizia ad \"invadere\" le funzioni degli altri elementi di Rete, nonché inizia ad influire sui layer adiacenti (Trasporto e Collegamento). Nel tempo è stato coniato il termine ***middlebox*** per indicare qualunque intermediario tra mittente e destinatario end-to-end che svolge azioni diverse da quelle di un normale router.\n\ncon OpenFlow su un router posso implementare cose, compreso l'INSTRADAMENTO!\n\ncon le tabelle possiamo costruire un percorso.","x":2726,"y":11000,"width":780,"height":609,"color":"3"},
		{"id":"a1ca857cd4a6c415","type":"text","text":"# Come consulto la tabella?\n\nQuando l'IP in arrivo trova una corrispondenza sull'indirizzo di destinazione viene inoltrato all'interfaccia fisica corrispondente nella forwarding table (***destination-based forwarding***).\n\nSi usa il ***match del prefisso più lungo***, che per alcuni HW *ad-hoc* richiede un solo tempo di clock. Se ho ad esempio le righe `111 111 111 xxx 21` e `111 111 xxx xxx 34`\n- l'IP `111 111 111 111` matcha con entrambe, ma ha un bit di corrispondenza in più con la prima. Verrà quindi inoltrato sull'interfaccia `21`;\n- l'IP `111 111 000 000` matcha solo con la seconda, verrà inoltrato alla porta `34`;\n- l'IP `100 000 000 000` non matcha con nessuna delle precedenti. Che ci faccio?\n\t- Se non trovo nessun match, di default il router butta il pacchetto;\n\t- Posso definire come ultima scelta una ***default route*** `0.0.0.0/0` (che matcha con qualsiasi cosa, per definizione) in cui mando tutti i pacchetti che non matchano con le restanti ($O(10^6)$) righe.\n\n","x":1560,"y":11174,"width":916,"height":435,"color":"4"},
		{"id":"b7cbea2785c98166","type":"text","text":"# Routing Table\n\nTabella interna al router che fa corrispondere un IP o un gruppo di IP di destinazione ad una porta fisica (***interfaccia di rete***) a cui inoltrare i datagrammi (***destination-based forwarding***).\n\nLe *entries* della RT hanno forma `NetworkIdentifier Gateway Interface Metric`, dove\n- `NetworkIdentifier` è tutto ciò che serve ad identificare un IP o un gruppo di IP\n\t- Ciò include un `IP` (e.g. `192.168.1.0`) ed una `SubnetMask` (e.g. `255.255.255.0`), che insieme indicano un range di indirizzi (e.g. si può indicare anche come `192.168.1.0/24`);\n- `Gateway` è l'indirizzo IP del prossimo hop. Il valore `0.0.0.0` indica che non c'è un prossimo hop, ovvero che l'IP destinazione è collegato alla LAN di questo router;\n- `Interface` è l'interfaccia fisica su cui inoltrare il pacchetto (e.g. `eth0`);\n- `Metric` è il costo del percorso (utile per gli algoritmi di routing).\n\nVi sono tre modi per riempire una Routing Table.\n\n- ***Direct Connection*** - la subnet `10.0.44.0/24` è connessa sull'interfaccia `eth0`. Il router sa che un qualsiasi pacchetto con un IP in questo range è arrivato a destinazione;\n- ***Static Route*** - l'admin di rete inserisce manualmente le direttive nella tabella;\n- ***Dynamic Route*** - i router parlano automaticamente tra loro dicendosi a vicenda cosa possono raggiungere e aggiornando di conseguenza le tabelle. In genere ci sono più percorsi possibili, motivo per cui si usano degli ***algoritmi di instradamento***.\n\nNel caso in cui arrivi un pacchetto destinato ad un IP che non compare nella tabella, il router di default lo butta. Bisogna quindi popolarla prima che arrivi il traffico.","x":1560,"y":10408,"width":916,"height":720,"color":"3"},
		{"id":"d1b8f4d6b685141c","type":"text","text":"# Router\n\nDispositivo che implementa il layer di Rete reindirizzando i pacchetti non diretti a lui (invece di scartarli, come farebbe un host).\n\nElemento di base con cui è costruito il ***nucleo di rete***, si occupa di smistare i datagrammi IP (***forwarding***) in tempi $O(ns)$ tramite una ***routing table*** che associa ogni IP ad una porta fisica di uscita ($\\Rightarrow$ si comporta anche da switch). Gestisce flussi di dati $O(Tbit/s)$.\n\nAgisce sia a livello di data plane (implementando il forwarding tramite HW *ad-hoc*) sia a livello di control plane (ad esempio, modificando a livello SW le routing table secondo gli algoritmi di instradamento)","x":1560,"y":9979,"width":916,"height":331,"color":"4"},
		{"id":"447f8e71a756c709","type":"text","text":"# Come comunicano i Router? (ICMP)\n\nCome faccio a sapere se un router è online? Se il `TTL` è scaduto? Come stimo *RTT*?\n\nPer tutte queste domande (e molto altro) esiste un simpatico e snello protocollo che viaggia direttamente come *payload* di IP. Serve tendenzialmente a comunicare tra il router e chi gli ha mandato il pacchetto.\n\nConsta di $4\\,byte$ più eventuali dati, così suddivisi:\n\n- ***Tipo*** - i primi $8\\,bit$ sono dedicati alla tipologia di messaggio, ad esempio\n\t- $0$ - Risposta *echo* (\"ci sono!\");\n\t- $3$ - Destinazione Irraggiungibile;\n\t- $8$ - Richiesta *echo* (\"ci sei?\");\n\t- $30$ - Dedicato a Traceroute;\n- ***Codice*** - i successivi $8\\,bit$ specificano l'informazione del Tipo. Per la maggior parte dei Tipi esiste solo il codice $0$, ma ad esempio per il Tipo $3$ abbiamo codici\n\t- $0$ - Rete non raggiungibile\n\t- $1$ - Host non raggiungibile\n\t- $3$ - Porta di destinazione non raggiungibile (\"su questa porta non c'è alcun servizio\");\n\t- $7$ - Host di destinazione sconosciuto;\n\t- \\[...\\]\n- Gli ultimi $16\\,bit$ sono un checksum.\n\n***Traceroute*** è un abuso di ICMP: si inviano datagrammi UDP con un numero di porta tipicamente non usato per UDP, in sequenza. Prima mando `TTL = 1`, il primo router lo scarta e risponde ICMP, il che include l'IP del router che l'ha scartato. Poi `TTL = 2`, e così via. quando arrivo a destinazione, il server non ha un servizio attivo su quella porta, quindi ricevo un \"porta irraggiungibile\" e so di aver finito. Così trovo la gente anche se non accetta i ping. I router possono anche decidere di non rispondere. Qui non sto mandando ping, sono loro che decidono di rispondere al fatto che un pacchetto è stato scartato. Ci sono altre N cose da sfruttare per costruire servizi sfruttando l'architettura di rete.\n\nesiste, un po' diverso, anche a livello di IPv6. Utile perché non essendoci frammentazione voglio trovare l'MTU minimo, c'è un algoritmo per trovarlo usando ICMPv6 (PathMTUDiscovery)","x":2726,"y":8876,"width":780,"height":983,"color":"3"},
		{"id":"b5f5edb4ee399ff2","type":"file","file":"3 - Rete/ReteMistaIPv4IPv6.png","x":2716,"y":8508,"width":789,"height":232},
		{"id":"0053091728148919","type":"text","text":"# Come fa un host ad ottenere un indirizzo IP? (DHCP)\n\nInizialmente gli IP erano statici, quindi *hard-coded* sull'host ad opera dell'admin di rete (e.g. da `/etc/rc.config` su UNIX). Questo approccio manuale è obsoleto, ormai IP è dinamico.\n\nSi usa invece un ***protocollo Applicazione*** basato su UDP, ***DHCP*** (***Dynamic Host Configuration Protocol***). L'idea generale degli indirizzi IP è che vengano *presi in prestito*. La gestione di questi *leasing* sta al ***server DHCP***, spesso integrato nei router domestici. Questa la procedura:\n\n- Chi si connette alla sottorete cerca un server DHCP mandando broadcast un messaggio ***DHCP discover***, in cui specifica\n\t- **Sorgente** - `0.0.0.0` (\"non ho un IP\") `68`, la porta 68 è usata come standard lato client per ricevere i messaggi DHCP);\n\t- **Destinazione** - `255.255.255.255 67` broadcast sulla porta 67, su cui il server DHCP è in ascolto;\n\t- `Requested IP Address` - Eventualmente posso specificare l'IP che vorrei avere tra le opzioni facoltative. `0.0.0.0` significa \"boh, fai tu\";\n\t- **Transaction ID** - Dato che l'host non ha ancora un IP, tutti i messaggi DHCP vengono mandati broadcast. Questo valore viene scelto in modo casuale e assicura che non possano esserci conflitti;\n\t- Altre opzioni, ma si scende troppo nel tecnico e le ignoriamo;\n- Il server DHCP in ascolto sulla porta `67` vede il messaggio *discover* e risponde con una ***DHCP Offer***:\n\t- **Sorgente** - `223.1.2.5 67`, \"sono il server DHCP, e mi chiamo `Server Identifier`\";\n\t- **Destinazione** - `255.255.255.255 68`, faccio di nuovo broadcast perché il client non ha ancora un IP;\n\t- `yiaddr` - `223.1.2.4` (\"ti propongo questo IP\");\n\t- **Transaction ID** - Visto che il messaggio è ancora broadcast devo specificare a chi sto rispondendo;\n\t- **Lifetime** - Specifica quanto dura il leasing (e.g. `3600`, \"questo IP dura un'ora, poi devi chiederlo di nuovo\");\n- Questi primi due passaggi possono essere saltati se il client aveva già un indirizzo IP e vuole conservarlo;\n- A questo punto il client ha una proposta di IP. Chiede al server se può usarlo con una ***DHCP Request***. I campi sono gli stessi di una discover (il tipo di richiesta è specificato con l'`opzione 53 (DHCP Message Type`), il `Requested IP Address` (`opzione 50`) è quello dell'Offerta DHCP o il mio vecchio IP;\n\t- Anche la Request è broadcast, perché devo scegliere un solo server e comunicare ad altri eventuali server che hanno risposto con una Offer che il loro IP non verrà usato. Lo faccio tramite l'`opzione 54 (Server Identifier)`;\n- Finalmente, il server DHCP scelto dal client conferma l'IP con un messaggio ***DHCP ACK***.\n\t- Se però ho richiesto un IP non valido o non disponibile, il server risponderà con un messaggio ***DHCP NAK***, che in pratica mi costringe a ripetere tutta la procedura.\n\nOltre all'indirizzo IP del client, il server DHCP fornisce gli IP del gateway, di un server DNS e la subnet mask.","x":1560,"y":8876,"width":916,"height":983,"color":"4"},
		{"id":"e58dbfee9f01dbaf","type":"text","text":"# Come fa un ISP ad ottenere un range di indirizzi IP?\n\nLa Grande Madre degli IP è l'***ICANN*** (**Internet Corporation for Assigned Names and Numbers**).\n\nQuesta gestisce l'intero spazio degli indirizzi IP a livello globale, assegnandoli in macro-blocchi a 5 ***Regional Internet Registers*** (**ARIN** Nord America, **RIPE NCC** Europa, Medio Oriente e parti dell'Asia Centrale, **APNIC** Asia-Pacifico, **LACNIC** America Latina e i Caraibi, **AFRINIC** Africa).\n\nGli ISP comprano i range di indirizzi dai RIR, dividendoli in blocchi e vendendoli alle organizzazioni.\n```\n11001000 00010111 0001yyyx xxxxxxxx <--> 200.23.16.0/20   # Comprato dall'ISP\n```\nIpotizziamo di volerli dividere in 8 blocchi, indicizzabili con 3 bit (`yyy`). Allora abbiamo\n```\n11001000 00010111 0001000x xxxxxxxx <--> 200.23.16.0/23   # Comprato da Organizzazione 1\n11001000 00010111 0001001x xxxxxxxx <--> 200.23.18.0/23   # Comprato da Organizzazione 2\n[...]\n11001000 00010111 0001111x xxxxxxxx <--> 200.23.30.0/23   # Comprato da Organizzazione 8\n```\nIn pratica, gli ISP pagano i RIR, i quali pagano l'ICANN, la quale investe in manutenzione della rete, sicurezza, ricerca e sviluppo (e.g. TLD del DNS). Gli ultimi indirizzi IPv4 sono stati assegnati ai RIR nel 2011. Ad oggi, IPv4 si tiene in piedi grazie al NAT, ed è in corso il passaggio a IPv6. ","x":1560,"y":8140,"width":916,"height":600,"color":"4"},
		{"id":"88c9b35b0c391a8a","type":"text","text":"# Frammentazione IPv4\n\nI protocolli del livello di Collegamento prevedono una dimensione massima del frame, oltre la quale è necessario \"spezzarlo\" in due $\\Rightarrow$ ***Maximum Transmission Unit*** (e.g. $MTU_{\\text{Ethernet}} = 1500 byte$).\n\nSe ad IPv4 arriva un pacchetto troppo grande, deve spezzarlo. Se il datagramma iniziale era lungo `length = 4000` devo dividerlo in 3 datagrammi più piccoli, rispettivamente\n\n1. `length = 1500, fragflag = 1, offset = 0`;\n2. `length = 1500, fragflag = 1, offset = 185`;\n3. `length = 1500, fragflag = 0, offset = 370`.\n\nSi vede bene che la frammentazione è gestita da due campi dell'header:\n\n- `fragflag` - se  `= 1` significa \"ciao, sono solo un pezzo di un datagramma più grande, dopo di me ne arriverà un altro, se sei il destinatario ci devi riassemblare grazieprego\";\n- `offset` -  tiene traccia di dove sono arrivato rispetto al messaggio iniziale, e si conta in ottetti di byte. Il primo *payload* è di $1480\\,byte$, quindi il secondo partirà dall'ottetto $1480/8 = 185$. In pratica potevano sostituirli con dei numeri progressivi, ma le cose facili non ci piacciono.\n\nQuesti tre datagrammi sono indipendenti dal punto di vista della Rete, e possono potenzialmente prendere percorsi differenti a livello di routing. L'unico a cui interessano questi campi è il destinatario, al quale spetta il compito di usarli per riassemblare il datagramma originale.\n\nIPv6 vieta la frammentazione, esplora il livello di Collegamento per trovare $MTU_{\\text{min}}$ e capire quanto grande può mandare i pacchetti. Notare che, di nuovo, viola il principio di divisione dei layer.","x":-446,"y":8653,"width":814,"height":643,"color":"4"},
		{"id":"220142b1b2ce8091","type":"text","text":"upper layer protocol specifica cosa c'è dentro il payload (TCP, UDP, OSPF 89, ...)","x":-275,"y":9728,"width":472,"height":116},
		{"id":"4dc94bc414dbc8c0","type":"text","text":"# Indirizzi IPv4\n\nIdentificativo a $32\\,bit$ ($2^{32}$ indirizzamenti) pensato originariamente per individuare univocamente ogni interfaccia di rete (e.g. cavo Ethernet) di ogni nodo. Adotta un notazione decimale puntata.\n\n```\ne.g. 11011111 00000001 00000001 00000001 = 223.1.1.1\n```\n\nIn pratica, l'IP non è né *hard-coded* né specifico del dispositivo di rete. Si tratta di un indirizzo\n- ***logico*** - individua la ***posizione*** dell'interfaccia all'interno della rete (non l'interfaccia in sé);\n- ***dinamico*** - proprio in virtù del suo individuare una posizione lo stesso dispositivo può avere IP diversi a seconda di dove si trova.\n\nQuesto suggerisce di costruire l'IP in modo ***gerarchico***. La struttura degli indirizzi IP viene oggi definita dal **Classless Inter Domain Routing** (***CIDR***, 1993), e si può dividere in due parti:\n\n- Una prima parte (***prefisso***) identifica la ***sottorete*** (***subnet***).\n\t- Se due host possono raggiungersi fisicamente senza attraversare un router (e quindi senza entrare propriamente in Internet) si definiscono essere all'interno di una *sottorete*;\n\t- In generale, sono *sottoreti* tutti i gruppi di host che risultano ancora interconnessi anche togliendo i router dalla rete;\n- Una seconda parte (***host***) che identifica l'interfaccia all'interno della sottorete.\n\nPer sapere quando è lungo il prefisso e quanto l'host si possono usare due notazioni:\n\n- `223.1.1.0/24` o `223.1.1/24`- indica che i primi 24 bit sono prefisso (subnet `11011111 00000001 00000001 = 223.1.1`), e i restanti 8 sono interfacce interne a quella sottorete (ce ne possono essere fino a 256, corrispondenti ai valori dell'ultimo ottetto da `0` a `255`);\n\t- Questa notazione è un po' più *human-friendly*;\n- `IP = 223.1.1.0` `subent_mask = 255.255.255.0` - indica la stessa identica cosa dell'esempio precedente, ma usando una ***maschera di sottorete*** (***subnet mask***). Molto utile a livello computazionale: `255.255.255.0 = 11111111 11111111 11111111 00000000`, notiamo che\n\t- `IP` $\\land$ `subnet_mask` = `prefisso`;\n\t\t- Il `prefisso` è anche il primo indirizzo della sottorete;\n\t\t- Se ho un `IP_destinazione` a cui voglio comunicare, mi basta fare l'$and$ con `subnet_mask` e confrontare con la mia sottorete (ottenuta in modo analogo con il `mio_IP`) per sapere se sto parlando in locale o devo passare per il ***gateway***;\n\t- $\\neg($`subnet_mask`$)+  1  =$ quanti indirizzi IP ci sono in questa sottorete;\n\t- `IP` $\\lor\\,(\\neg($`subnet_mask`$)) =$  ultimo indirizzo della sottorete ($\\Rightarrow$ broadcast sulla sottorete).\n\n","x":534,"y":8140,"width":814,"height":1156,"color":"4"},
		{"id":"23a2937e757042d7","type":"text","text":"# Internet Protocol (IP)\n\nProtocollo standard *de facto* del livello di Rete. Definisce il formato del ***datagramma***, come frammentare/ricostruire i pacchetti che superano l'MTU Ethernet e la struttura degli ***indirizzi IP***.\n\n\n\n","x":714,"y":9405,"width":454,"height":181,"color":"4"},
		{"id":"7eefd49bc7f4fed8","type":"text","text":"# Data Plane\n\nA livello locale, il data plane si preoccupa di gestire il (***de)multiplexing logico e fisico dei singoli router*** ($\\Rightarrow$ associare a ogni informazione in ingresso l'uscita adeguata). Ciò avviene tramite una ***tabella di corrispondenze***, ed è detto ***forwarding***.\n\n","x":714,"y":9700,"width":454,"height":211,"color":"6"},
		{"id":"010165be9fd56b6c","type":"text","text":"# Livello di Rete\n\nLayer d'incontro tra SW (***control plane***) e HW (***data plane***).","x":-197,"y":11700,"width":316,"height":121,"color":"6"},
		{"id":"21dcd3bd8d213a16","type":"file","file":"3 - Rete/IPv4.png","x":-397,"y":9329,"width":716,"height":334},
		{"id":"6605d0100c8c141c","type":"text","text":"# PPP\n\nprotocollo point to point vecchio.","x":5260,"y":9028,"width":313,"height":122},
		{"id":"ed24fea7f7d33914","type":"file","file":"3 - Rete/ICMP.png","x":3926,"y":9209,"width":400,"height":317},
		{"id":"b2d45f43b178faa6","type":"text","text":"# IP Sec e VPN\n\nLayer di sicurezza direttamente su IP. Può agire in due modi:\n\n- ***Authentication Header Protocol*** (***AH***) - Cifra il payload del datagramma. Questo porta problemi con i NAT, che controllano l'integrità del messaggio con una funzione di hash (la modifica del solo payload rompe il digest). Poco usato;\n- ***Encapsulation Security Protocol*** (***ESP***) - Detta ***modalità tunnel*** o più comunemente ***Virtual Private Network*** (***VPN***). Cifra l'intero datagramma e lo incapsula in un altro, sostituendo le vere informazioni end-to-end tra gli host con quelle end-to-end dei router della VPN. Solo a destinazione il datagramma originale viene riesumato, motivo per cui chi legge il traffico non vede l'IP dell'host che lo ha inviato, ma solo quello del router VPN.\n\nQuando si parla di IPsec ci si riferisce in pratica alla seconda modalità d'uso.\n\nSi può intuire che mentre IP è stateless ***IPsec crea una connessione***. Quando ciò avviene, il router di partenza $R_1$ invia al router di arrivo $R_2$ un set di ***Security Associations*** (***SAs***), che include chiavi si sessione e quant'altro. Una sorta di handshaking unidirezionale, i cui risultati vengono salvati in due distinti DB:\n\n- ***Security Policy Database*** (***SPD***) - Contiene le informazioni relative a quando e se usare IPsec, nonché quale SA usare. In pratica **sa cosa fare**;\n- ***Security Association Database*** (***SAD***) - Contiene le informazioni relative alle varie SAs, su come trattare i datagrammi in uscita e quelli in ingresso. In pratica **sa come farlo**.\n\nA questo punto aggiunge del padding in coda al datagramma originale (per evitare attacchi di tipo ***deep packet inspection***, in cui deduco informazioni sul messaggio dalla sua lunghezza) e cifra il tutto con la chiave simmetrica.\n\nAggiunge quindi header ESP che specifica l'ID del tunnel e il numero di sequenza del pacchetto. Questo, insieme al MAC aggiunto in coda, evita gli attacchi replay: ricevere un duplicato farà cadere la connessione.\n\nInfine, aggiunge il nuovo header IP e invia il datagramma.\n\nQualunque agente esterno tra $R_1$ ed $R_2$ non può fare assolutamente niente rispetto al messaggio originale (se non eventualmente far cadere la connessione).","x":3736,"y":7749,"width":780,"height":991,"color":"#4545ff"},
		{"id":"43ff4c2e2c9a9b72","type":"text","text":"\nmessaggi importanti: richiesta eco (\"voglio sapere se ci sei\") e risposta eco (\"ci sono\"). \\[Questi ping sono a livello ICMP (esistono anche quelli a livello UDP)\\].","x":4391,"y":8800,"width":250,"height":314},
		{"id":"eb0d5090bf33936f","type":"text","text":"# Quanto è affidabile una VPN?\n\nPer quanto sembri impeccabile, c'è un unico punto di failure: chi controlla la VPN ha tutti i dati. Mi devo fidare della VPN, perché sa tutto quello che mando.\n\nNon che rivendano i dati, ma possono bussare alla porta quelli dell'FBI. E se succede non possono neanche dirlo al pubblico, ma c'è uno stratagemma: usare una cosiddetta \"dichiarazione canarino\", ovvero un sito la cui sola presenza online è un messaggio del tipo \"se questa pagina esiste ancora allora i servizi segreti non sono ancora entrati\".\n\nOgni azienda che offre una VPN deve rispondere alle leggi del proprio paese. In genere conviene usare una VPN svizzera (o meglio ancora Panama).\n\n- USA, UK, Canada, Australia e Nuova Zelanda formano ***I Cinque Occhi***, un'alleanza internazionale per la condivisione di informazioni di intelligence, in particolare circa la sorveglianza elettronica. Possono essere fatte richieste invasive ai provider di VPN;\n- Se aggiungiamo Danimarca, Francia, Paesi Bassi e Norvegia otteniamo ***I Nove Occhi***;\n- Se aggiungiamo anche Germania, Belgio, ***Italia***, Spagna e Svezia arriviamo a ***Quattordici Occhi***, ma come ogni fazione che riguarda l'Italia sembra essere un po' più easy delle altre.","x":4667,"y":8220,"width":757,"height":520,"color":"#4545ff"},
		{"id":"abb130ae59623855","type":"file","file":"VPN.png","x":4776,"y":7880,"width":539,"height":197},
		{"id":"aad711b95a488d69","type":"file","file":"3 - Rete/CleverMiddleboxes.png","x":1129,"y":11775,"width":372,"height":160},
		{"id":"352b4beb483d264e","type":"text","text":"# Control Plane\n\nA livello globale, il Control Plane definisce i percorsi end-to-end dei pacchetti modificando le singole tabelle di forwarding dei router.","x":714,"y":13575,"width":453,"height":211,"color":"6"},
		{"id":"2cb08263dc5f0edb","type":"text","text":"# Amministrazione della Rete (SNMP, NETCONF)\n\nMa in pratica come fa l'admin di rete ad esercitare questo ruolo?\n\nInternamente ad ogni ***managed device*** vi è un ***Management Information Base*** (***MIB***), cioè un database contenente dati di configurazione del dispositivo la cui struttura è definita dal *Data Definition Language* ***Structure of Management Information*** (***SMI***).\n\nBene, abbiamo un DDL. E il linguaggio d'interrogazione? L'admin usa il ***Simple Network Management Protocol*** (***SNMP***), che gira a livello Applicazione e si appoggia su UDP porta 161 (si può implementare anche su TCP, l'uso di UDP prova ad evitare la congestione di rete). Oltre ai messaggi standard di ***request/response***, SNMP prevede dei messaggi ***trap*** provenienti dal *managed device*, che segnalano eventuali errori o malfunzionamenti (*eccezioni*, in generale). **SNMPv3** introduce autenticazione e crittografia per evitare spoofing (qualcun altro configura i router al posto mio).\n\nTutto molto bello, non fosse che SNMP ha dei limiti (e.g. parla con un solo router alla volta, la modifica del DB può essere delicata, ...), per questo è nato ***NETCONF***.\n\nAggiunge il concetto di gruppi di router e si appoggia su SSH. I messaggi sono in formato XML, un buon punto d'incontro tra la leggibilità umana e la semplicità di un *parser* che deve estrarre i dati. La scrittura di un codice NETCONF è ulteriormente semplificata dal DDL ***YANG***, anch'esso XML.","x":575,"y":13874,"width":731,"height":612,"color":"4"},
		{"id":"b356a8ba2ad031a0","type":"text","text":"# Rete\ncontrol plane - la visione globale, che definisce gli algoritmi di routing. a sua volta può essere implementato\n- nei singoli router, in cui è una tabella con tutti gli ip e le porte corrispondenti, che risolve il forwarding. ogni router fa girare un pezzetto di un algoritmo distribuito (basato su scambi di messaggi tra nodi), che ha come output la modifica di questa tabella. è responsabile dalla propria tabella ma influenza i vicini (in quanto distribuito). rischio loop di configurazione\n- nei server (SDN), lo stesso algoritmo, ma centralizzato. Remoto. Conosce tutte le tabelle. non rischio loop. Dentro un singolo ISP posso fare tutto centralizzato. faccio copie di questo supercomputer per sicurezza.\n","x":549,"y":11433,"width":441,"height":542},
		{"id":"9727e675784a8b75","type":"text","text":"**Load Balancer (Bilanciatore di Carico)**: Immagina che stai lanciando una festa e hai molte persone che vogliono entrare. Un \"load balancer\" è come il tipo che controlla l'ingresso e distribuisce le persone in modo uniforme in modo che non ci sia troppa confusione in una zona. Nei server, il load balancer fa lo stesso, distribuendo il traffico in modo equo tra diversi server, in modo che nessun server sia sovraccaricato.","x":468,"y":12015,"width":907,"height":148},
		{"id":"ead16293e18517a7","type":"text","text":"\np4.org??\n\ninizialmente si pensava \"solo mittente e destinatario hanno tutte le info per controllare la correttezza, inutile che faccio a livello di rete. posso farlo solo ent-to-end, la rete sa solo come instradarlo\"\n\nquesto si basa sul tenere l'intelligenza sul bordo della rete\n","x":529,"y":12172,"width":786,"height":261},
		{"id":"76eb84babbdcea6a","type":"text","text":"# Algoritmo di Dijkstra (Link-State)\n\nLa premessa di ogni algoritmo Link-State è che ogni router comunichi a tutti gli altri router tutti i costi (e.g. livelli di \"intasamento\") di tutte le porte. Una volta acquisite tutte le informazioni globali, ogni nodo risolve il proprio Dijkstra (i.e. quel Dijkstra che ha se stesso come nodo di partenza).\n\nL'algoritmo si può dividere in due parti:\n\n- ***Inizializzazione*** - Definisco il nodo di partenza e per ogni nodo $k$ della rete inizializzo il valore di $D(k)$ a\n\t- $c_{u, k}$ se $k$ è direttamente collegato a $u$;\n\t- $\\infty$ altrimenti (in pratica scelgo un `terror_value` molto grande);\n- ***Loop*** - Ciclo le seguenti operazioni finché non riempio $N$ con tutti i nodi:\n\t- `i = find()` - A questo punto ho un insieme di nodi non ancora in $N$. Tra questi, seleziono quello per cui $D(i)$ è minima;\n\t\t- Sono sempre sicuro di non selezionare un \"falso minimo\";\n\t- `add_to_N(i)` - Una volta trovato, lo aggiungo ad $N$. In questo modo ho trovato il percorso ottimale definitivo per $i$, quindi non devo più cercarlo.\n\t- `for (j adjacent_to i) and (j not in N)` - Mi metto in $i$ e guardo i primi vicini, ignorando quelli per cui ho già trovato il percorso ottimale;\n\t- `D(j) = min(D(j), D(i) + c_{i,j})` - Aggiorno le stime provvisorie per tutti i $j$. Questa riga mi dice sostanzialmente che le possibilità sono due:\n\t\t- Avevo già una stima migliore di quella attuale, lascio quella;\n\t\t- Ho trovato una stima migliore, sostituisco.\n\t- Ricomincio.\n\nUna volta che converge, ogni router conosce il percorso ottimale per raggiungere qualsiasi altro router sulla rete.\n\nDijkstra funziona bene per reti piccole, altrimenti è un problema far conoscere a tutti la topologia della rete. Se $n$ router inviano ciascuno $n$ messaggi, la ***complessità di comunicazione*** (i.e. l'overhead del processo di scambio di messaggi) è $O(n^2)$.\n\nPuò avere ***comportamenti patologici*** se si definiscono male i pesi degli archi. Se ad esempio uso il volume istantaneo di traffico, ogni aggiornamento sposta i flussi creando nuovi bottleneck, che portano ad un nuovo ricalcolo, che sposta i flussi, ... (***oscillazioni***). \n\nIn generale, ad ogni variazione di anche un solo costo bisogna ricalcolare tutto (c'è un *refresh rate*, diciamo ogni $t$ secondi).\n\n","x":1205,"y":14810,"width":711,"height":1034,"color":"4"},
		{"id":"d24861aa7ccdefd8","type":"text","text":"# Algoritmo di Bellman-Ford (Distance-Vector)\n\nNasce dall'idea che se i costi cambiano *poco* voglio eseguire *poco* codice.\n\nL'inizializzazione è identica a Dijkstra: supponiamo di essere il router $u$ e di avere una stima $D_u(w) = 5$, mentre ad esempio $x$ avrà una stima $D_x(w) = 3$.\n\nA questo punto tutti i router inviano ai primi vicini le proprie stime. In particolare, $x$ comunica la sua stima $D_x(w)$ ad $u$, il quale ricalcola $D_u(w)$ tramite l'***equazione di Bellman-Ford***\n\n$$D_u(w) = \\min\\limits_{i}(c_{u,i} + D_i(w)) = \\min\\limits_{i}(\\text{distanza}_{ui} + \\text{minima distanza}_{iw})$$\n\ndove $i$ sono tutti e soli i primi vicini. Quando $i = x$, $u$ si accorge di aver trovato una stima migliore e la comunica ai propri primi vicini. $v$ riceve questa nuova stima ma la sua vecchia $D_v(w) = 3$ è ancora la scelta più conveniente, quindi non la aggiorna e non la comunica ai primi vicini. Riassumendo, ogni router\n\n- ***Attende*** la modifica del costo di un link a cui è direttamente collegato, oppure un messaggio da un router vicino;\n\t- Algoritmo ***asincrono*** - non ha un un *refresh rate* fisso, ma aspetta un evento. **Se in qualche modo non cambiano i costi, il router non calcola niente**;\n- ***Ricalcola*** le proprie stime;\n- Se cambiano, ***avvisa*** i vicini.\n\t- In quanto algoritmo ***distribuito*** nessun nodo conosce il percorso globale, e spesso il cambiamento dei costi influisce solo su una piccola parte di rete.\n\nNotare che ***l'informazione si propaga a velocità finita***, quindi quando il singolo router calcola le proprie stime lo sta in realtà facendo con dati vecchi. In realtà la velocità di propagazione dell'informazione dipende dal tipo di notizia, e porta a due ***comportamenti patologici***:\n\n- Le buone notizie si propagano velocemente. Questo può portare rapidamente ad una situazione di ***black-holing***, in cui un router pubblicizza dei costi molto bassi, il traffico viene massicciamente spostato su di lui e si crea un bottleneck;\n- Le cattive notizie si propagano lentamente, in particolare se si rompe un cavo si verifica il ***conteggio all'infinito***.\n\n\n\n","x":2114,"y":14810,"width":725,"height":1034,"color":"4"},
		{"id":"821f59516a54210b","type":"text","text":"# Pseudocodice Dijkstra\n\n```\n###    Initialization    ###\nN = {u}; \nfor all nodes k\n\tif k is_adjacent_to u\n\t\tD(k) = c_{u,k}\n\telse D(k) = ∞\n\n###         Loop         ###\n\ni = find();\nadd_to_N(i);\n\nfor (j adjacent_to i) and (j not in N):\n\tD(j) = min(D(j), D(i) + c_{i,j})\n\n### Until all nodes in N ###\n```\n","x":644,"y":15074,"width":447,"height":506,"color":"4"},
		{"id":"280a1469437d1e2d","type":"text","text":"# Quale usare?\n\n- ***Dijkstra*** ha complessità computazionale $O(n^2)$ (a meno di oscillazioni), ma è possibile implementarlo $O(n\\,log(n))$, ed una complessità di comunicazione pari a $O(n^2)$, poiché ogni messaggio comunicato dagli $n$ router al resto della rete impiega un tempo $O(n)$ con algoritmi efficienti;\n- conviene sulle reti dense (di archi) e grandi\n- non può gestire pesi negativi;\n- Si usa con un controller esterno nelle SDN;\n- Tipicamente Intra-AS\n- \n- ***Bellman-Ford*** ha complessità computazionale $O(n)$, è più veloce ma richiede condizioni molto favorevoli;\n- gestisce pesi negativi\n- conviene su reti piccole e sparse (pochi link)\n- è tipicamente Inter-AS.","x":1205,"y":16007,"width":711,"height":726,"color":"3"},
		{"id":"d186c26b15065da4","type":"text","text":"# Conteggio all'Infinito\n\n- $y$ ha un pacchetto per $x$, controlla il cavo e si accorge che il costo è aumentato;\n- Nota allora che $z$ afferma di poter arrivare ad $x$ con costo $5$;\n\t- $z$ dice così perché sta usando l'informazione non aggiornata di $y$, e si basa sul mandare il pacchetto proprio ad $y$;\n- $y$ aggiorna la sua *best route* per $x$, perché \"`z dice che ci mette 5, io per z ci metto 1, 6 è meglio di 60`\". Ora nella tabella di $y$ c'è scritto $x \\rightarrow 6$, e prevede di mandare i pacchetti a $z$;\n- $y$ aggiorna $z$, dicendogli che per arrivare ad $x$ ci mette $6$;\n- $z$ aggiorna le sue stime, trovando che \"`y dice che ci mette 6, io per y ci metto 1, 7 è meglio di 50`\";\n- $z$ aggiorna $y$, dicendogli che per arrivare ad $x$ ci mette $7$;\n- \\[...\\]\n\nIn pratica, se si rompe il cavo tra $x$ ed $y$, $y$ e $z$ aggiornano il costo sommando ciclicamente il costo del collegamento tra loro due.\n\nCome si risolve il problema delle ***rotte cicliche***?\n\n- ***Split Horizon*** - Tutto questo sta succedendo perché $z$ invia ad $y$ aggiornamenti dei percorsi che prevedono di passare da $y$ stesso (idem per $y$). Quanto poco senso ha per un umano dire \"`ciao z io ci metto 5 passando da z`\"? Non ha senso dire a $z$ le informazioni che mi ha già dato lui, quindi semplicemente gli comunico tutte le rotte **tranne** quelle che prevedono di passare da lui;\n- ***Poisoned Reverse*** - Una specie di \"non ti azzardare a rimandarmi quello che ti mando io\". In pratica comunico a $z$ che il costo del nostro link è appena diventato *enorme*, in modo da rompere la rotta ciclica;","x":2106,"y":16007,"width":725,"height":726,"color":"4"},
		{"id":"0313a94afb01da35","type":"text","text":"Sulla rete non si usa praticamente più, si usa dijkstra ma per collegare diverse reti si usano i concetti di distance vector.","x":376,"y":16090,"width":336,"height":178},
		{"id":"dbc47f290845eb11","type":"text","text":"# Algoritmi di Instradamento\n\nPer per essere in grado di direzionare il traffico in rete mi servono due cose:\n\n- Conoscere la ***topologia della rete***, che si traduce nel costruire un ***grafo pesato*** $G = (N, E)$, dove $N$ è l'insieme dei router ed $E$ l'insieme dei collegamenti fisici;\n\t- Nelle *flow table* dei singoli router ad ogni interfaccia è associato un ***costo***, ad esempio proporzionale a quanto tempo impiega il pacchetto a raggiungere l'*hop* successivo;\n\t\t- Il costo di un collegamento è spesso definito da un *admin* di rete, il quale può in realtà scegliere come vuole la logica dei costi. Può penalizzare (i.e. assegnare un costo alto) ad un collegamento verso una rete che gli sta *antipatica*;\n\t\t- Il costo di un collegamento che non esiste o che si rompe è $\\infty$;\n\t- La conoscenza della topologia divide gli algoritmi di instradamento in due macro-categorie:\n\t\t- ***Distribuiti (Distance-Vector)*** - Ogni router conosce solo le sue immediate vicinanze (e.g. ***RIP***);\n\t\t- ***Centralizzati (Link-State)*** - Ogni router conosce l'intera topologia della rete (e.g. ***OSPF***, è una centralizzazione logica mentre a livello fisico ho ridondanza), oppure questa informazione è in possesso di un ***controller*** esterno (***SDN***, e.g. ***OpenFlow***, centralizzazione sia logica che fisica, anche se di norma un controller ha un paio di computer di backup fisici);\n\t\t- In entrambi i casi i router comunicano tra loro scambiando messaggi;\n\t\t- Di norma gli algoritmi centralizzati sono più potenti dei distribuiti (hanno più informazioni!);\n- Essere in grado di **modificare le tabelle dei singoli router**.\n\t- Questa cosa può in certe situazioni può essere fatta manualmente, sia per evitare l'overhead computazionale di un algoritmo che modifica costantemente le tabelle (***dinamico***) sia per controllare in modo più preciso il flusso di dati. Qualcuno lo chiama algoritmo ***statico***, secondo me non è neanche considerabile un algoritmo (piuttosto, una configurazione manuale);\n\t- Non devo esagerare con il dinamismo. Pensa se il navigatore aggiornasse il percorso ogni 5 secondi.\n\nIpotizziamo di partire da $u$ e diamo dei nomi semplici ai concetti importanti.\n\n- $c_{x,y}$ il ***costo del collegamento*** tra $x$ e $y$.\n- $N$ è l'insieme di ***nodi per i quali il percorso minimo è stato già trovato***. Inizialmente $N = \\{u\\}$, poi tra i primi vicini di $u$ è facile vedere che l'arco dal costo minore è quello che porta a $x$, quindi dopo il primo step avremo $N = \\{ux\\}$, e così via;\n- Ipotizziamo di essere ancora al primo step. Attualmente conosco solo $u$ e i suoi primi vicini, quindi per quanto ne so il percorso ottimale $u \\rightarrow w$ costa $5$. Chiamo questa ***stima provvisoria*** $D(w)$. Più avanti nell'algoritmo mi renderò conto che il percorso che minimizza $D(w)$ è $u \\rightarrow x \\rightarrow w$;\n- Ipotizziamo di voler minimizzare $D(w)$ e di ritrovarci con due valori, $5$ e $4$. Come faccio a distinguere a livello di algoritmo qual è il percorso che è costato meno? Mi serve tenere traccia del ***nodo predecessore*** per disambiguare tra i valori di $D(w)$. Lo indico con $P(w)$, e in questo modo distinguo $D(w)\\,P(w) = \\{(5, u),\\,(4, x)\\}$.","x":1560,"y":13178,"width":916,"height":1005,"color":"4"},
		{"id":"d3537c6f38444c1e","type":"file","file":"3 - Rete/Protocolli di Instradamento/TopologiaRete.png","x":1739,"y":14302,"width":559,"height":369},
		{"id":"466f90390ebea2d9","type":"text","text":"# Middleboxes\n\nL'Internet moderno è pieno di middleboxes - NAT, Firewall, Intrusion Detection System (IDS), Load Balancers, Content Delivery Network (CDN, e.g. Netflix), Caches, ...\n\nTutte queste cose hanno spesso un funzionamento \"oscuro\", motivo per cui oggi si prova a spingere verso cose più trasparenti (che chiamano whiteboxes, per dare l'idea). Poi non ho capito se la virtualizzazione delle funzioni di rete (NFV) e quindi SDN e OpenFlow è una cosa bella in questo senso","x":1560,"y":11734,"width":916,"height":241,"color":"2"},
		{"id":"9d6f3da2e265c5bb","type":"file","file":"3 - Rete/Screenshot from 2024-05-23 17-31-44.png","x":714,"y":10049,"width":453,"height":192},
		{"id":"c61f4345c0fcfe50","type":"text","text":"# SDN\n\nSoftware Defined Network, quando c'è un controller remoto che setta tutte le tabelle con un algoritmo come Dijkstra","x":1129,"y":10559,"width":340,"height":221},
		{"id":"27f824a4b2b06850","type":"text","text":"\n\"il router è più un forwarder che un router\".  keep router simple, basta la tabella di corrispondenze, ma come passo da comportamento locale a globale?\n\nl'autostrada dei pacchetti può essere modificata live (Negli anni 50 si faceva a mano), ma facciamo un passo indietro.\n\novviamente è best effort.\nci sono stati tentativi di implementazione di rete che offra qualche servizio, ma non hanno funzionato. Ma alla fine scialla, è semplice! non serve HW particolare.\n\nse la rete soffre faccio caching. insomma, un modo lo trovo senza cambiare IP. \"ormai è così, chi è che si mette a cambiare tutto?\"","x":619,"y":10580,"width":441,"height":548},
		{"id":"b6aaf46ed042cc05","type":"text","text":"# Nomi delle interfacce fisiche\n\ninterfaccia fisica del router (layer 2) ha nomi tipo fa01, e0, e3, ...\n","x":549,"y":11202,"width":580,"height":187},
		{"id":"ca1308091356d679","type":"text","text":"# Border Gateway Protocol (BGP)\n\nProtocollo ***Distance-Vector pseudo-gerarchico*** basato su connessioni ***TCP***, è la \"*colla che tiene insieme Internet*\". Opera a due livelli:\n\n- ***eBGP*** (***External BGP***) - Collega tra loro i gateway router dei vari AS. A nome del proprio AS, possono pubblicizzare una destinazione agli altri router eBGP (i.e. `sono NEXT-HOP e posso raggiungere PREFISSO`). Il messaggio di annuncio consta di due parti:\n\t- ***prefisso***, cioè chi dichiaro di poter raggiungere (e.g. `100.1.1/24`);\n\t- ***attributi***, cioè ulteriori specifiche circa il percorso che sto pubblicizzando, ad esempio\n\t\t- `AS-PATH` - Lista degli AS da cui è passato l'annuncio, in modo tale che chi lo riceve possa fare il percorso inverso e ritrovare l'AS che lo ha divulgato;\n\t\t- `NEXT-HOP` - Indirizzo IP dell'interfaccia dell'**egress router** che ha pubblicizzato la rotta;\n\t\t- `COMMUNITY` - Etichette utili a prendere decisioni di ***policy***;\n\t\t- `ORIGIN` - Specifica chi ha generato la rotta. Se pubblicizzo un range di indirizzi interno al mio AS è `= IGP` (\"`Internal Gateway Protocol`\"), se sto inoltrando un'informazione ricevuta da un altro AS è `= EGP`. Se l'origine non è chiara trovo `INCOMPLETE`; \n- ***iBGP*** (***Internal BGP***) - All'interno del singolo AS, divulga a tutti i router le rotte apprese tramite eBGP.\n\nIl formato di un messaggio BGP prevede messaggi di tipo\n\n- `OPEN` - Apre la connessione TCP e autentica il router;\n- `UPDATE` - Pubblicizza un nuovo percorso, o ne ritira uno vecchio;\n- `KEEP-ALIVE` - A partire dal primo `ACK` di risposta alla `OPEN`, mantiene attiva la connessione in assenza di `UPDATE`;\n- `NOTIFICATION` - Usato per segnalare errori nei messaggi precedenti e per chiudere la connessione.","x":4876,"y":13112,"width":860,"height":684,"color":"4"},
		{"id":"a10663cbe8856cda","type":"file","file":"3 - Rete/Protocolli di Instradamento/BGP.png","x":5816,"y":13321,"width":628,"height":266},
		{"id":"b0579d29d6d2cd09","type":"text","text":"# Policy-Based Routing\n\nSe il routing interno è governato dall'ottimizzazione dei flussi di traffico, in quello inter-AS entrano in gioco interessi economici, diplomatici e politici. Pertanto, gli amministratori di Rete possono definire delle ***policy*** sulla base delle quali prendere decisioni come ***scegliere di non pubblicizzare una rotta*** oppure ***rifiutare una rotta*** che arriva da un altro AS.\n\nUn certo provider può essere ad esempio interessato a non far passare il proprio traffico per un certo paese. Questo si traduce in un controllo del campo `AS-PATH` come ***condizione per accettare una rotta***.\n\nPosso scegliere di non pubblicizzare un percorso se temo che questo mi inonderà di traffico che non voglio. Tipico è ad esempio un ISP che vuole solo il traffico dei propri clienti, evitando di instradare il traffico altrui. Oppure, se sono una rete piccola che collega due reti grosse non mi conviene pubblicizzare questa rotta, altrimenti mi inondano di roba.\n\nAnche internamente al singolo AS vi sono delle policy. Se ad esempio ci sono due egress router che offrono due rotte per la stessa destinazione, il router interno sceglierà l'egress router con il minor costo intra-AS, ignorando il costo inter-AS (***hot potato routing***).","x":4876,"y":13889,"width":860,"height":596,"color":"3"},
		{"id":"8f17bdc8407df68d","type":"text","text":"\n\ndi  di sopra delle tabelle c'è un algoritmo distribuito basato sulla trasmissione di messaggi. una volta che converge, modifica le tabelle.in realtà se possibile tendiamo a non renderlo distribuito, ma a usare un server centralizzato (remote controller). perché? se lascio ai router il compito di comunicare tra loro potrebbe metterci una vita. è una centralizzazione logica, ovviamente, a livello fisico ho ridondanza. il punto è che per ogni istante so l'informazione complessiva dello stato delle tabelle. idealmente.\n","x":6516,"y":14066,"width":855,"height":470},
		{"id":"ff85fbdd6c733437","type":"text","text":"# Protocolli di Instradamento\n\nsulla rete reale nessuno di questi algoritmi funziona. $O(n^2)$ se ho milioni di router è problematico. inoltre, una sottorete dovrebbe essere indipendente dagli \"ordini imposti dall'alto\" (e.g. un'ISP è veloce ma non vuole che il traffico passi da lei. è legale...? oppure (non) vuole far passare il suo traffico da una sottorete specifica).\n\ndistinguiamo allora protocolli intra-ISP e inter-ISP. Diversi ISP hanno obiettivi, capacità e politiche diverse. ogni admin vorrebbe controllare il traffico e l'instradamento della propria rete e come gestire il traffico di passaggio.\n\nmagari internamente mi implemento dijkstra. quello fuori deve essere uguale per tutti. I router interni li aggiorna il mio algoritmo, sui gateway intervengono sia il mio sia quello di tutti.\n\nquello di tutti deve avere il quadro generale degli indirizzi raggiungibili dalle varie reti autonome.","x":6676,"y":14749,"width":780,"height":540},
		{"id":"44b71fd4ce71a7b1","type":"file","file":"3 - Rete/Protocolli di Instradamento/PropagazioneInformazioneBellmanFord.png","x":2936,"y":15144,"width":400,"height":366},
		{"id":"02b1bc097aa674f5","type":"text","text":"\"Se conoscete Linux sapete cosa sono i demoni\"","x":3814,"y":15181,"width":431,"height":29},
		{"id":"d92ff2e0bcf964fc","type":"text","text":"# Routing interno\n\nEIGRP (Cisco, USA) - open source dal 2013, ci hanno trovato un tot di backdoor, c'era un periodo in cui se non avevi questo router non funzionava niente (???) \"Cisco non ha mai letto i paper di chi studiava le reti nelle università\"\n\n\ndistancevector gerarchico non sa se è stato implementato, forse è difficile\ndijkstra è più facile (infatti esiste OSPF).\n\n","x":3736,"y":15373,"width":780,"height":590},
		{"id":"ecf8f05756698441","type":"file","file":"3 - Rete/Protocolli di Instradamento/BadNewsMrBellmanFord.png","x":2936,"y":16235,"width":400,"height":271},
		{"id":"1203987fd1017803","type":"text","text":"# Protocolli di Instradamento su Internet\n\nScelgo l'algoritmo di instradamento migliore, no? ... Ni. Ci sono due macro-problemi:\n\n- L'intera ***Internet è troppo grande*** perché ogni router abbia davvero una tabella dei costi verso tutti, senza contare che inviarle agli altri router creerebbe tonnellate di traffico;\n- **Gli algoritmi assumono router identici e rete non-gerarchica**. Nella realtà bisogna tenere in considerazione l'***indipendenza dei singoli ISP***, che possono voler implementare i propri algoritmi per le proprie sottoreti.\n\nLa situazione reale è che già gli esistono dei ***domini*** (anche detti ***AS*** ***Autonomous Systems***, e.g. le sottoreti di un ISP) si distinguono due tipi di instradamento:\n\n- ***Intra-AS*** - Tutti i router all'interno dello stesso AS seguono lo stesso algoritmo di instradamento (e.g. ***RIP***, ***EIGRP***, ***OSPF***), oppure si utilizza una ***SDN***;\n- ***Inter-AS*** - I gateway router dei vari AS sono connessi tra loro tramite un unico protocollo (***BGP***), e vengono distinti in\n\t- ***egress router*** - gestiscono il traffico in uscita verso un altro AS;\n\t- ***ingress router*** - gestiscono il traffico in ingresso proveniente da un altro AS.\n\t\t- Possono essere considerati fisicamente lo stesso router, ma sono spesso separati.","x":2726,"y":13178,"width":780,"height":551,"color":"4"},
		{"id":"a2829db16c364faf","type":"text","text":"# Protocolli Inter-AS","x":3961,"y":13433,"width":330,"height":41,"color":"6"},
		{"id":"0f515725446c17f3","type":"text","text":"# EIGRP\n\nEnhanced Interior Gateway Routing Protocol  (EIGRP) è un protocollo basato su un algoritmo ***Distance-Vector***, originariamente proprietario di Cisco ma diventato open source nel 2013.","x":3736,"y":13798,"width":780,"height":121,"color":"4"},
		{"id":"0e901d7b4a68e75e","type":"text","text":"# Routing Information Protocol (RIP)\n\nProtocollo che gira a ***livello Applicazione*** (**routed**, o **route deamon**) e si appoggia su UDP (porta $520$). Usa un algoritmo ***Distance-Vector*** in cui ***tutti i link hanno costo 1*** (**distance metric**), con un massimo di $15$ ($16$ equivale a $\\infty$).\n\n- Le tabelle vengono inviate\n\t- a seguito di una ***RIP request*** (si parla di ***solicited RIP response***);\n\t- alla scadenza di un ***timer*** di circa $30$ secondi (***unsolicited RIP response***);\n- Vi sono poi tre ulteriori timer:\n\t- Se dopo circa $180$ secondi il router non riceve aggiornamenti da un vicino, questo viene considerato spento (il costo verso di lui è posto a 16);\n\t- Ogni circa $120$ secondi rimuove le righe con costi pari a $16$ (***garbage collection***).\n\t- Se arriva un'informazione da un router considerato non valido, si avvia un timer. Tutti i messaggi che arrivano entro la scadenza di tale timer vengono ignorati (***Hold-Down***);\n\nRIP non è più in uso da almeno 20 anni.","x":2726,"y":13998,"width":780,"height":487,"color":"4"},
		{"id":"ff446abb49f6a431","type":"text","text":"# Open Shortest Path First (OSPF)\n\nSfrutta un algoritmo ***Link-State*** classico (***Dijkstra***) i cui messaggi viaggiano direttamente come ***payload di IP***. I costi dei link sono decisi a priori dall'admin di rete.\n\nRispetto all'algoritmo di base, OSPF è ***gerarchico***. Distingue infatti due livelli:\n\n- una ***backbone***, di cui ogni router che ne fa parte conosce la topologia;\n- diverse ***aree locali***, ognuna a conoscenza della propria topologia ma non di quelle altrui.\n\nA fare da anello di congiunzione ci sono gli ***Area Border Routers*** (***ABR***), che conoscono sia la topologia della backbone sia quella della propria area (in pratica fanno da ***gateway*** per le proprie aree locali, come se dalla backbone in poi fosse già Internet). Nessun router conosce l'intera topologia: il ***flooding*** delle tabelle è limitato all'interno della singola area, riducendo il numero di messaggi scambiati. Quindi è sia scalabile che ottimizzato per piccole LAN.\n\nOSPF implementa un ***digest hash*** per proteggere i pacchetti dalla manomissione. Non sembra invece esserci interesse nell'evitare l'eavesdropping, cosa che comunque su IPsec è prevenuta dalla cifratura dell'intero payload.","x":3736,"y":13998,"width":780,"height":487,"color":"4"},
		{"id":"f763695377247ef9","type":"file","file":"3 - Rete/Protocolli di Instradamento/HierarchicOSPF.png","x":3736,"y":14629,"width":780,"height":239},
		{"id":"90fdccb213e512d8","type":"text","text":"# Protocolli Intra-AS","x":2956,"y":13838,"width":320,"height":41,"color":"6"},
		{"id":"b88982893d4a4621","type":"text","text":"internet best effort perché semplice\n\nNessuna\ngaranzia su consegna\ndel datagramma\na destinazione tempistica\no ordine di consegna largehezza di banda endtoend\n\n\n\ncomunque buoni risultati per la maggior parte del tempo, poi delego ai protocolli sopra","x":5552,"y":10002,"width":250,"height":531},
		{"id":"fae7f07301362f4f","type":"text","text":"guardo IP e decido la porta. oppure leggo intestazioni (e.g. se l'IP sorgente è bannato, butta il pacchetto (firewall)).\n\n\nOgni cavo in ingresso ed in uscita può in linea di principio avere la propria implementazione del livello di collegamento (e.g. ethernet, ...), ma in pratica spesso sono tutti uguali.","x":5776,"y":10644,"width":250,"height":848},
		{"id":"828e56b6e0fa5425","type":"text","text":"Oltre agli algoritmi di routing implementati all’interno dei singoli router, per il control plane può essere utilizzato anche il Software-Defined Networking (SDN), dove un server remoto, detto controller remoto, calcola preventivamente tutte le forwarding table dei router, ossia le tabelle contenenti le regole di inoltro, i quali poi si connetteranno con il controller stesso per ottenere ed installare la propria tabella","x":6616,"y":11162,"width":444,"height":285},
		{"id":"ce100f424589e14e","type":"text","text":"# Broadcast e Multicast\n\nQuando si parla di instradamento e percorsi più brevi si sottintende di avere un solo IP di destinazione (***unicast***). E se volessi mandare lo stesso messaggio a più IP?\n\n- ***Broadcast*** - Qualsiasi IP che abbia come parte host tutti `1` è un messaggio broadcast sulla sottorete specificata nel prefisso di rete. Ogni nodo che riceve un messaggio broadcast lo inoltra a tutte le altre interfacce (**uncontrolled flooding**). Questo può portare all'**instradamento ciclico**, motivo per cui si controlla il flooding con tre tecniche:\n\t- ***Sequence Number*** - Ogni nodo tiene traccia dei pacchetti già inoltrati, evitando di inoltrarli di nuovo se dovessero tornare da lui;\n\t- ***Reverse Path Forwarding*** (***RFP***) - Ipotizziamo che il mittente sia `A`. `D` inoltra solo se ha ricevuto il pacchetto dall'interfaccia che lo collega a `B`, perché corrisponde alla rotta più breve verso `A`. Se lo stesso pacchetto arriva da qualsiasi altra interfaccia, lo scarta a priori. Questo elimina una parte del problema, ma si può fare di meglio;\n\t- ***Spanning Tree*** - All'interno del grafo di rete si costruisce un albero, in modo tale che i pacchetti vengano inoltrati solo verso i figli. Questo elimina tutti i messaggi inutili.\n- ***Multicast*** - Se voglio mandare un messaggio ad un gruppo di utenti, è scomodo fare tanti unicast. Allora assegno a tutti gli host di quel gruppo uno stesso ***indirizzo IP secondario*** nel range da `224.0.0.0/8` a `239.0.0.0/8`, che definisce il ***gruppo multicast***.\n\t- I router apprendono le associazioni tra gli host e i gruppi multicast tramite ***IGMP*** (***Internet Group Management Protocol***). Sono mandati direttamente su IP con `protocol number = 2` e `TTL = 1`. I messaggi possono essere\n\t\t- `Membership Query` - Il router chiede periodicamente agli host direttamente connessi a quali gruppi multicast aderiscono. Questo perché ogni  associazione interna al router ha un timer, che viene *refreshato* dai messaggi `Report`;\n\t\t- `Membership Report` - L'host comunica al router l'adesione ad un gruppo multicast (non necessariamente in risposta ad una `Query`, e.g. appena si unisce al gruppo);\n\t\t- `Leaver Group` - L'host comunica esplicitamente al router l'abbandono di un gruppo multicast (è opzionale, il router annulla l'associazione anche se scade il timer).\n\t- A livello di instradamento, è un problema parallelo all'unicast. Questo significa che esistono ***protocolli intra-AS*** (DVMRP, ***MOSPF***, PIM) ***e inter-AS*** (***MBGP***) ***specifici per il multicast***.","x":4876,"y":12140,"width":860,"height":840,"color":"4"},
		{"id":"3140c475c121f719","type":"file","file":"3 - Rete/Protocolli di Instradamento/SpanningTreeBroadcast.png","x":5930,"y":12319,"width":400,"height":152},
		{"id":"6c1d71d878ef0bdf","type":"file","file":"3 - Rete/LawISP.png","x":3926,"y":11668,"width":400,"height":214},
		{"id":"c052c9c3688cfda2","type":"text","text":"# OpenFlow\n\nIl paradigma match-plus-action permette di programmare ad alto livello il comportamento della rete. I router non comunicano tra loro come in un algoritmo di instradamento classico, ma sono tutti connessi ad un ***controller remoto*** che raccoglie i dati, fa girare un Dijkstra, ritocca qualche dettaglio e restituisce i risultati.\n\nQuesti \"ritocchi\" permettono di implementare ***politiche di instradamento*** (e.g. far passare il traffico su una rotta meno conveniente perché quella migliore attraversa la Corea del Nord), ***bilanciamento di carico*** e altre cose belle che gli algoritmi da soli non riescono a gestire.\n\nTramite le ***API OpenFlow***, il controller parla con il livello Applicazione (***Northbound API***) e con le tabelle dei router (***Southbound API***).\n\nLa comunicazione Southbound (tra router e controller) è gestita dal ***protocollo OpenFlow***, basato su TCP, e prevede tre tipologie di messaggi:\n\n- ***controller-to-switch***\n\t- `features` - il controller chiede allo switch che tipo di operazioni supporta;\n\t- `configure` - legge o modifica i parametri di configurazione dello switch;\n\t- `modify-state` - modifica la flow table;\n\t- `packet-out` - posso iniettare un pacchetto nello switch e mandarlo su un'interfaccia;\n- ***switch-to-controller*** (**asincrono**)\n\t- `packet-in` - lo switch può mandare un pacchetto al controller (e.g. non ha un match nella flow table, evito di buttarlo);\n\t- `flow-removed` - elimina una riga della flow table ed informa il controller;\n\t- `port status` - informa il controller sullo stato di operatività di un'interfaccia.\n- ***simmetrici*** (e.g. *echo*, messaggi di errore, ...).\n\nAd oggi, le SDN sono alternative all'instradamento Intra-AS, ma è possibile pensare ad un'evoluzione Inter-AS in cui potenzialmente si implementa un controllo della congestione.","x":2726,"y":11736,"width":780,"height":782,"color":"3"},
		{"id":"e40e21afbcf471a6","type":"file","file":"3 - Rete/SwitchingFabric.png","x":2726,"y":10673,"width":780,"height":207},
		{"id":"6760b2368e759df5","type":"text","text":" Diventa difficile *bucare* il NAT, ovvero targettare correttamente un pc dietro il NAT di tipo 1;","x":5140,"y":6280,"width":250,"height":460},
		{"id":"ec6ccf01a85f8152","type":"text","text":"# DNS Dinamico\nSvantaggi: se apro un server non ho modo di comunicare il mio IP al mondo. Come si risolve? DNS dinamico.","x":4667,"y":6848,"width":349,"height":305},
		{"id":"b22d3f4b612c7e6e","type":"text","text":"# Quindi cosa devo usare?\n\nDipende da cosa devi fare. Se devi creare una singola connessione che parte dall'interno della LAN non ci sono problemi.\n\n|                                                                                                                     | NAT Statico | NAT Dinamico | PAT Statico                  | PAT Dinamico                 |\n| ------------------------------------------------------------------------------------------------------------------- | ----------- | ------------ | ---------------------------- | ---------------------------- |\n| Assegna l'IP in modo deterministico?                                                                                | Sì          | No           | Sì                           | Dipende dalla configurazione |\n| Posso avviare la comunicazione dall'esterno (i.e. ha senso metterci dietro un server)?                              | Sì          | No           | Sì                           | No                           |\n| Una volta che fuori conoscono il mio IP, posso creare facilmente una connessione a doppio canale (e.g. Active FTP)? | Sì          | Sì           | Va scritto in modo esplicito | No                           |\n| Protegge bene da un *NAT Traversal*?                                                                                | No          | Circa        | No                           | Sì                           |\n\nTutte queste decisioni vengono prese guardando soltanto l'`IP_Sorgente`. Posso prendere decisioni anche a seconda dell'`IP_Destinazione` (***Policy NAT***).\n```\nif source 192.168.1/24 and destination 100.1.1.1\n\t192.168.1/24 > 200.1.1.1\n\nif source 192.168.1/24\n\t192.168.1/24 > 200.1.1.5\n```\nInoltre posso tradurre anche la destinazione (***Twice NAT***). Se ad esempio cerco un server DNS, il router aziendale può reindirizzarmi da `8.8.8.8` (check sulla destinazione, quindi usando *Policy NAT*) al proprio server DNS (e.g. `static NAT destination to 80.80.80.80`).","x":3736,"y":6860,"width":780,"height":815,"color":"4"},
		{"id":"0efd8ee11f90ca64","type":"file","file":"3 - Rete/NAT_Disambigua.png","x":3736,"y":6194,"width":780,"height":421},
		{"id":"e1afeb32532f4b6e","type":"text","text":"# Tipi di NAT e Port Address Translation (PAT)\n\nIn realtà questa descrizione di NAT è un po' superficiale e serve solo a capire il meccanismo generale. Il NAT è la traduzione degli indirizzi IP privati in pubblici, non delle porte.\n\n- Un ***NAT Statico*** mappa *one-to-one* gli `IP_Host` agli `IP_NAT` disponibili tramite delle direttive *hard-coded* dall'admin di rete (e.g. `192.168.1.165` -> `200.1.1.1`). In questo caso, ogni assegnazione viene dichiarata esplicitamente;\n- Un ***NAT Dinamico*** fa la stessa cosa, ma in modo più flessibile. Una direttiva può essere `192.168.1.0\\24 will share 200.1.1.1 through 200.1.1.5`, ovvero \"quando un host `192.168.1.xxx` manda una richiesta per Internet, assegnagli un indirizzo casuale tra quelli disponibili nel range \\[`200.1.1.1`, `200.1.1.5`\\]\".\n\nIn entrambi i casi, il numero di `Host` che si possono collegare dietro NAT è limitato dal numero di indirizzi `IP_NAT` disponibili, perché il **NAT opera solo a livello di Rete**. Mappare diversi `IP_Host` in uno stesso `IP_NAT` pubblico (***IP*** (o ***NAT***) ***Overloading***) è possibile solo se si usano le porte per demultiplexare. Questo significa usare anche un ***Port Address Translation*** (***PAT***). Usare insieme *NAT* e *PAT* è a rigore indicato come ***NAPT***, ma dato che cambiare solamente la porta è una pratica abbastanza inusuale si usa semplicemente **PAT come sinonimo di NAPT.** Poi in pratica la gente è ignorante e usa *NAT* per indicare tutto. Dal momento che questa tecnica permette di nascondere l'`IP_Host` è anche nota come ***IP Masquerading***. Anche qui distinguo\n\n- ***PAT Statico*** - Sostituisce sempre una certa coppia `IP_Host Porta_Host` con la stessa coppia `IP_PAT Porta_PAT` (e.g. `192.168.1.165 8080` -> `200.1.1.1 80`). Questo consente di rendere un ***server*** disponibile dall'esterno sempre sulla stessa coppia `IP Porta`;\n\t- Cambiare la porta permette al server di ascoltare su porte non-standard (e.g. ascolto `HTTP` sulla `Porta_Server = 8080`, ma traduco in `Porta_PAT = 80`. Le richieste client da browser vanno in automatico sulla `Porta 80`, il *PAT* me le reindirizza su `8080`);\n- ***PAT Dinamico*** - Fa la stessa cosa, ma la `Porta_PAT` è scelta in modo casuale tra quelle disponibili. Il comportamento esatto è quello del riquadro a fianco.\n","x":2716,"y":6860,"width":790,"height":815,"color":"4"},
		{"id":"c46e0b69e7092d81","type":"text","text":"# Indirizzi IPv6\n\nNon ci sono più IPv4 disponibili? La soluzione non è il NAT, ma creare un nuovo formato di indirizzi a $128\\,bit$. Questo permette di identificare *ogni oggetto* su internet (e.g. una pagina web ha indirizzo fisso). O almeno, questa è la teoria. In pratica IPv6 è lontano dall'adozione globale.\n\nPerò è molto bello, si focalizza sull'essere snello e veloce.\n\n- L'header ha lunghezza fissa, so già dov'è il payload e posso leggerlo in parallelo;\n- Niente checksum (ci pensano i protocolli superiori)\n- Niente frammentazione (se un pacchetto supera l'MTU viene scartato!). Questo richiede di esplorare il percorso con un algoritmo di ***Path MTU Discovery*** (***PMTUD***) che sfrutta ICMP;\n- Prevede un parametro `flow label` per sviluppi futuri (il controllo di flusso secondo etichetta da parte dei router non è ancora implementato su Internet);\n- Implementa bene l'***anycast***, ovvero la consegna a tutti gli host facenti parte di un gruppo;\n- La lunghezza complessiva del datagramma è molto minore rispetto ad IPv4.\n\nil problema è che quasi tutti i router sono ancora IPv4. Per trasmettere un IPv6 devo spesso Incapsularlo come payload dell'IPv4 (***tunneling***).\n\nAttualmente non funziona bene, ma in futuro si può cambiare il concetto di cosa rappresenta un indirizzo: può diventare direttamente un URI di ogni oggetto che metto online (piuttosto che una destinazione!). Ovvero, è un hash che identifica l'oggetto. IPFS (Interplanetary Filesystem), molto carino per applicazioni p2p.","x":2716,"y":7749,"width":790,"height":691,"color":"3"},
		{"id":"07b851654a6db276","type":"text","text":"# Network Address Translation (NAT) - Overview\n\nIpotizziamo che il mio ISP mi fornisca un solo indirizzo IP. Sono costretto a poter collegare un solo host alla rete globale? No, assegno questo IP al router e poi sulla mia subnet locale uso gli ***indirizzi privati***. A quel punto sta al router reindirizzare il traffico ai vari host collegati.\n\nPer poter fare questo, il router deve disporre di un software in grado di eseguire la ***Network Address Translation*** (***NAT***). Come funziona?\n\n- Sono un host, e sulla rete locale ho indirizzo privato `192.168.1.165`. Voglio aprire una connessione TCP con il server `100.1.1.1` tra la mia porta `300` e la sua porta `443`. Creo il mio socket e invio il pacchetto al mio router che usa il NAT;\n- Il router non può mandare in rete un pacchetto con indirizzo `192.168.xxx.xxx`, perché è un indirizzo privato.\n\t- Se tutti facessero così, si romperebbe l'univocità degli IP. Esistono $N >> 1$ host che hanno indirizzo `192.168.1.165` sulla LAN, a chi mai dovrebbe essere consegnata la risposta?\n\t- In barba al concetto di *privato*, gli indirizzi IPv4 sono talmente pochi che ormai `192.168.1.165` esiste anche come indirizzo pubblico di rete. \"Del maiale non si butta niente\", diceva nonna IPv4.\n- Ma il router ha almeno un indirizzo IP pubblico assegnatogli dall'ISP (diciamo `200.1.1.1`), quindi può legittimamente mandare il pacchetto a nome suo. Allora sostituisce le informazioni del vero mittente con le proprie. `192.168.1.165 300` diventa `200.1.1.1 31`;\n\t- Perché cambiare anche la porta? Metti che anche `192.168.1.100` vuole aprire una connessione sulla porta `300`. Possono mai diventare entrambi `200.1.1.1 300`? E poi quando arriva la risposta come li distinguo? $\\Rightarrow$ La porta serve a **demultiplexare**;\n\t- Si potrebbe obiettare (e si sa che la gente obietta appena può) che essendo il router un dispositivo di Rete non dovrebbe cambiare gli header di Trasporto. Ma il router non lo sa e la cambia lo stesso;\n\t- Dato che uso la porta per demultiplexare, posso gestire fino a $2^{16}$ connessioni.\n- Le informazioni di demultiplexing (`192.168.1.165 300 31`) vengono salvate in una ***tabella di traduzione NAT***. Il pacchetto parte.\n- Il server si vede arrivare una richiesta TCP da `200.1.1.1 31`. C'è qualcosa di strano? Assolutamente no, perché il NAT è invisibile dall'esterno. Quindi lui tutto contento inizia l'handshaking e invia la prima risposta a `200.1.1.1 31`;\n- Quando al mio router arriva la risposta gli è sufficiente guardare la porta per capire a chi mandare il pacchetto. Sostituisce l'header `200.1.1.1 31` con `192.168.1.165 300` e lo spara al giusto MAC in LAN, come se niente fosse successo.\n\t- In pratica, io host sono convinto che la vera connessione sia tra `192.168.1.165 300` e `100.1.1.1 443`. Inutile dirlo, questa connessione in realtà non esiste.\n\nRiassumendo, quindi, il NAT\n\n- sostituisce l'header di rete dei datagrammi in uscita: `IP_Host Porta_Host` -> `IP_NAT Porta_NAT`;\n- salva la corrispondenza `IP_Host Porta_Host Porta_NAT` nella tabella di traduzione NAT;\n- sostituisce l'header di rete dei datagrammi in ingresso secondo la tabella di traduzione: `IP_NAT Porta_NAT`-> `IP_Host Porta_Host`.","x":1560,"y":6860,"width":916,"height":1215,"color":"4"},
		{"id":"d0f01def2aede3e1","type":"text","text":"# Il NAPT è un layer di Sicurezza?\n\nIn breve, sì. Passare attraverso il NAPT (***NAT Traversal***) non è banale.\n\n- Specificare una porta con una direttiva di ***NAPT Statico*** (anche detto ***Full Cone NAT***) permette di ignorare tutte le altre (e.g. se specifico `192.168.1.1 10` -> `200.1.1.1 30` tutti i pacchetti indirizzati a `200.1.1.1` ma con `porta`$\\neq$ `30` verranno cestinati). In pratica, posso fare *NAT Traversal* solo sapendo quale porta è aperta. Questa *feature* prende il nome di ***port forwarding*** (o ***port mapping***);\n\t- Posso invece passare attraverso il *NAT Statico* con *qualsiasi* `porta`, se conosco l'`IP`;\n- Se uso ***NAPT Dinamico***, stabilire una connessione con un host non è banale perché neanche l'host stesso conosce il suo indirizzo pubblico. A meno che, naturalmente, non sia lui ad aprirla. C'è una giungla di tecniche per provare a \"bucare\" il NAPT (**UDP Hole Punching**, **UPnP**, **MAT-PMP**, ...), che però devono (credo) sempre sfruttare un server di segnalazione (e.g. **STUN**).\n\t- Il NAPT Dinamico è anche detto ***NAPT Simmetrico*** (usa una nuova `Porta_NAT` per ogni combinazione `IP_Host Porta_Host`, anche se `IP_Destinazione` è lo stesso);\n\t- Esiste anche il ***NAPT Asimmetrico***, che usa una `Porta_NAT` per ogni `IP_Host` indipendentemente dalla `Porta_Host` e gestisce fino a $2^{16}$ dispositivi. Utile in applicazioni P2P e giochi. Dato che randomizza meno le porte è un po' più facile da bucare, motivo per cui si usa sempre meno.\n\nIn pratica, il layer di sicurezza dato dal NAPT si riassume così: se l'host dietro NAPT non ha creato una connessione con il computer target, i pacchetti a lui diretti vengono scartati.\n\nLa grossa falla di questo sistema è che il router è l'unico ***failure point***: se un malintenzionato riesce a ad entrarci dentro può potenzialmente compromettere la sicurezza di tutti i dispositivi sulla rete locale dietro quel router.\n\nContro questo rischio ci sono due \"argini\":\n\n- Possono esistere più livelli di NAPT annidati. Il singolo router non è più l'unico *point of failure* per tutta la rete, ma solo della sua LAN;\n- Meccanismi di difesa implementati dagli admin di Rete.","x":2716,"y":5980,"width":790,"height":848,"color":"#4545ff"},
		{"id":"aaf8819b6669b15b","type":"text","text":"netfilter, VoIP, DMZ. p4.org","x":534,"y":6900,"width":601,"height":194},
		{"id":"56d5c4239c1f0ac4","type":"text","text":"# Varie IP\n\nAll'interno della sottorete è previsto che tutti comunichino con tutti\n\nUn singolo dispositivo fisico ha tanti IP quante sono le sue interfacce. I router ne hanno $N$, gli host tipicamente due (Ethernet, Wi-Fi).\n","x":-479,"y":7153,"width":716,"height":229},
		{"id":"244935d41f204155","type":"text","text":"# Classi D ed E (Multicast e sviluppi futuri)\n\n- Il range di indirizzi da `224.0.0.0/8` a `239.0.0.0/8` è riservato al ***multicast***;\n- Il range di indirizzi da `240.0.0.0/8` a `255.0.0.0/8` è riservato ad eventuali sviluppi futuri. Questi IP possono essere utilizzati nelle reti locali, ma nessun router farà forwarding su pacchetti simili. Ovviamente *riservato* significa che sono in possesso degli USA.","x":534,"y":7223,"width":814,"height":187,"color":"3"},
		{"id":"82140cfb9656659a","type":"text","text":"# Classi A, B e C (Indirizzi IP Privati)\n\nPrima dell'avvento di CIDR (1993), gli indirizzi IP erano divisi in classi.\n\n- Classe A - Blocchi di IP destinati ad organizzazioni più grandi, range da `1.0.0.0/8` a `126.0.0.0/8` (si usano i primi 8 bit per identificare la classe A);\n- Classe B - Blocchi di IP più piccoli, identificati dai primi 16 bit. Range da `128.0.0.0/16` a `191.255.0.0/16`;\n- Classe C - Blocchi di IP per reti domestiche o uffici. Range da `192.168.0.0/24` a `223.255.255.0/24`.\n\nFamiliare? Perché da queste classi nascono gli ***indirizzi privati***.\n\n- Classe A - `10.0.0.0/8`;\n- Classe B - `172.16.0.0/12` ($\\Rightarrow$ iniziano con `10101100.0001xxxx`);\n- Classe C - `192.168.0.0/16`\n\nQuando mando un pacchetto entro tali range, questo non viene inoltrato in rete. Segue che lo stesso indirizzo privato può essere riutilizzato in diverse sottoreti, rendendo necessario il ***NAT***.","x":534,"y":7582,"width":814,"height":493,"color":"4"},
		{"id":"dc29aa00bf6c80bd","type":"text","text":"# Indirizzi IP Speciali\n\nAlcuni indirizzi IP non identificano un'interfaccia, ma piuttosto dei comportamenti standard.\n\n- `0.0.0.0` è usato quando l'interfaccia non ha ancora un IP associato;\n- Qualsiasi IP che abbia come prefisso di rete tutti `0` si riferisce alla sottorete corrente;\n- `255.255.255.255` è un messaggio ***broadcast*** sulla LAN;\n\t- Qualsiasi IP che abbia come parte host tutti `1` è un messaggio broadcast sulla sottorete specificata nel prefisso di rete (\"Se sono admin di rete, la prima cosa che faccio è proibire i broadcast dall'esterno, sennò chiunque mi può bombardare di dati\");\n- Qualsiasi IP della forma `127.xxx.xxx.xxx` è un indirizzo di ***loopback***. Quando l'host invia un pacchetto con un IP di loopback, questo non esce dal computer ma viene trattato come pacchetto in arrivo;\n- Indirizzi privati.","x":-446,"y":8140,"width":814,"height":420,"color":"4"},
		{"id":"ca5c134f4171b830","type":"file","file":"3 - Rete/SDN.png","x":3560,"y":11928,"width":301,"height":399},
		{"id":"ee5b41e945fefa02","type":"file","file":"3 - Rete/DettaglioControllerSDN.png","x":3926,"y":11970,"width":400,"height":315},
		{"id":"85e2ebfd8550e69e","type":"text","text":"# Software Defined Network (SDN)\n\nParticolare tipo di instradamento ***Intra-AS*** gestito tramite un controller remoto che sfrutta il ***forwarding generalizzato***.","x":2846,"y":12777,"width":540,"height":125,"color":"6"},
		{"id":"87358e95a4cca411","type":"text","text":"# Firewall\n\nTra la rete privata e la rete pubblica si erge tipicamente un ***firewall***, il cui compito è sostanzialmente filtrare i pacchetti in ingresso. Ciò include la prevenzione di attacchi di ***SYN Flooding*** (i.e. bombardamento di richieste di aperture di connessioni TCP fittizie, una sorta di ***DoS***), nonché impedire modifiche o letture non autorizzate ad utenti esterni (implementando un meccanismo di autenticazione). La scelta può essere fatta secondo criteri\n\n- di indirizzo IP di origine e/o destinazione;\n- di protocollo utilizzato (TCP/UDP) e/o porta logica (e.g. bloccare la porta 23 significa bloccare Telnet);\n- di tipologia di messaggio ICMP (e.g. impedire i broadcast sulla propria rete che provengono dall'esterno);\n\nTutto questo avviene in modo \"stupido\", i.e. c'è una tabella che specifica quali range di IP o porta ammettere (`allow`) o bloccare (`deny`). Per un controllo più intelligente (e.g. correlazioni tra più pacchetti, in grado di identificare un traffico \"inusuale\") serve un ***Intruder Detection System*** (***IDS***).","x":1560,"y":12635,"width":916,"height":409,"color":"#4545ff"},
		{"id":"06174ae2aacf2d26","type":"text","text":"# Tipi di Reti\n\nLe Reti si classificano in base a quanto sono grosse. Già.\n\n- **Personal Area Network** (**PAN**) - tipicamente pochi metri (e.g. Bluetooth);\n- **_Local Area Network_** (**_LAN_**) - tipicamente entro un appartamento (e.g. Wi-Fi, Ethernet). Ogni nodo estremale possiede un indirizzo (**MAC**) che lo identifica univocamente all’interno della LAN. Si può implementare come\n\t- **cavo condiviso** - tutti i dispositivi sono connessi al router tramite un cavo comune. Questa roba non si fa più, anche perché si creano interferenze e non esiste la privacy (chiunque poteva attaccarsi al cavo e leggere il traffico dati di tutti, \"oggi a meno che tu non sia l'NSA non lo fai\");\n\t- **switch** - da un lato ha i vari dispositivi in parallelo, dall'altra il router. Permette la trasmissione simultanea di più host.\n- **Metropolitan Area Network** (**MAN**) - tipicamente copre una città;\n- **_Wide Area Network_** (**_WAN_**) - tipicamente copre un paese o una nazione ed è gestita da un **_Internet Service Provider_** (**_ISP_**). Abbiamo anche qui due casi:\n\t- **point-to-point** - ho due reti collegate tramite un singolo mezzo di trasmissione. Questo è il modo più semplice di realizzare una **internet** (con la i minuscola, che qui ci tengono, abbreviativo per **internetwork**), ovvero una rete di reti;\n\t- **commutazione** - ho più reti collegate tramite più mezzi di trasmissione, il che probabilmente includerà anche più nodi di interconnessione.\n- **_Internet_** - la rete di tutte le reti, il Tutto, il MoaN (Mother of All Networks), una specie di divinità, un concetto filosofico, ...","x":-4143,"y":-220,"width":698,"height":740,"color":"4"},
		{"id":"ed6dd0d5b788bd3e","type":"text","text":"# In pratica e in breve\n\nPer accedere ad Internet ($\\Rightarrow$ scambiare dati con qualsiasi altro nodo collegato), gli host si devono in qualche modo connettere agli ISP (aziendali, università, commerciali), i quali a loro volta devono essere interconnessi (tramite ISP più grandi o IXP).\n\nLa risultante rete di reti è molto complessa, perché la sua evoluzione è figlia di un abnorme ammasso disordinato di fattori (politici, economici, nazionali, ...).","x":-4570,"y":-781,"width":772,"height":300,"color":"4"}
	],
	"edges":[
		{"id":"6ddf40dd3d233286","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"23227e82062b49bc","toSide":"right"},
		{"id":"f97b165cd5b79ca1","fromNode":"23227e82062b49bc","fromSide":"top","toNode":"06174ae2aacf2d26","toSide":"bottom"},
		{"id":"79cea350f5f65501","fromNode":"a569f47822207faf","fromSide":"left","toNode":"4f9f693b64bc0e3f","toSide":"right"},
		{"id":"6d5ee26096e39af5","fromNode":"06174ae2aacf2d26","fromSide":"left","toNode":"a569f47822207faf","toSide":"right"},
		{"id":"efca276162b37995","fromNode":"a569f47822207faf","fromSide":"right","toNode":"06174ae2aacf2d26","toSide":"left"},
		{"id":"61b78f68c63f4e8a","fromNode":"23227e82062b49bc","fromSide":"left","toNode":"b72f299bae389d13","toSide":"right"},
		{"id":"6f94fecf4639c0f4","fromNode":"4958894e7197fe3c","fromSide":"bottom","toNode":"1ec4d0918042c205","toSide":"right"},
		{"id":"18732b858dd6d8e8","fromNode":"b72f299bae389d13","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"top"},
		{"id":"236fb80dc10bcb1c","fromNode":"795690d5ce7e1c11","fromSide":"top","toNode":"b72f299bae389d13","toSide":"bottom"},
		{"id":"08f8c4d75162bc70","fromNode":"1ec4d0918042c205","fromSide":"left","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"2ad6aae7b242e920","fromNode":"795690d5ce7e1c11","fromSide":"left","toNode":"c842e00522cec07d","toSide":"right"},
		{"id":"6231bef59e40ecfa","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"5cf8d16de6efff56","toSide":"top"},
		{"id":"7ddcd8cf952994b6","fromNode":"9ed19d6e9980b34b","fromSide":"left","toNode":"0276409902e40e9c","toSide":"right"},
		{"id":"fceeaf4ae4ae9491","fromNode":"23227e82062b49bc","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"818a74c3caa1b0b6","fromNode":"5cf8d16de6efff56","fromSide":"bottom","toNode":"1bd86960d6e5a8e2","toSide":"top"},
		{"id":"c16c39c9b26ca69c","fromNode":"1ec4d0918042c205","fromSide":"right","toNode":"44898ee22f42afdc","toSide":"left"},
		{"id":"91f484736f73f3df","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"56958c816f8128f6","toSide":"bottom"},
		{"id":"49bc3d9146b806bb","fromNode":"665f35bd71acbb90","fromSide":"top","toNode":"44898ee22f42afdc","toSide":"bottom"},
		{"id":"4d323ae12dc8b711","fromNode":"44898ee22f42afdc","fromSide":"right","toNode":"c45a83a3705f7881","toSide":"left"},
		{"id":"7534cf6c10d8c863","fromNode":"5cf8d16de6efff56","fromSide":"right","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"fe0cb992b8bb8e89","fromNode":"0c876453e3807959","fromSide":"right","toNode":"665f35bd71acbb90","toSide":"left"},
		{"id":"9ab56fb991918b05","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"892fdf290715d14d","fromNode":"795690d5ce7e1c11","fromSide":"bottom","toNode":"9ed19d6e9980b34b","toSide":"top"},
		{"id":"ebcab486927cb5de","fromNode":"9ed19d6e9980b34b","fromSide":"right","toNode":"5cf8d16de6efff56","toSide":"left"},
		{"id":"6a0ae24e30667e00","fromNode":"665f35bd71acbb90","fromSide":"right","toNode":"981b264b7f7630c2","toSide":"left"},
		{"id":"7286f70c7c7e9e6f","fromNode":"981b264b7f7630c2","fromSide":"top","toNode":"c45a83a3705f7881","toSide":"bottom"},
		{"id":"9e27c5c48748361f","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"45a11294a8434cf8","toSide":"bottom"},
		{"id":"8af8a5f3e2ad1274","fromNode":"a569f47822207faf","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"4bc5fcb03b652768","fromNode":"4f9f693b64bc0e3f","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"a0745a8a10aa21ec","fromNode":"c45a83a3705f7881","fromSide":"bottom","toNode":"981b264b7f7630c2","toSide":"top"},
		{"id":"1c2152fd9676e1e4","fromNode":"c45a83a3705f7881","fromSide":"top","toNode":"305c16fa5fcbfca6","toSide":"bottom"},
		{"id":"7d0ac71b97316b5b","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"0e49609704fa8c9e","toSide":"bottom"},
		{"id":"feab48c838e8a738","fromNode":"0e49609704fa8c9e","fromSide":"top","toNode":"d7a25775f996e167","toSide":"bottom"},
		{"id":"4def83e52862fb08","fromNode":"665f35bd71acbb90","fromSide":"bottom","toNode":"1b501ca1023c98e0","toSide":"top"},
		{"id":"ee61d1fcc7c2de03","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"f6c22dc935238119","toSide":"right"},
		{"id":"5edcd65f331c9876","fromNode":"1a0fe951bbf51b93","fromSide":"left","toNode":"472a39255272296f","toSide":"right"},
		{"id":"f14f75bb6f530e76","fromNode":"1bd86960d6e5a8e2","fromSide":"left","toNode":"4df27d69ac9764ca","toSide":"right"},
		{"id":"47a253347dc37b5d","fromNode":"1bd86960d6e5a8e2","fromSide":"bottom","toNode":"3881465ee755981e","toSide":"top"},
		{"id":"5d939219c7bb9a7a","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"34401d45639b449d","toSide":"top","label":"To Layer 4"},
		{"id":"7db3cb5e783eb5a1","fromNode":"3881465ee755981e","fromSide":"left","toNode":"179ce6b66f1a29fe","toSide":"right","label":"To Layer 5"},
		{"id":"f0bd2107ddee8ba5","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"010165be9fd56b6c","toSide":"left","label":"To Layer 3"},
		{"id":"cd673b03983e203e","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"8ca68ef0d9cba75a","toSide":"right"},
		{"id":"048457974880d02b","fromNode":"179ce6b66f1a29fe","fromSide":"left","toNode":"ea111d8cb579b650","toSide":"bottom"},
		{"id":"86da5dab44bb03d1","fromNode":"bd9ffece9b4d9aa9","fromSide":"top","toNode":"f10a4ae200557701","toSide":"bottom"},
		{"id":"7f22da68abb7dd48","fromNode":"34401d45639b449d","fromSide":"bottom","toNode":"6f3226cdbb9850aa","toSide":"top"},
		{"id":"fa4fd6ac27fede83","fromNode":"179ce6b66f1a29fe","fromSide":"left","toNode":"349ec5026bac8b92","toSide":"top"},
		{"id":"c229738031cda2ac","fromNode":"179ce6b66f1a29fe","fromSide":"bottom","toNode":"e47fac0c91452bb7","toSide":"top"},
		{"id":"94b6a91f71272017","fromNode":"dff88af00a536f81","fromSide":"right","toNode":"34401d45639b449d","toSide":"left"},
		{"id":"731f0ec0ddf99b38","fromNode":"ea111d8cb579b650","fromSide":"left","toNode":"52edf2e6ee84f9b0","toSide":"right"},
		{"id":"d980c1a93aafee90","fromNode":"4df27d69ac9764ca","fromSide":"top","toNode":"1a0fe951bbf51b93","toSide":"bottom"},
		{"id":"99ef61b1863659dc","fromNode":"1bd86960d6e5a8e2","fromSide":"bottom","toNode":"35235b872aeaab53","toSide":"top"},
		{"id":"3c0abd32c7fec049","fromNode":"8b3faa26de750a2c","fromSide":"bottom","toNode":"89560ca8221b899c","toSide":"top"},
		{"id":"ea054aef41b0cca0","fromNode":"8b3faa26de750a2c","fromSide":"bottom","toNode":"a30868312d411d98","toSide":"top"},
		{"id":"7ce23dadaa651095","fromNode":"89560ca8221b899c","fromSide":"left","toNode":"6ce8f85f78362603","toSide":"right"},
		{"id":"dbf52d276f427907","fromNode":"973215b7fd31a26a","fromSide":"bottom","toNode":"ee9aa768d32eb89f","toSide":"top"},
		{"id":"6b464d08ca48f405","fromNode":"a30868312d411d98","fromSide":"right","toNode":"55d3231875e83cc8","toSide":"left"},
		{"id":"bd3886a5bc77d5a0","fromNode":"89560ca8221b899c","fromSide":"bottom","toNode":"ff01e5961e252647","toSide":"top"},
		{"id":"8d5e2dc5232a299d","fromNode":"a30868312d411d98","fromSide":"bottom","toNode":"ff01e5961e252647","toSide":"top"},
		{"id":"3b7a2fa2471a6608","fromNode":"ff01e5961e252647","fromSide":"bottom","toNode":"16f174d47e0dd2b5","toSide":"top"},
		{"id":"4631afa28cad3105","fromNode":"ff01e5961e252647","fromSide":"bottom","toNode":"44ce1eef2a1a2afa","toSide":"top"},
		{"id":"684296b62490a2a4","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"973215b7fd31a26a","toSide":"top"},
		{"id":"81a09b69b0c5bbbf","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"ada1ce65a17b1ff7","toSide":"top"},
		{"id":"8348e2cf9fcc3177","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"be024ab3c20ae124","toSide":"left"},
		{"id":"d1500d777e5a6d46","fromNode":"acb4f16f12e3f2e9","fromSide":"bottom","toNode":"6694e27578406638","toSide":"top"},
		{"id":"70d68af1971fd88f","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"acb4f16f12e3f2e9","toSide":"top"},
		{"id":"8f627262a584f38a","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"b42a1d8cb55878e0","toSide":"bottom"},
		{"id":"8fbed3ff33aca630","fromNode":"c25570b5d51372e2","fromSide":"bottom","toNode":"77ddaf1188c7b900","toSide":"top"},
		{"id":"d3994aec3181fafe","fromNode":"77ddaf1188c7b900","fromSide":"bottom","toNode":"04b979f48c716c0b","toSide":"top"},
		{"id":"95a357d298fdd7b9","fromNode":"6694e27578406638","fromSide":"bottom","toNode":"f99413b00ff804a3","toSide":"top"},
		{"id":"1684ada3383a3b04","fromNode":"f99413b00ff804a3","fromSide":"bottom","toNode":"431962e65465019d","toSide":"top"},
		{"id":"757b6e2877809f77","fromNode":"f99413b00ff804a3","fromSide":"bottom","toNode":"dab2f7463a1544fc","toSide":"top"},
		{"id":"0a9dc2c060770823","fromNode":"431962e65465019d","fromSide":"left","toNode":"beb0fa9d0cb9609a","toSide":"right"},
		{"id":"9e73506530a57cb1","fromNode":"dab2f7463a1544fc","fromSide":"right","toNode":"431962e65465019d","toSide":"left"},
		{"id":"4f90efa6599cf187","fromNode":"431962e65465019d","fromSide":"left","toNode":"dab2f7463a1544fc","toSide":"right"},
		{"id":"94aba2fbbe97d827","fromNode":"305c16fa5fcbfca6","fromSide":"right","toNode":"e98fee2b8eb0a179","toSide":"left"},
		{"id":"b91001174f697fce","fromNode":"0719791a80c12eb2","fromSide":"top","toNode":"d0bc31a12d2847f8","toSide":"bottom"},
		{"id":"581c8be36c8c5d8f","fromNode":"ff62151f49666864","fromSide":"left","toNode":"0b031d2a05976038","toSide":"right"},
		{"id":"e2c0b939a1c3a84e","fromNode":"2edbb402780f44c6","fromSide":"right","toNode":"8b3faa26de750a2c","toSide":"left"},
		{"id":"26db68dfe4ccff0c","fromNode":"b42a1d8cb55878e0","fromSide":"left","toNode":"ff62151f49666864","toSide":"right"},
		{"id":"19be112fc67481ac","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"a13ba86d0881bc3c","toSide":"top"},
		{"id":"502b754c3aa17464","fromNode":"a13ba86d0881bc3c","fromSide":"top","toNode":"c25570b5d51372e2","toSide":"top"},
		{"id":"56c3bb85acedb920","fromNode":"a13ba86d0881bc3c","fromSide":"top","toNode":"8235584e2a6409b7","toSide":"bottom"},
		{"id":"3e1856f5b89479ab","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"8235584e2a6409b7","toSide":"bottom"},
		{"id":"11b4f3af12879717","fromNode":"ea111d8cb579b650","fromSide":"top","toNode":"aa2f1768f7663ebf","toSide":"bottom"},
		{"id":"0392c6a0826a8fab","fromNode":"dff88af00a536f81","fromSide":"top","toNode":"b81367aa9de6afb4","toSide":"bottom"},
		{"id":"6879b643affd1e0e","fromNode":"dff88af00a536f81","fromSide":"bottom","toNode":"a040ad793f9beeac","toSide":"top"},
		{"id":"4e88dd4229982007","fromNode":"a040ad793f9beeac","fromSide":"bottom","toNode":"e2750b6b7a2c01af","toSide":"top"},
		{"id":"0bd09d94413ca585","fromNode":"3881465ee755981e","fromSide":"top","toNode":"0719791a80c12eb2","toSide":"bottom"},
		{"id":"b1b50abed84b9191","fromNode":"4df27d69ac9764ca","fromSide":"bottom","toNode":"35235b872aeaab53","toSide":"top"},
		{"id":"175fce85c6410af9","fromNode":"acea343615dea605","fromSide":"bottom","toNode":"2edbb402780f44c6","toSide":"top"},
		{"id":"e0741c499f5a9599","fromNode":"349ec5026bac8b92","fromSide":"left","toNode":"acea343615dea605","toSide":"right"},
		{"id":"472c8c49ca90d2e6","fromNode":"40ee9c3447f7fb82","fromSide":"right","toNode":"0efd970a1119442f","toSide":"left"},
		{"id":"33280d80c35d33bf","fromNode":"acea343615dea605","fromSide":"top","toNode":"6efc85167597eec6","toSide":"right"},
		{"id":"1dd2b92926522dfc","fromNode":"acea343615dea605","fromSide":"top","toNode":"877a13b60a49c414","toSide":"left"},
		{"id":"ee99fc1ed31f00ef","fromNode":"877a13b60a49c414","fromSide":"top","toNode":"aa76e477e11e779d","toSide":"bottom"},
		{"id":"06b74f9e3f7e46bd","fromNode":"6efc85167597eec6","fromSide":"bottom","toNode":"2c357555847a692e","toSide":"top"},
		{"id":"bca4d744f7646067","fromNode":"0d69bbc0efaf38ce","fromSide":"top","toNode":"2a51de9d069e3b02","toSide":"bottom"},
		{"id":"cacccf6ae674edbe","fromNode":"0d69bbc0efaf38ce","fromSide":"right","toNode":"2c547fef2c5dcf45","toSide":"left"},
		{"id":"9dd973f761a8185c","fromNode":"6efc85167597eec6","fromSide":"top","toNode":"0d69bbc0efaf38ce","toSide":"bottom"},
		{"id":"102ce3f1c097fdbf","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"a0476a2b8399dc67","toSide":"top"},
		{"id":"a9b365d356249eaf","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"0bcac05d389026f2","toSide":"bottom"},
		{"id":"dfac2447c54a08cc","fromNode":"0d69bbc0efaf38ce","fromSide":"left","toNode":"d9218fbe64e55603","toSide":"bottom"},
		{"id":"500541804019d1c5","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"84caca764ec7fb4e","toSide":"right"},
		{"id":"02d34002b55f347e","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"f4a58217f873b504","toSide":"top"},
		{"id":"60be2888bbfbe9f4","fromNode":"0bcac05d389026f2","fromSide":"top","toNode":"d9218fbe64e55603","toSide":"bottom"},
		{"id":"5de96e4cfcae595a","fromNode":"0bcac05d389026f2","fromSide":"bottom","toNode":"84caca764ec7fb4e","toSide":"right"},
		{"id":"8fb21869f7e78d8c","fromNode":"d9218fbe64e55603","fromSide":"left","toNode":"4694cc6e9478ff73","toSide":"right"},
		{"id":"d0a9712c0a098f37","fromNode":"d9218fbe64e55603","fromSide":"left","toNode":"b99dcc266569a95d","toSide":"right"},
		{"id":"d61c7aa7366222a9","fromNode":"d9218fbe64e55603","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"right"},
		{"id":"3b79b164037dce89","fromNode":"0bcac05d389026f2","fromSide":"left","toNode":"2cf0e73ceaebad33","toSide":"right"},
		{"id":"133dc4f16a496df4","fromNode":"807b9ea551e9eb4a","fromSide":"bottom","toNode":"2cf0e73ceaebad33","toSide":"left"},
		{"id":"cdcedae67dc73ef0","fromNode":"2cf0e73ceaebad33","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"bottom"},
		{"id":"48f18a94c4689c94","fromNode":"2cf0e73ceaebad33","fromSide":"right","toNode":"d9218fbe64e55603","toSide":"bottom"},
		{"id":"f80af4331101f38b","fromNode":"b99dcc266569a95d","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"right"},
		{"id":"78a251b841c56b27","fromNode":"4694cc6e9478ff73","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"right"},
		{"id":"0f53cc5be936e481","fromNode":"d9194ed55437e184","fromSide":"left","toNode":"d9218fbe64e55603","toSide":"right"},
		{"id":"79b3fa714035a627","fromNode":"84caca764ec7fb4e","fromSide":"left","toNode":"bd9ffece9b4d9aa9","toSide":"right"},
		{"id":"71708495721d21ca","fromNode":"84caca764ec7fb4e","fromSide":"left","toNode":"60429356d103493a","toSide":"right"},
		{"id":"450556ccb0e0a941","fromNode":"f4a58217f873b504","fromSide":"right","toNode":"29e1d3a847d6212b","toSide":"left"},
		{"id":"be05070237675422","fromNode":"34401d45639b449d","fromSide":"right","toNode":"1a7e522c18045e6d","toSide":"left"},
		{"id":"f195684b063a3945","fromNode":"6f3226cdbb9850aa","fromSide":"bottom","toNode":"78a5ab219227020b","toSide":"top"},
		{"id":"5c4afc93813ef4ca","fromNode":"ba32fe7205e2606f","fromSide":"right","toNode":"78a5ab219227020b","toSide":"left"},
		{"id":"7ede39539c2cdd37","fromNode":"352b4beb483d264e","fromSide":"right","toNode":"dbc47f290845eb11","toSide":"left"},
		{"id":"ecf4d2f44b241822","fromNode":"6f3226cdbb9850aa","fromSide":"right","toNode":"fb29b2016fb66f0d","toSide":"left"},
		{"id":"a5ffe1b88ee5cb9a","fromNode":"6f3226cdbb9850aa","fromSide":"right","toNode":"968f90c621f36328","toSide":"left"},
		{"id":"41bf4dd6499b56b0","fromNode":"fb29b2016fb66f0d","fromSide":"bottom","toNode":"968f90c621f36328","toSide":"top","toEnd":"none","label":"+"},
		{"id":"e7555b9b24534d41","fromNode":"968f90c621f36328","fromSide":"bottom","toNode":"b2c8e74231cf5ae9","toSide":"top","toEnd":"none","label":"="},
		{"id":"0052c55476d4df64","fromNode":"78a5ab219227020b","fromSide":"bottom","toNode":"b2c8e74231cf5ae9","toSide":"top"},
		{"id":"6e7db06d4aee5f49","fromNode":"78a5ab219227020b","fromSide":"bottom","toNode":"cfd8a6577c228df0","toSide":"right"},
		{"id":"22d30b12759822d9","fromNode":"1a7e522c18045e6d","fromSide":"right","toNode":"35bf718e7b0b1267","toSide":"left"},
		{"id":"79b2fc54f561c692","fromNode":"fb29b2016fb66f0d","fromSide":"right","toNode":"587ced46e42595c9","toSide":"left"},
		{"id":"aba4db3af060ec4b","fromNode":"fb29b2016fb66f0d","fromSide":"top","toNode":"51014418878ce34a","toSide":"bottom"},
		{"id":"46d81da55e0b71d5","fromNode":"587ced46e42595c9","fromSide":"top","toNode":"ca345537eca5f999","toSide":"bottom"},
		{"id":"e2c167b44e1f7bb5","fromNode":"587ced46e42595c9","fromSide":"bottom","toNode":"42184aaeeadc6b30","toSide":"top"},
		{"id":"c0414ee677bb368a","fromNode":"587ced46e42595c9","fromSide":"right","toNode":"2282be8cea1536dd","toSide":"left"},
		{"id":"c659558735a7521d","fromNode":"2282be8cea1536dd","fromSide":"bottom","toNode":"97af67201a182e72","toSide":"top"},
		{"id":"98da2f55505e32f8","fromNode":"2282be8cea1536dd","fromSide":"right","toNode":"10dba3310cd9aed8","toSide":"left"},
		{"id":"cd56a58396e741c7","fromNode":"10dba3310cd9aed8","fromSide":"top","toNode":"219387a67a5b2a86","toSide":"bottom"},
		{"id":"3b0e2cb2565af188","fromNode":"10dba3310cd9aed8","fromSide":"top","toNode":"2f558b72d21a3998","toSide":"bottom"},
		{"id":"3218fb97b7d99697","fromNode":"10dba3310cd9aed8","fromSide":"right","toNode":"976d5b3f569f713f","toSide":"left"},
		{"id":"97f0e4aa926e7397","fromNode":"976d5b3f569f713f","fromSide":"bottom","toNode":"00cca53cff5a9684","toSide":"top"},
		{"id":"2523faa8c3134d3d","fromNode":"976d5b3f569f713f","fromSide":"right","toNode":"2df2877d35b32cbf","toSide":"left"},
		{"id":"a33e38e0672a62a1","fromNode":"2df2877d35b32cbf","fromSide":"bottom","toNode":"d336bdc958fc40a1","toSide":"top"},
		{"id":"b3c3793214b2f36d","fromNode":"2df2877d35b32cbf","fromSide":"right","toNode":"133c092a1da3e3ae","toSide":"left"},
		{"id":"9ad333442c33e1b3","fromNode":"133c092a1da3e3ae","fromSide":"bottom","toNode":"aafdfc81117b9e28","toSide":"top"},
		{"id":"08935985d6adac55","fromNode":"aafdfc81117b9e28","fromSide":"bottom","toNode":"f55770ab8bdeed44","toSide":"top"},
		{"id":"559fc712e8a39acb","fromNode":"aafdfc81117b9e28","fromSide":"bottom","toNode":"9b35587f0d6f95ff","toSide":"top"},
		{"id":"1c0339604e1610d8","fromNode":"010165be9fd56b6c","fromSide":"top","toNode":"7eefd49bc7f4fed8","toSide":"left"},
		{"id":"0169e3fbf2b4cf68","fromNode":"b72f299bae389d13","fromSide":"left","toNode":"fd5376187828d385","toSide":"right"},
		{"id":"121d6e0e6a0bbfac","fromNode":"3881465ee755981e","fromSide":"top","toNode":"9f731eac72823c6c","toSide":"left","label":"To Layer 2"},
		{"id":"05f61ec5eee5f8af","fromNode":"010165be9fd56b6c","fromSide":"bottom","toNode":"352b4beb483d264e","toSide":"left"},
		{"id":"b71ad694ff506106","fromNode":"d1b8f4d6b685141c","fromSide":"bottom","toNode":"b7cbea2785c98166","toSide":"top"},
		{"id":"f45471b23cc5e3df","fromNode":"7eefd49bc7f4fed8","fromSide":"right","toNode":"d1b8f4d6b685141c","toSide":"left"},
		{"id":"f62fea1c41ce9348","fromNode":"968f90c621f36328","fromSide":"right","toNode":"0b291757625d92c0","toSide":"left"},
		{"id":"0ab4326e24e41140","fromNode":"0b291757625d92c0","fromSide":"right","toNode":"ea742b05a7119ace","toSide":"left"},
		{"id":"efb5ed51d052bbf6","fromNode":"ea742b05a7119ace","fromSide":"left","toNode":"0b291757625d92c0","toSide":"right"},
		{"id":"33cf90e6a246d509","fromNode":"9764b381a2329f2a","fromSide":"right","toNode":"37b58e88f2ef363d","toSide":"left"},
		{"id":"72b9f47140d4e2a2","fromNode":"968f90c621f36328","fromSide":"right","toNode":"47339376d0be509e","toSide":"left"},
		{"id":"23415a1a844b5b1d","fromNode":"b2c8e74231cf5ae9","fromSide":"right","toNode":"47339376d0be509e","toSide":"left"},
		{"id":"2d2c8a5fdbda053e","fromNode":"47339376d0be509e","fromSide":"right","toNode":"7eac4e5422d7b896","toSide":"left"},
		{"id":"2bd958e6201bdb08","fromNode":"47339376d0be509e","fromSide":"bottom","toNode":"3e3d13c4f8b98712","toSide":"top"},
		{"id":"da769821382eefbf","fromNode":"47339376d0be509e","fromSide":"bottom","toNode":"74887c9278678a80","toSide":"top"},
		{"id":"8ec3c1c29ef06ed6","fromNode":"3e3d13c4f8b98712","fromSide":"bottom","toNode":"65291f3a25033246","toSide":"top"},
		{"id":"288db7e6690169d8","fromNode":"74887c9278678a80","fromSide":"right","toNode":"d0bf911b53869b69","toSide":"left"},
		{"id":"61c714fd4a109052","fromNode":"b2c8e74231cf5ae9","fromSide":"left","toNode":"9c002ace9319f7e3","toSide":"right"},
		{"id":"41ceb71df395e872","fromNode":"b2c8e74231cf5ae9","fromSide":"bottom","toNode":"d2bed5e555c3844b","toSide":"top"},
		{"id":"c27c0a7aca0c843a","fromNode":"d2bed5e555c3844b","fromSide":"bottom","toNode":"d1472b8d646b14ad","toSide":"left"},
		{"id":"8e9379f57318120e","fromNode":"d1472b8d646b14ad","fromSide":"left","toNode":"0436be9329309ad0","toSide":"top"},
		{"id":"28032feb16a73b3b","fromNode":"d2bed5e555c3844b","fromSide":"bottom","toNode":"0436be9329309ad0","toSide":"top"},
		{"id":"721d2dc8b5faf72b","fromNode":"b2c8e74231cf5ae9","fromSide":"bottom","toNode":"ebaaa4d935ae2768","toSide":"right"},
		{"id":"a93d75511b4d0111","fromNode":"ebaaa4d935ae2768","fromSide":"left","toNode":"3fd6f7170699d719","toSide":"right"},
		{"id":"68a26ea677fbb08e","fromNode":"ebaaa4d935ae2768","fromSide":"bottom","toNode":"5208deabb50423e0","toSide":"top"},
		{"id":"390455f1a310b481","fromNode":"ebaaa4d935ae2768","fromSide":"bottom","toNode":"ba959693f76625dc","toSide":"top"},
		{"id":"da17655b5d9f8375","fromNode":"ba959693f76625dc","fromSide":"bottom","toNode":"7d6b28e899228bae","toSide":"top"},
		{"id":"c4909b47c6d74a69","fromNode":"ba959693f76625dc","fromSide":"bottom","toNode":"567c76ad9244562d","toSide":"top"},
		{"id":"09f5aa5392d58e60","fromNode":"e47fac0c91452bb7","fromSide":"bottom","toNode":"ba32fe7205e2606f","toSide":"top"},
		{"id":"fec3f32cd80e6b87","fromNode":"e47fac0c91452bb7","fromSide":"bottom","toNode":"dff88af00a536f81","toSide":"left"},
		{"id":"eb5f3d061bf56e4d","fromNode":"133c092a1da3e3ae","fromSide":"top","toNode":"bc91687bf97c4515","toSide":"bottom"},
		{"id":"4258e5313c24971f","fromNode":"9b35587f0d6f95ff","fromSide":"right","toNode":"21c89f14ccde6dc6","toSide":"left"},
		{"id":"c35bd192d62bc5bf","fromNode":"f55770ab8bdeed44","fromSide":"left","toNode":"991d5b508f22877f","toSide":"right"},
		{"id":"cb8ea3e6c30b30b3","fromNode":"f55770ab8bdeed44","fromSide":"left","toNode":"be538ff257591a0a","toSide":"right"},
		{"id":"cd8a2b7b18f1b2e3","fromNode":"f55770ab8bdeed44","fromSide":"bottom","toNode":"c985195098f59000","toSide":"top"},
		{"id":"f9f1df5d3fd07578","fromNode":"9b35587f0d6f95ff","fromSide":"bottom","toNode":"c985195098f59000","toSide":"top"},
		{"id":"1acce1cfe069522c","fromNode":"d1472b8d646b14ad","fromSide":"right","toNode":"71a58d9affac5b95","toSide":"left"},
		{"id":"33102866424caeb8","fromNode":"47339376d0be509e","fromSide":"bottom","toNode":"f1a7cba73c578431","toSide":"left"},
		{"id":"c29a55f71b0eb506","fromNode":"f1a7cba73c578431","fromSide":"bottom","toNode":"71a58d9affac5b95","toSide":"top"},
		{"id":"06d6854edcdc6f3c","fromNode":"f1a7cba73c578431","fromSide":"top","toNode":"4fbfe23af23d71e0","toSide":"left"},
		{"id":"5dd74d5788ddb356","fromNode":"ea742b05a7119ace","fromSide":"right","toNode":"9764b381a2329f2a","toSide":"left"},
		{"id":"2b1f06bfa3c3a9d6","fromNode":"47339376d0be509e","fromSide":"top","toNode":"e237cbb67555c043","toSide":"left"},
		{"id":"b6b0f0ac1a6df3f6","fromNode":"e237cbb67555c043","fromSide":"right","toNode":"d29333aec77d471c","toSide":"left"},
		{"id":"162b580fcab5e06e","fromNode":"cfd8a6577c228df0","fromSide":"left","toNode":"a122bc5c3c127d03","toSide":"right"},
		{"id":"446871f55ff0fec6","fromNode":"b7cbea2785c98166","fromSide":"bottom","toNode":"a1ca857cd4a6c415","toSide":"top"},
		{"id":"1a7d649251315544","fromNode":"d1b8f4d6b685141c","fromSide":"right","toNode":"7f27ffe9c326e924","toSide":"left"},
		{"id":"de3464ac8a4e3542","fromNode":"58d2afa4103e892d","fromSide":"bottom","toNode":"2434ffd16440ef70","toSide":"top"},
		{"id":"c607b80262f77ce2","fromNode":"7f27ffe9c326e924","fromSide":"right","toNode":"58d2afa4103e892d","toSide":"left"},
		{"id":"4d36358cb7047dd4","fromNode":"7f27ffe9c326e924","fromSide":"bottom","toNode":"e40e21afbcf471a6","toSide":"top"},
		{"id":"a83035a85f87b130","fromNode":"2434ffd16440ef70","fromSide":"bottom","toNode":"18797cfbb25b2f9c","toSide":"top"},
		{"id":"d405e3e81d11b0b8","fromNode":"18797cfbb25b2f9c","fromSide":"bottom","toNode":"6c1d71d878ef0bdf","toSide":"top"},
		{"id":"97b9c186d2e5f5bb","fromNode":"23a2937e757042d7","fromSide":"left","toNode":"21dcd3bd8d213a16","toSide":"right"},
		{"id":"0d74e84088944f49","fromNode":"7eefd49bc7f4fed8","fromSide":"top","toNode":"23a2937e757042d7","toSide":"bottom"},
		{"id":"4e0d027f7cf02fb6","fromNode":"7eefd49bc7f4fed8","fromSide":"bottom","toNode":"9d6f3da2e265c5bb","toSide":"top"},
		{"id":"bf2e968f7bbc8eef","fromNode":"0053091728148919","fromSide":"bottom","toNode":"d1b8f4d6b685141c","toSide":"top"},
		{"id":"9cfef494f33e692b","fromNode":"d1b8f4d6b685141c","fromSide":"top","toNode":"0053091728148919","toSide":"bottom"},
		{"id":"1ea7cb4926f7d462","fromNode":"4dc94bc414dbc8c0","fromSide":"right","toNode":"0053091728148919","toSide":"left"},
		{"id":"e834485a8f6c35b1","fromNode":"4dc94bc414dbc8c0","fromSide":"right","toNode":"e58dbfee9f01dbaf","toSide":"left"},
		{"id":"a0ed4f3f540ca4f5","fromNode":"23a2937e757042d7","fromSide":"top","toNode":"4dc94bc414dbc8c0","toSide":"bottom"},
		{"id":"fbfa66dfe6a9e854","fromNode":"4dc94bc414dbc8c0","fromSide":"top","toNode":"82140cfb9656659a","toSide":"bottom"},
		{"id":"222caff5a46fdd6f","fromNode":"82140cfb9656659a","fromSide":"right","toNode":"07b851654a6db276","toSide":"left"},
		{"id":"ab43e2ef621f2074","fromNode":"4dc94bc414dbc8c0","fromSide":"left","toNode":"dc29aa00bf6c80bd","toSide":"right"},
		{"id":"3701ec35b29f18ae","fromNode":"dc29aa00bf6c80bd","fromSide":"top","toNode":"82140cfb9656659a","toSide":"left"},
		{"id":"68aa6b9756b15394","fromNode":"82140cfb9656659a","fromSide":"top","toNode":"244935d41f204155","toSide":"bottom"},
		{"id":"bd0c0354e42b39f4","fromNode":"07b851654a6db276","fromSide":"right","toNode":"e1afeb32532f4b6e","toSide":"left"},
		{"id":"cc6326c8f3b8477e","fromNode":"07b851654a6db276","fromSide":"top","toNode":"d0f01def2aede3e1","toSide":"left"},
		{"id":"c7eb9544c3eea1d1","fromNode":"e1afeb32532f4b6e","fromSide":"top","toNode":"d0f01def2aede3e1","toSide":"bottom"},
		{"id":"bb2bb84ffaa89f5c","fromNode":"e1afeb32532f4b6e","fromSide":"right","toNode":"b22d3f4b612c7e6e","toSide":"left"},
		{"id":"9041cbcdc16e2efe","fromNode":"07b851654a6db276","fromSide":"right","toNode":"c46e0b69e7092d81","toSide":"left"},
		{"id":"910c5881f155f9b5","fromNode":"d0f01def2aede3e1","fromSide":"right","toNode":"0efd8ee11f90ca64","toSide":"left"},
		{"id":"6176b99c7be75e75","fromNode":"b22d3f4b612c7e6e","fromSide":"top","toNode":"0efd8ee11f90ca64","toSide":"bottom"},
		{"id":"70ae7d1c6f5d699b","fromNode":"b22d3f4b612c7e6e","fromSide":"right","toNode":"ec6ccf01a85f8152","toSide":"left"},
		{"id":"1f9404d558f05796","fromNode":"d1b8f4d6b685141c","fromSide":"right","toNode":"447f8e71a756c709","toSide":"left"},
		{"id":"33d760f644790c6b","fromNode":"c46e0b69e7092d81","fromSide":"bottom","toNode":"b5f5edb4ee399ff2","toSide":"top"},
		{"id":"3c4763de82027f79","fromNode":"b7cbea2785c98166","fromSide":"right","toNode":"f51086f517d2e458","toSide":"left"},
		{"id":"219c367ea2ccd5c3","fromNode":"4dc94bc414dbc8c0","fromSide":"left","toNode":"88c9b35b0c391a8a","toSide":"right"},
		{"id":"ac29aeb33d462929","fromNode":"f51086f517d2e458","fromSide":"bottom","toNode":"466f90390ebea2d9","toSide":"top"},
		{"id":"ce6f1881be56d80c","fromNode":"f51086f517d2e458","fromSide":"bottom","toNode":"c052c9c3688cfda2","toSide":"top"},
		{"id":"8a3a133209095511","fromNode":"35235b872aeaab53","fromSide":"bottom","toNode":"3881465ee755981e","toSide":"top"},
		{"id":"f203c50d5197f14a","fromNode":"76eb84babbdcea6a","fromSide":"left","toNode":"821f59516a54210b","toSide":"right"},
		{"id":"13da668c8b31d403","fromNode":"dbc47f290845eb11","fromSide":"bottom","toNode":"d3537c6f38444c1e","toSide":"top"},
		{"id":"c99dec01852d9235","fromNode":"d3537c6f38444c1e","fromSide":"bottom","toNode":"76eb84babbdcea6a","toSide":"top"},
		{"id":"8972086d32cb3709","fromNode":"d3537c6f38444c1e","fromSide":"bottom","toNode":"d24861aa7ccdefd8","toSide":"top"},
		{"id":"5ed8faa7331b26bd","fromNode":"d24861aa7ccdefd8","fromSide":"right","toNode":"44b71fd4ce71a7b1","toSide":"left"},
		{"id":"2c3c86210dc2eaa8","fromNode":"d24861aa7ccdefd8","fromSide":"bottom","toNode":"d186c26b15065da4","toSide":"top"},
		{"id":"0322671c803d0da9","fromNode":"d186c26b15065da4","fromSide":"right","toNode":"ecf8f05756698441","toSide":"left"},
		{"id":"6579fed3caa36ddb","fromNode":"ecf8f05756698441","fromSide":"left","toNode":"d186c26b15065da4","toSide":"right"},
		{"id":"1b7ed4938be37b0b","fromNode":"aad711b95a488d69","fromSide":"right","toNode":"466f90390ebea2d9","toSide":"left"},
		{"id":"e838b5d6120e3a28","fromNode":"466f90390ebea2d9","fromSide":"left","toNode":"aad711b95a488d69","toSide":"right"},
		{"id":"6f50f619d5f7541c","fromNode":"dbc47f290845eb11","fromSide":"right","toNode":"1203987fd1017803","toSide":"left"},
		{"id":"d49165c993800011","fromNode":"d24861aa7ccdefd8","fromSide":"bottom","toNode":"280a1469437d1e2d","toSide":"top"},
		{"id":"d1c75502512c5283","fromNode":"76eb84babbdcea6a","fromSide":"bottom","toNode":"280a1469437d1e2d","toSide":"top"},
		{"id":"5616d83e7a147594","fromNode":"21dcd3bd8d213a16","fromSide":"bottom","toNode":"220142b1b2ce8091","toSide":"top"},
		{"id":"149d4ce9c0421d18","fromNode":"ff446abb49f6a431","fromSide":"bottom","toNode":"f763695377247ef9","toSide":"top"},
		{"id":"0fdcb35db6aac16e","fromNode":"c052c9c3688cfda2","fromSide":"bottom","toNode":"85e2ebfd8550e69e","toSide":"top"},
		{"id":"bde91597409fbc9f","fromNode":"1203987fd1017803","fromSide":"top","toNode":"85e2ebfd8550e69e","toSide":"bottom"},
		{"id":"02ed2bf741b55d58","fromNode":"90fdccb213e512d8","fromSide":"bottom","toNode":"0e901d7b4a68e75e","toSide":"top"},
		{"id":"f78a3692c7413eba","fromNode":"90fdccb213e512d8","fromSide":"right","toNode":"ff446abb49f6a431","toSide":"left"},
		{"id":"877b9c41fc02a345","fromNode":"1203987fd1017803","fromSide":"right","toNode":"a2829db16c364faf","toSide":"left"},
		{"id":"970dc00dc6f419de","fromNode":"a2829db16c364faf","fromSide":"right","toNode":"ca1308091356d679","toSide":"left"},
		{"id":"7633924a3dca95c5","fromNode":"90fdccb213e512d8","fromSide":"right","toNode":"0f515725446c17f3","toSide":"left"},
		{"id":"3d58c13efe63a545","fromNode":"1203987fd1017803","fromSide":"bottom","toNode":"90fdccb213e512d8","toSide":"top"},
		{"id":"c9e044c6805f8ccd","fromNode":"ca1308091356d679","fromSide":"bottom","toNode":"b0579d29d6d2cd09","toSide":"top"},
		{"id":"9ca5bd4dd14bef56","fromNode":"447f8e71a756c709","fromSide":"right","toNode":"ed24fea7f7d33914","toSide":"left"},
		{"id":"4095b7fdab6786cd","fromNode":"1203987fd1017803","fromSide":"right","toNode":"ce100f424589e14e","toSide":"left","label":"Instradamento Multicast"},
		{"id":"b0034040f560e34f","fromNode":"ca1308091356d679","fromSide":"right","toNode":"a10663cbe8856cda","toSide":"left"},
		{"id":"daa898b1b0fe47f2","fromNode":"ce100f424589e14e","fromSide":"right","toNode":"3140c475c121f719","toSide":"left"},
		{"id":"63b9d156f1a5555d","fromNode":"85e2ebfd8550e69e","fromSide":"top","toNode":"c052c9c3688cfda2","toSide":"bottom"},
		{"id":"709a9c63ab4f5925","fromNode":"c052c9c3688cfda2","fromSide":"right","toNode":"ee5b41e945fefa02","toSide":"left"},
		{"id":"95a0047c0b228d4b","fromNode":"352b4beb483d264e","fromSide":"bottom","toNode":"2cb08263dc5f0edb","toSide":"top"},
		{"id":"556bcf763811dafe","fromNode":"c46e0b69e7092d81","fromSide":"right","toNode":"b2d45f43b178faa6","toSide":"left"},
		{"id":"dd68de5cf2386dab","fromNode":"9f731eac72823c6c","fromSide":"left","toNode":"05c3b8792f604a34","toSide":"bottom"},
		{"id":"d2e55ceaab11c193","fromNode":"9f731eac72823c6c","fromSide":"bottom","toNode":"e02622616641968a","toSide":"top"},
		{"id":"78e3829ca5079478","fromNode":"f537b296b73bc81b","fromSide":"bottom","toNode":"c3187d1caf5835bf","toSide":"top"},
		{"id":"eaf4b10ae7848d2a","fromNode":"9f731eac72823c6c","fromSide":"top","toNode":"f528096ce03bdf37","toSide":"bottom"},
		{"id":"10bd1fe43f9ef748","fromNode":"e02622616641968a","fromSide":"bottom","toNode":"f537b296b73bc81b","toSide":"top"},
		{"id":"5fc923e2ebfebf04","fromNode":"9f731eac72823c6c","fromSide":"right","toNode":"0202ebbf2e1ec94d","toSide":"left"},
		{"id":"733a2c2735cc8ed7","fromNode":"0202ebbf2e1ec94d","fromSide":"right","toNode":"e658737db3a8ad38","toSide":"left"},
		{"id":"790daf9a548e4a21","fromNode":"e658737db3a8ad38","fromSide":"top","toNode":"68a80636908ff1d0","toSide":"bottom"},
		{"id":"5eac4d23e68b5872","fromNode":"68a80636908ff1d0","fromSide":"top","toNode":"c1b511e910f4bc8e","toSide":"bottom"},
		{"id":"839f8d9fc77818f1","fromNode":"68a80636908ff1d0","fromSide":"right","toNode":"e8c2c4b82c00f3af","toSide":"left"},
		{"id":"fafaec0593dc6179","fromNode":"e658737db3a8ad38","fromSide":"bottom","toNode":"a748d731a69642c5","toSide":"top"},
		{"id":"d49eef1956948b7a","fromNode":"68a80636908ff1d0","fromSide":"right","toNode":"bbae9deb840c71de","toSide":"left"},
		{"id":"ed427d4e19acbfae","fromNode":"93755965c6d5798d","fromSide":"right","toNode":"9d135ba1fbe86052","toSide":"top"},
		{"id":"2e2412622af2191c","fromNode":"e02622616641968a","fromSide":"right","toNode":"9d135ba1fbe86052","toSide":"left"},
		{"id":"0c9090a65fc78b48","fromNode":"a748d731a69642c5","fromSide":"bottom","toNode":"2c9a45f1836182ef","toSide":"top"},
		{"id":"f757e7f4bcb92ed6","fromNode":"2fd35aa9629d9192","fromSide":"bottom","toNode":"d1e8b6fe9e5d399f","toSide":"left"},
		{"id":"f343591322156e7b","fromNode":"93755965c6d5798d","fromSide":"left","toNode":"e1a9fb50e854767d","toSide":"top"},
		{"id":"f04e27359fb6020d","fromNode":"e1a9fb50e854767d","fromSide":"right","toNode":"e02622616641968a","toSide":"left"},
		{"id":"be538ae6b6c3f902","fromNode":"e1a9fb50e854767d","fromSide":"right","toNode":"f537b296b73bc81b","toSide":"left"},
		{"id":"fcf97e285ea5957d","fromNode":"f537b296b73bc81b","fromSide":"left","toNode":"7d6a530421499f12","toSide":"right"},
		{"id":"e65a5265e4d99dc4","fromNode":"e8c2c4b82c00f3af","fromSide":"right","toNode":"3157cc90e4c3c62e","toSide":"left"},
		{"id":"0fb1772f31b8a909","fromNode":"9d135ba1fbe86052","fromSide":"right","toNode":"9782d3812a907a46","toSide":"left"},
		{"id":"42f1066278a772dc","fromNode":"9d135ba1fbe86052","fromSide":"right","toNode":"cb8b6e91609f50e1","toSide":"left"},
		{"id":"70ccc5111a909c21","fromNode":"9d135ba1fbe86052","fromSide":"bottom","toNode":"f0c161be25e73aa9","toSide":"top"},
		{"id":"6a3d19fb9b30e200","fromNode":"9f731eac72823c6c","fromSide":"right","toNode":"2f11157c3ad03b20","toSide":"bottom"},
		{"id":"2ba67d5b85cfd5f2","fromNode":"2f11157c3ad03b20","fromSide":"top","toNode":"10c1d2a569e26cca","toSide":"bottom"},
		{"id":"f4988a6688b846d5","fromNode":"0202ebbf2e1ec94d","fromSide":"top","toNode":"0a4f8fcdbbf562f6","toSide":"bottom"},
		{"id":"61019f3abc82d0d7","fromNode":"10c1d2a569e26cca","fromSide":"right","toNode":"c53cd443f866e734","toSide":"left"},
		{"id":"3d94d7018bfa46e0","fromNode":"c53cd443f866e734","fromSide":"bottom","toNode":"bf64a19397872fe0","toSide":"top","label":"Accesso Casuale"},
		{"id":"71f50fc49f690db0","fromNode":"9b77bd85f7310032","fromSide":"right","toNode":"0a4f8fcdbbf562f6","toSide":"top"},
		{"id":"825152cef5846bbe","fromNode":"2f11157c3ad03b20","fromSide":"right","toNode":"bf64a19397872fe0","toSide":"left"},
		{"id":"b57e602c0fd31ef4","fromNode":"bf64a19397872fe0","fromSide":"right","toNode":"cfe34563fe1c4a2e","toSide":"left"},
		{"id":"56d25aca6578aa55","fromNode":"10c1d2a569e26cca","fromSide":"right","toNode":"9b77bd85f7310032","toSide":"left"},
		{"id":"31ecf4b5b74b3b5d","fromNode":"bf64a19397872fe0","fromSide":"right","toNode":"1c8430c176f6a96d","toSide":"left"},
		{"id":"fc783104063582c2","fromNode":"1c8430c176f6a96d","fromSide":"right","toNode":"bd21e4f69b2002f0","toSide":"left"},
		{"id":"ffe5aa51aaa31a63","fromNode":"e453784f6e09b6f7","fromSide":"bottom","toNode":"cf1f7e0084f469af","toSide":"top"},
		{"id":"384cf420b60e3f63","fromNode":"0a4f8fcdbbf562f6","fromSide":"top","toNode":"b32953fe59134813","toSide":"bottom"},
		{"id":"f241b38541102259","fromNode":"0a4f8fcdbbf562f6","fromSide":"top","toNode":"89b32e604650897b","toSide":"bottom"},
		{"id":"ad6c494bf2bddc98","fromNode":"0202ebbf2e1ec94d","fromSide":"bottom","toNode":"2fd35aa9629d9192","toSide":"top"},
		{"id":"f439376a8f7ce585","fromNode":"2fd35aa9629d9192","fromSide":"bottom","toNode":"e453784f6e09b6f7","toSide":"right"},
		{"id":"9f0bf79affb410f7","fromNode":"e658737db3a8ad38","fromSide":"right","toNode":"6e77aa4e9440b128","toSide":"left"},
		{"id":"e88f2ed37b1b2d8c","fromNode":"c53cd443f866e734","fromSide":"right","toNode":"89b32e604650897b","toSide":"top","label":"Partizionamento del Canale"},
		{"id":"03dfbbf1a36275b7","fromNode":"1bd86960d6e5a8e2","fromSide":"right","toNode":"eceff6dd26730572","toSide":"left"},
		{"id":"c2ad6e6af2ab90e0","fromNode":"2fd35aa9629d9192","fromSide":"bottom","toNode":"cf1f7e0084f469af","toSide":"right"},
		{"id":"5e09ca962986fa2b","fromNode":"2f11157c3ad03b20","fromSide":"top","toNode":"e46fb428ba8d5134","toSide":"bottom"},
		{"id":"c4f5954545713ab5","fromNode":"cf1f7e0084f469af","fromSide":"bottom","toNode":"21d7fd3fb678e357","toSide":"top"},
		{"id":"18e82ac0be146aa3","fromNode":"2fd35aa9629d9192","fromSide":"bottom","toNode":"514018efb59d3dd5","toSide":"left"},
		{"id":"3dddd1a2d7c96248","fromNode":"514018efb59d3dd5","fromSide":"bottom","toNode":"cbc26214a019c6f0","toSide":"top"},
		{"id":"07c0547accc0ca7e","fromNode":"514018efb59d3dd5","fromSide":"right","toNode":"5d7e25930cb4c399","toSide":"left","label":"Circa"},
		{"id":"5f6b0ee59293a96a","fromNode":"56958c816f8128f6","fromSide":"right","toNode":"db883eebaaa5c410","toSide":"left"},
		{"id":"05708edb4a457a2e","fromNode":"56958c816f8128f6","fromSide":"top","toNode":"09b6578ece5bef37","toSide":"bottom"},
		{"id":"625ea807585c7aa9","fromNode":"09b6578ece5bef37","fromSide":"top","toNode":"ffec127414d8e871","toSide":"bottom"},
		{"id":"b771e7acf0d079bf","fromNode":"09b6578ece5bef37","fromSide":"top","toNode":"f41363e3c1079edd","toSide":"bottom"},
		{"id":"33eb26e20d75cf46","fromNode":"f41363e3c1079edd","fromSide":"top","toNode":"5aa7116653d29b37","toSide":"bottom"},
		{"id":"d23f332da2226382","fromNode":"ffec127414d8e871","fromSide":"top","toNode":"37bf791ca3d98663","toSide":"bottom"},
		{"id":"77bdbca34f242b52","fromNode":"f41363e3c1079edd","fromSide":"right","toNode":"d2710649599d3e60","toSide":"left"},
		{"id":"7063bb3f3a0f0ad4","fromNode":"56958c816f8128f6","fromSide":"left","toNode":"7684347bd7b8066c","toSide":"right"},
		{"id":"da7bccd51c2e2eb0","fromNode":"56958c816f8128f6","fromSide":"top","toNode":"9622da6072e60568","toSide":"bottom"},
		{"id":"098dd86cb01418f0","fromNode":"5aa7116653d29b37","fromSide":"right","toNode":"d2710649599d3e60","toSide":"top"},
		{"id":"22de0359935b4310","fromNode":"9622da6072e60568","fromSide":"top","toNode":"d45579c34fc613d5","toSide":"bottom"},
		{"id":"66fe8fd84999d809","fromNode":"7684347bd7b8066c","fromSide":"top","toNode":"56555adae1f2d043","toSide":"bottom"},
		{"id":"126782d0d9711df9","fromNode":"9622da6072e60568","fromSide":"left","toNode":"56555adae1f2d043","toSide":"right"},
		{"id":"12c0fba91e069934","fromNode":"56555adae1f2d043","fromSide":"left","toNode":"e29cb1b11175b1c4","toSide":"right"},
		{"id":"c528d212bda61ac5","fromNode":"7684347bd7b8066c","fromSide":"left","toNode":"6958668a930e7c2f","toSide":"right"},
		{"id":"929ce0136c487561","fromNode":"7684347bd7b8066c","fromSide":"left","toNode":"de2d85d4a92d84bc","toSide":"right"},
		{"id":"f735a274670cf251","fromNode":"b2d45f43b178faa6","fromSide":"right","toNode":"abb130ae59623855","toSide":"left"},
		{"id":"05b8d4494505600b","fromNode":"e47fac0c91452bb7","fromSide":"right","toNode":"5c7cb3e9b597a877","toSide":"bottom"},
		{"id":"4356941d48dcb795","fromNode":"b2d45f43b178faa6","fromSide":"right","toNode":"eb0d5090bf33936f","toSide":"left"},
		{"id":"1ea61df86cfa3890","fromNode":"1203987fd1017803","fromSide":"left","toNode":"87358e95a4cca411","toSide":"right"},
		{"id":"131503daed53f4ab","fromNode":"466f90390ebea2d9","fromSide":"bottom","toNode":"87358e95a4cca411","toSide":"top"},
		{"id":"d5c7e60d09f95001","fromNode":"a569f47822207faf","fromSide":"top","toNode":"ed6dd0d5b788bd3e","toSide":"bottom"},
		{"id":"cb2ae67384607688","fromNode":"06174ae2aacf2d26","fromSide":"top","toNode":"ed6dd0d5b788bd3e","toSide":"bottom"}
	]
}