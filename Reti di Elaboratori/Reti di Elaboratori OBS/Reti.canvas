{
	"nodes":[
		{"id":"b72f299bae389d13","type":"text","text":"# Nodi\n\nSe le Reti sono grafi, cosa sono i nodi? Abbiamo due macro-categorie:\n\n- **_Nodi estremali_** (o **_sistemi terminali_**) - situati alle **periferie** della rete, sono le \"foglie\". C'è una distinzione interna tra\n\t- **_Host_** - tipicamente è il nome che si dà al dispositivo (dell') utente che vuole usare un servizio;\n\t- **_Server_** - tipicamente è il nome che si dà al dispositivo (spesso a elevate prestazioni) che offre servizi agli host.\n- **_Nodi di interconnessione_** - sostanzialmente dei ripetitori, che all'occorrenza possono modificare il segnale che vi transita (e.g. amplificazione, incremento di un counter per tenere traccia del passaggio). Una trasmissione senza modifiche è detta **trasparente**. Ulteriormente divisi in\n\t- **_Router_** - collegano tra loro più reti;\n\t- **_Switch_** - collegano tra loro più nodi estremali all'interno di una rete.\n","x":-4940,"y":638,"width":700,"height":448,"color":"4"},
		{"id":"06174ae2aacf2d26","type":"text","text":"# Tipi di Reti\n\nLe Reti si classificano in base a quanto sono grosse. Già.\n\n- **Personal Area Network** (**PAN**) - tipicamente pochi metri (e.g. Bluetooth);\n- **_Local Area Network_** (**_LAN_**) - tipicamente entro un appartamento (e.g. Wi-Fi, Ethernet). Ogni nodo estremale possiede un indirizzo (**MAC**) che lo identifica univocamente all’interno della LAN. Si può implementare come\n\t- **cavo condiviso** - tutti i dispositivi sono connessi al router tramite un cavo comune. Questa roba non si fa più, anche perché si creano interferenze e non esiste la privacy (chiunque poteva attaccarsi al cavo e leggere il traffico dati di tutti, \"oggi a meno che tu non sia l'NSA non lo fai\");\n\t- **switch** - da un lato ha i vari dispositivi in parallelo, dall'altra il router. Permette la trasmissione simultanea di più host.\n- **Metropolitan Area Network** (**MAN**) - tipicamente copre una città;\n- **_Wide Area Network_** (**_WAN_**) - tipicamente copre un paese o una nazione ed è gestita da un **_Internet Service Provider_** (**_ISP_**). Abbiamo anche qui due casi:\n\t- **point-to-point** - ho due reti collegate tramite un singolo mezzo di trasmissione. Questo è il modo più semplice di realizzare una **internet** (con la i minuscola, che qui ci tengono, abbreviativo per **internetwork**), ovvero una rete di reti;\n\t- **commutazione** - ho più reti collegate tramite più mezzi di trasmissione, il che probabilmente includerà anche più nodi di interconnessione.\n- **_Internet_** - la rete di tutte le reti, il Tutto, il MoaN (Mother of All Networks), una specie di divinità, un concetto filosofico, ...","x":-4128,"y":-220,"width":660,"height":740,"color":"4"},
		{"id":"23227e82062b49bc","type":"text","text":"# Struttura delle Reti","x":-3968,"y":837,"width":340,"height":50,"color":"6"},
		{"id":"1ec4d0918042c205","type":"text","text":"# Tramissioni su Rete","x":-3972,"y":1400,"width":348,"height":50,"color":"6"},
		{"id":"4f9f693b64bc0e3f","type":"text","text":"# Glossario delle Reti\n\n- **_edge router_** - i router più periferici dell'Internet;\n- **_headend_** - termine generico che si riferisce a un nodo cruciale di una rete di telecomunicazioni, in cui convergono e vengono aggregati più segnali. Un edge router è un headend, ma se ad esempio vi sono molti cavi coassiali che vorrebbero entrarvi si può usare un cable headend, ovvero un dispositivo fisico che raggruppa le varie sorgenti per trasmetterle all'edge router;\n- **_access point_** - pezzetto di HW che funge da interfaccia tra il segnale Wi-Fi e il router;\n- **_Internet Service Provider_** (**_ISP_**) - riferito ad un'organizzazione di qualsiasi tipo (privata, no-profit, ...) che fornisce il servizio per l'accesso a Internet. Sono gestite da ISP\n\t- le **reti di accesso** ad Internet;\n\t- alcune infrastrutture che collegano più reti di accesso locali (**ISP regionale**)\n\t- le componenti del **nucleo di rete** a cui si connettono le reti di accesso e gli ISP regionali (**ISP globali**, o di **livello 1**)","x":-5752,"y":-220,"width":716,"height":740,"color":"4"},
		{"id":"795690d5ce7e1c11","type":"text","text":"# Link\n\nI collegamenti fisici tra nodi possono essere realizzati in diversi modi.\n\n- **_Supporti guidati_** - I segnali si propagano in mezzi solidi (cavi). Esempi sono\n\t- **Doppino intrecciato** - due fili di rame isolati, uno per inviare i dati ed uno per riceverli (e.g. Ethernet, fino a 10 Gbps). Suscettibile a interferenze EM;\n\t- **Cavo coassiale** - due fili di rame concentrici, entrambi bidirezionali. Supporta i canali (**FDM**, $\\sim 100$ Mbps ciascuno), molto resistente alle  interferenze ma ad oggi soppiantato dalla fibra ottica;\n\t- **Fibra ottica** - fibra di vetro che sfrutta la riflessione totale interna della luce. Ogni fotone trasporta un singolo bit. Velocissimo ($v \\sim c$), basso rate di errore, ovviamente immune all'interferenza EM, costituisce la quasi totalità dei collegamenti nelle dorsali di Internet;\n- **_Propagazione libera_** - Spazia dal **Wi-Fi** domestico al **segnale satellitare**, e sfrutta lo spettro elettromagnetico con tutti gli ostacoli che ne conseguono (riflessione, attenuazione, interferenza). La potenza del segnale sferico decade come $1/r^2 \\Rightarrow$ molto forte nelle immediate vicinanze, molto debole poco dopo. Questo rende i link a propagazione libera dei canali **_half-duplex_** $\\Rightarrow$ chi riceve non può trasmettere a sua volta, perché con il forte segnale in uscita coprirebbe il segnale debole in entrata.","x":-4940,"y":1143,"width":700,"height":565,"color":"4"},
		{"id":"5cf8d16de6efff56","type":"text","text":"# Commutazione di Pacchetto","x":-4032,"y":2125,"width":468,"height":50,"color":"6"},
		{"id":"0c876453e3807959","type":"text","text":"# Pose e Coreografia\n\nHo un pacchetto con una destinazione. Devo avere chiare due cose:\n\n- Il percorso che seguirà nell'Internet attraverso i vari router, detto **_instradamento_** o **_routing_**. Definito da speciali **_algoritmi di instradamento_**, è un concetto **_globale_** (che riguarda cioè la rete nella sua interezza);\n- Il modo in cui il singolo router smista i pacchetti nel link corretto, ovvero la funzione interna che lega il segnale in ingresso a quello in uscita: internamente, ogni router ha una **_local forwarding table_** contenente le varie associazioni con i nodi adiacenti. Per scrivere le tabelle mi servono i percorsi. Viene detto **_commutazione_** (o **_forwarding_**, o **_switching_**).\n\nIn pratica, se il *forwarding* è la regola locale che definisce come si \"posiziona\" il singolo router, il *routing* è la \"coreografia\" globale risultante.","x":-3273,"y":1570,"width":700,"height":410,"color":"4"},
		{"id":"4958894e7197fe3c","type":"text","text":"# Rete\n\nInfrastruttura \"a grafo\" composta da dispositivi (_**nodi**_) che possono scambiarsi informazioni tramite dei collegamenti (**_link_**)","x":-3084,"y":1045,"width":323,"height":196,"color":"6"},
		{"id":"a569f47822207faf","type":"text","text":"# Struttura di Internet\n\nL'Internet può essere suddiviso con un criterio di \"profondità\".\n\n- **Periferia della rete** (**network edge**) - host e server;\n- **_Reti di accesso_** (**_access network_**) - tutto ciò che è connesso al router più periferico (**edge router**, ovvero il primo router che incontra il segnale partito da un host o da un server), a sua volta connesso con l'Internet. La connessione all'edge router può presentarsi in diversi gusti.\n\t- **Cavo** - Puro e semplice, non ci sono intermediari. Si collega insieme agli altri cavi della zona a un **cable headend**;\n\t- **Digital Subscriber Line** (**DSL**) - Sfrutta le linee telefoniche come cavi. Usa un **DSLAM** (**DSL Access Multiplexer**), uno specifico **headend** che smista il traffico internet e telefonico;\n\t- **Wireless LAN** (**WLAN**) - Mediato da un **access point** fisico che si interfaccia con il router domestico;\n\t- Rete cellulare;\n- **_Nucleo di Rete_** (**_dorsale_**, **_core_**, **_backbone_**) - questi termini vengono spesso usati in modo intercambiabile in quanto reti ad alta velocità che rappresentano la \"spina dorsale\" di Internet. In pratica, il nucleo di rete si occupa di collegare tra loro le reti di accesso (gestite da **ISP locali**). **NON** ciascuna di esse con tutte le altre (sono milioni e sarebbe $O(n^2)$), ma attraverso delle reti di più alto livello. ","x":-4940,"y":-220,"width":700,"height":740,"color":"4"},
		{"id":"c842e00522cec07d","type":"text","text":"## Velocità e latenze\n\n- DSL\n\t- Downstream: $24\\div52$ Mbps\n\t- Upstream: $3\\div16$ Mbps\n\t- Latenza: ?????\n- Ethernet\n\t- 100 Mbps, 1 Gbps, 10 Gbps\n- HFC\n\t- Downstream: $40\\div1200$ Mbps\n\t- Upstream: $30\\div100$ Mbps\n\t- Latenza: ???\n- Fibra\n- Microonde\n- Wi-Fi\n\t- Trasmissione: 11-54-450 Mbps\n\t- Latenza: ????\n- 4G\n- Satellite\n\t- Trasmissione: fino a $45$ Mbps\n\t-  latenza (end-end): $\\sim 270 ms$.","x":-5752,"y":1143,"width":716,"height":565,"color":"2"},
		{"id":"0276409902e40e9c","type":"text","text":"## Tradurre \"bursty\" in matematica\n\nCi sono $n$ utenti, ognuno dei quali ha una (bassa) probabilità $p$ di essere attivo in un dato istante. Quanti utenti sono attivi contemporaneamente?\nOvviamente problema binomiale.\n\n$$\nP(x) = \\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$\nda cui segue la cumulativa (qui nel caso $x > k$)\n\n$$\nP(x > k) = \\sum^n_{i = k}\\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$","x":-5736,"y":1930,"width":700,"height":440,"color":"4"},
		{"id":"165209213bc6a130","type":"text","text":"## Sulla divisione delle Reti e di Internet\n\nIn pratica, Internet è un sistema talmente complesso che ho una mezza infinità di modi di suddividerlo. Diciamo che a seconda di cosa mi serve fare uso la divisione che più mi è utile. ","x":-4570,"y":-520,"width":772,"height":137,"color":"4"},
		{"id":"a3eaa4b44f0f3c44","type":"text","text":"# Giungla pseudo-gerarchica ISP\n\nQuello di ISP è quasi un concetto filosofico. Io che ti metto l'hotspot sono tanto ISP quanto lo è Fastweb. Circa. In realtà c'è una specie di gerarchia.\n\n- Io che metto l'hotspot sono considerabile un edge router che funge da ISP locale (livello 3);\n- Il mio telefono però ha a sua volta un ISP, stavolta regionale (livello 2, e.g. *Fastweb*). Questo ISP ha accordi alla pari (**_peer-to-peer_**) per comunicare con altri ISP regionali senza passare dal nucleo di Internet. Tuttavia può essere necessario raggiungere nodi che necessitano un passaggio per le dorsali, motivo per cui i *livello 2* **_pagano il transito_** ai *livello 1*;\n- In cima alla catena alimentare troviamo gli **_ISP globali_** (livello 1, e.g. *AT&T*), connessi tra loro tramite degli **_Internet Exchange Point_** (**_IXP_**);\n- Ultimamente vi sono entità (e.g. Google, Netflix) che non hanno tutta questa voglia di pagare gli ISP più grossi, motivo per cui costruiscono delle proprie _**reti dei content provider**_ a livello degli ISP globali riuscendo a bypassarli e ad offrire un servizio più efficiente ai consumatori.","x":-5752,"y":-880,"width":716,"height":497,"color":"4"},
		{"id":"44898ee22f42afdc","type":"text","text":"# Prestazioni","x":-1800,"y":1400,"width":240,"height":50,"color":"6"},
		{"id":"665f35bd71acbb90","type":"text","text":"# Forwarding","x":-1800,"y":1750,"width":240,"height":50,"color":"6"},
		{"id":"981b264b7f7630c2","type":"text","text":"# Store&Forward\n\nUn pacchetto deve raggiungere completamente il nodo destinazione prima che questo possa iniziare il processo di *forwarding* (**_store&forward_**).\n\nLa trasmissione però richiede tempo, quindi è possibile che arrivino più pacchetti di quanti il router ne riesce effettivamente a smistare.\nQuesto implica che deve avere un *buffer* in cui mettere in coda i pacchetti in attesa. Nel migliore dei casi questo mi genera un **_queuing delay_**, e nel peggiore, ovvero se il buffer si riempie, può verificarsi la **_perdita dei pacchetti_**.\n\nD'altronde, quando mando un pacchetto su Internet devo essere consapevole che nessuno mi potrà mai garantire il suo effettivo arrivo a destinazione.\n\nNotare che il primo bit di un pacchetto può arrivare a destinazione prima che questo sia stato completamente trasmesso dal router di partenza sul link!","x":-1280,"y":1570,"width":680,"height":410,"color":"4"},
		{"id":"c45a83a3705f7881","type":"text","text":"# Latenza\n\nIl tempo totale necessario ad un pacchetto per essere inviato completamente da un nodo origine ad un nodo destinatario è detto **_latenza_** o _**delay**_.\n\nSi può scrivere come somma di 4 contributi:\n\n- Delay di Queuing ($D_q$) - dato dal tempo di attesa in coda dovuto al meccanismo di **store&forward**, qui il pacchetto aspetta di essere processato. Difficile da stimare, divergente se il pacchetto si perde;\n- Delay di Elaborazione ($D_e$) - dato dalle operazioni interne effettuate dal nodo sul pacchetto (controllo errori, determinazione del link di uscita, ...), in genere trascurabile rispetto agli altri ($D_e \\lesssim\\mu s$);\n- Delay di Trasmissione ($D_t$) - il router deve caricare tutto il pacchetto di lunghezza $L$ sul link avente bit rate $R$ $\\Rightarrow$ ci mette un tempo $D_t = L/R$. Tipicamente è il termine dominante, nonché l'unico che dipende dalla lunghezza del pacchetto. Trasmettere un $L$ enorme su un $R$ basso fa da bottleneck per l'intero sistema;\n- Delay di Propagazione ($D_p$) - quanto ci mette il pacchetto a transitare sul link, e dipende esclusivamente dalle caratteristiche di quest'ultimo. Se è lungo $k$ e i bit si propagano a velocità $v$ serve un tempo $D_p = k/v$. In genere è indicato come tempo di propagazione dell'ultimo bit del pacchetto (non cambia nulla, è solo per ricordarsi che esiste la politica di *store&forward*).\n\nIn sintesi quelli fondamentali sono [trasmissione e propagazione](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/transmission-vs-propogation-delay/transmission-propagation-delay-ch1/index.html), e ogni router da cui passa il segnale (anche detto **_hop_**) introduce un termine dominante $L/R$.","x":-1280,"y":780,"width":680,"height":674,"color":"4"},
		{"id":"45a11294a8434cf8","type":"text","text":"# Glossario delle Prestazioni\n\n- **_trasmissione_** - il caricamento del pacchetto sul link da parte del router (\"modulare il segnale nel cavo\"). **_NON_** include la propagazione sul link.\n\t- Ogni link è caratterizzato da una **massima velocità di trasmissione** $R$ (*Rate*, misurato in bit/s), anche detta **_bit rate_** o **transmission rate**;\n- **_larghezza di banda_** (**_bandwidth_**) - si può usare per intendere\n\t- la larghezza dell'intervallo di frequenze utilizzate dal sistema trasmissivo ($Hz$);\n\t- il **bit rate** (bit/s), ad essa proporzionale.\n- **_throughput_** ($T$)- quantità di bit al secondo che passano a regime attraverso un generico punto della rete. Notare che è una misura di velocità effettiva, e che il suo massimo è il **bit rate** $\\Rightarrow$ è una misura effettiva di bit rate, e si effettua con un **_ping_**, ovvero un bit-sonda che mando avanti e indietro dal server che mi interessa;\n- **_bottleneck_** - quel collegamento che limita il throughput dell'intero percorso end-to-end;","x":-1940,"y":495,"width":520,"height":617,"color":"4"},
		{"id":"305c16fa5fcbfca6","type":"text","text":"# Teoria delle Code\n\nPer il Delay di Queuing c'è tutta una teoria (delle code) che calcola il ritardo medio in coda in funzione dell'intensità del traffico $La/R$ , dove $a$ è il rate di arrivo di pacchetti in coda.\n\nIn questo modo si trova che questo ritardo diverge già per un traffico $La/R = 1$ $\\Rightarrow$ il router non sopporta un rate di arrivo dei pacchetti identico al rate di smistamento ([vedere per credere!](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/queuing-loss-applet/index.html)).\n\nQuesto succede perché $a$ è un rate medio, e \"quando sono fortunato e me ne arrivano meno mentre la queue è vuota non posso anticiparmi il lavoro\".\n\nCredo in realtà succeda anche perché non sto considerando il micro-ritardo di processamento interno, che seppur trascurabile sul singolo pacchetto magari sulla coda fa effetto.","x":-1280,"y":285,"width":680,"height":420,"color":"3"},
		{"id":"f1e9ad03f9edbfdd","type":"text","text":"# Prova\n\n- a cambiare la dimensione dei pacchetti TCP/IP di un computer (impostazioni del SO? chissà)","x":-420,"y":375,"width":420,"height":240,"color":"5"},
		{"id":"0e49609704fa8c9e","type":"text","text":"# Gestire le Congestioni\n\nCosa succede se a un certo punto del percorso tra i router un pacchetto entra in un loop? Resta intrappolato all'infinito, sprecando banda? Sconveniente. Devo metterci un *cut-off* $\\Rightarrow$ introduco un **_Time To Live_** (**_TTL_**), in pratica un numero che viene decrementato a ogni router che incontra (e che quindi rappresenta quanti altri router possono inoltrarlo).\n\nQuando il TTL diventa 0 il pacchetto muore. In questi casi sarebbe buona educazione da parte del router mandare un feedback a chi glielo ha inviato (\"*hey, ti ricordi quel bellissimo pacchetto che mi avevi mandato? sì, ecco, è morto*\").\n\nConoscere il motivo della perdita di un pacchetto è fondamentale. Se ad esempio viene perso per traffico (e quindi per via di una coda piena) dovrei rallentare la trasmissione per evitare di perderne altri.\n\nIl protocollo TCP/IP, ad esempio, è in grado di capire se una perdita è causata dal traffico o da altri fattori.","x":-2540,"y":560,"width":540,"height":552,"color":"4"},
		{"id":"56958c816f8128f6","type":"text","text":"# Sicurezza","x":-3042,"y":590,"width":240,"height":50,"color":"6"},
		{"id":"d7a25775f996e167","type":"text","text":"# Leak della struttura di rete (Latenza + TTL)\n\nScelgo una destinazione e mando pacchetti con un TTL sempre maggiore. Grazie al progressivo delay sono in grado di stimare il percorso end-to-end. \n\n... o quasi. Nessuno mi garantisce che ogni pacchetto seguirà sempre lo stesso percorso. Esistono però programmi diagnostici (e.g. **_traceroute_** su UNIX, o **_tracert_** su Windows) che restituiscono suddetti delay.\n\nNon c'è da stupirsi se a volte i router scelgono di non mandare feedback alla morte di un pacchetto per esaurimento del TTL.\nSe accetto il meccanismo dei TTL potrei far leakare la struttura interna della rete. ","x":-2540,"y":-20,"width":540,"height":440,"color":"#4545ff"},
		{"id":"5b16a0a8827edeef","type":"text","text":"# Formulario (?)\n\n- Massimo numero di bit su un link - $R\\cdot D_p$\n- Avere un TDM (e.g. 10 slot/s) tipicamente in un esercizio significa che ad ogni host è associato uno solo degli slot indicati nel TDM (e.g. 1 slot/s).","x":-422,"y":967,"width":422,"height":267,"color":"2"},
		{"id":"45b932caa35cd5e2","type":"text","text":"# Rete (guarda slides) tipo intro ai termini\n\nrete = nodi (computer) collegati da collegamenti (link). Distinguo i nodi estremali (host (vuole usare il servizio) o server (lo fornisce), non è una distinzione rigida) e quelli di interconnessione (router collega due reti o switch collegano terminali in locale). Dispositivi che possono scambiarsi info. Durante i passaggi di info queste spesso si modificano (fisico, quindi amplificazione, o tenere traccia del passaggio. esistono anche trasmissioni trasparenti).\n\nperiferia della rete -> host e server\nrete di accesso: utenti (problemi: max utenti per antenna)\nnucleo di rete: router interconnessi che fanno interagire sottoreti indirizzando il traffico\n\n(guarda slides)\n\nreti via cavo: tutto collegato allo stesso cavo condiviso. ogni casa ha splitter e modem.\n\nasimmetria: ci si aspetta che l'host scarichi più di quanto carica\n\na casa modem, router e access point sono integrati nello stesso coso.\n\n\"half duplex\" -> mentre trasmetto non posso ricevere. Questo perché la potenza del segnale scende come 1/r^2, e chi riceve vede un segnale debole -> non può trasmettere a sua volta, perché copro il segnale debole. Questo per il wifi e simili, su cavo faccio come voglio.\n\nsplitting di frequenze (anche su stesso cavo) ha costo (multiplexing?), nell'esempio del cavo sopra (credo) sia tutto su stessa frequenza.\n\n\n","x":-2270,"y":-1900,"width":640,"height":860,"color":"1"},
		{"id":"38f42aa977e02595","type":"text","text":"# (\"... comunque lo vedremo meglio\")\n\nnon ci sono computer, solo router che fanno commutazione di pacchetto (= forwarding = switching: qualcosa entra da una porta, lo faccio uscire da un'altra, ognuno ha una tabella di corrispondenze, è na roba LOCALE). NON sa che percorso farà. Ma chi le scrive le tabelle? Serve sapere i percorsi -> serve Algoritmo di Instradamento. Il ROUTING è un'azione GLOBALE.\n\nforwarding: come mi devo mettere; routing: coreografia\n\nstore and forward: prima ricevo tutto, poi mando. na specie de buffering. Pushare il pacchetto nel cavo = trasmettere, ergo se devo mettere L bit di pacchetto a velocità R bit/s ci metto L/R secondi ed è detto ritardo di trasmissione (trasmissione è solo l'uploat del pacchetto nel collegamento (cavo), poi c'è delay di trasporto ma spesso è trascurabile). \"modulare il segnale nel cavo\". ogni router che trasmette (HOP) porta un ritardo +L/R. Se poi mi interessa il delay del segnale totale trasportato da N pacchetti moltiplico per N. Poi c'è ritardo di accodamento (vedi slides).\n\nTEORIA DELLE CODE???\n\nA - algoritmo per ottimizzare commutaizone di circuito?\n\nSe multiplexo sulle frequenze (costo alto) mitigo il problema delle code. Posso farlo anche sul tempo (costo minore, eg bluetooth), ma sono a rischio latenza. Qual è meglio? Dipende da che ci devo fare. Comm di circuito però non si usa su Internet. cellulari usano entrambi. pacchetto consente a più utenti di usare la rete. Internet è _bursty_, impulsiva, dati inframezzati da lunghi silenzi. Mi baso sul fatto che molti stanno zitti per permettere a più persone di parlare (e.g. se ho 35 utenti P(attivi>20) $\\sim$ poco, conto con binomiale). se uso comm circuito dedico una linea fissa e non sfrutto le \"caratteristiche\" degli utenti (che stanno spesso zitti).\n\nSe mando un pacchetto su Internet non ho garanzie che arrivi a destinazione. Tutti i tentativi per dare garanzie (ovvero strutturare diversamente i protocolli) hanno fallito miseramente. Comm di circuito garantisce, ma se non comunico spreco risorse. \"Internet è accettare che tutti provano e provare a risolvere quando si creano problemi\".\n\nISP punto debole di interet, in mano ai grandi fornitori. interconnessi, guidati dagli interessi aziendali più che geografici. Abbiamo milioni di ISP di accesso. Li collego tutti tra loro? No, è $O(n^2)$. Inizialmente: ISP di transito globale a fare da centralino (pagato da ISP locali). Ora ci sono tanti ISP globali collegati da IXP (internet exchange point, collegamento di peering). La rete degli IXP ha una rete dei content provider.\n\nSegue discorso sulla legislazione perché sta roba dà un sacco di potere\n\n","x":-1580,"y":-1981,"width":640,"height":1120,"color":"1"},
		{"id":"435d7ec357e56abd","type":"text","text":"# prestazioni slides 3\n\nthroughput è una misura a regime (un po' una misura del bitrate effettivo, ed è sistematicamente minore o uguale). è il flusso/portata della fluidodinamica. Non basta un ping (singolo bit, quello misura la latenza).\ncolli di bottiglia creano grossi problemi su internet, ma non nelle dorsali (backbone, sono enormi), quanto quelli che si collegano.\ntutto questo comunque resta molto teorico perché non considero perdite e ritardi, all'atto pratico misuro per sapere quant'è.\nSeguono i ritardi che sommati fanno la latenza\n- processamento (elaborazione del pacchetto: controllo errori, switching, ... tipicamente svariati odg meno degli altri)\n- Trasmissione (tutta  la dipendenza dalla grandezza del pacchetto è qua)\n- Accodamento (queuing delay, dipende dal traffico, difficile da calcolare, c'è teoria delle code)\n- propagazione (SOLO lunghezza del cavo, satellite 300ms, cavo oceanico 30ms)\n\ni primi bit caricati in trasmissione non devono aspettare gli ultimi. Infatti, se ho n bit e ognuno ci mette m secondi, l'ultimo verrà processato dopo nxm secondi. Ma intanto il primo è partito. Magari è pure arrivato all'altro router, il quale però deve aspettare di ricevere tutto il pacchetto per inoltrarlo.\nAttenzione a fare pacchetti troppo grossi, il ritardo di trasmissione schizza alle stelle. (posso cambiarlo su pc con la mia connessione???)\n\nSe sto trasmettendo un pacchetto enorme con bassa velocità ci metto un botto, il che blocca la rete per tutti!\n\n","x":-920,"y":-1840,"width":640,"height":740,"color":"1"},
		{"id":"c3e8022233e42700","type":"text","text":"# Ritardi\n\n- accodamento (\"quando siamo fortunati non possiamo portarci avanti col lavoro) rivedilo che non ho capito cosa vuole dire (vedi animazione di due slides dopo, perdita di pacchetti, mettendo stesso rate di emission e transmission) --> se si riempie la coda perdo pacchetti --> un pacchetto perso ha tempo di attesa infinito\n\nse ci stanno dei loop nel percorso router i pacchetti intrappolati restano all'infinito? Devo metterci un cut-off -> tempo di vita (TTL time to live), spesso espresso in \"quanti altri router possono inoltrarlo\". Se il pacchetto muore in genere il router manda un feedback a chi glielo ha inviato (\"hey, il tuo pacchetto è morto). Se mando TTL sempre crescenti stimo il percorso (non proprio, nessuno mi dice che faccio sempre lo stesso $\\forall$ invio).\nPer vari motivi i router possono non rispondere quando muore il pacchetto. Se accetto i TTL potrei far leakare la struttura interna della rete. Se il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). TCP/IP capisce se è una perdita per traffico o casuale. Importante perché se perdo per traffico dovrei rallentare, altrimenti scialla.\n\n- rate\\*ritardo = numero massimo di bit nel buffer (-> definisce grandezza del buffer). volume del \"tubo\" di trasmissione. non utilissimo perché a me interessa il throughput, cioè la sezione\n\n","x":-280,"y":-1830,"width":640,"height":720,"color":"1"},
		{"id":"187dc42cfef0546d","type":"text","text":"# Appunti lezioni raw in rosso - magari poi ci faccio un txt","x":-1492,"y":-2200,"width":465,"height":102,"color":"1"},
		{"id":"5b4bbd10c0ed915d","type":"text","text":"# Sicurezza\n\n\n\nQuasi tutti i governi fanno sniffing, anche se è crittografato.\nBanalmente ho i metadati, quindi posso risalire a chi parla (magari senza sapere cosa), ma posso mettermi ad ascoltare più \"vicino\" ai due che parlano. Se sei un governo puoi fare la qualunque, compreso con le crittografie (non tutto no? se faccio RSA col cazzo mi sa). Tecnicamente sniffing era attaccarmi col cavo (quando c'era un cavo per tutti) ma oggi dipende dalla tecnologia usata ed è un concetto astratto.\n\nPosso fare cose illegali in N (con N enorme) modi. Tipo, posso inviare pacchetti mettendo un mittente che non sono io (se mando la droga e metto come mittente qualcun altro quello non va in galera perché non è dimostrabile che l'ha mandato lui), oppure da router posso tenermi i pacchetti e leggerli, o inoltrarli a una macchina a mia scelta.\n\nContro queste cose c'è roba tipo\n- l'autenticazione\n- confidenzialità (crittografia)\n- autenticità\n- restrizioni di accesso (e.g. VPN protetta da password)\n- firewall (a livello di rete)\n\nCi sono attacchi diversi a seconda di\n- come reagisco alle richieste\n- come creo la connessione (e.g. TCP)\n- ...\n\nDi base si può fare tutto, è una giungla!\nSe mi fingo un altro comunque l'altro può trasmettere, a rigore dovrei anche preoccuparmi di bloccare quello che interpreto (man-in-the-middle).\n\n","x":-3360,"y":-433,"width":739,"height":853,"color":"1"},
		{"id":"9ed19d6e9980b34b","type":"text","text":"# Come invio i messaggi sui Link?\n\nHo sostanzialmente due modi per farlo.\n\n- **_Commutazione di Circuito_** - Letteralmente, creo un collegamento fisico riservato alla coppia sorgente-destinazione, sulla quale sono gli unici a poter comunicare (salvo collegamenti fisici alla linea da parte di terzi, dove i terzi sono verosimilmente i servizi segreti). Garantisce prestazioni stabili, e viene usato nelle linee telefoniche. Naturalmente si può fare anche senza dedicare un intero cavo al singolo canale di comunicazione:\n\t- **_Frequency Division Multiplexing_** (**_FDM_**) - Ogni cavo trasmette un certo range di frequenze EM. Allora le suddivido in N canali, e ad ognuno di questi assegno una certa larghezza di banda (che però sarà stretta);\n\t- **_Time Division Multiplexing_** (**_TDM_**) - Sostanzialmente tratto i canali come una *ready queue* e faccio *preemptive scheduling*. Entro il proprio intervallo di tempo assegnatogli, ogni canale trasmette avendo a disposizione la banda massima;\n- **_Commutazione di Pacchetto_** - Ogni messaggio viene suddiviso in **_pacchetti_**. La rete si occupa di instradare i singoli pacchetti e *tenta* di non fare casino. Interessante notare come nonostante possa fare casino in molti modi (e in effetti lo fa: li perde, sbaglia l'ordine di arrivo, li inoltra a terzi, ...) è il metodo più utilizzato su Internet. Ovviamente il motivo c'è: le comunicazioni sono spesso **_bursty_**, nel senso che gli host stanno *quasi* sempre zitti, tranne in singoli momenti isolati in cui vomitano un enorme messaggio da inviare. Non ha senso dedicare un circuito a una comunicazione in cui non succede *quasi* mai niente: blocco delle risorse che restano inutilizzate quando magari altri host rimasti tagliati fuori potrebbero comunicare il proprio messaggio *bursty*. Idealmente dovrei dare la sensazione all'host di avere una connessione dedicata, il che in parte si risolve aumentando la banda e in parte non si risolve perché ci stanno mille problemi.","x":-4940,"y":1761,"width":700,"height":780,"color":"4"},
		{"id":"4df27d69ac9764ca","type":"text","text":"# What is stack protocollare?\n\nUn **_Protocollo_** definisce l’insieme di regole che mittente e destinatario (e tutti i sistemi intermedi coinvolti) devono rispettare per essere in grado di comunicare.\n\nSe ho una situazione complessa è comodo suddividere i compiti fra più livelli (detti **_layer_**, o *strati*) indipendenti, secondo il buon vecchio principio di modularità.\n\nAd ogni livello corrisponderà quindi (almeno) un \"sotto-Protocollo\" (inteso come modularizzazione del Protocollo che definisce l'intero scambio di messaggi) che da qui in poi chiamerò **_protocollo_** (già... fa ridere).\n\nPer realizzare il Protocollo abbiamo creato una stratificazione di protocolli detta **_layering di protocolli_** o **_stack protocollare_**.\n\nQuesto porta in generale diversi vantaggi:\n\n- Concettualmente è più chiaro cosa succede $\\Rightarrow$ è più facile costruire modelli;\n- L'aggiornamento e/o la sostituzione dei moduli è più semplice e trasparente (è ben chiaro cosa sto facendo, e dove), e non influisce sul resto del sistema.\n\nOgni layer _comunica in modo_ **_bidirezionale_** _con i livelli adiacenti_, realizzando coppie *provider-user*, in cui il primo offre al secondo un **_servizio_**.\n","x":-4940,"y":3400,"width":700,"height":557,"color":"4"},
		{"id":"deea8f39a16646e1","type":"text","text":"**Throughput Minimo Garantito**: Questo è come l'assicurazione che un servizio Internet ti dà. Supponiamo che tu stia giocando a un videogioco online e non vuoi che la connessione diventi troppo lenta. Il \"throughput minimo garantito\" è come la promessa dell'azienda che la tua connessione rimarrà almeno a una certa velocità. Quindi, anche se Internet diventa affollato, sei sicuro di avere almeno quella velocità per continuare a giocare senza problemi.","x":-1680,"y":-260,"width":546,"height":267},
		{"id":"6e7c8cc6c0993984","type":"text","text":"Livello un po' filosofico, né HW né SW","x":-2540,"y":3570,"width":250,"height":105},
		{"id":"1a0fe951bbf51b93","type":"text","text":"# Simmetrie tra le stack protocollari\n\nSe comunico voglio sia inviare che ricevere, quindi\n\n- ci sono almeno due stack, una per chi invia e una per chi riceve;\n- tutti gli host possono essere sia mittente che destinatario.\n\nDa questo segue che guardando le varie stack in **_orizzontale_** troviamo una **_simmetria logica_**, ovvero **protocolli omologhi** e **oggetti identici**.\n\nConcettualmente, il **_collegamento logico_** è tra layer di pari livello di tutte le stack, che parlano la stessa \"lingua\" $\\Rightarrow$ il layer $N$ di un dispositivo comunica virtualmente solo e soltanto con il layer $N$ degli altri dispositivi.\n\nL'effettivo **_flusso di informazione_** è però **_verticale_**, eccetto per il livello più basso che rappresenta lo spostamento fisico.\n\nLungo la propria stack, il mittente applica delle funzioni per incapsulare il messaggio (e.g. lo critta e lo mette in una scatola), questo viene fisicamente trasportato al nodo successivo dal livello più basso (e.g. il furgone delle poste) e infine il destinatario applica le funzioni inverse (in ordine inverso, perché stavolta il messaggio risale la stack) per riottenere il messaggio originale (e.g. apre la scatola e lo decritta). \n\nNel complesso, l'informazione \"scende\" e \"risale\" lungo le stack protocollari.\n","x":-4940,"y":2740,"width":700,"height":620,"color":"4"},
		{"id":"472a39255272296f","type":"file","file":"Layering.png","x":-5736,"y":2740,"width":700,"height":380},
		{"id":"8ca68ef0d9cba75a","type":"text","text":"# Where stack protocollare?\n\nOvunque sia necessario far comunicare più elaboratori, in un range che spazia da una semplice LAN fino all'Internet.\n\nSu **LAN** si possono trovare diversi esempi di stack protocollari proprietarie nate tra gli anni '70 e '90, come **NetBIOS** (**Microsoft**) o **AppleTalk**.\n\nCon l'avvento di **_Internet_** si è però tutto uniformato a **_TCP/IP_**, rimasto praticamente l'unico ad oggi in uso.","x":-5736,"y":3681,"width":700,"height":276,"color":"4"},
		{"id":"f6c22dc935238119","type":"text","text":"# Protocolli e Servizi\n\nIl servizio è il **_cosa_** garantisco (e.g. in questo caso un insieme di primitive che uno strato offre a quello superiore), il protocollo è **_come_** implemento il servizio.\n\n```\nServizio del livello di trasporto: \"Usa la mia primitiva INVIA. Ti garantisco che i tuoi pacchetti arriveranno a destinazione tutti e in ordine, se si disordinano ci penso io a rimetterli a posto\"\nProtocollo del livello di trasporto: TCP\n```\n\nOgni layer, secondo il proprio protocollo, implementa dei servizi usando le proprie risorse e i servizi forniti dal livello sottostante.\n\n Tramite i servizi si possono vedere i layer come delle **_black box_** $\\Rightarrow$ ci si può dimenticare dell'implementazione (protocollo) sottostante in favore di una vista di più alto livello che consta di input e output (servizi e/o informazioni).","x":-5736,"y":3180,"width":700,"height":440,"color":"4"},
		{"id":"aa2f1768f7663ebf","type":"text","text":"# Come?\n\nChi vuole avviare una comunicazione ha bisogno di far girare un **_processo client_**. Questo dovrà scegliere un canale di comunicazione virtuale, detto **_socket_** (o **identifier**, che puoi vedere come un'interfaccia con il layer di Trasporto), una coppia di valori che rappresentano\n\n- **_indirizzo IP_**, che identifica univocamente da dove il client sta comunicando (e quindi dove inviare la risposta);\n- **_porta_**, un numero che convenzionalmente specifica con quale tipo di protocollo Applicazione standard *mi aspetto* di inviare e ricevere, ma che più in generale serve a identificare il socket.\n\nLa creazione del socket avviene tramite le API fornite dal livello di Trasporto.\n\nA questo punto la richiesta discende la stack protocollare del client e risale quella del **_destinatario_**, che per ricevere il messaggio a livello Applicazione deve essere **_già in ascolto_** sulla porta richiesta dal client. Questo si realizza tramite un **_processo server_**, che a sua volta per ascoltare ha creato un **_socket_**.\n\nIl che ci fa capire che in realtà quello che rompe il ghiaccio è il server. Costui runna il suo processo server mettendosi in ascolto, e si fa pubblicità (*\"Ciao a tutti, sono 6.6.6.6! Mandatemi pure un messaggio sulla porta 69!\"*).\n\nA questo punto il client sa a chi scrivere e su quale porta.\n\nLa coppia di socket definisce il **_canale di comunicazione_** $\\Rightarrow$ entrambi sanno a chi comunicare (IP) e come comunicare (porta). Stabilito il canale di comunicazione, i due processi usano uno schema di tipo **_message passing_**.\n\nO meglio, questo succede se uso TCP. A UDP non frega niente di creare canali di comunicazione. *\"Sei in ascolto? Daje, tieni questo pacchetto\"* fine ciao.","x":-6620,"y":4520,"width":720,"height":777,"color":"4"},
		{"id":"52edf2e6ee84f9b0","type":"text","text":"# P2P (cenni)\n\nvedi slides\n\nserve un sistema per coordinare il gruppo di peer. si può anche decentralizzare (database distribuito).\nI vicini sono scelti secondo criterio di download più veloce. potrei anche fare solo download (greedy), servono incentivi a condividere.\n\ndevo iniziare chiedendo lista dei blocchi e scaricando i pezzi di di file più rari. \"optimistic unchoke\" anche se non sei nella top 4 ti includo (altrimenti si scambiano dati solo i primi 4) (tutti questi numeri sono parametri modificabili)\n\ntesto randomicamente velocità dei vicini per vedere se è top, in caso ci accoppiamo e inizia il torrent\n\nnel protocollo non è richiesto che qualcuno abbia il file intero, così come potrei mettere a disposizione il file e poi scollegarmi a metà\n\nil protocollo aumenta la velocità di download secondo la disponibilità di upload\n\nskype era p2p, poi l'ha preso microsoft e hanno centralizzato e non ha funzionato bene fino al dimensionamento dei server.\n\nci sono modi per fare l'Internet decentralizzato, ogni oggetto è rappresentato in modo univoco tramite un oggetto hash e poi \"boh qualcuno ce lo avrà\"","x":-6620,"y":5417,"width":720,"height":610},
		{"id":"d0bc31a12d2847f8","type":"file","file":"chifacosa.png","x":-5736,"y":4983,"width":700,"height":209},
		{"id":"0719791a80c12eb2","type":"text","text":"# Chi fa cosa?\n\nMittente e destinatario devono implementare tutti gli step dell'incapsulamento o decapsulamento, naturalmente mediante dispositivi diversi.\n\nUn router vede solo dal livello di Rete in giù. Una sua azione tipica è **distruggere l'header di Rete** del pacchetto in ingresso **e crearne uno nuovo** ($\\Rightarrow$ così realizza il **reindirizzamento**).\n\nNon ha bisogno di avere i protocolli software di Trasporto e Applicazione (tipicamente implementati solo a livello di SO), perché non arriva a vederli. Si limita a collegare $N$ sottoreti tramite $N$ strutture diverse sottostanti.\n\nUno switch si ferma al Collegamento. Non dovendo reindirizzare (si limita ad inoltrare i frame in ingresso), non distrugge/crea alcun header.","x":-4940,"y":4877,"width":700,"height":420,"color":"3"},
		{"id":"6f3226cdbb9850aa","type":"text","text":"# Servizi del Trasporto\n\n(de)multiplexing: raggruppare cose in un unico canale e poi saperle ridistribuire\n\ncomunicazione logica = dal pov applicazione è come se i vari livelli di trasporto siano connessi (poi come succede non è affare mio). a me livello di trasporto basta che i messaggi in qualche modo arrivino.\n\nUDP è un portiere che \"non fa niente\", se non il (de)multiplexing.\n\ni due socket UDP non devono avere per forza lo stesso numero di porta. devo conoscere quella del processo a cui invio però.\n\nil numero di porta è una convenzione, il SO ha una lista di quelle standard (80 HTTP, ma se la cambio funziona lo stesso)\n\nper il demultiplexing UDP basta la porta, in pratica, perché è stateless\nuno che ascolta sempre su un canale (porta), gente che quando vuole può parlare dicendo una parola alla volta\n\nil socket TCP vuole stabilire una connessione, quindi gli servono \n\n- indirizzo IP di origine\n- numero di porta di origine\n- indirizzo IP di destinazione\n- numero di porta di destinazione\n\nregola per mappare i pacchetti al processo.\nperché metto anche l'IP? anche per aumentare lo spazio dei socket (avere più scelte per demultiplare).\n\nPosso mentire sul mio IP sorgente? (direi in UDP sì e sta alla rete controllare che io non faccia cose strane) ma non lo mette UDP nell'header mi sa, sta alla rete temo\nPiù processi che si aspettano HTTP (e.g. firefox e chrome) lo fanno sullo stesso socket? c'è un ulteriore demux? uno dei due è forzato a cambiare porta (tanto è TCP)? (secondo me ognuno apre un socket)\n\n","x":-4151,"y":6734,"width":708,"height":1046},
		{"id":"9f731eac72823c6c","type":"text","text":"# Livello di Collegamento","x":-3000,"y":6377,"width":391,"height":50,"color":"6"},
		{"id":"34401d45639b449d","type":"text","text":"# Livello di Trasporto","x":-3968,"y":6452,"width":341,"height":50,"color":"6"},
		{"id":"3881465ee755981e","type":"text","text":"# Stack Protocollare TCP/IP\n\nLo standard *de facto* di Internet. **_TCP/IP_** prevede **_5 livelli_**, che descriverò in approccio _down-top_ (si dice? chissà), partendo quindi dalla realtà fisica per arrivare alla virtualizzazione di più alto livello.\n\n- **_Livello Fisico (Physical Layer)_** - l'infrastruttura fisica, dove avviene il vero e proprio **_trasferimento dei segnali_** (e.g. **cavi**, spettro EM). Gestisce l'HW nudo e crudo, incluse le frequenze, le tensioni e la modulazione dei segnali. Ad esempio, un **_modem_** trasforma la codifica dei dati per l'invio dell'informazione (**trasmissione**, da digitale ad analogico) e viceversa (**ricezione**);\n- **_Livello di Collegamento (Data Link Layer)_** - a livello HW, regola e gestisce il **trasferimento dei pacchetti da un nodo al successivo** (e.g. **Ethernet**, **Wi-Fi**, **PPP**, ...). Lungo il suo percorso, un singolo pacchetto può essere gestito da protocolli diversi. Spesso si schematizza TCP/IP a 4 livelli, unificando Fisico e Collegamento. \n- **_Livello di Rete (Network Layer)_** - a livello matematico, regola e gestisce l’**_instradamento dei pacchetti_** dall'origine alla destinazione attraverso opportuni algoritmi (e.g. **IP**);\n- **_Livello di Trasporto_** - a livello SW, regola e gestisce il trasferimento dei pacchetti dal processo del dispositivo mittente a quello del dispositivo destinatario (e.g. TCP, UDP);\n- **_Livello di Applicazione_** - è la vista di più alto livello (e.g. HTTP, FTP, DNS).\n\nOra però passiamo all'approccio *top-down* per seguire l'evoluzione di un messaggio.\n\n- il **_messaggio_** corrisponde al pacchetto originale, per come visto dall'utente a livello di Applicazione. Quest'ultimo applica delle trasformazioni utili (e.g. compressione, aggiunta di metadati, crittografia, ...) e lo passa al Trasporto attraverso la loro **_interfaccia_**;\n- il Trasporto riceve il messaggio e gli aggiunge le proprie informazioni (**_header_**), portando a termine il primo **_incapsulamento_** e rendendo il messaggio un **_segmento_** (o **_datagramma utente_**). (((L'header del Trasporto è comprensibile per la Rete, che saprà cosa farci, e contiene _almeno_ mittente e destinatario))) NON SO SE GIUSTO;\n- in modo analogo il Trasporto passa il segmento alla Rete, che aggiunge il proprio header e crea un **_datagramma_**, comprensibile per il Collegamento;\n- si passa quindi al Collegamento, che aggiungendo il proprio header rende il pacchetto un **_frame_**, utile a livello di collegamento Fisico.\n\nA questo punto il pacchetto ha completamente disceso la stack. Può avvenire il trasferimento fisico attraverso la rete e un altro dispositivo può applicare le trasformazioni inverse per risalire prima al datagramma, poi al segmento e infine al messaggio.","x":-4148,"y":4210,"width":700,"height":1087,"color":"3"},
		{"id":"ea111d8cb579b650","type":"text","text":"# Paradigmi di Comunicazione\n\nUn **_paradigma di comunicazione_** è uno schema secondo cui avvengono lo scambio di informazioni e la gestione delle connessioni all'interno di una rete (tendenzialmente si implementa a livello di Internet).\n\nVi sono due paradigmi di comunicazione principali:\n\n- **_client-server_** - utilizzato da protocolli Applicazione quali HTTP, FTP e IMAP. I sistemi terminali vengono divisi in due categorie:\n\t- **_server_** - host sempre attivo ($\\Rightarrow$ **_sempre in ascolto_**) e con indirizzo IP permanente ($\\Rightarrow$ sempre identificabile nella rete). **_Fornisce servizi_** al client. Se si scollega non può esserci comunicazione, neanche tra client (in quanto si basano su percorsi di tipo client -> server -> client);\n\t- **_client_** - host che comunica solo e soltanto con un terminale di tipo server, a cui **_richiede servizi_**. Non è tenuto ad essere sempre attivo, né ad avere un IP fisso $\\Rightarrow$ non è tenuto ad essere reperibile (da chi, poi?);\n- **_peer-to-peer (p2p)_** - ogni host (*peer*, \"di egual importanza\") può essere sia client che server, richiedendo e fornendo servizi. Questo paradigma rende la rete estremamente **_scalabile_**, in quanto al crescere dei peer aumenta anche l'offerta di servizi. Più complesso da gestire, perché non ci sono indirizzi fissi e nessun peer è tenuto ad essere sempre in ascolto. Utilizzato tipicamente da protocolli legati alla condivisione di file.\n","x":-5736,"y":5417,"width":700,"height":610,"color":"4"},
		{"id":"179ce6b66f1a29fe","type":"text","text":"# Livello di Applicazione","x":-5586,"y":6452,"width":400,"height":50,"color":"6"},
		{"id":"dff88af00a536f81","type":"text","text":"# Su cosa si basano?","x":-4757,"y":6557,"width":330,"height":50,"color":"6"},
		{"id":"349ec5026bac8b92","type":"text","text":"# Protocolli Applicazione\n\nSono i protocolli di livello più alto, e ignorano completamente la complessità della rete (e.g. percorso dei pacchetti, reinvio in caso di perdita, ...).\n\nA ogni porta è associato un protocollo, che definisce\n\n- le **_tipologie_** dei messaggi scambiati (e.g. richiesta, risposta, ...);\n- la **_sintassi_** del messaggio ($\\Rightarrow$ come va scritto, e.g. definisce i **campi**);\n- la **_semantica_** del messaggio ($\\Rightarrow$ cosa significa quello che scrivo secondo la sintassi);\n- le **_regole_** che devono rispettare mittente e destinatario per scambiarsi i messaggi (e.g. quanto aspettare tra un messaggio e l'altro, \"se cancello un messaggio qui va cancellato anche dall'altra parte\").\n\nTra i protocolli applicazione troviamo due macro-categorie:\n\n- **_open-source_** (e.g. HTTP), definiti con uno standard pubblico ([RFC](https://it.wikipedia.org/wiki/Request_for_Comments)). Paradossalmente questo aiuta a ridurre le vulnerabilità del protocollo, in quanto aumentano le persone che possono individuarle e conseguentemente correggerle. La condivisione del protocollo è in generale un principio ben noto in ambito sicurezza, e di norma i problemi di vulnerabilità in questi casi si riducono al tempo che intercorre tra il ritrovamento di un bug e il suo *fix*;\n- **_proprietari_** (e.g. Skype), più ottimizzati ma a volte meno efficienti (difficile trovare problemi con poca statistica). \n\nPossiamo poi distinguere protocolli per \n\n- trasferimento file (e.g. HTTP, FTP);\n- posta elettronica (e.g. SMTP, POP, IMAP);\n- accesso a terminali remoti (e.g. Telnet, SSH);\n- servizi (e.g. DNS, NTP)","x":-5736,"y":6734,"width":700,"height":806,"color":"4"},
		{"id":"b81367aa9de6afb4","type":"text","text":"# Garanzie\n\nSe invio un messaggio voglio anzitutto **_che arrivi a destinazione_** (... e no, su Internet non è scontato), dopodiché se possibile vorrei lo facesse\n\n- ***integro***, ovvero che non subisca corruzione (e.g. se faccio una chiamata non voglio pacchetti in disordine o fenomeni di *bit-flip*), che naturalmente può essere anche volontaria;\n- **_in tempi ragionevoli_** (e.g. nell'esempio della chiamata, non voglio un ritardo di minuti tra l'invio e la ricezione)\n\nSe ho tanti messaggi di grandi dimensioni (e.g. straming video) sarebbe carino avere un **_throughput minimo garantito_**.\n\nOra, chi è che si occupa di fornire tali garanzie?\n\n- Il layer di **_Trasporto_**, se si usa un servizio affidabile come TCP. Questi protocolli sono distribuiti come API e implementati a livello di SO;\n- Il layer di **_Applicazione_** stesso, rimediando ad alto livello alle non-garanzie di servizi inaffidabili come UDP (il quale non garantisce neanche che il messaggio arrivi, in caso sta all'Applicazione programmare il suo reinvio). I protocolli dell'Applicazione sono implementabili direttamente (appunto) sulle applicazioni (e.g. un browser), senza necessità di API standardizzate e distribuite su SO. Questo li rende generalmente più rapidi nello sviluppo.\n\nInoltre posso aver bisogno di comunicare informazioni riservate, e avere necessità di **_sicurezza_** nei confronti di ascoltatori indesiderati. Questo può essere implementato tramite schemi di **_crittografia_**\n\n- nel layer di Applicazione, e quindi a livello di browser (nel modello OSI se ne occupava esplicitamente il layer di Presentazione);\n- nel **_TLS (Transport Layer Security)_**, e prima nel suo predecessore **SSL (Secure Sockets Layer)**. Sebbene non sia ufficialmente parte di TCP/IP, è diventato uno standard *de facto*. Viene diffuso insieme alle API di TCP, e critta i messaggi prima di passarli a quest'ultimo. Si noti che aggiungere un layer è molto più semplice rispetto ad aggiornare esplicitamente un protocollo come TCP.\n\nA seconda di che applicazione sto usando posso avere necessità diverse.\nSe mando una mail non voglio perdite ma non ho particolari necessità di velocità o di throughput, mentre se faccio live streaming posso accettare di perdere qualche frame purché il ritardo sia minimo (e se non ho un thoughput minimo garantito... non faccio live streaming).\n","x":-4920,"y":6734,"width":656,"height":1076,"color":"4"},
		{"id":"1a7e522c18045e6d","type":"text","text":"# (De)multiplexing\n\nTCP/IP prevede più protocolli per uno stesso layer, da cui la domanda: se a TCP arriva un segmento, come fa a sapere a quale protocollo del livello Applicazione (e.g. HTTP, FTP, SMTP, DNS, ...) consegnarlo?\n\nDomanda importante, visto che se consegno un messaggio HTTP a un processo che parla la lingua dei DNS quest'ultimo non capisce niente.\n\nEssendo il layer inferiore ad offrire il servizio, quando TCP riceve un messaggio dall'Applicazione scrive nell'header qual è il protocollo che lo ha generato (e.g. HTML, FTP, ...). In questo modo a destinazione può comodamente leggere il proprio header e scegliere a quale protocollo Applicazione consegnare i dati.\n\nIn pratica, qualsiasi protocollo può mandare pacchetti a TCP, al quale non importa niente del protocollo sovrastante.\n\nIn generale, ogni protocollo deve essere in grado di **gestire** (incapsulare, sempre uno alla volta!) i **pacchetti ricevuti da più protocolli presenti al livello superiore** mantenendo le informazioni sulla sorgente (**_multiplexing_**) per poi eseguire l'**operazione inversa** a destinazione tramite l'informazione mantenuta nell'header, ovvero decapsulare e consegnare i pacchetti a più protocolli del livello superiore (**_demultiplexing_**).\n\nBello, ma come lo implemento? Scrivo nell'header \"HTTP\" e poi...?\n\nNo, nell'header ci scrivo dei codici standard (**_porte_**), che individuano un canale di comunicazione standard usato da un certo protocollo. Ad esempio, il protocollo HTTP leggerà di default le informazioni che arrivano sulla porta 80 ($\\Rightarrow$ 80 è il valore corrispondente al campo adeguato dell'header di trasporto).\n\nDetto questo, nel caso di TCP si parla di **_(de)multiplexing protocollare_** (potremmo dire _logico_ o *virtuale*, in quanto avviene a livello software), ed è associato principalmente al livello di Trasporto.\n\nIl (de)multiplexing _**non**_ avviene solo a livello di Trasporto, ma i layer inferiori (e.g. Rete) possono implementarne delle versioni un po' più fisiche (**_qua dovresti entrare un minimo nel dettaglio perché non ti sei capito nemmeno da solo_**)","x":-3220,"y":4210,"width":700,"height":930,"color":"3"},
		{"id":"010165be9fd56b6c","type":"text","text":"# Livello di Rete","x":-3054,"y":3130,"width":264,"height":50,"color":"6"},
		{"id":"a69d18b26b90862d","type":"text","text":"# Algoritmi di Instradamento","x":-1898,"y":3130,"width":437,"height":50,"color":"6"},
		{"id":"798615d376321d80","type":"text","text":"Il livello di rete è gestito da protocolli come IP, RIP, OSPF e BGF, che instradano i pacchetti attraverso Internet. Al livello di collegamento, ci sono diverse tecnologie, tra cui Ethernet e Wi-Fi, mentre il livello fisico si occupa della trasmissione fisica dei dati.\n\nICMP è un protocollo di controllo di Internet che consente ai router di segnalare errori di instradamento o di comunicare con gli host.\n\nL'indirizzamento IPv4 utilizza indirizzi a 32 bit suddivisi in net_id (identificativo di sottorete) e host_id (identificativo dell'host). La frammentazione dei pacchetti è gestita per adattarsi alle dimensioni massime di trasmissione delle reti fisiche.\n\nInfine, IPv4 ha subito una serie di evoluzioni per affrontare problemi di esaurimento degli indirizzi e migliorare l'efficienza delle comunicazioni.","x":-2290,"y":4491,"width":515,"height":560},
		{"id":"35235b872aeaab53","type":"text","text":"# Stack Protocollare ISO/OSI\n\nNel 1984 l'_International Organization for Standardization_ (ISO) ufficializza uno standard architetturale chiamato _Open Systems Interconnection_ (OSI).\n\nLa stack protocollare prevede 7 livelli. Rispetto a TCP/IP (di cui è predecessore spirituale) vi sono due layer aggiuntivi:\n\n- Layer di Presentazione (anche detto livello 6, partendo dal basso) - si pone subito sotto al livello di Applicazione, il quale lo assorbe completamente in TCP/IP. Si occupa esplicitamente della codifica e della crittografia dei dati;\n- Layer di Sessione (livello 5) - definisce alcuni dettagli della comunicazione inter-host, come la gestione degli errori nell'invio dei pacchetti E ALTRO???? Nel modello TCP/IP, i suoi compiti sono stati divisi tra l'Applicazione e il Trasporto.\n\n","x":-4940,"y":4210,"width":700,"height":530,"color":"3"},
		{"id":"1bd86960d6e5a8e2","type":"text","text":"# Stack protocollare","x":-3966,"y":3654,"width":336,"height":50,"color":"6"},
		{"id":"ed6dd0d5b788bd3e","type":"text","text":"# In pratica e in breve\n\nPer accedere ad Internet ($\\Rightarrow$ scambiare dati con qualsiasi altro nodo collegato), gli host si devono in qualche modo connettere agli ISP (aziendali, università, commerciali), i quali a loro volta devono essere interconnessi (tramite ISP più grandi o IXP).\n\nLa risultante rete di reti è molto complessa, perché la sua evoluzione è figlia di un abnorme ammasso disordinato di fattori (politici, economici, nazionali, ...).","x":-4570,"y":-880,"width":772,"height":300,"color":"3"},
		{"id":"ba32fe7205e2606f","type":"text","text":"# Guida alla scelta tra TCP e UDP\n\n- **_TCP_** - è il *lawful good* della situazione. Dà garanzie di arrivo, di non-congestione dell'utente (controllo flusso) e della rete (controllo congestione) (\"se su TCP vado al massimo blocco anche me stesso\"). NON dà garanzie di velocità. chi va piano... ma tanto timing e throughput non può mai essere garantito in commutazione di pacchetto, devo fare circuito con linea dedicata. è in chiaro, non offre crittografia. orientato alla connessione -> esiste paradigma mittente destinatario. se c'è traffico rallenta\n- **_UDP_** - è *chaotic evil*, non fornisce manco la connessione (l'altro non sa che gli ho inviato la richiesta di connessione). \"io ci provo a trasmettere i dati, poi... da parte mia best effort fratello\". può essere veloce, non è necessario il paradigma client-server. ogni servizio che offre tcp aggiunge complessità e potenzialmente ritardi e/o capacità computazionale. ma io posso costruire il mio trasporto affidabile a livello sw e poi sparare tutto su udp che potenzialmente ci mette meno. infatti tutti oggi tendono a implementare regole a livello applicazione, e se http era basato su tcp si sta lentamente passando a udp. http3 usa udp e si costruisce i servizi di tcp a livello applicazione, il che mi garantisce flessibilità. (\"deve rimanere leggero\")\n","x":-4920,"y":7900,"width":656,"height":627},
		{"id":"9446a50b389809a0","type":"text","text":"ci sono anche delle vie di mezzo tipo TLS (sicurezza). prima se mandavo una password era in chiaro, chi trovava il pacchetto (non facilissimo) aveva vinto. Transport Layer Security usa TCP ma sta sotto l'applicazione. Quindi io scrivo la phrase in chiaro, tls la critta e la passa a tcp. non lo faccio a livello tcp perché è un casino cambiare un protocollo così lento ad evolversi (super diffuso).","x":-3318,"y":-800,"width":656,"height":200},
		{"id":"2df2877d35b32cbf","type":"text","text":"# Trasferimento affidabile RDT (Reliable Data Transfer)\n\nDevo gestire problemi come perdita o danneggiamento dei dati. Costruiamolo da zero. Partiamo da assunzioni ideali e poi rilassiamo un pezzetto alla volta.\n\n\n\n###### Canale perfetto (completamente affidabile)\nAssunzione monodirezionale: il dato va solo in una direzione, ma l'informazione di ricezione deve tornare indietro, anche con una connessione non affidabile.\nSe lo voglio simmetrico devo farne due.\nSe il canale inaffidabile ha problemi devo risolverli. \nLe uniche info che hanno mittente e destinatario sono i pacchetti che ricevono!! Ci sono alcuni messaggi che ricevo che possono corrispondere a più stati dietro la tenda. Cerchiamo di massimizzare la probabilità di comprendere cosa accade dove non vediamo.\nUDT (Unreliable...)\nnon c'è una corrispondenza 1:1 tra i pacchetti scambiati e ricevuti.\nDevo creare 2 protocolli: invio e ricezione.\n\n###### RDT 1.0\nnessun problema. costruisco una FSM per mittente e destinatario\nl'unico stato è di costante attesa, per il mittente dal livello applicativo, per il receiver dai livelli sottostanti. Se ricevo chiamata RDT eseguo le azioni e torno in attesa.\n\n###### RDT 2.0 (BIT FLIP)\n**_Assumiamo di poter rilevare gli errori_**. \"Puoi ripetere?\". Ipotesi di stop-and-wait.\nSender: ora ho due stati: attesa dall'Applicazione o attesa ACK, NAK. Lambda è un modo per dire \"nessuna azione\".\nReceiver: sempre uno stato, ma ci sono due possibili frecce (Azioni): ACK e NAK.\nProblema: chi mi dice che ACK/NAK non sia corrotto? So solo quello che ricevo! in situazioni complicate potrei andare fuori sync perché non so cosa si aspettano gli altri. Sottoproblema: se invio ACK ma sender riceve NAK quello rimanda il pacchetto, e il destinatario per ora non sa che è lo stesso (si potrebbe mettere un numero di sequenza (che in questo caso è tipo un solo bit, perché faccio stop and wait))\nProblema2: potrei entrare in un loop infinito, ma è inevitabile\n\nConvenzione: il numero di riscontro (ack) indica sempre il numero di\nsequenza del prossimo pacchetto atteso dal destinatario\n###### RDT 2.1 (GESTIRE ACK E NAK CORROTTI)\nse ACK/NAK è corrotto non so cos'è, so che mi è stato detto qualcosa ma non so cosa. call 1 e call 0 si riferisce al bit del numero di sequenza (basta quello perché ho stop and wait).\n\n\n###### RDT 2.2 (solo con gli ACK)\nnon entriamo nel dettaglio. mi dici solo se hai capito, l'ACK ha un numero di sequenza esplicito. **_Lo implementa TCP._**.\nChe vantaggio ho ad essere privo di NAK?\n\n#### RDT 3.0 (PERDITE)\nServono dei timeout oltre i quali se non arriva risposta considero il pacchetto perso.\nQuesto potenzialmente mi fa perdere la sincronizzazione, a maggior ragione mi serve il numero di sequenza nell'ACK.\nSe assumo pacchetto perso ignoro controllo errori. Per semplificare protocollo posso trattare allo stesso modo pacchetti persi e corrotti (ovvero: se arriva un ACK corrotto lo ignoro, tanto scatterà il timer, ci rimette un po' in efficienza, TCP è stato migliorato in questo senso).\nSono ancora in regime stop-and-wait, e questo è un enorme spreco per le capacità del cavo. Allora faccio **_PIPELINING_**.\n\n\n#### Oltre RDT 3.0\nMando più pacchetti prima di aver ricevuto l'ACK del primo. Il protocollo va solo aggiustato per gestire più di un messaggio alla volta","x":-4151,"y":8240,"width":708,"height":1820},
		{"id":"621da05b43f27ecc","type":"text","text":"# Varie\n\nPosso manovrare ad hoc il checksum per far apparire un pacchetto autentico e fare injection","x":-3280,"y":8780,"width":617,"height":600},
		{"id":"f55770ab8bdeed44","type":"text","text":"# Go-Back-N\n\nl'ack è sempre cumulativo, sta al destinatario mandarlo bene (ogni volta che riceve un pacchetto, qualsiasi pacchetto).\nla sua implementazione è semplificata: non ha una finestra, deve solo tenere traccia di dove è arrivato. un vantaggio è infatti semplicità di applicazione.\n Se i pacchetti arrivano fuori ordine e non ho un buffer butto pacchetti (finestra destinatario > 1 = buffer).\n \nlato mittente quando arriva l'ack cumulativo scorro la finestra.\nse perdo anche solo il primo nella finestra (c'è il timer) nel dubbio rimando tutta la finestra\n\ncosa brutta: spreco un sacco di banda\ncosa bella:\n- faccio spesso dei refresh del protocollo (rimandando tutta la finestra in pratica lo faccio ricominciare)\n- ridondanza (che sembra una cosa negativa, ma se mi perdo gli ack che mi manda il destinatario non sposto la finestra e continuo a mandare roba che già ha, vedi SR)","x":-4560,"y":10239,"width":577,"height":641},
		{"id":"9b35587f0d6f95ff","type":"text","text":"# Selective Repeat\n\nniente ack cumulativi, faccio tutto individualmente. timeout per ogni pacchetto. migliora la congestione ma è più pesante da implementare. TCP usa l'ack cumulativo ma anche alcuni concetti di SR.\n\nmittente: finestra come prima\nreceiver: deve avere una finestra perché tiene in buffer la roba. potrebbe spostare la finestra ma il mittente potrebbe non ricevere gli ack e andare fuori sync.\n\nse la sequenza è in base 2m,la\nfinestra può essere al più grande 2m-1","x":-3693,"y":10239,"width":490,"height":641},
		{"id":"594865c9c2779a13","type":"text","text":"# UDP\n\nUser Datagram Protocol (della serie, in pratica lavoro sui datagrammi)\n\nsnmp gestione router, devo mandare info asap\n\nchecksum molto rudimentale (somma complemento a 1), se trovo errore lo scarto (e lo richiedo? dipende dal protocollo applicazione).\n\nce n'è più d'uno, il che rende vagamente più sensato il fatto che sia molto grezzo","x":-3280,"y":6967,"width":367,"height":580},
		{"id":"9727e675784a8b75","type":"text","text":"**Load Balancer (Bilanciatore di Carico)**: Immagina che stai lanciando una festa e hai molte persone che vogliono entrare. Un \"load balancer\" è come il tipo che controlla l'ingresso e distribuisce le persone in modo uniforme in modo che non ci sia troppa confusione in una zona. Nei server, il load balancer fa lo stesso, distribuendo il traffico in modo equo tra diversi server, in modo che nessun server sia sovraccaricato.","x":-2807,"y":7012,"width":468,"height":491},
		{"id":"8c6c0c607ea31c4a","type":"text","text":"\n\nInternet utilizza una pila protocollare che discende dai sette livelli dell'architettura ISO/OSI. Al livello di applicazione, esistono vari protocolli per diverse funzioni, come HTTP per la navigazione web, SSH per il controllo remoto, FTP per il trasferimento di file e SMTP per l'invio di email. Gli sviluppatori di applicazioni non devono preoccuparsi dei dettagli dei livelli inferiori.\n\nA livello di trasporto, ci sono due protocolli principali: TCP (Transfer Control Protocol) e UDP (User Data Protocol). TCP è orientato alla connessione e offre affidabilità, mentre UDP è senza connessione e utilizzato per applicazioni che richiedono velocità.","x":-3081,"y":7732,"width":549,"height":482},
		{"id":"7ef6e3a292cb6a28","type":"text","text":"Il Transmission Control Protocol (TCP) è un protocollo risiedente sul layer di\ntrasporto in grado di fornire trasporto affidabile, ossia senza perdita di alcun pac-\nchetto, e controllo del flusso e della congestione, in cambio di un’assenza di garanzie\ntemporali, di throughput e di sicurezza.\nInoltre, il protocollo TCP è orientato alla connessione, ossia richiedente una confi-\ngurazione (handshaking) tra il processo client e il processo server\nDefinizione 18: User Datagram Protocol (UDP)\nL’User Datagram Protocol (UDP) è un protocollo risiedente sul layer di traspor-\nto in grado di fornire trasporto veloce poiché non orientato alla connessione ed\nestremamente scarno, ossia sprovvisto di: trasporto affidabile, controllo del flusso e\ndella congestione e garanzie temporali, di throughput e di sicurezza","x":-3081,"y":8295,"width":708,"height":402},
		{"id":"877a13b60a49c414","type":"text","text":"# Posta Elettronica","x":-6377,"y":7060,"width":317,"height":50,"color":"6"},
		{"id":"40ee9c3447f7fb82","type":"text","text":"# Trasferimento File","x":-5545,"y":7660,"width":319,"height":60,"color":"6"},
		{"id":"3c83dc58c55637a4","type":"text","text":"\n(Tendono ad essere più che altro descrittivi, un insieme di regole fenomenologiche che possono rompersi in qualsiasi momento.??????)\n\n\n\"avere protocolli aperti permette a tutti di competere\"\n\n\n\nIl livello N prende il payload (mole di dati) del livello N-1 e gli aggiunge le proprie etichette (header, ...)\n\nSwitch non fa niente, router fa entrambe le cose\n\nIP e MAC fanno riferimento a layer (protocolli) diversi.\n\n\nOSI bello ma mai stato implementato, la sicurezza sta all'applicazione","x":-4581,"y":9577,"width":385,"height":506},
		{"id":"ec189bfa1c37a5e8","type":"text","text":"Il trasporto TCP prevede il controllo di flusso e la gestione degli errori per garantire l'affidabilità. Esistono anche meccanismi di controllo di congestione per evitare sovraccarichi di rete.","x":-4514,"y":8697,"width":250,"height":307},
		{"id":"4b0440947706cde0","type":"text","text":"\ncomuni con complicazioni sw. API socket -> mi servono i servizi del livello sotto per funzionare, sono interessato solo a cosa posso usare. creare un'app a questo livello ignora la complessità della rete (percorso pacchetti, reinvio in caso di perdita, ...). Anche i router ignorano il livello applicazione (non esiste http sui router).\n","x":-4514,"y":9027,"width":250,"height":484},
		{"id":"ff01e5961e252647","type":"text","text":"# Campi degli Header\n\n### Solo Client\n\n- **Accept** - Indica i tipi di contenuto che accetta come risposta;\n- **Accept-Charset** - Indica i set di caratteri che accetta come risposta;\n- **Accept-Encoding** - Indica le codifiche che accetta come risposta;\n- **Accept-Language** - Indica le lingue in cui accetta la risposta;\n- **Authorization** - Trasmette le credenziali di autenticazione;\n- **Cookie** - Invia i cookie al server.\n- **Host** - Specifica il nome dell'host e la relativa porta al quale è destinata la richiesta;\n- **If-Modified-Since**: Richiede la risorsa solo se è stata modificata dopo una data specificata;\n- **Upgrade** - Usato dal client per chiedere al server di cambiare il protocollo utilizzato;\n- **User-Agent** - Specifica al server il software utilizzato per inviare il messaggio HTTP;\n### Solo Server\n- **Last-Modified** - Indica la data e l'ora dell'ultima modifica alla risorsa;\n- **Expires** - Specifica la scadenza della risorsa ($\\Rightarrow$ quando non deve più essere considerata valida se trovata in cache);\n- **ETag** - Identificatore univoco per una specifica versione di una risorsa;\n- **Accept-Ranges** - Stai scaricando un file e ti salta la connessione. Devi riscaricarlo tutto? No, se questo valore è impostato a `bytes` puoi riprendere da dove ti eri interrotto! \n- **Location** - Reindirizza il client a una nuova locazione URL;\n- **Server** - Comunica al client il processo server che ha generato la risposta;\n- **Set-Cookie** - Invia cookie al client;\n### Sia Client che Server\n- **Cache-Control** - Specifica le istruzioni di caching;\n- **Connection** - Indica se a seguito del messaggio voglio chiudere la connessione (`close`, comportamento predefinito di HTTP/1.0) o se voglio mantenerla attiva (`keep-alive`, comportamento predefinito di HTTP/1.1); \n- **Content-Encoding** - Indica la codifica del corpo del messaggio;\n- **Content-Language** - Indica la lingua del corpo del messaggio;\n- **Content-Length** - Indica la lunghezza del messaggio nel body. Utile quando uso il metodo HEAD per capire quanto è grande il file che voglio scaricare;\n- **Content-Type** - Indica il tipo di contenuto presente nel body;\n- **Date** - Specifica data e ora d'invio del messaggio;\n- **Keep-Alive** - Quando `Connection` è impostato su `keep-alive`, questo parametro specifica dopo quanto tempo il server chiuderà la connessione dopo l'ultimo messaggio inviato (`timeout=60` imposta la tolleranza a 1 minuto) oppure al raggiungimento di quale numero massimo di richieste (`max`);\n- **Server**: Usato dal server per identificarsi con il client.\n","x":-6755,"y":9385,"width":805,"height":1200,"color":"3"},
		{"id":"16f174d47e0dd2b5","type":"text","text":"### Esempio di richiesta\n```\nGET /index.html HTTP/1.1\\r\\n\nHost: www-net.cs.umass.edu\\r\\n\nUser-Agent: Firefox/3.6.10\\r\\n\nAccept: text/html,application/xhtml+xml\\r\\n\nAccept-Language: en-us,en;q=0.5\\r\\n\nAccept-Encoding: gzip,deflate\\r\\n\nAccept-Charset: ISO-8859-1,utf-8;q=0.7\\r\\n\nKeep-Alive: 115\\r\\n\nConnection: keep-alive\\r\\n\n\\r\\n\n```","x":-6865,"y":10685,"width":473,"height":447,"color":"4"},
		{"id":"44ce1eef2a1a2afa","type":"text","text":"### Esempio di Risposta\n\n```\nHTTP/1.1 200 OK\\r\\n\nDate: Sun, 26 Sep 2010 20:09:20 GMT\\r\\n\nServer: Apache/2.0.52 (CentOS)\\r\\n\nLast-Modified: Tue, 30 Oct 2007 17:00:02 GMT\\r\\n\nETag: \"17dc6-a5c-bf716880\"\\r\\n\nAccept-Ranges: bytes\\r\\n\nContent-Length: 2652\\r\\n\nKeep-Alive: timeout=10, max=100\\r\\n\nConnection: Keep-Alive\\r\\n\nContent-Type: text/html; charset=ISO-8859-1\\r\\n\n\\r\\n\n[document content...]\n[...]\n```","x":-6355,"y":10685,"width":511,"height":447,"color":"4"},
		{"id":"2edbb402780f44c6","type":"text","text":"# HTTP\n\nParadigma **_richiesta-risposta (client-server)_** di tipo ***stateless*** basato su ***TCP*** che convenzionalmente utilizza la ***porta 80***.\n","x":-6629,"y":8406,"width":548,"height":160,"color":"6"},
		{"id":"89560ca8221b899c","type":"text","text":"# Messaggio di Richiesta HTTP\n\n Inviato dal client al server, consta di tre parti:\n \n - ***Riga di richiesta*** - Una stringa avente sintassi `metodo URI versione_HTTP \\r \\n`, dove\n\t- `metodo` specifica *cosa* voglio fare;\n\t- `URI` specifica l'oggetto all'interno del server con cui voglio interagire. ;\n\t- `versione_HTTP` serve ad assicurarmi che parleremo la stessa lingua;\n\t- `\\r \\n`, caratteri di ritorno a capo e avanzamento riga, comunicano la fine della stringa di richiesta.\n- ***Intestazione (header)*** - Varie righe aventi sintassi `parametro: valore` che specificano informazioni utili alla richiesta;\n- ***Corpo (body)*** - Payload diretto al server, preceduto da una riga vuota. Tipicamente vuoto a sua volta, a meno che non si faccia una richiesta di upload (metodo POST).\n\t","x":-6865,"y":8685,"width":473,"height":580,"color":"4"},
		{"id":"a30868312d411d98","type":"text","text":"# Messaggio di Risposta HTTP\n\nRisposta del server al client, anche qui tre parti:\n\n- Riga di stato - Una stringa avente sintassi `versione_HTTP STATUS PHRASE \\r \\n`, dove\n\t- `versione_HTTP` serve ad assicurarmi che parleremo la stessa lingua;\n\t- `STATUS` è un codice che identifica l'esito della richiesta;\n\t- `PHRASE` è una breve descrizione testuale associata al codice `STATUS`.\n- ***Intestazione (header)*** - Varie righe aventi sintassi `parametro: valore` che specificano informazioni utili alla risposta;\n- ***Corpo (body)*** - L'effettivo contenuto della risposta. Spesso in caso di errore si tratta della stampa a schermo a caratteri cubitali del codice di errore.","x":-6317,"y":8685,"width":473,"height":580,"color":"4"},
		{"id":"6ce8f85f78362603","type":"text","text":"# Metodi di Richiesta\n\n- ***GET*** - Richiede la risorsa `path` al server. Può essere usato per richiedere metadati o per far generare sul momento la risorsa di cui ho bisogno.\n\t- Lo stesso indirizzo IP con cui ho stabilito la connessione potrebbe contenere più domini, per cui sono obbligato a specificare il campo `host` dell'header;\n\t- Posso fornire al server ulteriori specifiche su *come* rispondermi aggiungendo `?` alla fine dell'`URI` e scrivendo ***parametri*** (nella forma `parametro=valore`) separati da `&` (e.g. `/page.html?categoria=notizie&anno=2022`);\n\t- Esiste una variante del GET, detto ***GET CONDIZIONALE***, per sfruttare il **_web caching_** $\\Rightarrow$ richiede la pagina al server solo se è stata modificata rispetto alla versione che conosce;\n\t- Il GET dovrebbe essere sempre una richiesta ***idempotente***, nel senso che due GET di fila dovrebbero produrre lo stesso risultato. Questo non è sempre vero, perché esistono parametri dinamici che possono modificare lo stato del server. Possiamo considerarla una vulnerabilità, potrei usarli per fare injection (e.g. SQL), cambiare le autorizzazioni o accedere a risorse riservate;\n- ***HEAD*** - Richiede l'header che verrebbe restituito a seguito di una richiesta GET. Usato principalmente nei controlli di validità della ***web cache*** (e.g. \"la pagina è stata modificata?\");\n- ***POST*** - Invia dati al server tramite il body. E come fa il server a sapere cosa fare con questi dati?\n\t- L'applicazione server definisce degli ***endpoint***, ovvero dei \"contenitori\" di richieste di azioni simili (e.g. `/crea`, `/aggiungi`, `/elimina`, ...);\n\t- Nella richiesta POST posso quindi specificare direttamente l'endpoint a cui è diretta (e.g. so di voler creare un file e so che il server usa l'endpoint `/crea`);\n\t- Se non conosco l'endpoint corretto posso indirizzare le richieste a un endpoint generico. A quel punto il server prova a capire cosa farci ($\\Rightarrow$ a quale endpoint mandarlo), magari anche interpretando il body (l'implementazione specifica sono fatti suoi);\n\t\t- Se non conosco neanche l'endpoint generico tocca cercare la documentazione, salvo avere voglia di fare trial-and-error: se specifico un endpoint che non esiste il server mi risponde 404;\n\t\t- Inviare deliberatamente un gran numero di richieste POST generiche per costringere il server ad un overhead di smistamento è considerabile un attacco DoS;\n\n- **_PUT_** - Invia nel body un intero documento da salvare nella locazione `URI`, sovrascrivendo qualsiasi cosa ci fosse prima. Ovviamente è un'operazione rischiosa, sta al server gestirla bene;\n- **_DELETE_** - Autoesplicativo;\n- ***PATCH*** - applica modifiche parziali a una risorsa.\n- **_COPY, MOVE_** - Copiano o spostano la risorse in una nuova locazione (anche un'altro server);\n- **_LOCK, UNLOCK_** - Primitive di sincronizzazione (come in un SO);\n- **_OPTIONS, TRACE_** - Opzioni e diagnostica della connessione;\n- ***CONNECT*** - Stabilisce una connessione di tunnel (e.g. VPN).","x":-7787,"y":8685,"width":837,"height":1040,"color":"4"},
		{"id":"973215b7fd31a26a","type":"text","text":"### Esempio di GET\n```\nGET /page.html?parametro=valore HTTP/1.1\nHost: example.com\n```","x":-7880,"y":9825,"width":459,"height":160,"color":"4"},
		{"id":"ada1ce65a17b1ff7","type":"text","text":"### Esempio di POST\n```\nPOST /endpoint HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 25\n\nparametro1=valore1&parametro2=valore2\n```","x":-7324,"y":9825,"width":459,"height":301,"color":"4"},
		{"id":"be024ab3c20ae124","type":"text","text":"### Esempio di PUT\n```\nPUT /risorsa HTTP/1.1\nHost: example.com\nContent-Type: application/json\nContent-Length: 43\n\n{\"chiave\": \"valore\", \"altro\": \"dato da salvare\"}\n```","x":-7324,"y":10165,"width":459,"height":301,"color":"4"},
		{"id":"ee9aa768d32eb89f","type":"text","text":"# Parametri delle query\n\nSebbene esistano parametri per diversi metodi, quelli che compaiono nell'URL sono comunemente associati al metodo GET.\n\nNon esiste una lista assoluta di parametri standard, poiché dipendono da come è scritto il singolo server.\n\nComplessivamente possiamo trovare parametri di\n\n- **ricerca o filtro** - specificano una query all'interno del server:\n\t`?q=termine_di_ricerca`\n\t`?categoria=notizie&anno=2022`\n- **ordinamento** - specificano l'ordine dei risultati restituiti dal server:\n\t`?ordine=asc&campo=data`\n- **paginazione** - specificano come vengono visualizzati i risultati della richiesta:\n\t`?pagina=2&per_pagina=10`\n- **autenticazione** - comunicano token di accesso e/o credenziali utente:\n\t`?token=abc123`\n- **localizzazione** - specificano la localizzazione e/o le preferenze linguistiche dell'utente:\n\t`?lingua=it_IT&paese=IT`\n\nChi crea il server può definire dei parametri personalizzati per trasmettere informazioni specifiche:\n\n\t ?parametro1=valore1&parametro2=valore2","x":-7880,"y":10036,"width":459,"height":873,"color":"4"},
		{"id":"0efd970a1119442f","type":"text","text":"# FTP\n\nil processo client ftp crea una connessione tcp sulla porta 21. handshaking, poi il client si autentica. esistono due connessioni FTP.\n\n- una tcp di controllo (porta 21). chi controlla? la connessione dati (out of band, controllo che non è nello stesso canale, non è limitato a questo discorso ma molto generale). persistente\n- una connessione dati (porta 20). non persistente (finisco transfer? chiudo)\n\nse tutti usassero ftp, per come funziona tcp andrebbe tutto alla grande (poche connessioni, grandi quantità di dati). nel browser posso usare ftp (scrivendo `ftp:` al posto di `http:`). capire quanto cambia. con FTP posso abortire il download in caso di sovraccarico (in http non avendo due canali non arriva manco l'abort, perché è *in band*). se devo scaricare 20 file apro 21 connessioni TCP: un controllo e 20 file.\n\nper il resto è simile a smtp, http.","x":-5736,"y":7906,"width":700,"height":660},
		{"id":"55d3231875e83cc8","type":"text","text":"# Codici di Risposta\n\n\tSe sei un Server devi rispondere bene, altrimenti dall'altra parte non capiscono\nVi sono 5 categorie di codici `STATUS`, il cui significato è poi chiarito dalla `PHRASE`:\n\n- ***Codici 1xx*** - la risposta contiene solo informazioni.\n\t- `100 Continue` indica che il server è pronto a ricevere la richiesta del client;\n- ***Codici 2xx*** - l'operazione è andata a buon fine.\n\t- `200 OK` è la risposta che vorremmo ricevere sempre, e restituisce del contenuto;\n\t- `204 No Content` significa \"tutto bene, ma non ho niente da inviarti\", può succedere se ad esempio chiedo di salvare la pagina;\n- ***Codici 3xx*** - \"ho dovuto reindirizzare la richiesta che mi hai fatto\".\n\t- `301 Moved Permanently` significa esattamente \"quello che chiedi non è più qui, da adesso in poi reindirizzo tutte le tue richieste per questo oggetto al nuovo URI;\n- ***Codici 4xx*** - errore nella richiesta del client.\n\t- `400 Bad Request` significa \"non ho capito, ed è colpa tua\";\n\t- `403 Forbidden` è un \"non hai i permessi per chiedermi questa risorsa\";\n\t- `404 Not Found` è un \"la risorsa che chiedi non esiste su questo server\";\n- ***Codici 5xx*** - \"non ci sono riuscito, ma è colpa mia\".\n\t- `500 Internal Server Error` significa \"non so manco io che è successo\";\n\t- `503 Service Unavailable` indica che il server al momento non può gestire la richiesta, in pratica è un \"riprova più tardi\"\n\t- `505 HTTP Version Not Supported` significa \"no hablo tacos\".","x":-5735,"y":8685,"width":700,"height":1040,"color":"4"},
		{"id":"12862795d7c14b6d","type":"text","text":"# Restrizioni (aggiorna slides domani?)","x":-10315,"y":3877,"width":315,"height":209},
		{"id":"8142f6eec6ad761b","type":"text","text":"# glue?\n\nse non sono il server di competenza devo fornire due cose:\n\n- il nameserver di quelo vero\n- il relativo IP\n\nperché altrimenti dove lo trovo?\nin generale posso ricevere più risposte (in genere, appunto, due\n\nun cname può puntare ad un altro cname, ma è buona norma evitare questa pratica","x":-9909,"y":4006,"width":629,"height":554},
		{"id":"ad79665cff57c7f0","type":"text","text":"# UDP\n\ndns gira su udp perché evita il traffico e i vari handshaking di tcp.\n\nper dns non ha senso il concetto di connessione, perché è stateless.","x":-11040,"y":4223,"width":250,"height":383},
		{"id":"f10a4ae200557701","type":"text","text":"se voglio mat.uniroma1, phys.uniroma1, ... devo fornire diversi CNAME. se però faccio così mappo tutto su un unico server. utile perché se cambia cambio solo il canonico. ","x":-10670,"y":4266,"width":414,"height":294},
		{"id":"3c95ceb1f8d66d4b","type":"text","text":"# rappresentazione domini \n\nho due modi di rappresentare i domini\n- assoluti (rispetto alla root), in teoria terminano con un punto (e.g. google.com.)\n- relativi (alla locazione in cui sono), se sono connesso a di.uniroma1.it va a cercare in di.","x":-11040,"y":4726,"width":393,"height":354},
		{"id":"bd9ffece9b4d9aa9","type":"text","text":"# Record DNS\n\na seconda di type gli altri valori cambiano significato.\n- A (address) associo nome a IP, se trovo questo ho vinto\n- NS (Name Server) ti dico quale server DNS può aiutarti a vincere\n- CNAME punta all'alias. mi hai dato un alias, non devi cercare questo ma quello che ti dico mo. fa puntare più sottodomini allo stesso server\n- MX (mail server) richiede esplicitamente il mail server associato al nome. dovrebbe essere sempre usato su un nome canonico, ma non sempre succede","x":-10480,"y":4726,"width":448,"height":460},
		{"id":"79f9f9b698f80e1d","type":"text","text":"dns server = name server","x":-9784,"y":4896,"width":250,"height":60},
		{"id":"d857fb6bb469a958","type":"text","text":"gerarchico distribuito sembra una contraddizione, in realtà il .com potrebbe sapere qualcosa del .it","x":-9784,"y":5326,"width":250,"height":170},
		{"id":"d9218fbe64e55603","type":"text","text":"# query dns iterativa\n\nè stato creato un nuovo sito, nessuno sa niente. voglio gaia.cs.umass.edu. faccio richiesta UDP al local host. \"mi dai l'IP di gaia.cs.umass.edu?\". Quello mi dice che non lo sa, va dal root, il quale risponde \"al massimo ti dico dove sta .edu\", il quale risponde con l'indirizzo dell'autoritativo umass.edu e dovrebbe sapere tutto (salvo sotto-dns). la maggior parte del lavoro lo fa il local dns, ma posso sostituirmi a lui e fare \"a mano\"\n\n# query dns ricorsiva\nil peso del lavoro va su tutta la rete. tutto il lavoro dell'iterativa è in locale, qui invece ogni server contattato deve fare da sé. non si dovrebbe fare per il sovraccarico sulla root. non si usa. e se la usi il root non risponde. il protocollo ti consente di fare richiesta ricorsiva, ma non obbliga root a rispondere con la ricorsione, probabilmente ti risponde con iterativa.\n\n\nin generale, io host o server dns locale mi arrangio con i dati che ho. se volevo ricorsione e quello mi dice solo .edu allora contatto .edu.\n\nQuando il server apprende una mappatura la memorizza. se root sa già in cache la risposta me la dà diretto. ","x":-10778,"y":5411,"width":658,"height":735},
		{"id":"dadc08ce77ef0c49","type":"text","text":"dns potrebbe essere usato come controllo blocchi (dare not found per certi ip), però se chiedo a root bypassando il locale lo frego","x":-9911,"y":5779,"width":329,"height":144},
		{"id":"2c357555847a692e","type":"text","text":"# DNS\n\nTraduzione dei nomi. per raggiungere un server mi serve l'indirizzo IP. potrei ricordarmi quello, ma\n\n- non è detto che sia fisso\n- difficile da ricordare\n\nserve un'astrazione. \"devo raggiungere google, come scopro dove sta?\". ha senso che sia a livello applicativo, perché riguarda la periferia (per quanto sono operazioni a livello di rete, IP). client-server, mappa nome (rimane fisso ed è utilizzato da umani) in ip (variabile, utilizzato per indirizzare i datagrammi). In pratica mi serve una tabella di corrispondenze. nella preistoria c'era un singolo file con un povero cristo che li aggiornava. oggi è un database distribuito e gerarchico. (chiamo dns sia DB sia anche protocollo app che gestisce questo DB). Non posso metterlo nei router, mi servono dei server!\n\nALIASING: hostname canonico è il \"vero\" nome, sotto al quale c'è l'ip, ma poi a questo collego gli alias. in questo modo se cambio ip lo cambio solo al nome canonico. Se cambio IP in teoria dovrei avvisare tutti i DB e cambiarlo, ma non succede. Ogni associazione ha un TTL che alla scadenza chiede al proprietario del dominio dove sta.\n\nLOAD BALANCING: il sito viene sdoppiato su più server. Nel DNS li associo tutti e a chi lo chiede dò una lista random. qualunque metodo scelgo io richiedente resta random, a meno che non conosco il loro seed di randomizzazione.\n\nGERARCHIA: il punto definisce la gerarchia, e si legge da dx a sx. il punto definisce la root. poi ci sta `.it`, `.com`, ecc... raggruppati \"da una parte\". quindi c'è \"chi gestisce `.it`\", e se mi serve un tale sito chiedo a lui (che si chiama Top Level Domain TLD). Poi sotto ci sono gli autoritativi, esampio `uniroma1.it`, che mi cercano esplicitamente l'IP. Quindi la richiesta DNS è\n\n- interrogo punto, il root server, che mi sa dire dove sta il TLD (e.g. .com);\n- interrogo il TLD, il quale mi dà l'autoritativo (e.g. amazon.com)\n- interrogo l'autoritativo per l'IP\n\nil root server POTREBBE pure rispondermi subito con l'IP se ce l'ha in cache o se decide di risolverselo da solo e darmi una risposta. se un server risponde a nome di qualcun altro (e.g. .com mi restituisce l'ip di uniroma.it) ti dovrebbe anche dire che non è autoritativo (tipo mettere le mani avanti e dirti che non è responsabile).\n\nMa chi mi dice come trovare l'IP del DNS ROOT? Sono standard. Quando scarico il SO lo sa già, ce ne sono 13 in totale (non server, IP! server ce ne sono di più!). Non è che ogni volta vado dal root. se il mio server dns locale sa l'IP me lo dà lui. se non lo sa, salgo di livello. se non lo sa \\[...\\] arrivo al root. Se non so niente e tutte le tabelle sono vuote sicuramente partendo da root qualcosa trovo.\n\nC'è tutta una questione di sicurezza, se si rompe il DNS si rompe tutto.\n\nICANN sono \"gentlemen agreement\" tra le varie nazioni. chi gestisce il TLD può fare quello che vuole (e.g. lo stato italiano può nazionalizzare il .it). Posso creare amazon.it e venderlo ad amazon.com? ... sì ma ci stanno le leggi sul copyright.\n\nogni organizzazione privata che mette a disposizione un server deve mettere a disposizione anche un dns server. in genere ce ne sono sempre due per protocollo (perché? boh!)\n\nin realtà il primo hop (accesso) alla rete fornisce un DNS LOCALE (e.g. `8.8.8.8`), che NON fanno parte della gerarchia ma fa da servizio. Perché offrire il DNS? perché così sa cosa cerco. A parte la rivendita di info, posso usarlo per fare caching, ed è l'unico modo in cui decentralizzo il DB. queste cache hanno il TTL e quando scade si aggiornano. Quindi fa da proxy (se ce l'ha) oppure fa partire la ricerca dns. anche il servizio di aggiornamento dei nomi è best effort. potrei mette TTL a 10 secondi e aggiornare in continuazione, oppure \"fuori protocollo\" posso svuotare le cache con operazioni di purge. non ho garanzie di quanto ci mette l'info a propagarsi nella rete (ma comunque ordine dei 5/10 minuti).\n\nse scade uniroma1.it il dns locale chiede a .it chi è uniroma1. oppure no, dipende dalla configurazione interna.\n\n","x":-9251,"y":4303,"width":1160,"height":1336},
		{"id":"aa76e477e11e779d","type":"text","text":"# SMTP, IMAP (posta elettronica)\n\nforse cronolgicamente prima di HTTP. slides. in teoria posso farlo p2p ma in quel caso devo essere acceso. allora uso il server (al tempo potevano anche essere spenti a tratti). quello di uscita poteva tenere le cose se il secondo non rispondeva. smtp è un protocollo di tipo push, serve a scrivere i messaggi. per il pull (leggere i messaggi) serve pop3 o imap. smtp è anche usato end-to-end tra server di posta (p2p), ma in mezzo ci sono i router e TCP. Posso creare io stesso un server di posta con smtp. porta 25 vedi slides per protocollo.\n\nConnessione tcp persistente fino al quit. server ha timeout lungo. 7bit (8 con primo bit 0). dopo fine messaggio (CRLF, ovvero semanticamente cr+lf) ne aspetta un altro a meno che non scrivo quit.\n\nintestazione stessa della mail (to, from, subject) ma non è SMTP. prima c'è handshaking con comandi helo, ...\n\nQuesto è solo ascii 8bit. per altri formati c'è un altro protocollo (MIME). Immagine convertita in ascii e poi riconvertita a destinazione.\nDi nuovo, i protocolli interni sono lenti a cambiare. piuttosto che modificare SMTP creo un altro protocollo a livello più alto.\n\nCome accedo alla posta? POP3 o IMAP, o addirittura HTTP se lo faccio da browser. non specifico quante connessioni apro.\n- POP3 porta 110 (slides), quando il client scarica i messaggi il server li cancella (posso non farlo togliendo comando dele). basta definire regole per comunicare. problemi: pensato per un solo client. se ne ho tanti devo sincronizzare tutto, ma è difficile senza stato. allora uso\n- IMAP, che tiene traccia dello stato (e.g. ci sono le cartelle tipo spam, i tag, ...), se faccio modifiche in locale viene aggiornata anche sugli altri client.\n- HTTP, l'agente è un browser\n\ninizialmente associavo mail ad ogni utente linux, ora no (?) (se uso postfix?) \"sono vago perché serve poco\".\n\nse uso thunderbird (IMAP) per mettere gmail (HTTP) posso trovare differenze in cose tipo la divisione in cartelle, i tag, ...\n\n\n\" a livello applicativo è abbastanza lasciato libero\"","x":-9161,"y":5711,"width":1100,"height":720},
		{"id":"a290001f0c2b618c","type":"text","text":"# PROVA NSLOOKUP!","x":-9011,"y":3530,"width":419,"height":90},
		{"id":"acb4f16f12e3f2e9","type":"text","text":"# ... ma perché stateless?!\n\nSe TCP supporta lo storico, perché HTTP sceglie di non implementarlo?\n\n- Da qualche parte devo salvare (grandi quantità di) dati $\\Rightarrow$ mi serve altro spazio di archiviazione;\n- Client e Server devono in ogni momento concordare sullo storico, il che richiede sincronizzazione e causa problemi se un terminale crasha;\n- In generale, i protocolli non-stateless sono più complessi.","x":-8800,"y":8685,"width":837,"height":254,"color":"4"},
		{"id":"a13ba86d0881bc3c","type":"text","text":"# Evoluzione del protocollo HTTP\n\nIl prototipo di HTTP, ***HTTP/0.9***, nasce nel 1991 con il World Wide Web. Si trattava di un protocollo scarno, in cui esisteva solo il metodo GET con pochi parametri.\n\nNella sua prima versione ufficiale _**HTTP/1.0**_ ([RFC 1945](https://www.rfc-editor.org/rfc/pdfrfc/rfc1945.txt.pdf), 1996) era prevista una connessione di tipo ***non-persistente*** (si apre il canale TCP, si invia uno e un solo oggetto, si chiude il canale TCP).\n\nIl problema ovvio è che per richiedere $N$ oggetti devo aprire e chiudere $N$ connessioni, ognuna delle quali deve fare *handshaking* sprecando un RTT. \n\nAllora i browser dissero \"abbiamo la soluzione! mandiamo $N$ richieste TCP in parallelo!\". Bello, ma TCP non è pensato per una cosa del genere, e questa pratica congestiona la rete.\n\nLa vera soluzione la porta **_HTTP/1.1_** ([RFC 2616](https://www.rfc-editor.org/rfc/pdfrfc/rfc2616.txt.pdf), 1999), lasciando la connessione aperta e introducendo introducendo i GET in successione (può essere visto come una forma di **multiplexing**, essendo più informazioni su singolo canale che vengono poi smistate dal server).\n\nQuesto mitiga il problema, ma non lo risolve del tutto. Una pagina web è un contenitore di elementi \"grandi\" e \"piccoli\", i quali vengono richiesti al server, che gestisce le richieste GET secondo l'ordine di arrivo (FCFS), motivo per cui\n\n- Un oggetto piccolo può ritrovarsi dietro oggetti grandi, facendo schizzare alle stelle l'*average waiting time* $\\Rightarrow$ **blocco head-of-line (HOL)**;\n- Per come è scritto TCP, se perdo anche un solo pacchetto dell'oggetto grande perdo un sacco di tempo prima di ritrasmetterlo $\\Rightarrow$ l'attesa media cresce ancora.\n\nQuesto problema viene risolto da ***HTTP/2*** (**RFC 7540, 2015**) \"spezzettando\" ogni richiesta/risposta in **frame** e costruendo una **pipeline** (migliora quindi il multiplexing di HTTP/1.1, trasmettendo più oggetti contemporaneamente).\n\nInclude anche migliorie generali al protocollo:\n\n- ***server push*** - cerca di fare prediction e inviarti cose che non hai ancora richiesto, potenzialmente riducendo il numero di richieste. In teoria questi elementi non vengono eseguiti se non richiesti, ma potrebbero restare salvati in una qualche cache;\n- ***priorità*** - consente di assegnare una priorità alle richieste;\n- ***compressione degli header*** - riduce l'overhead di trasferimento.\n\nResta ancora un problema. TCP assume che ogni client instauri una e una sola connessione, e gestisce il sovraccarico di rete e l'affidabilità dando questo per scontato. In pratica, è un protocollo basato su grandi oggetti e su pochi flussi (connessioni), mentre Internet di fatto funziona al contrario.\n\nNasce quindi l'idea di spostare HTTP su UDP sfruttando ***QUIC*** (**Quick UDP Internet Connections**), un protocollo di trasporto sviluppato da ***Google***. Questo protocollo, chiamato ***HTTP/3*** ([RFC 9914](https://www.rfc-editor.org/rfc/rfc9114.html), 2022), al momento in cui scrivo è in fase di sviluppo e sperimentazione.\n\n\tOnce a client knows that an HTTP/3 server exists at a certain endpoint, it opens a QUIC connection. QUIC provides protocol negotiation, stream-based multiplexing, and flow control.","x":-9658,"y":8685,"width":700,"height":1395,"color":"4"},
		{"id":"b42a1d8cb55878e0","type":"text","text":"# Proxy Server\n\nIl client può scegliere di parlare con un ***proxy server*** fa da ***cache*** al \"vero\" server a cui è indirizzata la richiesta, con la solita speranza di fare *cache hit*. Se questo non succede (*cache miss*) è il server proxy stesso che si occupa di far partire la richiesta ($\\Rightarrow$ fa sia da client che da server).\n\nUn buon proxy cerca di imparare cosa chiede la platea. Una buona idea (e.g. che può avere Netflix) per sfruttare la ***web cache HTTP*** è hostare i film italiani su un proxy in italia (magari non in Antartide).\n\nvedi slides per dati utili (come odg). intensità del traffico è quella che esplode a 1. mettere cavo sgravo costa, allora metto proxy. funziona? forse. (installare un server è più economico di un cavo???) devo controllare il rate dei cache hit. Sicuro supporta HTTP, anche altri? boh, lui non lo sa. se ho cose vecchie in cache? dipende dal meccanismo implementativo.\n- GET condizionale - \"hey server mandami la cosa if-modified-since\", se non lo è codice 304 \"not-modified\" e poi come parlo con il server dipende;\n- boh","x":-8800,"y":7820,"width":837,"height":467},
		{"id":"6efc85167597eec6","type":"text","text":"# Servizi","x":-7787,"y":6844,"width":188,"height":50,"color":"6"},
		{"id":"ee8fed6684bf344f","type":"text","text":"# Web Caching","x":-8506,"y":7583,"width":250,"height":60,"color":"6"},
		{"id":"2661b4a7e85defac","type":"text","text":"# ChatGPT risponde: \"Perché lasciare aperta una connessione TCP (HTTP 1.1) non è banale a livello implementativo?\"\n\nLasciare aperta una connessione TCP, come previsto dal protocollo HTTP/1.1, non è banale a livello implementativo per diversi motivi:\n\n1. **Gestione delle risorse del server**: Ogni connessione TCP aperta richiede risorse da parte del server, come memoria e capacità di elaborazione. Mantenere molte connessioni aperte contemporaneamente può esaurire rapidamente le risorse del server, riducendo le prestazioni complessive del sistema.\n    \n2. **Gestione dello stato della connessione**: Quando una connessione TCP rimane aperta, il server deve mantenere uno stato associato a quella connessione, che include informazioni sullo stato della sessione, i dati in sospeso e altre informazioni di controllo. Gestire lo stato di molte connessioni aperte contemporaneamente può diventare complesso e richiedere una gestione accurata delle risorse.\n    \n3. **Rischio di esaurimento delle risorse**: Se non gestite correttamente, le connessioni TCP aperte possono portare all'esaurimento delle risorse del server, che può causare degrado delle prestazioni o addirittura un blocco completo del server.\n    \n4. **Potenziali problemi di sicurezza**: Le connessioni TCP aperte possono essere soggette a attacchi come attacchi di tipo DoS (Denial of Service) o DDoS (Distributed Denial of Service), che sfruttano la disponibilità delle connessioni per sovraccaricare o saturare il server.\n    \n5. **Complessità dell'implementazione del pooling delle connessioni**: Per mitigare i problemi sopra menzionati, è comune utilizzare meccanismi di pooling delle connessioni, che consentono di riutilizzare le connessioni TCP esistenti anziché aprirne continuamente di nuove. Tuttavia, la corretta implementazione di un pool di connessioni può essere complessa e richiedere una gestione accurata delle risorse e dei timeout.\n    \n\nIn sintesi, sebbene mantenere aperte le connessioni TCP possa offrire vantaggi come tempi di risposta più rapidi e una maggiore efficienza complessiva della comunicazione client-server, è necessario affrontare diverse sfide implementative e gestionali per farlo in modo sicuro ed efficiente.","x":-11500,"y":8864,"width":848,"height":817},
		{"id":"1b501ca1023c98e0","type":"text","text":"# Perdite\n\nInternet di base è non affidabile (\"best effort\"), il che significa che i pacchetti possono essere persi o consegnati in ordine casuale.\n\nSe il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). ","x":-2019,"y":2012,"width":680,"height":276,"color":"1"},
		{"id":"77ddaf1188c7b900","type":"file","file":"HTTP_1.1.png","x":-10480,"y":9223,"width":698,"height":319},
		{"id":"04b979f48c716c0b","type":"file","file":"HTTP_2.0.png","x":-10480,"y":9681,"width":698,"height":313},
		{"id":"c25570b5d51372e2","type":"file","file":"HTTP_1.0.png","x":-10361,"y":8720,"width":460,"height":411},
		{"id":"5c7cb3e9b597a877","type":"text","text":"# Telnet\n\ntelnet?? interfaccia con tcp a livello testuale, devo mandare a capo due volte. una volta che si apre una connessione ogni carattere fa un roundtrip, ma di default non vedo l'echo di quello che ho scritto su terminale.\nbrowser fa questo ma in automatico con le librerie TCP.\nwireshark???\n","x":-7787,"y":7006,"width":1032,"height":334},
		{"id":"19dd5229975701ca","type":"text","text":"Una pagina web è composta da oggetti, ciascuno dei quali\npuò essere archiviato su un diverso server Web\n§ l'oggetto può essere un file HTML, un’immagine JPEG, applet\nJava, file audio,...\n§ la pagina web consiste in un file HTML di base che include\ndiversi oggetti referenziati, ciascuno indirizzabile da un URL,\nad es.\nwww.someschool.edu/someDept/pic.gif\n\nclient: browser che richiede, riceve\n(utilizzando il protocollo HTTP) e\n“visualizza” oggetti Web\n• server: il server Web invia\n(utilizzando il protocollo HTTP)\noggetti in risposta alle richieste","x":-6628,"y":7482,"width":548,"height":417},
		{"id":"5b4a906a7f7134ec","type":"text","text":"\n***header***: insieme di campi che danno informazioni al destinatario. non fa parte dell'incapsulamento (leggo-distruggo-replace), ***payload*** del (parte del messaggio visto dal) livello sottostante, non cambia (resta leggibile","x":-4218,"y":5900,"width":250,"height":367},
		{"id":"84d5d9e7cf116171","type":"text","text":"network time protocol\n","x":-10631,"y":8348,"width":250,"height":60},
		{"id":"6694e27578406638","type":"text","text":"# Ma essere stateless è un problema!\n\n- **Autenticazione** - Faccio una richiesta mandando username e password. Il server mi dice `200 OK`, ma alla richiesta successiva non sa che sono io (`chi siete? cosa portate? un fiorino!`);\n- **Sessione** - Non posso memorizzare le preferenze sui siti;\n- **Lock** - Voglio fare due modifiche consecutive un oggetto, e non accetto che ne venga fatta una sola o che qualcuno usi l'oggetto tra una modifica e l'altra. Usando un protocollo *stateful* posso usare un *lock* fino a fine operazioni, ma HTTP non sa chi sono (`chi l'ha messo quel lucchetto? Boh vabbè, per me resta così`);","x":-8800,"y":8980,"width":837,"height":280,"color":"4"},
		{"id":"f99413b00ff804a3","type":"text","text":"# Una possibile soluzione: i Cookies di Sessione\n\nSono costretto ad usare qualcosa di esterno al protocollo che tenga traccia dello stato del client, e si chiama ***cookie***.\n- All'apertura di una connessione, il server riceve una prima richiesta senza cookie;\n- Al server non piace non sapere chi sei, quindi quando manda la prima risposta riempie il campo `set-cookie` dell'header con un valore che identifica univocamente l'utente (e.g. `1678`);\n- Il client riceve il cookie come stringa (e.g. `set-cookie: nome-cookie=1678; Max-Age=3600; Domain=example.com`), e sta a lui manipolarla per estrarne i dati. Tipicamente il browser si crea un file (e.g. `.txt`) che mantiene in RAM e che usa come riferimento per le richieste successive;\n- Quando invia una nuova richiesta, il client include nel campo `Cookie` dell'header le informazioni di cui è in possesso;\n- Adesso il server saprà con chi sta parlando e agirà di conseguenza fino alla scadenza del cookie, al termine della quale il client si ritroverà stampato a schermo `session expired`.\n\n**Il singolo cookie è associato a uno specifico dominio del server**, e vale solo per quest'ultimo. Si possono specificare ulteriori domini di validità del cookie nel campo `Domain`(e.g. `Domain=.eg.com` rende il cookie valido per tutti i sottodomini di tipo `subdomain.eg.com`).","x":-8800,"y":9305,"width":837,"height":520,"color":"4"},
		{"id":"29e96eab29abd54f","type":"text","text":"# Glossario dei Protocolli di alto livello\n\n- **_Handshaking_** - La danza rituale per aprire una connessione TCP. Tipicamente il client manda al server una richiesta di connessione, il quale tipicamente risponde con un OK. Il canale di comunicazione è nato, evviva! Tutto questo impiega almeno un RTT; \n- ***Round Trip Time (RTT)*** - tempo impiegato da un pacchetto di \"piccole dimensioni\" (idealmente un solo bit, in modo tale che $D_t \\sim 0$) per compiere il percorso client-server-client;\n- ***Request For Comments (RFC)*** - quando i primi sviluppatori ideavano un protocollo in ambito accademico, lo condividevano in cerca di feedback. Questa etichetta nel tempo è diventata il nome dei documenti definitivi che standardizzano i protocolli;\n- ***Stateless*** - protocollo che non conserva informazioni sulle interazioni passate;\n- ***Uniform Resource Identifier (URI)*** - convenzione standard per identificare univocamente le risorse su Internet. Può essere di diversi tipi:\n\t- ***Uniform Resource Locator (URL)*** - Specifica sia l'indirizzo della risorsa sia le istruzioni per accedervi. Consta di tre parti:\n\t\t- Il protocollo da utilizzare per stabilire una comunicazione con l'host della risorsa (HTTP, FTP, SSH, SMTP, ...);\n\t\t- Il nome dell'host, eventualmente da risolvere tramite ricerca DNS per trovare l'IP corrispondente;\n\t\t- Il percorso della risorsa all'interno dell'host.\n\t- ***Uniform Resource Name (URN)*** - Associa ad una risorsa un identificatore persistente e univoco, indipendentemente dalla sua posizione o raggiungibilità tramite URL, esattamente come un libro è identificato univocamente dal suo codice *ISBN (International Standard Book Number)* $\\Rightarrow$ `urn:isbn:0451450525313`. Va registrato presso l'altisonante *Internet Engineering Task Force (IETF)*, e immagino uno debba avere un buon motivo per farlo (?)\n\t- Se so per certo di essere, ad esempio, all'interno di un server, anche un **_path relativo_** è considerabile un URI. In questo senso, un URL è un path assoluto;\n\t- Contesti più specifici possono definire dei propri URI (e.g. il **_File URI_** viene usato dai browser per accedere ai file locali dell'utente);","x":-6658,"y":6084,"width":758,"height":837,"color":"4"},
		{"id":"431962e65465019d","type":"text","text":"# Sicurezza\n\nE se intercetto un cookie di sessione? In linea di principio posso impersonare un client regolarmente loggato pur non avendo alcuna password.\n\nIn pratica ci sono diverse forme di difesa:\n\n- Utilizzare il flag `Secure`, che consente lo scambio del cookie solo con ***HTTPS***;\n- Utilizzare il flag `HttpOnly`, che impedisce al codice ***Javascript*** di accedere al contenuto del cookie tramite l'API `document.cookie`;\n- Settare il parametro `SameSite` al valore `Strict` consente l'invio del cookie solo e soltanto al server che l'ha creato.\n\nChe c'entra Javascript?\n\nIl cookie è in generale un contenitore di informazioni i cui campi sono inizialmente stabiliti dal server che lo crea, ma il codice Javascript può aggiungerne e riempirli con le informazioni del client. Segue che il cookie può trasformarsi in una vera e propria *fingerprint* del client, con informazioni come\n\n- browser utilizzato, latenza, font, risoluzione schermo, ...\nIl problema sono i cookie di terze parti (cioè non del server che contatto direttamente) che permettono a gruppi di server di tracciare le attività del client. (e.g. di cookie: fingerprint che include browser, font, latenza, risoluzione schermo e io server posso venderlo a terzi). Come trasferisco la risoluzione?? HTTP non lo fa, è difficile profilare (so solo IP, latenza e poca roba). Potrei forzare il browser a limitarsi a questo. Però uso spesso anche javascript (-> il server fa girare codice sul client) e le regole a riguardo sono molto \"rilassate\". Posso fare injection per farmi mandare la risoluzione schermo o altra roba. Si può mascherare ma dall'altra parte possono accorgersi che tu mascheri ed attirare l'attenzione. l'unico metodo funzionante è disabilitare javascript. Attacco canvas??\n\nHo dei modi alternativi? Certo, ma più complessi.","x":-8331,"y":9905,"width":420,"height":1395,"color":"#4545ff"},
		{"id":"dab2f7463a1544fc","type":"text","text":"# Cookies Traccianti\n\nCi sono siti che si ricordano chi sei anche quando riavvii il computer. Ma il browser non si limita a salvare i cookie in RAM? Non proprio. A seconda della sua implementazione interna può decidere di salvarli su disco (e.g. se mi arriva un cookie che scade tra una settimana forse ha senso conservarlo).\n\nOra, è chiaro che mi va bene non dover loggare su Steam ogni volta che riavvio il computer. Infatti, finché questi ***cookies persistenti*** sono solo quelli del server con cui sto parlando non c'è problema.\n\nNon va più bene se oltre ai suoi cookies il server mi manda quelli di altri server che non contatto direttamente (***cookies di terze parti***), che permettono a gruppi di server di tracciare le attività del client.","x":-8851,"y":9905,"width":420,"height":568,"color":"4"},
		{"id":"beb0fa9d0cb9609a","type":"text","text":"### Cross-Site Scripting (XSS)\n\nSei su un forum, e un tizio senza foto profilo posta un link. Tu lo apri, sembra un sito tranquillo, interagisci ed esci. Fine.\n\nO almeno, questo è quello che vedi tu.\n\nCiò che succede è che in qualsiasi punto (URL compreso, in questo caso hai perso anche solo cliccando sul link) di questo *nuovo sito* (*Cross-Site*) potrebbe esserci *codice Javascript* (*scripting*) malevolo.\n\n\"Vabbè, ma cosa potrà mai fare il Javascript\".\n\n- Leggere e/o modificare la zona di memoria del browser (e quindi credenziali d'accesso, cookies, ...);\n- Inviare richieste web, come scaricare contenuto o inviare informazioni a un server malevolo;\n- Sfruttare vulnerabilità del browser per accedere al filesystem locale del client.","x":-8851,"y":10520,"width":420,"height":660,"color":"#4545ff"}
	],
	"edges":[
		{"id":"6ddf40dd3d233286","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"23227e82062b49bc","toSide":"right"},
		{"id":"f97b165cd5b79ca1","fromNode":"23227e82062b49bc","fromSide":"top","toNode":"06174ae2aacf2d26","toSide":"bottom"},
		{"id":"79cea350f5f65501","fromNode":"a569f47822207faf","fromSide":"left","toNode":"4f9f693b64bc0e3f","toSide":"right"},
		{"id":"6d5ee26096e39af5","fromNode":"06174ae2aacf2d26","fromSide":"left","toNode":"a569f47822207faf","toSide":"right"},
		{"id":"efca276162b37995","fromNode":"a569f47822207faf","fromSide":"right","toNode":"06174ae2aacf2d26","toSide":"left"},
		{"id":"a779e63db92ba963","fromNode":"06174ae2aacf2d26","fromSide":"top","toNode":"165209213bc6a130","toSide":"bottom"},
		{"id":"9f06416bd06bfdef","fromNode":"a569f47822207faf","fromSide":"top","toNode":"165209213bc6a130","toSide":"bottom"},
		{"id":"61b78f68c63f4e8a","fromNode":"23227e82062b49bc","fromSide":"left","toNode":"b72f299bae389d13","toSide":"right"},
		{"id":"6f94fecf4639c0f4","fromNode":"4958894e7197fe3c","fromSide":"bottom","toNode":"1ec4d0918042c205","toSide":"right"},
		{"id":"18732b858dd6d8e8","fromNode":"b72f299bae389d13","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"top"},
		{"id":"236fb80dc10bcb1c","fromNode":"795690d5ce7e1c11","fromSide":"top","toNode":"b72f299bae389d13","toSide":"bottom"},
		{"id":"08f8c4d75162bc70","fromNode":"1ec4d0918042c205","fromSide":"left","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"2ad6aae7b242e920","fromNode":"795690d5ce7e1c11","fromSide":"left","toNode":"c842e00522cec07d","toSide":"right"},
		{"id":"6231bef59e40ecfa","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"5cf8d16de6efff56","toSide":"top"},
		{"id":"7ddcd8cf952994b6","fromNode":"9ed19d6e9980b34b","fromSide":"left","toNode":"0276409902e40e9c","toSide":"right"},
		{"id":"b9f2cee56ecc6884","fromNode":"165209213bc6a130","fromSide":"top","toNode":"ed6dd0d5b788bd3e","toSide":"bottom"},
		{"id":"fceeaf4ae4ae9491","fromNode":"23227e82062b49bc","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"818a74c3caa1b0b6","fromNode":"5cf8d16de6efff56","fromSide":"bottom","toNode":"1bd86960d6e5a8e2","toSide":"top"},
		{"id":"c16c39c9b26ca69c","fromNode":"1ec4d0918042c205","fromSide":"right","toNode":"44898ee22f42afdc","toSide":"left"},
		{"id":"91f484736f73f3df","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"56958c816f8128f6","toSide":"bottom"},
		{"id":"49bc3d9146b806bb","fromNode":"665f35bd71acbb90","fromSide":"top","toNode":"44898ee22f42afdc","toSide":"bottom"},
		{"id":"4d323ae12dc8b711","fromNode":"44898ee22f42afdc","fromSide":"right","toNode":"c45a83a3705f7881","toSide":"left"},
		{"id":"7534cf6c10d8c863","fromNode":"5cf8d16de6efff56","fromSide":"right","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"fe0cb992b8bb8e89","fromNode":"0c876453e3807959","fromSide":"right","toNode":"665f35bd71acbb90","toSide":"left"},
		{"id":"9ab56fb991918b05","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"892fdf290715d14d","fromNode":"795690d5ce7e1c11","fromSide":"bottom","toNode":"9ed19d6e9980b34b","toSide":"top"},
		{"id":"ebcab486927cb5de","fromNode":"9ed19d6e9980b34b","fromSide":"right","toNode":"5cf8d16de6efff56","toSide":"left"},
		{"id":"6a0ae24e30667e00","fromNode":"665f35bd71acbb90","fromSide":"right","toNode":"981b264b7f7630c2","toSide":"left"},
		{"id":"7286f70c7c7e9e6f","fromNode":"981b264b7f7630c2","fromSide":"top","toNode":"c45a83a3705f7881","toSide":"bottom"},
		{"id":"9e27c5c48748361f","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"45a11294a8434cf8","toSide":"bottom"},
		{"id":"8af8a5f3e2ad1274","fromNode":"a569f47822207faf","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"4bc5fcb03b652768","fromNode":"4f9f693b64bc0e3f","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"a0745a8a10aa21ec","fromNode":"c45a83a3705f7881","fromSide":"bottom","toNode":"981b264b7f7630c2","toSide":"top"},
		{"id":"1c2152fd9676e1e4","fromNode":"c45a83a3705f7881","fromSide":"top","toNode":"305c16fa5fcbfca6","toSide":"bottom"},
		{"id":"7d0ac71b97316b5b","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"0e49609704fa8c9e","toSide":"bottom"},
		{"id":"feab48c838e8a738","fromNode":"0e49609704fa8c9e","fromSide":"top","toNode":"d7a25775f996e167","toSide":"bottom"},
		{"id":"4def83e52862fb08","fromNode":"665f35bd71acbb90","fromSide":"bottom","toNode":"1b501ca1023c98e0","toSide":"top"},
		{"id":"7b97b8d400a17d62","fromNode":"56958c816f8128f6","fromSide":"top","toNode":"d7a25775f996e167","toSide":"bottom"},
		{"id":"ee61d1fcc7c2de03","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"f6c22dc935238119","toSide":"right"},
		{"id":"5edcd65f331c9876","fromNode":"1a0fe951bbf51b93","fromSide":"left","toNode":"472a39255272296f","toSide":"right"},
		{"id":"f14f75bb6f530e76","fromNode":"1bd86960d6e5a8e2","fromSide":"left","toNode":"4df27d69ac9764ca","toSide":"right"},
		{"id":"47a253347dc37b5d","fromNode":"1bd86960d6e5a8e2","fromSide":"bottom","toNode":"3881465ee755981e","toSide":"top"},
		{"id":"5d939219c7bb9a7a","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"34401d45639b449d","toSide":"top"},
		{"id":"7db3cb5e783eb5a1","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"179ce6b66f1a29fe","toSide":"right"},
		{"id":"51f9edd90972a19b","fromNode":"0c876453e3807959","fromSide":"bottom","toNode":"010165be9fd56b6c","toSide":"top","fromEnd":"arrow"},
		{"id":"f0bd2107ddee8ba5","fromNode":"3881465ee755981e","fromSide":"right","toNode":"010165be9fd56b6c","toSide":"left"},
		{"id":"121d6e0e6a0bbfac","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"9f731eac72823c6c","toSide":"left"},
		{"id":"cd673b03983e203e","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"8ca68ef0d9cba75a","toSide":"right"},
		{"id":"7dd2c2ef84da8b02","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"0719791a80c12eb2","toSide":"bottom"},
		{"id":"43fcfa35c628c802","fromNode":"0719791a80c12eb2","fromSide":"left","toNode":"d0bc31a12d2847f8","toSide":"right"},
		{"id":"208d0a9d82fd8425","fromNode":"56958c816f8128f6","fromSide":"top","toNode":"5b4bbd10c0ed915d","toSide":"bottom"},
		{"id":"75c0f24600072246","fromNode":"0c876453e3807959","fromSide":"bottom","toNode":"a69d18b26b90862d","toSide":"left"},
		{"id":"99483e5740adc372","fromNode":"010165be9fd56b6c","fromSide":"right","toNode":"a69d18b26b90862d","toSide":"left"},
		{"id":"f81719e0c305400a","fromNode":"3881465ee755981e","fromSide":"right","toNode":"1a7e522c18045e6d","toSide":"left"},
		{"id":"048457974880d02b","fromNode":"179ce6b66f1a29fe","fromSide":"top","toNode":"ea111d8cb579b650","toSide":"bottom"},
		{"id":"05e16811ee30844a","fromNode":"ea111d8cb579b650","fromSide":"left","toNode":"aa2f1768f7663ebf","toSide":"right"},
		{"id":"0c54c96873a77df7","fromNode":"349ec5026bac8b92","fromSide":"left","toNode":"aa76e477e11e779d","toSide":"right"},
		{"id":"11acfd30484dbb77","fromNode":"349ec5026bac8b92","fromSide":"left","toNode":"2c357555847a692e","toSide":"right"},
		{"id":"f9eba0dde4fdd092","fromNode":"2c357555847a692e","fromSide":"left","toNode":"d9218fbe64e55603","toSide":"right"},
		{"id":"9f6ec62dce95beb2","fromNode":"2c357555847a692e","fromSide":"left","toNode":"bd9ffece9b4d9aa9","toSide":"right"},
		{"id":"86da5dab44bb03d1","fromNode":"bd9ffece9b4d9aa9","fromSide":"top","toNode":"f10a4ae200557701","toSide":"bottom"},
		{"id":"baa76cbdfd073400","fromNode":"bd9ffece9b4d9aa9","fromSide":"top","toNode":"8142f6eec6ad761b","toSide":"bottom"},
		{"id":"4daffd111e15d4f6","fromNode":"6f3226cdbb9850aa","fromSide":"right","toNode":"594865c9c2779a13","toSide":"left"},
		{"id":"d9c7152060968cba","fromNode":"6f3226cdbb9850aa","fromSide":"bottom","toNode":"2df2877d35b32cbf","toSide":"top"},
		{"id":"1255d2940ba86579","fromNode":"2df2877d35b32cbf","fromSide":"right","toNode":"621da05b43f27ecc","toSide":"left"},
		{"id":"51abe8e67cba8602","fromNode":"2df2877d35b32cbf","fromSide":"bottom","toNode":"f55770ab8bdeed44","toSide":"top"},
		{"id":"3d96f5c9da8b6ae3","fromNode":"2df2877d35b32cbf","fromSide":"bottom","toNode":"9b35587f0d6f95ff","toSide":"top"},
		{"id":"eee1f6d590c90e96","fromNode":"f55770ab8bdeed44","fromSide":"right","toNode":"9b35587f0d6f95ff","toSide":"left"},
		{"id":"7f22da68abb7dd48","fromNode":"34401d45639b449d","fromSide":"bottom","toNode":"6f3226cdbb9850aa","toSide":"top"},
		{"id":"fa4fd6ac27fede83","fromNode":"179ce6b66f1a29fe","fromSide":"bottom","toNode":"349ec5026bac8b92","toSide":"top"},
		{"id":"0d76261b6f052984","fromNode":"dff88af00a536f81","fromSide":"bottom","toNode":"b81367aa9de6afb4","toSide":"top"},
		{"id":"c229738031cda2ac","fromNode":"349ec5026bac8b92","fromSide":"top","toNode":"dff88af00a536f81","toSide":"left"},
		{"id":"94b6a91f71272017","fromNode":"dff88af00a536f81","fromSide":"right","toNode":"6f3226cdbb9850aa","toSide":"top"},
		{"id":"731f0ec0ddf99b38","fromNode":"ea111d8cb579b650","fromSide":"left","toNode":"52edf2e6ee84f9b0","toSide":"right"},
		{"id":"0f9ffd73c123311c","fromNode":"349ec5026bac8b92","fromSide":"bottom","toNode":"40ee9c3447f7fb82","toSide":"top"},
		{"id":"d980c1a93aafee90","fromNode":"4df27d69ac9764ca","fromSide":"top","toNode":"1a0fe951bbf51b93","toSide":"bottom"},
		{"id":"99ef61b1863659dc","fromNode":"1bd86960d6e5a8e2","fromSide":"bottom","toNode":"35235b872aeaab53","toSide":"top"},
		{"id":"5d8bfaab9287c038","fromNode":"35235b872aeaab53","fromSide":"right","toNode":"3881465ee755981e","toSide":"left"},
		{"id":"7766ada0b75b23b1","fromNode":"3881465ee755981e","fromSide":"left","toNode":"35235b872aeaab53","toSide":"right"},
		{"id":"deb4c83508b2b819","fromNode":"6f3226cdbb9850aa","fromSide":"bottom","toNode":"ba32fe7205e2606f","toSide":"right"},
		{"id":"1c637326d1971b53","fromNode":"b81367aa9de6afb4","fromSide":"bottom","toNode":"ba32fe7205e2606f","toSide":"top"},
		{"id":"f6d19c63cf644675","fromNode":"40ee9c3447f7fb82","fromSide":"bottom","toNode":"0efd970a1119442f","toSide":"top"},
		{"id":"3c0abd32c7fec049","fromNode":"2edbb402780f44c6","fromSide":"bottom","toNode":"89560ca8221b899c","toSide":"top"},
		{"id":"ea054aef41b0cca0","fromNode":"2edbb402780f44c6","fromSide":"bottom","toNode":"a30868312d411d98","toSide":"top"},
		{"id":"7ce23dadaa651095","fromNode":"89560ca8221b899c","fromSide":"left","toNode":"6ce8f85f78362603","toSide":"right"},
		{"id":"dbf52d276f427907","fromNode":"973215b7fd31a26a","fromSide":"bottom","toNode":"ee9aa768d32eb89f","toSide":"top"},
		{"id":"6b464d08ca48f405","fromNode":"a30868312d411d98","fromSide":"right","toNode":"55d3231875e83cc8","toSide":"left"},
		{"id":"bd3886a5bc77d5a0","fromNode":"89560ca8221b899c","fromSide":"bottom","toNode":"ff01e5961e252647","toSide":"top"},
		{"id":"8d5e2dc5232a299d","fromNode":"a30868312d411d98","fromSide":"bottom","toNode":"ff01e5961e252647","toSide":"top"},
		{"id":"3b7a2fa2471a6608","fromNode":"ff01e5961e252647","fromSide":"bottom","toNode":"16f174d47e0dd2b5","toSide":"top"},
		{"id":"4631afa28cad3105","fromNode":"ff01e5961e252647","fromSide":"bottom","toNode":"44ce1eef2a1a2afa","toSide":"top"},
		{"id":"684296b62490a2a4","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"973215b7fd31a26a","toSide":"top"},
		{"id":"81a09b69b0c5bbbf","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"ada1ce65a17b1ff7","toSide":"top"},
		{"id":"8348e2cf9fcc3177","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"be024ab3c20ae124","toSide":"left"},
		{"id":"63f198033e784c5d","fromNode":"40ee9c3447f7fb82","fromSide":"left","toNode":"2edbb402780f44c6","toSide":"top"},
		{"id":"19be112fc67481ac","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"a13ba86d0881bc3c","toSide":"top"},
		{"id":"33d1b4973515d576","fromNode":"877a13b60a49c414","fromSide":"left","toNode":"ee8fed6684bf344f","toSide":"right"},
		{"id":"4b28497f24dc6ee7","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"ee8fed6684bf344f","toSide":"right"},
		{"id":"d1500d777e5a6d46","fromNode":"acb4f16f12e3f2e9","fromSide":"bottom","toNode":"6694e27578406638","toSide":"top"},
		{"id":"70d68af1971fd88f","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"acb4f16f12e3f2e9","toSide":"top"},
		{"id":"8f627262a584f38a","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"b42a1d8cb55878e0","toSide":"bottom"},
		{"id":"8fbed3ff33aca630","fromNode":"c25570b5d51372e2","fromSide":"bottom","toNode":"77ddaf1188c7b900","toSide":"top"},
		{"id":"d3994aec3181fafe","fromNode":"77ddaf1188c7b900","fromSide":"bottom","toNode":"04b979f48c716c0b","toSide":"top"},
		{"id":"502b754c3aa17464","fromNode":"a13ba86d0881bc3c","fromSide":"top","toNode":"c25570b5d51372e2","toSide":"top"},
		{"id":"09c530a209bb815e","fromNode":"40ee9c3447f7fb82","fromSide":"left","toNode":"19dd5229975701ca","toSide":"right"},
		{"id":"95a357d298fdd7b9","fromNode":"6694e27578406638","fromSide":"bottom","toNode":"f99413b00ff804a3","toSide":"top"},
		{"id":"1684ada3383a3b04","fromNode":"f99413b00ff804a3","fromSide":"bottom","toNode":"431962e65465019d","toSide":"top"},
		{"id":"757b6e2877809f77","fromNode":"f99413b00ff804a3","fromSide":"bottom","toNode":"dab2f7463a1544fc","toSide":"top"},
		{"id":"0a9dc2c060770823","fromNode":"431962e65465019d","fromSide":"left","toNode":"beb0fa9d0cb9609a","toSide":"right"},
		{"id":"9e73506530a57cb1","fromNode":"dab2f7463a1544fc","fromSide":"right","toNode":"431962e65465019d","toSide":"left"},
		{"id":"4f90efa6599cf187","fromNode":"431962e65465019d","fromSide":"left","toNode":"dab2f7463a1544fc","toSide":"right"}
	]
}