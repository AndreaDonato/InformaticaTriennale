{
	"nodes":[
		{"id":"b72f299bae389d13","type":"text","text":"# Nodi\n\nSe le Reti sono grafi, cosa sono i nodi? Abbiamo due macro-categorie:\n\n- **_Nodi estremali_** (o **_sistemi terminali_**) - situati alle **periferie** della rete, sono le \"foglie\". C'è una distinzione interna tra\n\t- **_Host_** - tipicamente è il nome che si dà al dispositivo (dell') utente che vuole usare un servizio;\n\t- **_Server_** - tipicamente è il nome che si dà al dispositivo (spesso a elevate prestazioni) che offre servizi agli host.\n- **_Nodi di interconnessione_** - sostanzialmente dei ripetitori, che all'occorrenza possono modificare il segnale che vi transita (e.g. amplificazione, incremento di un counter per tenere traccia del passaggio). Una trasmissione senza modifiche è detta **trasparente**. Ulteriormente divisi in\n\t- **_Router_** - collegano tra loro più reti;\n\t- **_Switch_** - collegano tra loro più nodi estremali all'interno di una rete.\n","x":-4940,"y":638,"width":700,"height":448,"color":"4"},
		{"id":"06174ae2aacf2d26","type":"text","text":"# Tipi di Reti\n\nLe Reti si classificano in base a quanto sono grosse. Già.\n\n- **Personal Area Network** (**PAN**) - tipicamente pochi metri (e.g. Bluetooth);\n- **_Local Area Network_** (**_LAN_**) - tipicamente entro un appartamento (e.g. Wi-Fi, Ethernet). Ogni nodo estremale possiede un indirizzo (**MAC**) che lo identifica univocamente all’interno della LAN. Si può implementare come\n\t- **cavo condiviso** - tutti i dispositivi sono connessi al router tramite un cavo comune. Questa roba non si fa più, anche perché si creano interferenze e non esiste la privacy (chiunque poteva attaccarsi al cavo e leggere il traffico dati di tutti, \"oggi a meno che tu non sia l'NSA non lo fai\");\n\t- **switch** - da un lato ha i vari dispositivi in parallelo, dall'altra il router. Permette la trasmissione simultanea di più host.\n- **Metropolitan Area Network** (**MAN**) - tipicamente copre una città;\n- **_Wide Area Network_** (**_WAN_**) - tipicamente copre un paese o una nazione ed è gestita da un **_Internet Service Provider_** (**_ISP_**). Abbiamo anche qui due casi:\n\t- **point-to-point** - ho due reti collegate tramite un singolo mezzo di trasmissione. Questo è il modo più semplice di realizzare una **internet** (con la i minuscola, che qui ci tengono, abbreviativo per **internetwork**), ovvero una rete di reti;\n\t- **commutazione** - ho più reti collegate tramite più mezzi di trasmissione, il che probabilmente includerà anche più nodi di interconnessione.\n- **_Internet_** - la rete di tutte le reti, il Tutto, il MoaN (Mother of All Networks), una specie di divinità, un concetto filosofico, ...","x":-4128,"y":-220,"width":668,"height":740,"color":"4"},
		{"id":"4f9f693b64bc0e3f","type":"text","text":"# Glossario delle Reti\n\n- **_edge router_** - i router più periferici dell'Internet;\n- **_headend_** - termine generico che si riferisce a un nodo cruciale di una rete di telecomunicazioni, in cui convergono e vengono aggregati più segnali. Un edge router è un headend, ma se ad esempio vi sono molti cavi coassiali che vorrebbero entrarvi si può usare un cable headend, ovvero un dispositivo fisico che raggruppa le varie sorgenti per trasmetterle all'edge router;\n- **_access point_** - pezzetto di HW che funge da interfaccia tra il segnale Wi-Fi e il router;\n- **_Internet Service Provider_** (**_ISP_**) - riferito ad un'organizzazione di qualsiasi tipo (privata, no-profit, ...) che fornisce il servizio per l'accesso a Internet. Sono gestite da ISP\n\t- le **reti di accesso** ad Internet;\n\t- alcune infrastrutture che collegano più reti di accesso locali (**ISP regionale**)\n\t- le componenti del **nucleo di rete** a cui si connettono le reti di accesso e gli ISP regionali (**ISP globali**, o di **livello 1**)","x":-5752,"y":-220,"width":716,"height":740,"color":"4"},
		{"id":"795690d5ce7e1c11","type":"text","text":"# Link\n\nI collegamenti fisici tra nodi possono essere realizzati in diversi modi.\n\n- **_Supporti guidati_** - I segnali si propagano in mezzi solidi (cavi). Esempi sono\n\t- **Doppino intrecciato** - due fili di rame isolati, uno per inviare i dati ed uno per riceverli (e.g. Ethernet, fino a 10 Gbps). Suscettibile a interferenze EM;\n\t- **Cavo coassiale** - due fili di rame concentrici, entrambi bidirezionali. Supporta i canali (**FDM**, $\\sim 100$ Mbps ciascuno), molto resistente alle  interferenze ma ad oggi soppiantato dalla fibra ottica;\n\t- **Fibra ottica** - fibra di vetro che sfrutta la riflessione totale interna della luce. Ogni fotone trasporta un singolo bit. Velocissimo ($v \\sim c$), basso rate di errore, ovviamente immune all'interferenza EM, costituisce la quasi totalità dei collegamenti nelle dorsali di Internet;\n- **_Propagazione libera_** - Spazia dal **Wi-Fi** domestico al **segnale satellitare**, e sfrutta lo spettro elettromagnetico con tutti gli ostacoli che ne conseguono (riflessione, attenuazione, interferenza). La potenza del segnale sferico decade come $1/r^2 \\Rightarrow$ molto forte nelle immediate vicinanze, molto debole poco dopo. Questo rende i link a propagazione libera dei canali **_half-duplex_** $\\Rightarrow$ chi riceve non può trasmettere a sua volta, perché con il forte segnale in uscita coprirebbe il segnale debole in entrata.","x":-4940,"y":1143,"width":700,"height":565,"color":"4"},
		{"id":"0c876453e3807959","type":"text","text":"# Pose e Coreografia\n\nHo un pacchetto con una destinazione. Devo avere chiare due cose:\n\n- Il percorso che seguirà nell'Internet attraverso i vari router, detto **_instradamento_** o **_routing_**. Definito da speciali **_algoritmi di instradamento_**, è un concetto **_globale_** (che riguarda cioè la rete nella sua interezza);\n- Il modo in cui il singolo router smista i pacchetti nel link corretto, ovvero la funzione interna che lega il segnale in ingresso a quello in uscita: internamente, ogni router ha una **_local forwarding table_** contenente le varie associazioni con i nodi adiacenti. Per scrivere le tabelle mi servono i percorsi. Viene detto **_commutazione_** (o **_forwarding_**, o **_switching_**).\n\nIn pratica, se il *forwarding* è la regola locale che definisce come si \"posiziona\" il singolo router, il *routing* è la \"coreografia\" globale risultante.","x":-3273,"y":1570,"width":700,"height":410,"color":"4"},
		{"id":"4958894e7197fe3c","type":"text","text":"# Rete\n\nInfrastruttura \"a grafo\" composta da dispositivi (_**nodi**_) che possono scambiarsi informazioni tramite dei collegamenti (**_link_**)","x":-3084,"y":1045,"width":323,"height":196,"color":"6"},
		{"id":"a569f47822207faf","type":"text","text":"# Struttura di Internet\n\nL'Internet può essere suddiviso con un criterio di \"profondità\".\n\n- **Periferia della rete** (**network edge**) - host e server;\n- **_Reti di accesso_** (**_access network_**) - tutto ciò che è connesso al router più periferico (**edge router**, ovvero il primo router che incontra il segnale partito da un host o da un server), a sua volta connesso con l'Internet. La connessione all'edge router può presentarsi in diversi gusti.\n\t- **Cavo** - Puro e semplice, non ci sono intermediari. Si collega insieme agli altri cavi della zona a un **cable headend**;\n\t- **Digital Subscriber Line** (**DSL**) - Sfrutta le linee telefoniche come cavi. Usa un **DSLAM** (**DSL Access Multiplexer**), uno specifico **headend** che smista il traffico internet e telefonico;\n\t- **Wireless LAN** (**WLAN**) - Mediato da un **access point** fisico che si interfaccia con il router domestico;\n\t- Rete cellulare;\n- **_Nucleo di Rete_** (**_dorsale_**, **_core_**, **_backbone_**) - questi termini vengono spesso usati in modo intercambiabile in quanto reti ad alta velocità che rappresentano la \"spina dorsale\" di Internet. In pratica, il nucleo di rete si occupa di collegare tra loro le reti di accesso (gestite da **ISP locali**). **NON** ciascuna di esse con tutte le altre (sono milioni e sarebbe $O(n^2)$), ma attraverso delle reti di più alto livello. ","x":-4940,"y":-220,"width":700,"height":740,"color":"4"},
		{"id":"c842e00522cec07d","type":"text","text":"## Velocità e latenze\n\n- DSL\n\t- Downstream: $24\\div52$ Mbps\n\t- Upstream: $3\\div16$ Mbps\n\t- Latenza: ?????\n- Ethernet\n\t- 100 Mbps, 1 Gbps, 10 Gbps\n- HFC\n\t- Downstream: $40\\div1200$ Mbps\n\t- Upstream: $30\\div100$ Mbps\n\t- Latenza: ???\n- Fibra\n- Microonde\n- Wi-Fi\n\t- Trasmissione: 11-54-450 Mbps\n\t- Latenza: ????\n- 4G\n- Satellite\n\t- Trasmissione: fino a $45$ Mbps\n\t-  latenza (end-end): $\\sim 270 ms$.","x":-5752,"y":1143,"width":716,"height":565,"color":"2"},
		{"id":"0276409902e40e9c","type":"text","text":"## Tradurre \"bursty\" in matematica\n\nCi sono $n$ utenti, ognuno dei quali ha una (bassa) probabilità $p$ di essere attivo in un dato istante. Quanti utenti sono attivi contemporaneamente?\nOvviamente problema binomiale.\n\n$$\nP(x) = \\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$\nda cui segue la cumulativa (qui nel caso $x > k$)\n\n$$\nP(x > k) = \\sum^n_{i = k}\\binom{n}{i}\\,p^i\\,(1-p^{n-i})\n$$","x":-5736,"y":1930,"width":700,"height":440,"color":"4"},
		{"id":"a3eaa4b44f0f3c44","type":"text","text":"# Giungla pseudo-gerarchica ISP\n\nQuello di ISP è quasi un concetto filosofico. Io che ti metto l'hotspot sono tanto ISP quanto lo è Fastweb. Circa. In realtà c'è una specie di gerarchia.\n\n- Io che metto l'hotspot sono considerabile un edge router che funge da ISP locale (livello 3);\n- Il mio telefono però ha a sua volta un ISP, stavolta regionale (livello 2, e.g. *Fastweb*). Questo ISP ha accordi alla pari (**_peer-to-peer_**) per comunicare con altri ISP regionali senza passare dal nucleo di Internet. Tuttavia può essere necessario raggiungere nodi che necessitano un passaggio per le dorsali, motivo per cui i *livello 2* **_pagano il transito_** ai *livello 1*;\n- In cima alla catena alimentare troviamo gli **_ISP globali_** (livello 1, e.g. *AT&T*), connessi tra loro tramite degli **_Internet Exchange Point_** (**_IXP_**);\n- Ultimamente vi sono entità (e.g. Google, Netflix) che non hanno tutta questa voglia di pagare gli ISP più grossi, motivo per cui costruiscono delle proprie _**reti dei content provider**_ a livello degli ISP globali riuscendo a bypassarli e ad offrire un servizio più efficiente ai consumatori.","x":-5752,"y":-880,"width":716,"height":497,"color":"4"},
		{"id":"44898ee22f42afdc","type":"text","text":"# Prestazioni","x":-1800,"y":1400,"width":240,"height":50,"color":"6"},
		{"id":"665f35bd71acbb90","type":"text","text":"# Forwarding","x":-1800,"y":1750,"width":240,"height":50,"color":"6"},
		{"id":"981b264b7f7630c2","type":"text","text":"# Store&Forward\n\nUn pacchetto deve raggiungere completamente il nodo destinazione prima che questo possa iniziare il processo di *forwarding* (**_store&forward_**).\n\nLa trasmissione però richiede tempo, quindi è possibile che arrivino più pacchetti di quanti il router ne riesce effettivamente a smistare.\nQuesto implica che deve avere un *buffer* in cui mettere in coda i pacchetti in attesa. Nel migliore dei casi questo mi genera un **_queuing delay_**, e nel peggiore, ovvero se il buffer si riempie, può verificarsi la **_perdita dei pacchetti_**.\n\nD'altronde, quando mando un pacchetto su Internet devo essere consapevole che nessuno mi potrà mai garantire il suo effettivo arrivo a destinazione.\n\nNotare che il primo bit di un pacchetto può arrivare a destinazione prima che questo sia stato completamente trasmesso dal router di partenza sul link!","x":-1280,"y":1570,"width":680,"height":410,"color":"4"},
		{"id":"c45a83a3705f7881","type":"text","text":"# Latenza\n\nIl tempo totale necessario ad un pacchetto per essere inviato completamente da un nodo origine ad un nodo destinatario è detto **_latenza_** o _**delay**_.\n\nSi può scrivere come somma di 4 contributi:\n\n- Delay di Queuing ($D_q$) - dato dal tempo di attesa in coda dovuto al meccanismo di **store&forward**, qui il pacchetto aspetta di essere processato. Difficile da stimare, divergente se il pacchetto si perde;\n- Delay di Elaborazione ($D_e$) - dato dalle operazioni interne effettuate dal nodo sul pacchetto (controllo errori, determinazione del link di uscita, ...), in genere trascurabile rispetto agli altri ($D_e \\lesssim\\mu s$);\n- Delay di Trasmissione ($D_t$) - il router deve caricare tutto il pacchetto di lunghezza $L$ sul link avente bit rate $R$ $\\Rightarrow$ ci mette un tempo $D_t = L/R$. Tipicamente è il termine dominante, nonché l'unico che dipende dalla lunghezza del pacchetto. Trasmettere un $L$ enorme su un $R$ basso fa da bottleneck per l'intero sistema;\n- Delay di Propagazione ($D_p$) - quanto ci mette il pacchetto a transitare sul link, e dipende esclusivamente dalle caratteristiche di quest'ultimo. Se è lungo $k$ e i bit si propagano a velocità $v$ serve un tempo $D_p = k/v$. In genere è indicato come tempo di propagazione dell'ultimo bit del pacchetto (non cambia nulla, è solo per ricordarsi che esiste la politica di *store&forward*).\n\nIn sintesi quelli fondamentali sono [trasmissione e propagazione](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/transmission-vs-propogation-delay/transmission-propagation-delay-ch1/index.html), e ogni router da cui passa il segnale (anche detto **_hop_**) introduce un termine dominante $L/R$.","x":-1280,"y":780,"width":680,"height":674,"color":"4"},
		{"id":"45a11294a8434cf8","type":"text","text":"# Glossario delle Prestazioni\n\n- **_trasmissione_** - il caricamento del pacchetto sul link da parte del router (\"modulare il segnale nel cavo\"). **_NON_** include la propagazione sul link.\n\t- Ogni link è caratterizzato da una **massima velocità di trasmissione** $R$ (*Rate*, misurato in bit/s), anche detta **_bit rate_** o **transmission rate**;\n- **_larghezza di banda_** (**_bandwidth_**) - si può usare per intendere\n\t- la larghezza dell'intervallo di frequenze utilizzate dal sistema trasmissivo ($Hz$);\n\t- il **bit rate** (bit/s), ad essa proporzionale.\n- **_throughput_** ($T$)- quantità di bit al secondo che passano a regime attraverso un generico punto della rete. Notare che è una misura di velocità effettiva, e che il suo massimo è il **bit rate** $\\Rightarrow$ è una misura effettiva di bit rate, e si effettua con un **_ping_**, ovvero un bit-sonda che mando avanti e indietro dal server che mi interessa;\n- **_bottleneck_** - quel collegamento che limita il throughput dell'intero percorso end-to-end;","x":-1940,"y":495,"width":520,"height":617,"color":"4"},
		{"id":"305c16fa5fcbfca6","type":"text","text":"# Teoria delle Code\n\nPer il Delay di Queuing c'è tutta una teoria (delle code) che calcola il ritardo medio in coda in funzione dell'intensità del traffico $La/R$ , dove $a$ è il rate di arrivo di pacchetti in coda.\n\nIn questo modo si trova che questo ritardo diverge già per un traffico $La/R = 1$ $\\Rightarrow$ il router non sopporta un rate di arrivo dei pacchetti identico al rate di smistamento ([vedere per credere!](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/queuing-loss-applet/index.html)).\n\nQuesto succede perché $a$ è un rate medio, e \"quando sono fortunato e me ne arrivano meno mentre la queue è vuota non posso anticiparmi il lavoro\".\n\nCredo in realtà succeda anche perché non sto considerando il micro-ritardo di processamento interno, che seppur trascurabile sul singolo pacchetto magari sulla coda fa effetto.","x":-1280,"y":285,"width":680,"height":420,"color":"3"},
		{"id":"0e49609704fa8c9e","type":"text","text":"# Gestire le Congestioni\n\nCosa succede se a un certo punto del percorso tra i router un pacchetto entra in un loop? Resta intrappolato all'infinito, sprecando banda? Sconveniente. Devo metterci un *cut-off* $\\Rightarrow$ introduco un **_Time To Live_** (**_TTL_**), in pratica un numero che viene decrementato a ogni router che incontra (e che quindi rappresenta quanti altri router possono inoltrarlo).\n\nQuando il TTL diventa 0 il pacchetto muore. In questi casi sarebbe buona educazione da parte del router mandare un feedback a chi glielo ha inviato (\"*hey, ti ricordi quel bellissimo pacchetto che mi avevi mandato? sì, ecco, è morto*\").\n\nConoscere il motivo della perdita di un pacchetto è fondamentale. Se ad esempio viene perso per traffico (e quindi per via di una coda piena) dovrei rallentare la trasmissione per evitare di perderne altri.\n\nIl protocollo TCP/IP, ad esempio, è in grado di capire se una perdita è causata dal traffico o da altri fattori.","x":-2540,"y":560,"width":540,"height":552,"color":"4"},
		{"id":"56958c816f8128f6","type":"text","text":"# Sicurezza","x":-3042,"y":590,"width":240,"height":50,"color":"#4545ff"},
		{"id":"d7a25775f996e167","type":"text","text":"# Leak della struttura di rete (Latenza + TTL)\n\nScelgo una destinazione e mando pacchetti con un TTL sempre maggiore. Grazie al progressivo delay sono in grado di stimare il percorso end-to-end. \n\n... o quasi. Nessuno mi garantisce che ogni pacchetto seguirà sempre lo stesso percorso. Esistono però programmi diagnostici (e.g. **_traceroute_** su UNIX, o **_tracert_** su Windows) che restituiscono suddetti delay.\n\nNon c'è da stupirsi se a volte i router scelgono di non mandare feedback alla morte di un pacchetto per esaurimento del TTL.\nSe accetto il meccanismo dei TTL potrei far leakare la struttura interna della rete. ","x":-2540,"y":-20,"width":540,"height":440,"color":"#4545ff"},
		{"id":"45b932caa35cd5e2","type":"text","text":"# Rete (guarda slides) tipo intro ai termini\n\nrete = nodi (computer) collegati da collegamenti (link). Distinguo i nodi estremali (host (vuole usare il servizio) o server (lo fornisce), non è una distinzione rigida) e quelli di interconnessione (router collega due reti o switch collegano terminali in locale). Dispositivi che possono scambiarsi info. Durante i passaggi di info queste spesso si modificano (fisico, quindi amplificazione, o tenere traccia del passaggio. esistono anche trasmissioni trasparenti).\n\nperiferia della rete -> host e server\nrete di accesso: utenti (problemi: max utenti per antenna)\nnucleo di rete: router interconnessi che fanno interagire sottoreti indirizzando il traffico\n\n(guarda slides)\n\nreti via cavo: tutto collegato allo stesso cavo condiviso. ogni casa ha splitter e modem.\n\nasimmetria: ci si aspetta che l'host scarichi più di quanto carica\n\na casa modem, router e access point sono integrati nello stesso coso.\n\n\"half duplex\" -> mentre trasmetto non posso ricevere. Questo perché la potenza del segnale scende come 1/r^2, e chi riceve vede un segnale debole -> non può trasmettere a sua volta, perché copro il segnale debole. Questo per il wifi e simili, su cavo faccio come voglio.\n\nsplitting di frequenze (anche su stesso cavo) ha costo (multiplexing?), nell'esempio del cavo sopra (credo) sia tutto su stessa frequenza.\n\n\n","x":-2270,"y":-1900,"width":640,"height":860,"color":"1"},
		{"id":"38f42aa977e02595","type":"text","text":"# (\"... comunque lo vedremo meglio\")\n\nnon ci sono computer, solo router che fanno commutazione di pacchetto (= forwarding = switching: qualcosa entra da una porta, lo faccio uscire da un'altra, ognuno ha una tabella di corrispondenze, è na roba LOCALE). NON sa che percorso farà. Ma chi le scrive le tabelle? Serve sapere i percorsi -> serve Algoritmo di Instradamento. Il ROUTING è un'azione GLOBALE.\n\nforwarding: come mi devo mettere; routing: coreografia\n\nstore and forward: prima ricevo tutto, poi mando. na specie de buffering. Pushare il pacchetto nel cavo = trasmettere, ergo se devo mettere L bit di pacchetto a velocità R bit/s ci metto L/R secondi ed è detto ritardo di trasmissione (trasmissione è solo l'uploat del pacchetto nel collegamento (cavo), poi c'è delay di trasporto ma spesso è trascurabile). \"modulare il segnale nel cavo\". ogni router che trasmette (HOP) porta un ritardo +L/R. Se poi mi interessa il delay del segnale totale trasportato da N pacchetti moltiplico per N. Poi c'è ritardo di accodamento (vedi slides).\n\nTEORIA DELLE CODE???\n\nA - algoritmo per ottimizzare commutaizone di circuito?\n\nSe multiplexo sulle frequenze (costo alto) mitigo il problema delle code. Posso farlo anche sul tempo (costo minore, eg bluetooth), ma sono a rischio latenza. Qual è meglio? Dipende da che ci devo fare. Comm di circuito però non si usa su Internet. cellulari usano entrambi. pacchetto consente a più utenti di usare la rete. Internet è _bursty_, impulsiva, dati inframezzati da lunghi silenzi. Mi baso sul fatto che molti stanno zitti per permettere a più persone di parlare (e.g. se ho 35 utenti P(attivi>20) $\\sim$ poco, conto con binomiale). se uso comm circuito dedico una linea fissa e non sfrutto le \"caratteristiche\" degli utenti (che stanno spesso zitti).\n\nSe mando un pacchetto su Internet non ho garanzie che arrivi a destinazione. Tutti i tentativi per dare garanzie (ovvero strutturare diversamente i protocolli) hanno fallito miseramente. Comm di circuito garantisce, ma se non comunico spreco risorse. \"Internet è accettare che tutti provano e provare a risolvere quando si creano problemi\".\n\nISP punto debole di interet, in mano ai grandi fornitori. interconnessi, guidati dagli interessi aziendali più che geografici. Abbiamo milioni di ISP di accesso. Li collego tutti tra loro? No, è $O(n^2)$. Inizialmente: ISP di transito globale a fare da centralino (pagato da ISP locali). Ora ci sono tanti ISP globali collegati da IXP (internet exchange point, collegamento di peering). La rete degli IXP ha una rete dei content provider.\n\nSegue discorso sulla legislazione perché sta roba dà un sacco di potere\n\n","x":-1580,"y":-1981,"width":640,"height":1120,"color":"1"},
		{"id":"435d7ec357e56abd","type":"text","text":"# prestazioni slides 3\n\nthroughput è una misura a regime (un po' una misura del bitrate effettivo, ed è sistematicamente minore o uguale). è il flusso/portata della fluidodinamica. Non basta un ping (singolo bit, quello misura la latenza).\ncolli di bottiglia creano grossi problemi su internet, ma non nelle dorsali (backbone, sono enormi), quanto quelli che si collegano.\ntutto questo comunque resta molto teorico perché non considero perdite e ritardi, all'atto pratico misuro per sapere quant'è.\nSeguono i ritardi che sommati fanno la latenza\n- processamento (elaborazione del pacchetto: controllo errori, switching, ... tipicamente svariati odg meno degli altri)\n- Trasmissione (tutta  la dipendenza dalla grandezza del pacchetto è qua)\n- Accodamento (queuing delay, dipende dal traffico, difficile da calcolare, c'è teoria delle code)\n- propagazione (SOLO lunghezza del cavo, satellite 300ms, cavo oceanico 30ms)\n\ni primi bit caricati in trasmissione non devono aspettare gli ultimi. Infatti, se ho n bit e ognuno ci mette m secondi, l'ultimo verrà processato dopo nxm secondi. Ma intanto il primo è partito. Magari è pure arrivato all'altro router, il quale però deve aspettare di ricevere tutto il pacchetto per inoltrarlo.\nAttenzione a fare pacchetti troppo grossi, il ritardo di trasmissione schizza alle stelle. (posso cambiarlo su pc con la mia connessione???)\n\nSe sto trasmettendo un pacchetto enorme con bassa velocità ci metto un botto, il che blocca la rete per tutti!\n\n","x":-920,"y":-1840,"width":640,"height":740,"color":"1"},
		{"id":"c3e8022233e42700","type":"text","text":"# Ritardi\n\n- accodamento (\"quando siamo fortunati non possiamo portarci avanti col lavoro) rivedilo che non ho capito cosa vuole dire (vedi animazione di due slides dopo, perdita di pacchetti, mettendo stesso rate di emission e transmission) --> se si riempie la coda perdo pacchetti --> un pacchetto perso ha tempo di attesa infinito\n\nse ci stanno dei loop nel percorso router i pacchetti intrappolati restano all'infinito? Devo metterci un cut-off -> tempo di vita (TTL time to live), spesso espresso in \"quanti altri router possono inoltrarlo\". Se il pacchetto muore in genere il router manda un feedback a chi glielo ha inviato (\"hey, il tuo pacchetto è morto). Se mando TTL sempre crescenti stimo il percorso (non proprio, nessuno mi dice che faccio sempre lo stesso $\\forall$ invio).\nPer vari motivi i router possono non rispondere quando muore il pacchetto. Se accetto i TTL potrei far leakare la struttura interna della rete. Se il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). TCP/IP capisce se è una perdita per traffico o casuale. Importante perché se perdo per traffico dovrei rallentare, altrimenti scialla.\n\n- rate\\*ritardo = numero massimo di bit nel buffer (-> definisce grandezza del buffer). volume del \"tubo\" di trasmissione. non utilissimo perché a me interessa il throughput, cioè la sezione\n\n","x":-280,"y":-1830,"width":640,"height":720,"color":"1"},
		{"id":"187dc42cfef0546d","type":"text","text":"# Appunti lezioni raw in rosso - magari poi ci faccio un txt","x":-1492,"y":-2200,"width":465,"height":102,"color":"1"},
		{"id":"5b4bbd10c0ed915d","type":"text","text":"# Sicurezza\n\n\n\nQuasi tutti i governi fanno sniffing, anche se è crittografato.\nBanalmente ho i metadati, quindi posso risalire a chi parla (magari senza sapere cosa), ma posso mettermi ad ascoltare più \"vicino\" ai due che parlano. Se sei un governo puoi fare la qualunque, compreso con le crittografie (non tutto no? se faccio RSA col cazzo mi sa). Tecnicamente sniffing era attaccarmi col cavo (quando c'era un cavo per tutti) ma oggi dipende dalla tecnologia usata ed è un concetto astratto.\n\nPosso fare cose illegali in N (con N enorme) modi. Tipo, posso inviare pacchetti mettendo un mittente che non sono io (se mando la droga e metto come mittente qualcun altro quello non va in galera perché non è dimostrabile che l'ha mandato lui), oppure da router posso tenermi i pacchetti e leggerli, o inoltrarli a una macchina a mia scelta.\n\nContro queste cose c'è roba tipo\n- l'autenticazione\n- confidenzialità (crittografia)\n- autenticità\n- restrizioni di accesso (e.g. VPN protetta da password)\n- firewall (a livello di rete)\n\nCi sono attacchi diversi a seconda di\n- come reagisco alle richieste\n- come creo la connessione (e.g. TCP)\n- ...\n\nDi base si può fare tutto, è una giungla!\nSe mi fingo un altro comunque l'altro può trasmettere, a rigore dovrei anche preoccuparmi di bloccare quello che interpreto (man-in-the-middle).\n\n","x":-3360,"y":-433,"width":739,"height":853,"color":"1"},
		{"id":"9ed19d6e9980b34b","type":"text","text":"# Come invio i messaggi sui Link?\n\nHo sostanzialmente due modi per farlo.\n\n- **_Commutazione di Circuito_** - Letteralmente, creo un collegamento fisico riservato alla coppia sorgente-destinazione, sulla quale sono gli unici a poter comunicare (salvo collegamenti fisici alla linea da parte di terzi, dove i terzi sono verosimilmente i servizi segreti). Garantisce prestazioni stabili, e viene usato nelle linee telefoniche. Naturalmente si può fare anche senza dedicare un intero cavo al singolo canale di comunicazione:\n\t- **_Frequency Division Multiplexing_** (**_FDM_**) - Ogni cavo trasmette un certo range di frequenze EM. Allora le suddivido in N canali, e ad ognuno di questi assegno una certa larghezza di banda (che però sarà stretta);\n\t- **_Time Division Multiplexing_** (**_TDM_**) - Sostanzialmente tratto i canali come una *ready queue* e faccio *preemptive scheduling*. Entro il proprio intervallo di tempo assegnatogli, ogni canale trasmette avendo a disposizione la banda massima;\n- **_Commutazione di Pacchetto_** - Ogni messaggio viene suddiviso in **_pacchetti_**. La rete si occupa di instradare i singoli pacchetti e *tenta* di non fare casino. Interessante notare come nonostante possa fare casino in molti modi (e in effetti lo fa: li perde, sbaglia l'ordine di arrivo, li inoltra a terzi, ...) è il metodo più utilizzato su Internet. Ovviamente il motivo c'è: le comunicazioni sono spesso **_bursty_**, nel senso che gli host stanno *quasi* sempre zitti, tranne in singoli momenti isolati in cui vomitano un enorme messaggio da inviare. Non ha senso dedicare un circuito a una comunicazione in cui non succede *quasi* mai niente: blocco delle risorse che restano inutilizzate quando magari altri host rimasti tagliati fuori potrebbero comunicare il proprio messaggio *bursty*. Idealmente dovrei dare la sensazione all'host di avere una connessione dedicata, il che in parte si risolve aumentando la banda e in parte non si risolve perché ci stanno mille problemi.","x":-4940,"y":1761,"width":700,"height":780,"color":"4"},
		{"id":"deea8f39a16646e1","type":"text","text":"**Throughput Minimo Garantito**: Questo è come l'assicurazione che un servizio Internet ti dà. Supponiamo che tu stia giocando a un videogioco online e non vuoi che la connessione diventi troppo lenta. Il \"throughput minimo garantito\" è come la promessa dell'azienda che la tua connessione rimarrà almeno a una certa velocità. Quindi, anche se Internet diventa affollato, sei sicuro di avere almeno quella velocità per continuare a giocare senza problemi.","x":-1680,"y":-260,"width":546,"height":267},
		{"id":"ed6dd0d5b788bd3e","type":"text","text":"# In pratica e in breve\n\nPer accedere ad Internet ($\\Rightarrow$ scambiare dati con qualsiasi altro nodo collegato), gli host si devono in qualche modo connettere agli ISP (aziendali, università, commerciali), i quali a loro volta devono essere interconnessi (tramite ISP più grandi o IXP).\n\nLa risultante rete di reti è molto complessa, perché la sua evoluzione è figlia di un abnorme ammasso disordinato di fattori (politici, economici, nazionali, ...).","x":-4570,"y":-880,"width":772,"height":300,"color":"3"},
		{"id":"9446a50b389809a0","type":"text","text":"ci sono anche delle vie di mezzo tipo TLS (sicurezza). prima se mandavo una password era in chiaro, chi trovava il pacchetto (non facilissimo) aveva vinto. Transport Layer Security usa TCP ma sta sotto l'applicazione. Quindi io scrivo la phrase in chiaro, tls la critta e la passa a tcp. non lo faccio a livello tcp perché è un casino cambiare un protocollo così lento ad evolversi (super diffuso).","x":-3318,"y":-800,"width":656,"height":200},
		{"id":"1b501ca1023c98e0","type":"text","text":"# Perdite\n\nInternet di base è non affidabile (\"best effort\"), il che significa che i pacchetti possono essere persi o consegnati in ordine casuale.\n\nSe il pacchetto arriva a coda piena viene scartato. La rete non è per niente gentile con i pacchetti, sta a me farlo arrivare. Pacchetti persi nel 99% dei casi sono code e strade sbagliate (per motivi) se parlo di dorsali. Nella periferia posso avere interferenze (e.g. wifi). ","x":-2019,"y":2012,"width":680,"height":276,"color":"1"},
		{"id":"f1e9ad03f9edbfdd","type":"text","text":"# Prova\n\n- a cambiare la dimensione dei pacchetti TCP/IP di un computer (impostazioni del SO? chissà)","x":-545,"y":1182,"width":420,"height":240,"color":"5"},
		{"id":"5b16a0a8827edeef","type":"text","text":"# Formulario (?)\n\n- Massimo numero di bit su un link - $R\\cdot D_p$\n- Avere un TDM (e.g. 10 slot/s) tipicamente in un esercizio significa che ad ogni host è associato uno solo degli slot indicati nel TDM (e.g. 1 slot/s).","x":-545,"y":1454,"width":422,"height":267,"color":"2"},
		{"id":"e98fee2b8eb0a179","type":"file","file":"RitardoMedioInCoda.png","x":-545,"y":285,"width":461,"height":420},
		{"id":"165209213bc6a130","type":"text","text":"## Sulla divisione delle Reti e di Internet\n\nIn pratica, Internet è un sistema talmente complesso che ho una mezza infinità di modi di suddividerlo. Diciamo che a seconda di cosa mi serve fare uso la divisione che più mi è utile. ","x":-4570,"y":-520,"width":772,"height":137,"color":"4"},
		{"id":"23227e82062b49bc","type":"text","text":"# Struttura delle Reti","x":-3964,"y":836,"width":340,"height":50,"color":"6"},
		{"id":"1ec4d0918042c205","type":"text","text":"# Tramissioni su Rete","x":-3968,"y":1401,"width":348,"height":50,"color":"6"},
		{"id":"5cf8d16de6efff56","type":"text","text":"# Commutazione di Pacchetto","x":-4028,"y":2125,"width":468,"height":50,"color":"6"},
		{"id":"8ca68ef0d9cba75a","type":"text","text":"# Where stack protocollare?\n\nOvunque sia necessario far comunicare più elaboratori, in un range che spazia da una semplice LAN fino all'Internet.\n\nSu **LAN** si possono trovare diversi esempi di stack protocollari proprietarie nate tra gli anni '70 e '90, come **NetBIOS** (**Microsoft**) o **AppleTalk**.\n\nCon l'avvento di **_Internet_** si è però tutto uniformato a **_TCP/IP_**, rimasto praticamente l'unico ad oggi in uso.","x":-5736,"y":3655,"width":700,"height":278,"color":"4"},
		{"id":"1a0fe951bbf51b93","type":"text","text":"# Simmetrie tra le stack protocollari\n\nSe comunico voglio sia inviare che ricevere, quindi\n\n- ci sono almeno due stack, una per chi invia e una per chi riceve;\n- tutti gli host possono essere sia mittente che destinatario.\n\nDa questo segue che guardando le varie stack in **_orizzontale_** troviamo una **_simmetria logica_**, ovvero **protocolli omologhi** e **oggetti identici**.\n\nConcettualmente, il **_collegamento logico_** è tra layer di pari livello di tutte le stack, che parlano la stessa \"lingua\" $\\Rightarrow$ il layer $N$ di un dispositivo comunica virtualmente solo e soltanto con il layer $N$ degli altri dispositivi.\n\nL'effettivo **_flusso di informazione_** è però **_verticale_**, eccetto per il livello più basso che rappresenta lo spostamento fisico.\n\nLungo la propria stack, il mittente applica delle funzioni per incapsulare il messaggio (e.g. lo critta e lo mette in una scatola), questo viene fisicamente trasportato al nodo successivo dal livello più basso (e.g. il furgone delle poste) e infine il destinatario applica le funzioni inverse (in ordine inverso, perché stavolta il messaggio risale la stack) per riottenere il messaggio originale (e.g. apre la scatola e lo decritta). \n\nNel complesso, l'informazione \"scende\" e \"risale\" lungo le stack protocollari.\n","x":-4940,"y":2716,"width":700,"height":620,"color":"4"},
		{"id":"f6c22dc935238119","type":"text","text":"# Protocolli e Servizi\n\nIl servizio è il **_cosa_** garantisco (e.g. in questo caso un insieme di primitive che uno strato offre a quello superiore), il protocollo è **_come_** implemento il servizio.\n\n```\nServizio del livello di trasporto: \"Usa la mia primitiva INVIA. Ti garantisco che i tuoi pacchetti arriveranno a destinazione tutti e in ordine, se si disordinano ci penso io a rimetterli a posto\"\nProtocollo del livello di trasporto: TCP\n```\n\nOgni layer, secondo il proprio protocollo, implementa dei servizi usando le proprie risorse e i servizi forniti dal livello sottostante.\n\n Tramite i servizi si possono vedere i layer come delle **_black box_** $\\Rightarrow$ ci si può dimenticare dell'implementazione (protocollo) sottostante in favore di una vista di più alto livello che consta di input e output (servizi e/o informazioni).","x":-5736,"y":3156,"width":700,"height":440,"color":"4"},
		{"id":"4df27d69ac9764ca","type":"text","text":"# What is stack protocollare?\n\nUn **_Protocollo_** definisce l’insieme di regole che mittente e destinatario (e tutti i sistemi intermedi coinvolti) devono rispettare per essere in grado di comunicare.\n\nSe ho una situazione complessa è comodo suddividere i compiti fra più livelli (detti **_layer_**, o *strati*) indipendenti, secondo il buon vecchio principio di modularità.\n\nAd ogni livello corrisponderà quindi (almeno) un \"sotto-Protocollo\" (inteso come modularizzazione del Protocollo che definisce l'intero scambio di messaggi) che da qui in poi chiamerò **_protocollo_** (già... fa ridere).\n\nPer realizzare il Protocollo abbiamo creato una stratificazione di protocolli detta **_layering di protocolli_** o **_stack protocollare_**.\n\nQuesto porta in generale diversi vantaggi:\n\n- Concettualmente è più chiaro cosa succede $\\Rightarrow$ è più facile costruire modelli;\n- L'aggiornamento e/o la sostituzione dei moduli è più semplice e trasparente (è ben chiaro cosa sto facendo, e dove), e non influisce sul resto del sistema.\n\nOgni layer _comunica in modo_ **_bidirezionale_** _con i livelli adiacenti_, realizzando coppie *provider-user*, in cui il primo offre al secondo un **_servizio_**.\n","x":-4940,"y":3376,"width":700,"height":557,"color":"4"},
		{"id":"472a39255272296f","type":"file","file":"Layering.png","x":-5736,"y":2716,"width":700,"height":380},
		{"id":"1bd86960d6e5a8e2","type":"text","text":"# Stack protocollare","x":-3962,"y":3630,"width":336,"height":50,"color":"6"},
		{"id":"89560ca8221b899c","type":"text","text":"# Messaggio di Richiesta HTTP\n\n Inviato dal client al server, consta di tre parti:\n \n - ***Riga di richiesta*** - Una stringa avente sintassi `metodo URI versione_HTTP \\r \\n`, dove\n\t- `metodo` specifica *cosa* voglio fare;\n\t- `URI` specifica l'oggetto all'interno del server con cui voglio interagire. ;\n\t- `versione_HTTP` serve ad assicurarmi che parleremo la stessa lingua;\n\t- `\\r \\n`, caratteri di ritorno a capo e avanzamento riga, comunicano la fine della stringa di richiesta.\n- ***Intestazione (header)*** - Varie righe aventi sintassi `parametro: valore` che specificano informazioni utili alla richiesta;\n- ***Corpo (body)*** - Payload diretto al server, preceduto da una riga vuota. Tipicamente vuoto a sua volta, a meno che non si faccia una richiesta di upload (metodo POST).\n\t","x":-6865,"y":8799,"width":473,"height":580,"color":"4"},
		{"id":"a30868312d411d98","type":"text","text":"# Messaggio di Risposta HTTP\n\nRisposta del server al client, anche qui tre parti:\n\n- Riga di stato - Una stringa avente sintassi `versione_HTTP STATUS PHRASE \\r \\n`, dove\n\t- `versione_HTTP` serve ad assicurarmi che parleremo la stessa lingua;\n\t- `STATUS` è un codice che identifica l'esito della richiesta;\n\t- `PHRASE` è una breve descrizione testuale associata al codice `STATUS`.\n- ***Intestazione (header)*** - Varie righe aventi sintassi `parametro: valore` che specificano informazioni utili alla risposta;\n- ***Corpo (body)*** - L'effettivo contenuto della risposta. Spesso in caso di errore si tratta della stampa a schermo a caratteri cubitali del codice di errore.","x":-6317,"y":8799,"width":473,"height":580,"color":"4"},
		{"id":"55d3231875e83cc8","type":"text","text":"# Codici di Risposta\n\n\tSe sei un Server devi rispondere bene, altrimenti dall'altra parte non capiscono\nVi sono 5 categorie di codici `STATUS`, il cui significato è poi chiarito dalla `PHRASE`:\n\n- ***Codici 1xx*** - la risposta contiene solo informazioni.\n\t- `100 Continue` indica che il server è pronto a ricevere la richiesta del client;\n- ***Codici 2xx*** - l'operazione è andata a buon fine.\n\t- `200 OK` è la risposta che vorremmo ricevere sempre, e restituisce del contenuto;\n\t- `204 No Content` significa \"tutto bene, ma non ho niente da inviarti\", può succedere se ad esempio chiedo di salvare la pagina;\n- ***Codici 3xx*** - \"ho dovuto reindirizzare la richiesta che mi hai fatto\".\n\t- `301 Moved Permanently` significa esattamente \"quello che chiedi non è più qui, da adesso in poi reindirizzo tutte le tue richieste per questo oggetto al nuovo URI;\n- ***Codici 4xx*** - errore nella richiesta del client.\n\t- `400 Bad Request` significa \"non ho capito, ed è colpa tua\";\n\t- `403 Forbidden` è un \"non hai i permessi per chiedermi questa risorsa\";\n\t- `404 Not Found` è un \"la risorsa che chiedi non esiste su questo server\";\n- ***Codici 5xx*** - \"non ci sono riuscito, ma è colpa mia\".\n\t- `500 Internal Server Error` significa \"non so manco io che è successo\";\n\t- `503 Service Unavailable` indica che il server al momento non può gestire la richiesta, in pratica è un \"riprova più tardi\"\n\t- `505 HTTP Version Not Supported` significa \"no hablo tacos\".","x":-5735,"y":8799,"width":700,"height":1040,"color":"4"},
		{"id":"973215b7fd31a26a","type":"text","text":"### Esempio di GET\n```\nGET /page.html?parametro=valore HTTP/1.1\nHost: example.com\n```","x":-7880,"y":9939,"width":459,"height":160,"color":"4"},
		{"id":"ee9aa768d32eb89f","type":"text","text":"# Parametri delle query\n\nSebbene esistano parametri per diversi metodi, quelli che compaiono nell'URL sono comunemente associati al metodo GET.\n\nNon esiste una lista assoluta di parametri standard, poiché dipendono da come è scritto il singolo server.\n\nComplessivamente possiamo trovare parametri di\n\n- **ricerca o filtro** - specificano una query all'interno del server:\n\t`?q=termine_di_ricerca`\n\t`?categoria=notizie&anno=2022`\n- **ordinamento** - specificano l'ordine dei risultati restituiti dal server:\n\t`?ordine=asc&campo=data`\n- **paginazione** - specificano come vengono visualizzati i risultati della richiesta:\n\t`?pagina=2&per_pagina=10`\n- **autenticazione** - comunicano token di accesso e/o credenziali utente:\n\t`?token=abc123`\n- **localizzazione** - specificano la localizzazione e/o le preferenze linguistiche dell'utente:\n\t`?lingua=it_IT&paese=IT`\n\nChi crea il server può definire dei parametri personalizzati per trasmettere informazioni specifiche:\n\n\t ?parametro1=valore1&parametro2=valore2","x":-7880,"y":10150,"width":459,"height":904,"color":"4"},
		{"id":"ada1ce65a17b1ff7","type":"text","text":"### Esempio di POST\n```\nPOST /endpoint HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 25\n\nparametro1=valore1&parametro2=valore2\n```","x":-7324,"y":9939,"width":459,"height":301,"color":"4"},
		{"id":"be024ab3c20ae124","type":"text","text":"### Esempio di PUT\n```\nPUT /risorsa HTTP/1.1\nHost: example.com\nContent-Type: application/json\nContent-Length: 43\n\n{\"chiave\": \"valore\", \"altro\": \"dato da salvare\"}\n```","x":-7324,"y":10279,"width":459,"height":301,"color":"4"},
		{"id":"16f174d47e0dd2b5","type":"text","text":"### Esempio di richiesta\n```\nGET /index.html HTTP/1.1\\r\\n\nHost: www-net.cs.umass.edu\\r\\n\nUser-Agent: Firefox/3.6.10\\r\\n\nAccept: text/html,application/xhtml+xml\\r\\n\nAccept-Language: en-us,en;q=0.5\\r\\n\nAccept-Encoding: gzip,deflate\\r\\n\nAccept-Charset: ISO-8859-1,utf-8;q=0.7\\r\\n\nKeep-Alive: 115\\r\\n\nConnection: keep-alive\\r\\n\n\\r\\n\n```","x":-6865,"y":10799,"width":473,"height":447,"color":"4"},
		{"id":"ff01e5961e252647","type":"text","text":"# Campi degli Header\n\n### Solo Client\n\n- **Accept** - Indica i tipi di contenuto che accetta come risposta;\n- **Accept-Charset** - Indica i set di caratteri che accetta come risposta;\n- **Accept-Encoding** - Indica le codifiche che accetta come risposta;\n- **Accept-Language** - Indica le lingue in cui accetta la risposta;\n- **Authorization** - Trasmette le credenziali di autenticazione;\n- **Cookie** - Invia i cookie al server.\n- **Host** - Specifica il nome dell'host e la relativa porta al quale è destinata la richiesta;\n- **If-Modified-Since**: Richiede la risorsa solo se è stata modificata dopo una data specificata;\n- **Upgrade** - Usato dal client per chiedere al server di cambiare il protocollo utilizzato;\n- **User-Agent** - Specifica al server il software utilizzato per inviare il messaggio HTTP;\n### Solo Server\n- **Last-Modified** - Indica la data e l'ora dell'ultima modifica alla risorsa;\n- **Expires** - Specifica la scadenza della risorsa ($\\Rightarrow$ quando non deve più essere considerata valida se trovata in cache);\n- **ETag** - Identificatore univoco per una specifica versione di una risorsa;\n- **Accept-Ranges** - Stai scaricando un file e ti salta la connessione. Devi riscaricarlo tutto? No, se questo valore è impostato a `bytes` puoi riprendere da dove ti eri interrotto! \n- **Location** - Reindirizza il client a una nuova locazione URL;\n- **Server** - Comunica al client il processo server che ha generato la risposta;\n- **Set-Cookie** - Invia cookie al client;\n### Sia Client che Server\n- **Cache-Control** - Specifica le istruzioni di caching;\n- **Connection** - Indica se a seguito del messaggio voglio chiudere la connessione (`close`, comportamento predefinito di HTTP/1.0) o se voglio mantenerla attiva (`keep-alive`, comportamento predefinito di HTTP/1.1); \n- **Content-Encoding** - Indica la codifica del corpo del messaggio;\n- **Content-Language** - Indica la lingua del corpo del messaggio;\n- **Content-Length** - Indica la lunghezza del messaggio nel body. Utile quando uso il metodo HEAD per capire quanto è grande il file che voglio scaricare;\n- **Content-Type** - Indica il tipo di contenuto presente nel body (INDICA ANCHE QUELLO RICHIESTO??? IN ESAME DICE QUESTO!!!);\n- **Date** - Specifica data e ora d'invio del messaggio;\n- **Keep-Alive** - Quando `Connection` è impostato su `keep-alive`, questo parametro specifica dopo quanto tempo il server chiuderà la connessione dopo l'ultimo messaggio inviato (`timeout=60` imposta la tolleranza a 1 minuto) oppure al raggiungimento di quale numero massimo di richieste (`max`);\n- **Server**: Usato dal server per identificarsi con il client.\n","x":-6755,"y":9499,"width":805,"height":1200,"color":"3"},
		{"id":"44ce1eef2a1a2afa","type":"text","text":"### Esempio di Risposta\n\n```\nHTTP/1.1 200 OK\\r\\n\nDate: Sun, 26 Sep 2010 20:09:20 GMT\\r\\n\nServer: Apache/2.0.52 (CentOS)\\r\\n\nLast-Modified: Tue, 30 Oct 2007 17:00:02 GMT\\r\\n\nETag: \"17dc6-a5c-bf716880\"\\r\\n\nAccept-Ranges: bytes\\r\\n\nContent-Length: 2652\\r\\n\nKeep-Alive: timeout=10, max=100\\r\\n\nConnection: Keep-Alive\\r\\n\nContent-Type: text/html; charset=ISO-8859-1\\r\\n\n\\r\\n\n[document content...]\n[...]\n```","x":-6355,"y":10799,"width":511,"height":447,"color":"4"},
		{"id":"6ce8f85f78362603","type":"text","text":"# Metodi di Richiesta\n\n- ***GET*** - Richiede la risorsa `path` al server. Può essere usato per richiedere metadati o per far generare sul momento la risorsa di cui ho bisogno.\n\t- Lo stesso indirizzo IP con cui ho stabilito la connessione potrebbe contenere più domini, per cui sono obbligato a specificare il campo `host` dell'header;\n\t- Posso fornire al server ulteriori specifiche su *come* rispondermi aggiungendo `?` alla fine dell'`URI` e scrivendo ***parametri*** (nella forma `parametro=valore`) separati da `&` (e.g. `/page.html?categoria=notizie&anno=2022`);\n\t- Esiste una variante del GET, detto ***GET CONDIZIONALE***, per sfruttare il **_web caching_** $\\Rightarrow$ richiede la pagina al server solo se è stata modificata rispetto alla versione che conosce;\n\t- Il GET dovrebbe essere sempre una richiesta ***idempotente***, nel senso che due GET di fila dovrebbero produrre lo stesso risultato. Questo non è sempre vero, perché esistono parametri dinamici che possono modificare lo stato del server. Possiamo considerarla una vulnerabilità, potrei usarli per fare injection (e.g. SQL), cambiare le autorizzazioni o accedere a risorse riservate;\n- ***HEAD*** - Richiede l'header che verrebbe restituito a seguito di una richiesta GET. Usato principalmente nei controlli di validità della ***web cache*** (e.g. \"la pagina è stata modificata?\");\n- ***POST*** - Invia dati al server tramite il body. E come fa il server a sapere cosa fare con questi dati?\n\t- L'applicazione server definisce degli ***endpoint*** (in pratica degli URL), ovvero dei \"contenitori\" di richieste di azioni simili (e.g. `/crea`, `/aggiungi`, `/elimina`, ...);\n\t- Nella richiesta POST posso quindi specificare direttamente l'endpoint a cui è diretta (e.g. so di voler creare un file e so che il server usa l'endpoint `/crea`);\n\t- Se non conosco l'endpoint corretto posso indirizzare le richieste a un endpoint generico. A quel punto il server prova a capire cosa farci ($\\Rightarrow$ a quale endpoint mandarlo), magari anche interpretando il body (l'implementazione specifica sono fatti suoi);\n\t\t- Se non conosco neanche l'endpoint generico tocca cercare la documentazione, salvo avere voglia di fare trial-and-error: se specifico un endpoint che non esiste il server mi risponde 404;\n\t\t- Inviare deliberatamente un gran numero di richieste POST generiche per costringere il server ad un overhead di smistamento è considerabile un attacco DoS;\n\n- **_PUT_** - Invia nel body un intero documento da salvare nella locazione `URI`, sovrascrivendo qualsiasi cosa ci fosse prima. Ovviamente è un'operazione rischiosa, sta al server gestirla bene;\n- **_DELETE_** - Autoesplicativo;\n- ***PATCH*** - applica modifiche parziali a una risorsa.\n- **_COPY, MOVE_** - Copiano o spostano la risorse in una nuova locazione (anche un'altro server);\n- **_LOCK, UNLOCK_** - Primitive di sincronizzazione (come in un SO) (ESISTONO ??????);\n- **_OPTIONS, TRACE_** - Opzioni e diagnostica della connessione;\n- ***CONNECT*** - Stabilisce una connessione di tunnel (e.g. VPN).","x":-7787,"y":8799,"width":837,"height":1040,"color":"4"},
		{"id":"2edbb402780f44c6","type":"text","text":"# HTTP (Porta 80)\n\nParadigma **_richiesta-risposta (client-server)_** di tipo ***stateless*** basato su ***TCP*** che convenzionalmente utilizza la ***porta 80***.\n","x":-7642,"y":8559,"width":548,"height":160,"color":"6"},
		{"id":"8b3faa26de750a2c","type":"text","text":"# Protocollo HTTP","x":-6499,"y":8614,"width":290,"height":50,"color":"6"},
		{"id":"dff88af00a536f81","type":"text","text":"# Su cosa si basano?","x":-4757,"y":6671,"width":330,"height":50,"color":"6"},
		{"id":"349ec5026bac8b92","type":"text","text":"# Protocolli Applicazione\n\nSono i protocolli di livello più alto, e ignorano completamente la complessità della rete (e.g. percorso dei pacchetti, reinvio in caso di perdita, ...).\n\nA ogni porta è convenzionalmente associato un protocollo, che definisce\n\n- le **_tipologie_** dei messaggi scambiati (e.g. richiesta, risposta, ...);\n- la **_sintassi_** del messaggio ($\\Rightarrow$ come va scritto, e.g. definisce i **campi**);\n- la **_semantica_** del messaggio ($\\Rightarrow$ cosa significa quello che scrivo secondo la sintassi);\n- le **_regole_** che devono rispettare mittente e destinatario per scambiarsi i messaggi (e.g. quanto aspettare tra un messaggio e l'altro, \"se cancello un messaggio qui va cancellato anche dall'altra parte\").\n\nTra i protocolli applicazione troviamo due macro-categorie:\n\n- **_open-source_** (e.g. HTTP), definiti con uno standard pubblico ([RFC](https://it.wikipedia.org/wiki/Request_for_Comments)). Paradossalmente questo aiuta a ridurre le vulnerabilità del protocollo, in quanto aumentano le persone che possono individuarle e conseguentemente correggerle. La condivisione del protocollo è in generale un principio ben noto in ambito sicurezza, e di norma i problemi di vulnerabilità in questi casi si riducono al tempo che intercorre tra il ritrovamento di un bug e il suo *fix*;\n- **_proprietari_** (e.g. Skype), più ottimizzati ma a volte meno efficienti (difficile trovare problemi con poca statistica).\n\n","x":-5736,"y":6848,"width":700,"height":1072,"color":"4"},
		{"id":"a040ad793f9beeac","type":"text","text":"# Garanzie di Sicurezza\n\n\nInoltre posso aver bisogno di comunicare informazioni riservate, e avere necessità di **_sicurezza_** nei confronti di ascoltatori indesiderati. Questo può essere implementato tramite schemi di **_crittografia_**\n\n- nel layer di Applicazione, e quindi a livello di browser (nel modello OSI se ne occupava esplicitamente il layer di Presentazione);\n- nel **_TLS (Transport Layer Security)_**, e prima nel suo predecessore **SSL (Secure Sockets Layer)**. Sebbene non sia ufficialmente parte di TCP/IP, è diventato uno standard *de facto* (e.g. **HTTP + TLS = HTTPS**). Viene diffuso insieme alle API di TCP, e critta i messaggi prima di passarli a quest'ultimo. Si noti che aggiungere un layer è molto più semplice rispetto ad aggiornare esplicitamente un protocollo come TCP.\n\nA seconda di che applicazione sto usando posso avere necessità diverse.\nSe mando una mail non voglio perdite ma non ho particolari necessità di velocità o di throughput, mentre se faccio live streaming posso accettare di perdere qualche frame purché il ritardo sia minimo (e se non ho un thoughput minimo garantito... non faccio live streaming).\n","x":-4920,"y":6848,"width":656,"height":523,"color":"#4545ff"},
		{"id":"e2750b6b7a2c01af","type":"text","text":"# SSL/TLS\n\nSono protocolli di sicurezza che agiscono su un canale di comunicazione. \nSi occupano sia di crittare i dati (previene i leak di dati da **eavesdropping**) che di generare e verificare i ***certificati di autenticità***, ovvero delle firme digitali in grado di attestare che il server con cui si è stabilita la connessione è effettivamente chi dice di essere (previene attacchi di tipo **man-in-the-middle**). Seguono concettualmente uno schema del tipo\n\n- ***Handshaking*** - quando si crea la connessione con il server che supporta SSL/TLS succedono due cose in contemporanea:\n\t- vengono generate le chiavi pubbliche di uno schema di cifratura asimmetrica (e.g. RSA, DCC, ECC);\n\t- il server fornisce il suo certificato di autenticità al client, il quale lo inoltra a un server di un'Autorità di Certificazione (CA), in grado di validare il certificato tramite il proprio DB;\n- ***Message Authentication Code (MAC)*** - ad ogni messaggio inviato dal server viene allegato un codice generato da una funzione di hash, consentendo quindi di autenticare ogni singolo pacchetto.","x":-4920,"y":7400,"width":656,"height":520,"color":"#4545ff"},
		{"id":"798615d376321d80","type":"text","text":"Il livello di rete è gestito da protocolli come IP, RIP, OSPF e BGF, che instradano i pacchetti attraverso Internet. Al livello di collegamento, ci sono diverse tecnologie, tra cui Ethernet e Wi-Fi, mentre il livello fisico si occupa della trasmissione fisica dei dati.\n\nICMP è un protocollo di controllo di Internet che consente ai router di segnalare errori di instradamento o di comunicare con gli host.\n\nL'indirizzamento IPv4 utilizza indirizzi a 32 bit suddivisi in net_id (identificativo di sottorete) e host_id (identificativo dell'host). La frammentazione dei pacchetti è gestita per adattarsi alle dimensioni massime di trasmissione delle reti fisiche.\n\nInfine, IPv4 ha subito una serie di evoluzioni per affrontare problemi di esaurimento degli indirizzi e migliorare l'efficienza delle comunicazioni.","x":-2290,"y":4605,"width":515,"height":560},
		{"id":"d0bc31a12d2847f8","type":"file","file":"chifacosa.png","x":-4940,"y":4875,"width":700,"height":209},
		{"id":"3881465ee755981e","type":"text","text":"# Stack Protocollare TCP/IP\n\nLo standard *de facto* di Internet. **_TCP/IP_** prevede **_5 livelli_**, che descriverò in approccio _down-top_ (si dice? chissà), partendo quindi dalla realtà fisica per arrivare alla virtualizzazione di più alto livello.\n\n- **_Livello Fisico (Physical Layer)_** - l'infrastruttura fisica, dove avviene il vero e proprio **_trasferimento dei segnali_** (e.g. **cavi**, spettro EM). Gestisce l'HW nudo e crudo, incluse le frequenze, le tensioni e la modulazione dei segnali. Ad esempio, un **_modem_** trasforma la codifica dei dati per l'invio dell'informazione (**trasmissione**, da digitale ad analogico) e viceversa (**ricezione**);\n- **_Livello di Collegamento (Data Link Layer)_** - a livello HW, regola e gestisce il **trasferimento dei pacchetti da un nodo al successivo** (e.g. **Ethernet**, **Wi-Fi**, **PPP**, ...). Lungo il suo percorso, un singolo pacchetto può essere gestito da protocolli diversi. Spesso si schematizza TCP/IP a 4 livelli, unificando Fisico e Collegamento (che erano invece separati nel modello ISO/OSI). \n- **_Livello di Rete (Network Layer)_** - a livello matematico, regola e gestisce l’**_instradamento dei pacchetti_** dall'origine alla destinazione attraverso opportuni algoritmi (e.g. **IP**);\n- **_Livello di Trasporto_** - a livello SW, regola e gestisce il trasferimento dei pacchetti dal processo del dispositivo mittente a quello del dispositivo destinatario (e.g. TCP, UDP);\n- **(SSL/TLS)** - non incluso nel modello TCP/IP, ma di fatto è il layer di Presentazione del modello ISO/OSI. Si occupa esplicitamente della sicurezza.\n- **_Livello di Applicazione_** - è la vista di più alto livello (e.g. HTTP, FTP, DNS).\n\nOra però passiamo all'approccio *top-down* per seguire l'evoluzione di un messaggio.\n\n- ciò che comanda l'utente è trasformato dall'Applicazione in un **_messaggio_**, costituito da\n\t- ***header*** - qui si inseriscono istruzioni comprensibili al trasporto (e.g. \"devi raggiungere `www.example.com`, e questo è il il quarto di sei messaggi\") e all'Applicazione di chi lo riceverà, che deve parlare la stessa lingua (ovvero usare lo stesso protocollo) per poter decodificare correttamente;\n\t- ***corpo*** - i dati veri e propri, anche detti ***payload*** (un po' come se il vero messaggio ai fini della comunicazione sia una zavorra, uno sforzo).\n- L'Applicazione invoca le API del Trasporto, che riceve il messaggio e gli aggiunge le proprie informazioni (**header di trasporto**), portando a termine il secondo **_incapsulamento_** e rendendo il messaggio un **_segmento_** (o **_datagramma utente_**). Notare che il payload del segmento è il messaggio. Come per l'Applicazione, l'header del Trasporto è comprensibile per il trasporto stesso e per la Rete, che saprà cosa farci;\n- Il Trasporto passa il segmento alla Rete, che aggiunge il proprio header e crea un **_datagramma_**, comprensibile per il Collegamento;\n- si passa quindi al Collegamento, che aggiungendo il proprio header rende il pacchetto un **_frame_**, che viene poi modulato nel mezzo Fisico.\n\nA questo punto il pacchetto ha completamente disceso la stack. Può avvenire il trasferimento fisico attraverso la rete e un altro dispositivo può applicare le trasformazioni inverse per risalire prima al datagramma, poi al segmento e infine al messaggio.","x":-4138,"y":4203,"width":688,"height":1431,"color":"4"},
		{"id":"b81367aa9de6afb4","type":"text","text":"# Garanzie di Comunicazione\n\nSe invio un messaggio voglio anzitutto **_che arrivi a destinazione_** (... e no, su Internet non è scontato), dopodiché se possibile vorrei lo facesse\n\n- ***integro***, ovvero che non subisca corruzione (e.g. se faccio una chiamata non voglio pacchetti in disordine o fenomeni di *bit-flip*), che naturalmente può essere anche volontaria;\n- **_in tempi ragionevoli_** (e.g. nell'esempio della chiamata, non voglio un ritardo di minuti tra l'invio e la ricezione)\n\nSe ho tanti messaggi di grandi dimensioni (e.g. straming video) sarebbe carino avere un **_throughput minimo garantito_**.\n\nOra, chi è che si occupa di fornire tali garanzie?\n\n- Il layer di **_Trasporto_**, se si usa un servizio affidabile come TCP. Questi protocolli sono distribuiti come API e implementati a livello di SO;\n- Il layer di **_Applicazione_** stesso, rimediando ad alto livello alle non-garanzie di servizi inaffidabili come UDP (il quale non garantisce neanche che il messaggio arrivi, in caso sta all'Applicazione programmare il suo reinvio). I protocolli dell'Applicazione sono implementabili direttamente (appunto) sulle applicazioni (e.g. un browser), senza necessità di API standardizzate e distribuite su SO. Questo li rende generalmente più rapidi nello sviluppo.\n","x":-4942,"y":5948,"width":700,"height":623,"color":"4"},
		{"id":"35235b872aeaab53","type":"text","text":"# Stack Protocollare ISO/OSI\n\nNel 1984 l'_International Organization for Standardization_ (ISO) ufficializza uno standard architetturale chiamato _Open Systems Interconnection_ (OSI).\n\nLa stack protocollare prevede 7 livelli. Rispetto a TCP/IP (di cui è predecessore spirituale) vi sono due layer aggiuntivi:\n\n- Layer di Presentazione (anche detto livello 6, partendo dal basso) - si pone subito sotto al livello di Applicazione, il quale lo assorbe completamente in TCP/IP. Si occupa esplicitamente della codifica e della crittografia dei dati;\n- Layer di Sessione (livello 5) - definisce alcuni dettagli della comunicazione inter-host, come la gestione degli errori nell'invio dei pacchetti E ALTRO???? Nel modello TCP/IP, i suoi compiti sono stati divisi tra l'Applicazione e il Trasporto.\n\n","x":-4940,"y":4203,"width":700,"height":586,"color":"3"},
		{"id":"0719791a80c12eb2","type":"text","text":"# Chi fa cosa?\n\nMittente e destinatario devono implementare tutti gli step dell'incapsulamento o decapsulamento, naturalmente mediante dispositivi diversi.\n\nUn router vede solo dal livello di Rete in giù. Una sua azione tipica è **distruggere l'header di Rete** del pacchetto in ingresso **e crearne uno nuovo** ($\\Rightarrow$ così realizza il **reindirizzamento**).\n\nNon ha bisogno di avere i protocolli software di Trasporto e Applicazione (tipicamente implementati solo a livello di SO), perché non arriva a vederli. Si limita a collegare $N$ sottoreti tramite $N$ strutture diverse sottostanti.\n\nUno switch si ferma al Collegamento. Non dovendo reindirizzare (si limita ad inoltrare i frame in ingresso), non distrugge/crea alcun header.","x":-4940,"y":5194,"width":700,"height":440,"color":"3"},
		{"id":"179ce6b66f1a29fe","type":"text","text":"# Livello di Applicazione","x":-5586,"y":5810,"width":400,"height":50,"color":"6"},
		{"id":"ea111d8cb579b650","type":"text","text":"# Paradigmi di Comunicazione\n\nUn **_paradigma di comunicazione_** è uno schema secondo cui avvengono lo scambio di informazioni e la gestione delle connessioni all'interno di una rete (tendenzialmente si implementa a livello di Internet).\n\nVi sono due paradigmi di comunicazione principali:\n\n- **_client-server_** - utilizzato da protocolli Applicazione quali HTTP, FTP e IMAP. I sistemi terminali vengono divisi in due categorie:\n\t- **_server_** - host sempre attivo ($\\Rightarrow$ **_sempre in ascolto_**) e con indirizzo IP permanente ($\\Rightarrow$ sempre identificabile nella rete). **_Fornisce servizi_** al client. Se si scollega non può esserci comunicazione, neanche tra client (in quanto si basano su percorsi di tipo client -> server -> client);\n\t- **_client_** - host che comunica solo e soltanto con un terminale di tipo server, a cui **_richiede servizi_**. Non è tenuto ad essere sempre attivo, né ad avere un IP fisso $\\Rightarrow$ non è tenuto ad essere reperibile (da chi, poi?);\n- **_peer-to-peer (p2p)_** - ogni host (*peer*, \"di egual importanza\") può essere sia client che server, richiedendo e fornendo servizi. Questo paradigma rende la rete estremamente **_scalabile_**, in quanto al crescere dei peer aumenta anche l'offerta di servizi. Più complesso da gestire, perché non ci sono indirizzi fissi e nessun peer è tenuto ad essere sempre in ascolto. Utilizzato tipicamente da protocolli legati alla condivisione di file.\n","x":-5736,"y":5024,"width":700,"height":610,"color":"4"},
		{"id":"aa2f1768f7663ebf","type":"text","text":"# Come?\n\nChi vuole avviare una comunicazione ha bisogno di far girare un **_processo client_**. Questo dovrà scegliere un canale di comunicazione virtuale, detto **_socket_** (o **identifier**, che puoi vedere come un'interfaccia con il layer di Trasporto), una coppia di valori che rappresentano\n\n- **_indirizzo IP_**, che identifica univocamente da dove il client sta comunicando (e quindi dove inviare la risposta);\n- **_porta_**, un numero che convenzionalmente specifica con quale tipo di protocollo Applicazione standard *mi aspetto* di inviare e ricevere, ma che più in generale serve a identificare il socket.\n\nLa creazione del socket avviene tramite le API fornite dal livello di Trasporto.\n\nA questo punto la richiesta discende la stack protocollare del client e risale quella del **_destinatario_**, che per ricevere il messaggio a livello Applicazione deve essere **_già in ascolto_** sulla porta richiesta dal client. Questo si realizza tramite un **_processo server_**, che a sua volta per ascoltare ha creato un **_socket_**.\n\nIl che ci fa capire che in realtà quello che rompe il ghiaccio è il server. Costui runna il suo processo server mettendosi in ascolto, e si fa pubblicità (*\"Ciao a tutti, sono 6.6.6.6! Mandatemi pure un messaggio PAI (Protocollo che ho Appena Inventato) sulla porta 69!\"*). A questo punto il client sa a chi scrivere e su quale porta.\n\nLa coppia di socket definisce il **_canale di comunicazione_** $\\Rightarrow$ entrambi sanno a chi comunicare (IP) e come comunicare (porta). Stabilito il canale di comunicazione, i due processi usano uno schema di tipo **_message passing_**.\n\nO meglio, questo succede se uso TCP. A UDP non frega niente di creare canali di comunicazione. *\"Sei in ascolto? ... scherzo, non serve che tu lo sia, era una domanda retorica. Tieni questo pacchetto! Ciao!\"*. Sarà arrivato a destinazione?","x":-5736,"y":4203,"width":700,"height":777,"color":"4"},
		{"id":"19dd5229975701ca","type":"text","text":"# User-friendliness\n\nUna pagina web è composta da oggetti, ciascuno dei quali\npuò essere archiviato su un diverso server Web\n l'oggetto può essere un file HTML, un’immagine JPEG, applet\nJava, file audio,...\n la pagina web consiste in un file HTML di base che include\ndiversi oggetti referenziati, ciascuno indirizzabile da un URL,\nad es.\nwww.someschool.edu/someDept/pic.gif\n\nclient: browser che richiede, riceve\n(utilizzando il protocollo HTTP) e\n“visualizza” oggetti Web\n• server: il server Web invia\n(utilizzando il protocollo HTTP)\noggetti in risposta alle richieste","x":-5736,"y":5948,"width":700,"height":623},
		{"id":"40ee9c3447f7fb82","type":"text","text":"# Trasferimento File","x":-7528,"y":7890,"width":319,"height":60,"color":"6"},
		{"id":"acea343615dea605","type":"text","text":"# Protocolli Applicazione","x":-7561,"y":7351,"width":386,"height":66,"color":"6"},
		{"id":"5c7cb3e9b597a877","type":"text","text":"# Telnet\n\ntelnet?? interfaccia con tcp a livello testuale, devo mandare a capo due volte. una volta che si apre una connessione ogni carattere fa un roundtrip, ma di default non vedo l'echo di quello che ho scritto su terminale.\nbrowser fa questo ma in automatico con le librerie TCP.\nwireshark???\n","x":-6956,"y":6960,"width":1032,"height":334},
		{"id":"877a13b60a49c414","type":"text","text":"# Posta Elettronica (Porta 25)\n\nSchema per scambio di messaggi tra server basato su ***TCP*** che usa tre protocolli: ***SMTP*** per il *push*, ***POP*** e ***IMAP*** per il *pull*.","x":-6485,"y":6491,"width":548,"height":160,"color":"6"},
		{"id":"a13ba86d0881bc3c","type":"text","text":"# Evoluzione del protocollo HTTP\n\nIl prototipo di ***Hypertext Transfer Protocol***, ***HTTP/0.9***, nasce nel 1991 con il World Wide Web. Si trattava di un protocollo scarno, in cui esisteva solo il metodo GET con pochi parametri.\n\nNella sua prima versione ufficiale _**HTTP/1.0**_ ([RFC 1945](https://www.rfc-editor.org/rfc/pdfrfc/rfc1945.txt.pdf), 1996) era prevista una connessione di tipo ***non-persistente*** (si apre il canale TCP, si invia uno e un solo oggetto, si chiude il canale TCP).\n\nIl problema ovvio è che per richiedere $N$ oggetti devo aprire e chiudere $N$ connessioni, ognuna delle quali deve fare *handshaking* sprecando un RTT. \n\nAllora i browser dissero \"abbiamo la soluzione! mandiamo $N$ richieste TCP in parallelo!\". Bello, ma TCP non è pensato per una cosa del genere, e questa pratica congestiona la rete.\n\nLa vera soluzione la porta **_HTTP/1.1_** ([RFC 2616](https://www.rfc-editor.org/rfc/pdfrfc/rfc2616.txt.pdf), 1999), lasciando la connessione aperta e introducendo introducendo i GET in successione (può essere visto come una forma di **multiplexing**, essendo più informazioni su singolo canale che vengono poi smistate dal server).\n\nQuesto mitiga il problema, ma non lo risolve del tutto. Una pagina web è un contenitore di elementi \"grandi\" e \"piccoli\", i quali vengono richiesti al server, che gestisce le richieste GET secondo l'ordine di arrivo (FCFS), motivo per cui\n\n- Un oggetto piccolo può ritrovarsi dietro oggetti grandi, facendo schizzare alle stelle l'*average waiting time* $\\Rightarrow$ **blocco head-of-line (HOL)**;\n- Per come è scritto TCP, se perdo anche un solo pacchetto dell'oggetto grande perdo un sacco di tempo prima di ritrasmetterlo $\\Rightarrow$ l'attesa media cresce ancora.\n\nQuesto problema viene risolto da ***HTTP/2*** (**RFC 7540, 2015**) \"spezzettando\" ogni richiesta/risposta in **frame** e costruendo una **pipeline** (migliora quindi il multiplexing di HTTP/1.1, trasmettendo più oggetti contemporaneamente).\n\nInclude anche migliorie generali al protocollo:\n\n- ***server push*** - cerca di fare prediction e inviarti cose che non hai ancora richiesto, potenzialmente riducendo il numero di richieste. In teoria questi elementi non vengono eseguiti se non richiesti, ma potrebbero restare salvati in una qualche cache;\n- ***priorità*** - consente di assegnare una priorità alle richieste;\n- ***compressione degli header*** - riduce l'overhead di trasferimento.\n\nResta ancora un problema. TCP assume che ogni client instauri una e una sola connessione, e gestisce il sovraccarico di rete e l'affidabilità dando questo per scontato. In pratica, è un protocollo basato su grandi oggetti e su pochi flussi (connessioni), mentre Internet di fatto funziona al contrario.\n\nNasce quindi l'idea di spostare HTTP su UDP sfruttando ***QUIC*** (**Quick UDP Internet Connections**), un protocollo di trasporto sviluppato da ***Google***. Questo protocollo, chiamato ***HTTP/3*** ([RFC 9914](https://www.rfc-editor.org/rfc/rfc9114.html), 2022), al momento in cui scrivo è in fase di sviluppo e sperimentazione.\n\n\tOnce a client knows that an HTTP/3 server exists at a certain endpoint, it opens a QUIC connection. QUIC provides protocol negotiation, stream-based multiplexing, and flow control.","x":-9718,"y":8799,"width":700,"height":1395,"color":"4"},
		{"id":"6694e27578406638","type":"text","text":"# Ma essere stateless è un problema!\n\n- **Autenticazione** - Faccio una richiesta mandando username e password. Il server mi dice `200 OK`, ma alla richiesta successiva non sa che sono io (`chi siete? cosa portate? un fiorino!`);\n- **Sessione** - Non posso memorizzare le preferenze sui siti;\n- **Lock** - Voglio fare due modifiche consecutive un oggetto, e non accetto che ne venga fatta una sola o che qualcuno usi l'oggetto tra una modifica e l'altra. Usando un protocollo *stateful* posso usare un *lock* fino a fine operazioni, ma HTTP non sa chi sono (`chi l'ha messo quel lucchetto? Boh vabbè, per me resta così`);","x":-8860,"y":9094,"width":837,"height":280,"color":"4"},
		{"id":"f99413b00ff804a3","type":"text","text":"# Una possibile soluzione: i Cookies di Sessione\n\nSono costretto ad usare qualcosa di esterno al protocollo che tenga traccia dello stato del client, e si chiama ***cookie***.\n- All'apertura di una connessione, il server riceve una prima richiesta senza cookie;\n- Al server non piace non sapere chi sei, quindi quando manda la prima risposta riempie il campo `set-cookie` dell'header con un valore che identifica univocamente l'utente (e.g. `1678`);\n- Il client riceve il cookie come stringa (e.g. `set-cookie: nome-cookie=1678; Max-Age=3600; Domain=example.com`), e sta a lui manipolarla per estrarne i dati. Tipicamente il browser si crea un file (e.g. `.txt`) che mantiene in RAM e che usa come riferimento per le richieste successive;\n- Quando invia una nuova richiesta, il client include nel campo `Cookie` dell'header le informazioni di cui è in possesso;\n- Adesso il server saprà con chi sta parlando e agirà di conseguenza fino alla scadenza del cookie, al termine della quale il client si ritroverà stampato a schermo `session expired`.\n\n**Il singolo cookie è associato a uno specifico dominio del server**, e vale solo per quest'ultimo. Si possono specificare ulteriori domini di validità del cookie nel campo `Domain`(e.g. `Domain=.eg.com` rende il cookie valido per tutti i sottodomini di tipo `subdomain.eg.com`).","x":-8860,"y":9419,"width":837,"height":520,"color":"4"},
		{"id":"2661b4a7e85defac","type":"text","text":"# ChatGPT risponde: \"Perché lasciare aperta una connessione TCP (HTTP 1.1) non è banale a livello implementativo?\"\n\nLasciare aperta una connessione TCP, come previsto dal protocollo HTTP/1.1, non è banale a livello implementativo per diversi motivi:\n\n1. **Gestione delle risorse del server**: Ogni connessione TCP aperta richiede risorse da parte del server, come memoria e capacità di elaborazione. Mantenere molte connessioni aperte contemporaneamente può esaurire rapidamente le risorse del server, riducendo le prestazioni complessive del sistema.\n    \n2. **Gestione dello stato della connessione**: Quando una connessione TCP rimane aperta, il server deve mantenere uno stato associato a quella connessione, che include informazioni sullo stato della sessione, i dati in sospeso e altre informazioni di controllo. Gestire lo stato di molte connessioni aperte contemporaneamente può diventare complesso e richiedere una gestione accurata delle risorse.\n    \n3. **Rischio di esaurimento delle risorse**: Se non gestite correttamente, le connessioni TCP aperte possono portare all'esaurimento delle risorse del server, che può causare degrado delle prestazioni o addirittura un blocco completo del server.\n    \n4. **Potenziali problemi di sicurezza**: Le connessioni TCP aperte possono essere soggette a attacchi come attacchi di tipo DoS (Denial of Service) o DDoS (Distributed Denial of Service), che sfruttano la disponibilità delle connessioni per sovraccaricare o saturare il server.\n    \n5. **Complessità dell'implementazione del pooling delle connessioni**: Per mitigare i problemi sopra menzionati, è comune utilizzare meccanismi di pooling delle connessioni, che consentono di riutilizzare le connessioni TCP esistenti anziché aprirne continuamente di nuove. Tuttavia, la corretta implementazione di un pool di connessioni può essere complessa e richiedere una gestione accurata delle risorse e dei timeout.\n    \n\nIn sintesi, sebbene mantenere aperte le connessioni TCP possa offrire vantaggi come tempi di risposta più rapidi e una maggiore efficienza complessiva della comunicazione client-server, è necessario affrontare diverse sfide implementative e gestionali per farlo in modo sicuro ed efficiente.","x":-11560,"y":8978,"width":848,"height":817},
		{"id":"c25570b5d51372e2","type":"file","file":"HTTP_1.0.png","x":-10421,"y":8834,"width":460,"height":411},
		{"id":"04b979f48c716c0b","type":"file","file":"HTTP_2.0.png","x":-10540,"y":9795,"width":698,"height":313},
		{"id":"77ddaf1188c7b900","type":"file","file":"HTTP_1.1.png","x":-10540,"y":9337,"width":698,"height":319},
		{"id":"dab2f7463a1544fc","type":"text","text":"# Cookies Traccianti\n\nCi sono siti che si ricordano chi sei anche quando riavvii il computer. Ma il browser non si limita a salvare i cookie in RAM? Non proprio. A seconda della sua implementazione interna può decidere di salvarli su disco (e.g. se mi arriva un cookie che scade tra una settimana forse ha senso conservarlo).\n\nOra, è chiaro che mi va bene non dover loggare su Steam ogni volta che riavvio il computer. Infatti, finché questi ***cookies persistenti*** sono solo quelli del server con cui sto parlando non c'è problema.\n\nNon va più bene se oltre ai suoi cookies il server mi manda quelli di altri server che non contatto direttamente (***cookies di terze parti***), che permettono a gruppi di server di tracciare le attività del client.","x":-8911,"y":10019,"width":420,"height":568,"color":"4"},
		{"id":"431962e65465019d","type":"text","text":"# Sicurezza\n\nE se intercetto un cookie di sessione? In linea di principio posso impersonare un client regolarmente loggato pur non avendo alcuna password.\n\nIn pratica ci sono diverse forme di difesa:\n\n- Utilizzare il flag `Secure`, che consente lo scambio del cookie solo con ***HTTPS***;\n- Utilizzare il flag `HttpOnly`, che impedisce al codice ***Javascript*** di accedere al contenuto del cookie tramite l'API `document.cookie`;\n- Settare il parametro `SameSite` al valore `Strict` consente l'invio del cookie solo e soltanto al server che l'ha creato.\n\nChe c'entra Javascript?\n\nIl cookie è in generale un contenitore di informazioni i cui campi sono inizialmente stabiliti dal server che lo crea, ma il Javascript ($\\Rightarrow$ il server fa girare codice sul client) può aggiungerne e riempirli con le informazioni del client. Segue che il cookie può trasformarsi in una vera e propria ***fingerprint*** contenente informazioni come font, risoluzione dello schermo, latenza e preferenze sui siti che visito, e che il server può rivendere a gruppi di server interessati a tracciare un profilo dei miei gusti (e.g. siti di e-commerce).\n\n\tSi possono mascherare queste informazioni, ma dall'altra parte possono accorgersi che tu mascheri, quindi attiri l'attenzione. L'unico metodo funzionante è disabilitare Javascript\n","x":-8400,"y":10019,"width":420,"height":1035,"color":"#4545ff"},
		{"id":"beb0fa9d0cb9609a","type":"text","text":"### Cross-Site Scripting (XSS)\n\nSei su un forum, e un tizio senza foto profilo posta un link. Tu lo apri, sembra un sito tranquillo, interagisci ed esci. Fine.\n\nO almeno, questo è quello che vedi tu.\n\nCiò che succede è che in qualsiasi punto (URL compreso, in questo caso hai perso anche solo cliccando sul link) di questo *nuovo sito* (*Cross-Site*) potrebbe esserci *codice Javascript* (*scripting*) malevolo.\n\n\"Vabbè, ma cosa potrà mai fare il Javascript\".\n\n- Leggere e/o modificare la zona di memoria del browser (e quindi credenziali d'accesso, cookies, ...);\n- Inviare richieste web, come scaricare contenuto o inviare informazioni a un server malevolo;\n- Sfruttare vulnerabilità del browser per accedere al filesystem locale del client.","x":-8911,"y":10634,"width":420,"height":612,"color":"#4545ff"},
		{"id":"51c10dffbde894c3","type":"text","text":"Un attacco Canvas, anche noto come Canvas Fingerprinting, è una tecnica di tracciamento utilizzata dai siti web per identificare univocamente gli utenti visitatori basandosi sulle caratteristiche grafiche del loro browser e del loro dispositivo. Questa tecnica sfrutta l'elemento HTML5 Canvas, che consente ai browser di disegnare grafica dinamica e manipolare immagini utilizzando JavaScript.\n\nNell'attacco Canvas, il sito web genera un'immagine invisibile all'interno dell'elemento Canvas e utilizza JavaScript per manipolarne i pixel in modo specifico e univoco per ogni visita. Questa manipolazione dei pixel è sottoposta a un algoritmo che crea un \"fingerprint\" grafico univoco del dispositivo e del browser dell'utente, basato su caratteristiche come la precisione del colore, la profondità di bit, la risoluzione dello schermo e altre proprietà grafiche.\n\nIl fingerprint ottenuto attraverso l'attacco Canvas può essere utilizzato per tracciare gli utenti attraverso le loro visite a diversi siti web, anche se questi siti non condividono direttamente i dati di tracciamento. Questo perché il fingerprint grafico rimane costante anche quando l'utente visita diversi siti, consentendo ai tracker di profilare l'utente e seguire le sue attività online.\n\nGli attacchi Canvas sono considerati una minaccia alla privacy degli utenti, poiché consentono ai siti web di tracciare e profilare gli utenti senza il loro consenso esplicito. Tuttavia, le moderne tecnologie di privacy e sicurezza dei browser cercano di limitare l'efficacia di queste tecniche e offrono agli utenti opzioni per proteggere la propria privacy online, come il blocco dei fingerprinting e l'uso di estensioni anti-tracciamento.","x":-8400,"y":11080,"width":420,"height":1040},
		{"id":"8235584e2a6409b7","type":"text","text":"# HTTPS (Porta 443)\n\nA ognuna delle versioni di HTTP posso affiancare il layer di sicurezza SSL/TLS e chiamare il protocollo risultante HTTPS. In realtà posso farlo con tutti i protocolli Applicazione (e.g. FTPS, SSHS, ...), ma nessuno di loro è mainstream come HTTPS.","x":-9718,"y":8340,"width":700,"height":162,"color":"#4545ff"},
		{"id":"b42a1d8cb55878e0","type":"text","text":"# Proxy Server per Web Cache HTTP\n\nUn ***proxy server*** è in generale un intermediario tra un client e un server.  \n\nPosso usarlo per tante cose, tra le quali costruire una ***cache*** del \"vero\" server a cui è indirizzata la richiesta del client, mirando a **ridurre i tempi di risposta** e **alleggerire il traffico del server** di origine.\n\nIn che modo viene gestita questa web cache?\n\n- Il server distribuisce ai propri proxy delle copie dei dati, specificando per ognuno valori come `Last-Modified`, `ETag`, `TTL`, ...;\n- Quando il client fa una richiesta GET al proxy possono verificarsi due scenari:\n\t- ***cache miss*** - non ha il dato richiesto, si accolla il compito di recuperarlo con un GET dal server e se lo salva per eventuali richieste future.\n\t\t- Notare che il motivo per cui non ha il dato richiesto dipende dalle **politiche di gestione della cache**. Magari semplicemente non lo ha mai avuto, ma magari l'ha dovuto sacrificare perché aveva esaurito lo spazio. Come in tutte le cache, l'algoritmo che sceglie cosa rimuovere è fondamentale per l'ottimizzazione dei *cache hit*.\n\t- ***cache hit*** - ha il dato richiesto. Ma è aggiornato? Seguono esempi di **politiche di cache hit**:\n\t\t- il proxy non si pone nemmeno la domanda - \"`la copia che ho resta valida fino alla scadenza del TTL`\". Rischia di dare al client roba non aggiornata, ma non perde tempo;\n\t\t- il proxy manda una richiesta HEAD al server - è interessato al valore di `Last-Modified`:\n\t\t\t- se coincide con la propria copia, la congestione di rete tira un sospiro di sollievo. Il client un po' meno, perché per fare questo check serve comunque almeno un RTT;\n\t\t\t- se non coincide con la propria copia non solo ho già aspettato un RTT per l'HEAD, ma ora mi tocca aspettarne un altro per il GET (più il tempo di trasmissione!). In pratica è **peggio di un cache miss**!\n- A questo punto (e senza curarsi di quello che è successo internamente alla rete) il client è certo che il proxy gli fornirà il dato richiesto.\n\nNotare che in questo scenario anche nel caso migliore il proxy invia un file al client. Posso fare di meglio? Certamente, usando il ***GET condizionale***. Nella richiesta GET specifico una certa data e ora nel campo `If-Modified-Since`, intendendo \"dammi questo dato solo se è stato modificato rispetto alla versione indicata\". Dall'altra parte possono rispondere con\n\n- `304 Not Modified` - nessun payload in risposta;\n- `200 OK` - \"`è stato modificato, eccoti la versione più recente`\";\n- Eventuali codici di errore se il server non ha il dato.\n\nQuesto semplifica di parecchio lo schema di prima, sfrutta la cache del client e riduce ulteriormente i tempi di attesa, dal momento che il caso peggiore è il *cache miss*:\n\n- Il client manda un GET condizionale di un elemento che evidentemente ha in cache;\n- **cache miss** - \"`E che ne so? Chiedo al server usando un GET condizionale!`\";\n- **cache hit** - Se è aggiornato è finita, se non lo è ricadiamo nel cache miss. Uso il TTL per aggiornare periodicamente il contenuto della cache.","x":-8860,"y":7354,"width":837,"height":1148,"color":"#006400"},
		{"id":"acb4f16f12e3f2e9","type":"text","text":"# ... ma perché stateless?!\n\nSe TCP supporta lo storico, perché HTTP sceglie di non implementarlo?\n\n- Da qualche parte devo salvare (grandi quantità di) dati $\\Rightarrow$ mi serve altro spazio di archiviazione;\n- Client e Server devono in ogni momento concordare sullo storico, il che richiede sincronizzazione e causa problemi se un terminale crasha;\n- In generale, i protocolli non-stateless sono più complessi.","x":-8860,"y":8799,"width":837,"height":254,"color":"4"},
		{"id":"52edf2e6ee84f9b0","type":"text","text":"# P2P (cenni)\n\nvedi slides\n\nserve un sistema per coordinare il gruppo di peer. si può anche decentralizzare (database distribuito).\nI vicini sono scelti secondo criterio di download più veloce. potrei anche fare solo download (greedy), servono incentivi a condividere.\n\ndevo iniziare chiedendo lista dei blocchi e scaricando i pezzi di di file più rari. \"optimistic unchoke\" anche se non sei nella top 4 ti includo (altrimenti si scambiano dati solo i primi 4) (tutti questi numeri sono parametri modificabili)\n\ntesto randomicamente velocità dei vicini per vedere se è top, in caso ci accoppiamo e inizia il torrent\n\nnel protocollo non è richiesto che qualcuno abbia il file intero, così come potrei mettere a disposizione il file e poi scollegarmi a metà\n\nil protocollo aumenta la velocità di download secondo la disponibilità di upload\n\nskype era p2p, poi l'ha preso microsoft e hanno centralizzato e non ha funzionato bene fino al dimensionamento dei server.\n\nci sono modi per fare l'Internet decentralizzato, ogni oggetto è rappresentato in modo univoco tramite un oggetto hash e poi \"boh qualcuno ce lo avrà\"","x":-6571,"y":4203,"width":720,"height":1431},
		{"id":"aa76e477e11e779d","type":"text","text":"# SMTP, IMAP (posta elettronica)\n\n\nforse cronolgicamente prima di HTTP. slides. in teoria posso farlo p2p ma in quel caso devo essere acceso. allora uso il server (al tempo potevano anche essere spenti a tratti). quello di uscita poteva tenere le cose se il secondo non rispondeva. smtp è un protocollo di tipo push, serve a scrivere i messaggi. per il pull (leggere i messaggi) serve pop3 o imap. smtp è anche usato end-to-end tra server di posta (p2p), ma in mezzo ci sono i router e TCP. Posso creare io stesso un server di posta con smtp. porta 25 vedi slides per protocollo.\n\nConnessione tcp persistente fino al quit. server ha timeout lungo. 7bit (8 con primo bit 0). dopo fine messaggio (CRLF, ovvero semanticamente cr+lf) ne aspetta un altro a meno che non scrivo quit.\n\nintestazione stessa della mail (to, from, subject) ma non è SMTP. prima c'è handshaking con comandi helo, ...\n\nQuesto è solo ascii 8bit. per altri formati c'è un altro protocollo (MIME). Immagine convertita in ascii e poi riconvertita a destinazione.\nDi nuovo, i protocolli interni sono lenti a cambiare. piuttosto che modificare SMTP creo un altro protocollo a livello più alto.\n\nCome accedo alla posta? POP3 o IMAP, o addirittura HTTP se lo faccio da browser. non specifico quante connessioni apro.\n- POP3 porta 110 (slides), quando il client scarica i messaggi il server li cancella (posso non farlo togliendo comando dele). basta definire regole per comunicare. problemi: pensato per un solo client. se ne ho tanti devo sincronizzare tutto, ma è difficile senza stato. allora uso\n- IMAP, che tiene traccia dello stato (e.g. ci sono le cartelle tipo spam, i tag, ...), se faccio modifiche in locale viene aggiornata anche sugli altri client.\n- HTTP, l'agente è un browser\n\ninizialmente associavo mail ad ogni utente linux, ora no (?) (se uso postfix?) \"sono vago perché serve poco\".\n\nse uso thunderbird (IMAP) per mettere gmail (HTTP) posso trovare differenze in cose tipo la divisione in cartelle, i tag, ...\n\n\n\" a livello applicativo è abbastanza lasciato libero\"","x":-6571,"y":5780,"width":720,"height":596},
		{"id":"0efd970a1119442f","type":"text","text":"# FTP (Porte 20 e 21)\n\nParadigma ***client-server*** di tipo ***stateful*** basato su ***due connessioni TCP*** parallele:\n\n- **Connessione di Controllo (Porta 21)** - Resta sempre aperta (***persistente***), e viene usata per handshaking, autenticazione e scambio dei parametri della Connessione Dati (e.g. username e password, inizio e fine trasferimento dati, ...);\n- **Connessione Dati (Porta 20)** - Viene aperta dalla Connessione di Controllo ogniqualvolta sia necessario trasferire un file, e viene richiusa a trasmissione terminata (***non-persistente***).\n\nI parametri di controllo hanno una connessione dedicata e restano quindi separati dai dati. Questo schema è detto ***out-of-band***, e presenta diversi vantaggi:\n\n- per come è strutturato TCP è ottimale (poche connessioni, grandi quantità di dati);\n- posso abortire il download in caso di sovraccarico della rete;\n\t- protocolli in cui l'`abort` viene mandato nello stesso canale dei dati (**in-band**) come HTTP il segnale si perde nel traffico della rete.\n\nLato server, questo mantiene lo stato della connessione (directory di lavoro, autenticazione, ...) senza bisogno di cookies.\n\n\nper il resto è simile a smtp, http.\n\n\nSFTP, FTPS","x":-6571,"y":7590,"width":720,"height":660,"color":"3"},
		{"id":"6bf7cded55aa9efd","type":"file","file":"FTP.png","x":-7028,"y":8000,"width":400,"height":250},
		{"id":"bedf94234f8fbd9d","type":"text","text":"nel browser posso usare ftp (scrivendo `ftp:` al posto di `http:`).???????????????","x":-5805,"y":8079,"width":250,"height":171},
		{"id":"84d5d9e7cf116171","type":"text","text":"network time protocol\n","x":-5555,"y":7660,"width":250,"height":60},
		{"id":"2c357555847a692e","type":"text","text":"# DNS Overview\n\nI siti web sono hostati su server aventi un certo indirizzo IP. Questi però sono **difficili da ricordare** (e.g. 174.252.76.196) e **possono variare** (e.g. il sito può essere spostato su un altro server).\n\nInfatti nessuno usa gli indirizzi IP. Apro il browser e nel campo URL scrivo `google.com`. Come fa la rete a conoscere la locazione del server che hosta il sito che cerco?\n\nCon un servizio di ***traduzione dei nomi*** (semplici e fissi, utilizzabili dagli umani) ***in indirizzi IP*** (complessi e variabili, utilizzati dalla rete per indirizzare i datagrammi), detto ***Domain Name System (DNS)***. In pratica è una ***tabella di corrispondenze***, inizialmente ([RFC 882](https://www.rfc-editor.org/rfc/rfc882), 1983) contenuta in un singolo file (con allegato un povero cristo che la aggiornava).\n\nIn generale, il server DNS è quello che \"sa a chi devi chiedere\", e se non è direttamente il server che hosta il sito che cerchi sarà un altro server DNS che probabilmente ha le informazioni di tuo interesse.\n\nOggi ([RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) ed [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035), 1987) è un DB hostato su più server (***distribuito***) avente struttura ad albero (***gerarchico***). Con DNS si può intendere sia il DB che il protocollo applicazione che fa da DMBS.\n\n","x":-8860,"y":6740,"width":837,"height":532,"color":"4"},
		{"id":"6efc85167597eec6","type":"text","text":"# DNS (Porta 53)\n\nServizio (***client-server***) di ***traduzione dei nomi in indirizzi IP*** implementato tramite ***DB delocalizzato*** che sfrutta principalmente ***UDP***.","x":-8715,"y":6491,"width":548,"height":160,"color":"6"},
		{"id":"0d69bbc0efaf38ce","type":"text","text":"# Gerarchia DNS\n\nConsideriamo l'URL `www.uniroma1.it.`. Sì, in teoria ci sarebbe un punto alla fine. Perché? In generale, ***il punto divide i livelli gerarchici***. Leggiamo questo indirizzo da destra verso sinistra.\n\n- ***Root nameserver*** - Il punto finale si riferisce alla ***radice dell'albero*** gerarchico del DB distribuito, il *punto* (no pun intended) da cui devo partire per trovare il server che mi interessa. Ma non ho ancora fatto alcuna richiesta DNS, come faccio a sapere il suo IP?\n\t- Anzitutto, il root nameserver non è uno solo. Ci sono ***13 indirizzi IP standard*** (10 in USA, 2 in Europa, 1 in Giappone), che vengono inclusi nelle distribuzioni dei SO. Possono variare, ma succede poco spesso. Ovviamente se variano sta a me distributore di SO starci attento;\n\t- Quindi a questi 13 IP standard trovo 13 copie del root nameserver? No! ***Ad ognuno di questi 13 indirizzi è associato un gran numero di copie del root nameserver*** (stavolta sono davvero server fisici), a ognuno dei quali corrisponde un IP. In pratica, i 13 IP standard fanno da \"switch\", e **reindirizzano la richiesta a una di queste copie fisiche** del root nameserver;\n\t\t- Il numero esatto di copie fisiche associato a ciascun IP standard è molto variabile, orientativamente si va **da poche decine a diverse centinaia**;\n\t- ... e ***non sono gli unici***, sono solo quelli standard! Copie del contenuto dei root nameserver standard lo si trova in vari server sparsi per il mondo, per ridurre la latenza e il carico sul singolo server.\n- ***Top Level Domain (TLD)*** -  Subito sotto al root troviamo il primo macro-raggruppamento (e.g. `.it.`, `.com.`, ...). In pratica ci sono (gruppi di) server che gestiscono principalmente (... lo vediamo dopo) `.it`, altri che gestiscono principalmente `.com`, e così via. Il root nameserver ha quindi il compito di indirizzare la richiesta al giusto TLD, il quale a sua volta reindirizza la richiesta al giusto server Autoritativo, oppure al giusto SLD;\n- ***Second-Level Domain (SLD)*** - I livelli di dominio sono la profondità dell'albero DNS. Una foglia può trovarsi a profondità 2, ma anche a profondità 3. In quest'ultimo caso troviamo anche gli SLD. E potenzialmente oltre, ma non è interessante a livello concettuale. In `it.wikipedia.org.` dopo il root `.` e il TLD `.org.` `wikipedia.org.` è un SLD, ma manca ancora da risolvere il sottodominio `it.wikipedia.org.`. E chi lo risolve? L'Autoritativo!\n- ***Autoritativi*** - Server che hanno l'autorità di rispondere per un dato dominio, restituendone l'IP corretto. Sono in pratica le foglie dell'albero DNS.","x":-8860,"y":5580,"width":837,"height":842,"color":"4"},
		{"id":"2c547fef2c5dcf45","type":"text","text":"# Chi gestisce cosa?\n\n\nC'è tutta una questione di sicurezza, se si rompe il DNS si rompe tutto.\n\nICANN sono \"gentlemen agreement\" tra le varie nazioni. chi gestisce il TLD può fare quello che vuole (e.g. lo stato italiano può nazionalizzare il .it). Posso creare amazon.it e venderlo ad amazon.com? ... sì ma ci stanno le leggi sul copyright.\n\nogni organizzazione privata che mette a disposizione un server deve mettere a disposizione anche un dns server. in genere ce ne sono sempre due per protocollo (perché? boh!)\n","x":-7900,"y":5580,"width":460,"height":842},
		{"id":"ff62151f49666864","type":"text","text":"# Quanto conviene un proxy?\n\nDipende principalmente dal ***cache hit rate*** e ovviamente da quali sono i problemi da risolvere. In generale, è ottimo per la congestione di rete: sappiamo che se il traffico cresce troppo il ritardo medio in coda esplode, sgravare il server è sempre una buona idea.\n\nE perché non metto semplicemente dei cavi più grossi?\n\n- il proxy è *mediamente* più economico;\n- il proxy ha prestazioni *mediamente* migliori.\n\nMa *mediamente* è una roba teorica che in pratica significa \"sempre\"? No, **bisogna fare i conti**. Magari scopri che il cavo più grosso serve davvero. E comunque fare i conti non basta, perché sono una roba teorica e l'unico dato attendibile è la misura delle prestazioni. Il proxy è un'ottima soluzione ma non è la panacea di tutti i mali.\n\nSicuramente è indicativo che ISP come Netflix scelgano di hostare i film italiani su un proxy in Italia (\"magari non in Antartide\"). O magari su più proxy in Italia.\n\nUn buon proxy cerca di imparare cosa chiede la platea nella zona che deve servire.\n\n","x":-9718,"y":7725,"width":700,"height":560,"color":"4"},
		{"id":"0b031d2a05976038","type":"file","file":"proxy.png","x":-10370,"y":7778,"width":359,"height":454},
		{"id":"2a51de9d069e3b02","type":"file","file":"GerarchiaDNS.png","x":-8860,"y":5340,"width":837,"height":191},
		{"id":"d9218fbe64e55603","type":"text","text":"# La mia prima query DNS\n\nIpotizziamo di cercare un sito appena creato (e.g. `gaia.cs.umass.edu.`), di cui nessuno sa niente se non l'Autoritativo corrispondente. Ho due modi di effettuare la ricerca.\n\n- ***Query Iterativa*** - Vado da `root`, il quale risponde \"ti dico dove sta `.edu`\". Vado da `.edu` (TLD), il quale risponde con l'indirizzo di `umass.edu`. Sicuramente è un SLD, se mi va bene è anche autoritativo. Dipende da cosa mi risponde. Nel peggiore dei casi mi risponde con l'IP di `cs.umass.edu`, il quale a questo punto dovrebbe essere Autoritativo, e in quanto tale avere gli indirizzi di tutti i sottodomini di tipo `*.cs.umass.edu.`;\n\t- Il **peso della ricerca** sta tutto **sul client**, o sul suo DNS locale;\n- ***Query Ricorsiva*** - Vado da `root`, chiedendogli con un'apposita flag di \"vedersela lui\" e darmi la risposta definitiva quando ha risolto. Lui prende in carico la mia richiesta e contatta il TLD, dicendogli la stessa cosa. In generale, ogni server contattato deve fare da sé, risolvendo personalmente la richiesta per conto di chi la fa.\n\t- Il **peso della ricerca** va **sulla rete**;\n\t- Sovraccarica `root`, motivo per cui non si dovrebbe fare;\n\t- Anche provandoci, ***probabilmente root risponderà iterativo***. Il protocollo **DNS non obbliga i nameserver a rispondere con la ricorsione**;\n\t- Se volevo la ricorsione e `root` mi risponde solo `.edu` allora la ricerca fallisce? No, semplicemente mi metto l'anima in pace e contatto `.edu`.","x":-9718,"y":4780,"width":700,"height":751,"color":"4"},
		{"id":"f4a58217f873b504","type":"text","text":"# Protocollo DNS\n\nQuery e risposte DNS hanno lo stesso formato.\n\n","x":-10539,"y":6880,"width":700,"height":532},
		{"id":"0bcac05d389026f2","type":"text","text":"# Query DNS","x":-9476,"y":5971,"width":216,"height":60,"color":"6"},
		{"id":"c2f115d30b383cd0","type":"text","text":"# Altri usi dei Proxy Server?\n\n- sicurezza\n- load balancing","x":-10541,"y":8261,"width":700,"height":320},
		{"id":"c242d9b28161dee6","type":"text","text":"localhost -> IP loopback solitamente `127.0.0.1`","x":-10791,"y":7846,"width":250,"height":171},
		{"id":"5b4a906a7f7134ec","type":"text","text":"\n***header***: insieme di campi che danno informazioni al destinatario. non fa parte dell'incapsulamento (leggo-distruggo-replace), ***payload*** del (parte del messaggio visto dal) livello sottostante, non cambia (resta leggibile","x":-12960,"y":7565,"width":250,"height":367},
		{"id":"29e96eab29abd54f","type":"text","text":"# Glossario dei Protocolli di alto livello\n\n- **_Handshaking_** - La danza rituale per aprire una connessione TCP. Tipicamente il client manda al server una richiesta di connessione, il quale tipicamente risponde con un OK. Il canale di comunicazione è nato, evviva! Tutto questo impiega almeno un RTT; \n- ***Round Trip Time (RTT)*** - tempo impiegato da un pacchetto di \"piccole dimensioni\" (idealmente un solo bit, in modo tale che $D_t \\sim 0$) per compiere il percorso client-server-client;\n- ***Request For Comments (RFC)*** - quando i primi sviluppatori ideavano un protocollo in ambito accademico, lo condividevano in cerca di feedback. Questa etichetta nel tempo è diventata il nome dei documenti definitivi che standardizzano i protocolli;\n- ***Stateless*** - protocollo che non conserva informazioni sulle interazioni passate;\n- ***Uniform Resource Identifier (URI)*** - convenzione standard per identificare univocamente le risorse su Internet. Può essere di diversi tipi:\n\t- ***Uniform Resource Locator (URL)*** - Specifica sia l'indirizzo della risorsa sia le istruzioni per accedervi. Consta di tre parti:\n\t\t- Il protocollo da utilizzare per stabilire una comunicazione con l'host della risorsa (HTTP, FTP, SSH, SMTP, ...);\n\t\t- Il nome dell'host, eventualmente da risolvere tramite ricerca DNS per trovare l'IP corrispondente;\n\t\t- Il percorso della risorsa all'interno dell'host.\n\t- ***Uniform Resource Name (URN)*** - Associa ad una risorsa un identificatore persistente e univoco, indipendentemente dalla sua posizione o raggiungibilità tramite URL, esattamente come un libro è identificato univocamente dal suo codice *ISBN (International Standard Book Number)* $\\Rightarrow$ `urn:isbn:0451450525313`. Va registrato presso l'altisonante *Internet Engineering Task Force (IETF)*, e immagino uno debba avere un buon motivo per farlo (?)\n\t- Se so per certo di essere, ad esempio, all'interno di un server, anche un **_path relativo_** è considerabile un URI. In questo senso, un URL è un path assoluto;\n\t- Contesti più specifici possono definire dei propri URI (e.g. il **_File URI_** viene usato dai browser per accedere ai file locali dell'utente);","x":-13880,"y":6960,"width":758,"height":837,"color":"4"},
		{"id":"807b9ea551e9eb4a","type":"text","text":"# DNS Locale\n\nIl client non si interfaccia direttamente con l'albero DNS, ma piuttosto usa un ***server DNS locale***.\n\nIn pratica, non serve partire ogni volta da `root`: il DNS locale potrebbe avere ciò che cerco in cache. Se così non è, si occupa di risolvere la ricerca al posto del client.\n\nPartendo da `root`? No, partendo dal basso! Non voglio sovraccaricarlo, quindi chiedo prima a SLD. Se non ne sa niente (ovvero, non ha quel valore in cache e non gestisce quei domini) risponde una roba tipo \"`boh!`\", e il DNS locale capisce che deve salire di livello, dal TLD. Se anche questo non sa niente ovviamente arrivo da `root`, dal quale sicuramente qualcosa trovo.\n\nBene, ma chi è il DNS locale?\n\n- La situazione più comune è che lo fornisca l'ISP tramite il primo accesso alla rete (hop). Nel caso domestico, il router (e.g. Fastweb `192.168.1.254`) reindirizza le richieste effettuate nella LAN al server DNS proprietario dell'ISP (e.g. Fastweb `85.18.200.200`);\n- In alternativa, posso impostarlo manualmente come parametro della connessione, specificando ad esempio `8.8.8.8` (nameserver offerto da Google);\n- Posso implementare un server DNS direttamente su `localhost`, ovvero il mio stesso computer (raggiungibile attraverso l'indirizzo IP loopback `127.0.0.1`)\n\nIl DNS locale ***non fa parte dell'albero gerarchico DNS***, piuttosto ***è un servizio*** per interagire con esso. Uno potrebbe allora chiedersi cosa ci guadagna ad avere un DNS locale.\n\n- Tu che lo usi hai una cache vicinissima, e ti fa comodo perché diminuisce la latenza. Inoltre, in sua assenza dovresti fare \"a mano\" con `localhost`, e scopriresti ti toccherebbe scrivere e runnare un sacco di roba;\n- La rete è contenta perché così decentralizza il DB DNS, sgravando i server \"standard\";\n- L'ISP che te lo offre apprende cosa cerchi, che nel dubbio male non le fa.\n","x":-11469,"y":4780,"width":806,"height":751,"color":"4"},
		{"id":"2cf0e73ceaebad33","type":"text","text":"# Cache DNS\n\nNel mondo reale i server hanno una ***cache***. Questo significa che già il root nameserver potrebbe rispondere subito con l'IP che mi interessa.\n\nLa garanzia che la risposta che mi arriva sia corretta me la dà solo l'Autoritativo associato a quell'IP. Un qualsiasi altro server che risponde al suo posto (e.g. `.com` mi restituisce l'IP di `uniroma.it`) è tenuto a specificare che non è l'Autoritativo per quell'IP (della serie, mette le mani avanti e ti dice che non è responsabile).\n\nQueste cache si aggiornano principalmente mediante ***TTL***, motivo per cui un server non-autoritativo può restituire una risposta obsoleta (anche ***DNS è best-effort***).\n\nLa durata dei TTL varia tipicamente tra i pochi minuti e i giorni/settimane, dipende molto dalle esigenze. Se ho fretta, esistono operazioni di *purge* (offerte dalla singola applicazione server e non incluse nel protocollo DNS) che permettono di svuotare manualmente le cache. Se mando un comando del genere lato client, i tempi tipici di propagazione di questa informazione sulla rete sono dell'ordine dei 5/10 minuti. Altrimenti, posso sempre settare un TTL molto breve (e.g. pochi secondi). In teoria potrebbe creare problemi all'intera rete, ma in genere regge bene.\n\nQuesto ovviamente senza contare che la cache potrebbe riempirsi, e gli oggetti al suo interno venire scartati prima della scadenza del TTL. Oppure potrebbe essere il server stesso ad avere come politica un timeout per gli oggetti in cache.\n\nAlla perdita di un dato cache, il DNS potrebbe richiederlo subito al livello superiore oppure attendere che venga richiesto lato client, dipende dall'implementazione.\n","x":-10539,"y":5668,"width":700,"height":667,"color":"#006400"},
		{"id":"84caca764ec7fb4e","type":"text","text":"# Server DNS","x":-10302,"y":6541,"width":223,"height":60,"color":"6"},
		{"id":"b99dcc266569a95d","type":"file","file":"DNSRicorsivo.png","x":-10426,"y":5242,"width":475,"height":289},
		{"id":"4694cc6e9478ff73","type":"file","file":"DNSIterativo.png","x":-10426,"y":4780,"width":475,"height":304},
		{"id":"d9194ed55437e184","type":"text","text":"# Registrar DNS\n\nSe voglio includere il mio sito (e.g. `cacciacapitale.it`) hostato sul mio personalissimo server nelle ricerche DNS devo fornire al ***registrar DNS*** gli indirizzi di due DNS Autoritativi per il mio dominio, detti **glue**, il quale li inserisce nel server TLD corrispondente (e.g. `.it`). Se il server non-autoritativo risponde con un oggetto in cache deve fornire anche i glue.\n\nIn alternativa posso pagare qualcuno che lo fa al posto mio. Spesso si fa per il mail server `MX` con un `CNAME` che punta a Cloudfare\n\n???????","x":-8860,"y":4780,"width":837,"height":391,"color":"3"},
		{"id":"a290001f0c2b618c","type":"text","text":"# PROVA NSLOOKUP!","x":-8651,"y":5200,"width":419,"height":90},
		{"id":"12862795d7c14b6d","type":"text","text":"# Restrizioni (aggiorna slides domani?)","x":-11845,"y":5580,"width":315,"height":209},
		{"id":"bd9ffece9b4d9aa9","type":"text","text":"# Record DNS\n\nCome ogni DB, anche DNS ha un formato standard per i record: `(name, value, type, ttl)`.\nIl valore dominante è `type`, al variare del quale gli altri valori cambiano di significato.\n\n- `type = A` - un record di tipo ***address*** associa il campo `A_name` all'IP corrispondente (nel campo `A_value`). Intuitivamente, è lo step finale della ricerca DNS: se trovo questo ho vinto;\n- `type = NS` - un record di tipo ***name server*** è un reindirizzamento ad un altro server DNS. Se trovo questo, il server mi sta dicendo una cosa del tipo \"se stai cercando il dominio `NS_name`, dovresti chiedere al nameserver `NS_value`\". Verosimilmente, oltre a questo mi darà anche un record di tipo address il cui campo `A_name` è il nameserver a cui chiedere (`NS_value`) e il cui campo `A_value` è il suo indirizzo IP;\n- `type = CNAME` - un record di tipo ***alias*** mi dice che \"in nome `CNAME_value` che mi hai dato è un nickname, quello che cerchi in realtà si chiama `CNAME_value`\";\n\t- Il \"vero\" nome del server è detto ***nome canonico***; \n\t- Un alias fa puntare più sottodomini allo stesso server (gestisco solo il nome canonico);\n\t- Un `CNAME` può puntare ad un altro `CNAME`, ma sarebbe buona norma evitarlo;\n\n- `type = MX` - un record di tipo ***mail server*** richiede esplicitamente il mail server associato al nome. dovrebbe essere sempre usato su un nome canonico, ma non sempre succede (???)","x":-11472,"y":6041,"width":806,"height":530,"color":"4"},
		{"id":"f10a4ae200557701","type":"text","text":"se voglio mat.uniroma1, phys.uniroma1, ... devo fornire diversi CNAME. se però faccio così mappo tutto su un unico server. utile perché se cambia cambio solo il canonico. ","x":-11480,"y":5700,"width":414,"height":257},
		{"id":"937953a052fa5efa","type":"file","file":"Screenshot from 2024-04-08 21-29-11.png","x":-12280,"y":5759,"width":400,"height":243},
		{"id":"bbe47f0bdff82cd9","type":"text","text":"# Vedi ultime slides 08 NEW","x":-12960,"y":6240,"width":461,"height":163,"color":"1"},
		{"id":"a0476a2b8399dc67","type":"text","text":"# Cosa posso fare con DNS?\n\n- Aliasing -  hostname canonico è il \"vero\" nome, sotto al quale c'è l'ip, ma poi a questo collego gli alias. in questo modo se cambio ip lo cambio solo al nome canonico. Se cambio IP in teoria dovrei avvisare tutti i DB e cambiarlo, ma non succede. Ogni associazione ha un TTL che alla scadenza chiede al proprietario del dominio dove sta.\n- LOAD BALANCING: il sito viene sdoppiato su più server. Nel DNS li associo tutti e a chi lo chiede dò una lista random. qualunque metodo scelgo io richiedente resta random, a meno che non conosco il loro seed di randomizzazione.\n","x":-9718,"y":6740,"width":700,"height":405},
		{"id":"29e1d3a847d6212b","type":"file","file":"Screenshot from 2024-04-09 01-46-25.png","x":-9718,"y":7243,"width":699,"height":338},
		{"id":"06b8d6a48ee1e326","type":"text","text":"# Vincoli\n§ CNAME non può coesistere con altri record di altro tipo per lo stesso\ndominio: non posso avere un record A e un record CNAME per lo\nstesso (sub)dominio nella stessa tabella\n§ CNAME non può essere usato nei domini di root. Quindi il DNS\nserver di example.com NON può contenere:\nexample.com.\nCNAME\nalias.example.net.\n§ Se si tengono in cache valori di un server non di competenza,\nbisogna anche fornire il NS autoritativo quando rispondiamo a una\nquery\n§ Raccomandati\n• MX dovrebbe essere usato su un nome canonico e non un CNAME\n• quando si fornisce il NS di un server autoritativo, bisogna anche fornire il\nrecord A (glue) per evitare riferimenti circolari","x":-13820,"y":6080,"width":677,"height":530},
		{"id":"3c95ceb1f8d66d4b","type":"text","text":"# rappresentazione domini \n\nho due modi di rappresentare i domini\n- assoluti (rispetto alla root), in teoria terminano con un punto (e.g. google.com.)\n- relativi (alla locazione in cui sono), se sono connesso a di.uniroma1.it va a cercare in di.","x":-12041,"y":6041,"width":393,"height":354},
		{"id":"dadc08ce77ef0c49","type":"text","text":"dns potrebbe essere usato come controllo blocchi (dare not found per certi ip), però se chiedo a root bypassando il locale lo frego","x":-11812,"y":6920,"width":329,"height":144},
		{"id":"60429356d103493a","type":"text","text":"# DNS e Sicurezza\n\nIn genere a tutti conviene che DNS funzioni, motivo per cui gli attacchi (DDoS) diretti ai nameserver sono limitati. Anche provandoci, i `root` sono protetti dal filtraggio del traffico (gli altri server hanno la cache). Sui TLD è potenzialmente più pericoloso (?)\n\nQuello che si può invece fare è sfruttare DNS per azioni illecite. Come?\n\n- ***man-in-the-middle*** - intercetto le query DNS (e che ci faccio????);\n- ***poisoning*** - mando risposte sbagliate ai server DNS, che le mettono in cache. Questo potenzialmente mi permette di reindirizzare delle richieste safe sul mio sito malevolo;\n- ***DDoS***- posso inviare query DNS falsificando l'IP di origine (***spoofing***), indirizzando le risposte DNS a chi voglio io (***reflection***). Con una singola richiesta non risolvo niente, ma esiste l'opzione `ANY`, che fa rispondere il nameserver con tutti i record relativi al dominio richiesto (e.g. chiedo `example.com` e mi arrivano tutti i `.com` che ha????). Questi due ingredienti insieme mi permettono in linea di principio di cucinare un DDoS, ma\n\t- se un IP `100.x.x.x` manda una richiesta specificando come mittente `200.x.x.x`, la rete locale dovrebbe essere in grado di riconoscerlo (Chi??? Come???);\n\t- il nameserver può essere impostato per non rispondere a richieste di tipo `ANY`.","x":-11472,"y":6616,"width":806,"height":530,"color":"#4545ff"},
		{"id":"6e7c8cc6c0993984","type":"text","text":"Livello un po' filosofico, né HW né SW","x":-3000,"y":3920,"width":250,"height":105},
		{"id":"b356a8ba2ad031a0","type":"text","text":"# Rete\n\ntutte le macchine di rete devono avere questo livello per inoltrare i pacchetti -> necessario per stare su una rete (obv). diviso in due parti\n\n- piano dei dati (data plane) - livello locale, ogni router deve sapere implementare queste funzioni. riceve datagamma da una porta e deve sapere da che porta farlo uscire (Tabella);\n- control plane - la visione globale, che definisce gli algoritmi di routing. a sua volta può essere implementato\n\t- nei singoli router, in cui è una tabella con tutti gli ip e le porte corrispondenti, che risolve il forwarding. ogni router fa girare un pezzetto di un algoritmo distribuito (basato su scambi di messaggi tra nodi), che ha come output la modifica di questa tabella. è responsabile dalla propria tabella ma influenza i vicini (in quanto distribuito). rischio loop di configurazione\n\t- nei server (SDN), lo stesso algoritmo, ma centralizzato. Remoto. Conosce tutte le tabelle. non rischio loop. Dentro un singolo ISP posso fare tutto centralizzato. faccio copie di questo supercomputer per sicurezza.\n\nspostiamoci nel nucleo di rete e programmiamo i router.\n\n\"il router è più un forwarder che un router\".  keep router simple, basta la tabella di corrispondenze, ma come passo da comportamento locale a globale?\n\nl'autostrada dei pacchetti può essere modificata live (Negli anni 50 si faceva a mano), ma facciamo un passo indietro.\n\novviamente è best effort.\nci sono stati tentativi di implementazione di rete che offra qualche servizio, ma non hanno funzionato. Ma alla fine scialla, è semplice! non serve HW particolare.\n\nse la rete soffre faccio caching. insomma, un modo lo trovo senza cambiare IP. \"ormai è così, chi è che si mette a cambiare tutto?\"","x":-2353,"y":3280,"width":713,"height":940},
		{"id":"7f27ffe9c326e924","type":"text","text":"# Il router\n\nnon ti impelagare sui dettagli, cambiano ogni anno\n\nrouter = device che opera a livello di rete (-> lavora sugli IP).\nprende decisioni in O(ns). embedded, hw specifico, oppure lato sw ma sono lentissimi. banda O(Tbit/s), centinaia di porte. SW si occupa di settare tabelle. rosso rete blu collegamento verde fisico (slides????).\nogni cavo ha la propria implementazione di collegamento/fisico. in pratica in genere i cavi sono tutti uguali.\n\nguardo IP e decido la porta. oppure leggo intestazioni (e.g. se l'IP sorgente è bannato, butta il pacchetto (firewall)).\n\nIPv4: 2^32 possibili destinazioni. Posso costruire IP in modo gerarchico. primi bit identificano \"macrorete\" in cui indirizzo il pacchetto.\n\nnella tabella dovrei andare in ordine e specificare i range di IP che forwardo dove (non è velocissimo da valutare), altrimenti ***match del prefisso più lungo*** è più rapido (1clock per certi HW) e semplifica la tabella. insomma tocca lavorare con O(10^6) voci da risolvere in O(ns).\n\nswitching fabric deve andare a N volte il rate se ci sono N ingressi ed N uscite. se lo fa, si dice non blocking. altrimenti (blocking): se il router rallenta rispetto alla velocità del cavo (non dovrebbe diventare il bottlenek!) se il router è blocking la coda è in ingresso (vecchi router, non succede più), se il bottleneck è il cavo di uscita la coda è in uscita.\n\nprimi SF erano computer linux scritti in assembly (openwrt (?) fa così). altrimenti BUS, altrimenti tanti bus (reti di interconnessione). idealmente sarebbe matrice NxN ma poi scala quadratica, allora uso struttura gerarchica. a livello hw il datagramma viene frammentato e ricomposto a destinazione (uscita). perché? per parallelizzare la trasmissione dei singoli bit. ogni datagramma subisce questa cosa in un fabric plane, e ce ne sono molteplici disponibilii.\n\nad ogni porta associo una velocità ($\\sum$ = NR).\n\nbuffer enorme non migliora, aumenta attesa in coda e il router di prima ritrasmette. come li gestisco? se lo costruisco ho un po' di gioco su chi favorire, ma rischio congestione e/o non-neutralità della rete.\n\npotrei garantire una bandwidth per una certa classe (e.g. voice over IP)\n\n","x":-1520,"y":4220,"width":681,"height":1060},
		{"id":"23a2937e757042d7","type":"text","text":"# IP\n\nriguarda il formato del datagramma e come strutturare gli indirizzi e come frammentare i pacchetti se non entrano in un solo datagramma (MAC address \"applicato a tutto il mondo\", dice quello che ha già hackerato la NASA).\n\nniente nel protocollo IP richiede che l'indirizzo IP sia unico! :)\nIl primo che raggiungo è quello a cui mando il pacchetto. oppure no.\n\nalcuni ip non sono reali ma virtuali (255.255.255.255 è broadcast, ovver \"mandalo ovunque\". Se il router è configurato per farlo, lo manderà a chiunque nella sottorete (non in giro per internet!). Sulle reti locali è usato spesso).\n\nvedi slides","x":-1139,"y":3320,"width":600,"height":820},
		{"id":"447f8e71a756c709","type":"text","text":"# ICMP\n\ncostruito direttamente su IP. Il suo payload va direttamente su IP. Serve tendenzialmente a comunicare tra il router e chi gli ha mandato il pacchetto. in pratica gestisce gli errori. dice qualcosa rispetto al pacchetto IP mandato in precedenza.\n\nmessaggi importanti: richiesta eco (\"voglio sapere se ci sei\") e risposta eco (\"ci sono\"). \\[Questi ping sono a livello ICMP (esistono anche quelli a livello UDP)\\].\nanche TTL scaduto e porta irraggiungibile ()\"guarda che su questa porta non c'è alcun servizio\", può essere usato per...?).\nTraceroute è un abuso di ICMP: datagrammi UDP con un numero di porta tipicamente non usato per UDP. Prima mando TTL = 1, il primo router lo scarta e risponde ICMP, il che include l'IP del router che l'ha scartato. e così via. quando arrivo a destinazione, il server non ha un servizio attivo su quella porta. Quindi ricevo un \"porta irraggiungibile\" e so di aver finito. Così trovo la gente anche se non accetta i ping. I router possono anche decidere di non rispondere. Qui non sto mandando ping, sono loro che decidono di rispondere al fatto che un pacchetto è stato scartato. Ci sono altre N cose da sfruttare per costruire servizi sfruttando l'architettura di rete.\n\nesiste, un po' diverso, anche a livello di IPv6. Utile perché non essendoci frammentazione voglio trovare l'MTU minimo, c'è un algoritmo per trovarlo usando ICMPv6 (PathMTUDiscovery)","x":-1139,"y":2500,"width":600,"height":713},
		{"id":"ad79665cff57c7f0","type":"text","text":"# UDP\n\ndns gira su udp perché evita il traffico e i vari handshaking di tcp.\n\nper dns non ha senso il concetto di connessione, perché è stateless.","x":-10916,"y":7221,"width":250,"height":383},
		{"id":"595d6fa8c5535979","type":"text","text":"# Su cosa appoggio il mio protocollo Applicazione?","x":-5386,"y":8165,"width":310,"height":128,"color":"6"},
		{"id":"ba32fe7205e2606f","type":"text","text":"# Guida alla scelta tra TCP e UDP\n\n- **_TCP_** - è il *lawful good* della situazione. \"Prima creiamo una connessione, dichiarando chi parla e chi ascolta (paradigma mittente-destinatario) ognuno con le rispettive informazioni (***handshaking***), poi parliamo\"\n\t- ***Garantisce l'arrivo dei pacchetti in ordine***;\n\t- Implementa dei controlli di non-congestione sull'utente (***controllo di flusso***) e sulla rete (***controllo della congestione***). In pratica evita il sovraccarico di rete aggiustando le velocità delle singole connessioni a seconda del livello di riempimento dei router, evitando che si blocchi tutto e che le informazioni si perdano;\n\t- NON dà garanzie di velocità (da bravo *lawful good*, \"chi va piano...\"). In ogni caso, se uso commutazione di pacchetto dovrei già sapere che latenza e throughput non possono mai essere garantiti;\n\t- Ogni servizio offerto da TCP aggiunge complessità, ritardi e overhead computazionale.\n\t- Utile in situazioni in cui mi interessa l'affidabilità piuttosto che la velocità (e.g. caricamento di pagine web, transazioni bancarie).\n\n- **_UDP_** - è ovviamente *chaotic evil*. \"Io ci provo a trasmettere i dati, poi se succede qualcosa non guardare me... da parte mia best effort fratello\"\n\t- Non crea alcuna connessione, non c'è nessun paradigma: se il destinatario è in ascolto, si vede semplicemente recapitare un pacchetto UDP;\n\t- Visto che non perdo tempo a creare la connessione, UDP può essere molto veloce... se il pacchetto arriva a destinazione. UDP non offre nessuna garanzia in tal senso;\n\t- Perché mai dovrei usare UDP se non garantisce niente?\n\t\t- Se non mi interessa che ogni tanto si perdano dei dati (e.g. streaming) sfrutto un servizio statisticamente più veloce;\n\t\t- Se mi interessa posso sempre costruire il mio trasporto affidabile a livello di Applicazione e poi usare UDP perché è più veloce di TCP. Questa è in generale una tendenza degli ultimi anni: implementare regole a livello applicazione senza cambiare i protocolli più bassi.","x":-4920,"y":8000,"width":656,"height":938,"color":"4"},
		{"id":"6f3226cdbb9850aa","type":"text","text":"# Servizi del Trasporto\n\nOffrono all'Applicazione un canale di comunicazione logico: dal su punto di vista è come se i vari livelli di Trasporto siano connessi (poi come succede non è affar suo). Dal punto di vista del Trasporto, è sufficiente sapere come inviare i messaggi in qualche modo arrivino a destinazione.\n\n","x":-4138,"y":6849,"width":688,"height":191},
		{"id":"34401d45639b449d","type":"text","text":"# Livello di Trasporto","x":-3964,"y":6671,"width":341,"height":50,"color":"6"},
		{"id":"010165be9fd56b6c","type":"text","text":"# Livello di Rete","x":-3055,"y":3630,"width":264,"height":50,"color":"6"},
		{"id":"9727e675784a8b75","type":"text","text":"**Load Balancer (Bilanciatore di Carico)**: Immagina che stai lanciando una festa e hai molte persone che vogliono entrare. Un \"load balancer\" è come il tipo che controlla l'ingresso e distribuisce le persone in modo uniforme in modo che non ci sia troppa confusione in una zona. Nei server, il load balancer fa lo stesso, distribuendo il traffico in modo equo tra diversi server, in modo che nessun server sia sovraccaricato.","x":-2400,"y":7040,"width":468,"height":491},
		{"id":"78a5ab219227020b","type":"text","text":"# Protocolli del Trasporto","x":-3988,"y":8439,"width":388,"height":60,"color":"6"},
		{"id":"1a7e522c18045e6d","type":"text","text":"# (De)multiplexing\n\nTCP/IP prevede più protocolli per uno stesso layer, da cui la domanda: se a TCP arriva un segmento, come fa a sapere a quale protocollo del livello Applicazione (e.g. HTTP, FTP, SMTP, DNS, ...) consegnarlo?\n\nDomanda importante, visto che se consegno un messaggio in formalismo HTTP a un processo che parla la lingua dei DNS quest'ultimo non capisce niente.\n\nEssendo il layer inferiore ad offrire il servizio, quando TCP riceve un messaggio dall'Applicazione scrive nell'header qual è il protocollo che lo ha generato (e.g. HTML, FTP, ...). In questo modo a destinazione può comodamente leggere il proprio header e scegliere a quale protocollo Applicazione consegnare i dati.\n\nIn pratica, qualsiasi protocollo può mandare pacchetti a TCP, al quale non importa niente del protocollo sovrastante.\n\nIn generale, ogni protocollo del trasporto deve essere in grado di **gestire** (incapsulare, sempre uno alla volta) i **pacchetti ricevuti da più protocolli presenti al livello Applicazione** mantenendo le informazioni sulla sorgente (**_multiplexing_**) per poi eseguire l'**operazione inversa** a destinazione tramite l'informazione mantenuta nell'header, ovvero decapsulare e consegnare i pacchetti a più protocolli del livello superiore (**_demultiplexing_**).\n\nBello, ma come lo implemento? Scrivo nell'header \"HTTP\" e poi...?\n\nNo, nell'header ci scrivo dei codici standard (**_porte_**), che individuano un canale di comunicazione standard usato da un certo protocollo. Ad esempio, il protocollo HTTP leggerà di default le informazioni che arrivano sulla porta 80 ($\\Rightarrow$ 80 è il valore corrispondente al campo adeguato dell'header di trasporto).\n\nDetto questo, nel caso di TCP si parla di **_(de)multiplexing protocollare_** (potremmo dire _logico_ o *virtuale*, in quanto avviene a livello software), ed è associato principalmente al livello di Trasporto.\n\nIl (de)multiplexing _**non**_ avviene solo a livello di Trasporto, ma i layer inferiori (e.g. Rete) possono implementarne delle versioni un po' più fisiche (**_qua dovresti entrare un minimo nel dettaglio perché non ti sei capito nemmeno da solo_**)","x":-3273,"y":5948,"width":700,"height":1092,"color":"3"},
		{"id":"cfd8a6577c228df0","type":"text","text":"\n\nUDP è un portiere che \"non fa niente\", se non il (de)multiplexing.\n\ni due socket UDP non devono avere per forza lo stesso numero di porta. devo conoscere quella del processo a cui invio però.\n\nil numero di porta è una convenzione, il SO ha una lista di quelle standard (80 HTTP, ma se la cambio funziona lo stesso)\n\nper il demultiplexing UDP basta la porta, in pratica, perché è stateless\nuno che ascolta sempre su un canale (porta), gente che quando vuole può parlare dicendo una parola alla volta\n\nil socket TCP vuole stabilire una connessione, quindi gli servono \n\n- indirizzo IP di origine\n- numero di porta di origine\n- indirizzo IP di destinazione\n- numero di porta di destinazione\n\nregola per mappare i pacchetti al processo.\nperché metto anche l'IP? anche per aumentare lo spazio dei socket (avere più scelte per demultiplare).\n\nPosso mentire sul mio IP sorgente? (direi in UDP sì e sta alla rete controllare che io non faccia cose strane) ma non lo mette UDP nell'header mi sa, sta alla rete temo\nPiù processi che si aspettano HTTP (e.g. firefox e chrome) lo fanno sullo stesso socket? c'è un ulteriore demux? uno dei due è forzato a cambiare porta (tanto è TCP)? (secondo me ognuno apre un socket)\n\n","x":-3342,"y":7221,"width":820,"height":699},
		{"id":"2df2877d35b32cbf","type":"text","text":"# RDT (Reliable Data Transfer)\n\nCosa mi serve per implementare un trasferimento affidabile dei pacchetti?\n\nDevo gestire problemi come perdita o danneggiamento dei dati. Costruiamolo da zero. Partiamo da assunzioni ideali e poi rilassiamo un pezzetto alla volta.\n\n\n\n###### Canale perfetto (completamente affidabile)\nAssunzione monodirezionale: il dato va solo in una direzione, ma l'informazione di ricezione deve tornare indietro, anche con una connessione non affidabile.\nSe lo voglio simmetrico devo farne due.\nSe il canale inaffidabile ha problemi devo risolverli. \nLe uniche info che hanno mittente e destinatario sono i pacchetti che ricevono!! Ci sono alcuni messaggi che ricevo che possono corrispondere a più stati dietro la tenda. Cerchiamo di massimizzare la probabilità di comprendere cosa accade dove non vediamo.\nUDT (Unreliable...)\nnon c'è una corrispondenza 1:1 tra i pacchetti scambiati e ricevuti.\nDevo creare 2 protocolli: invio e ricezione.\n\n###### RDT 1.0\nnessun problema. costruisco una FSM per mittente e destinatario\nl'unico stato è di costante attesa, per il mittente dal livello applicativo, per il receiver dai livelli sottostanti. Se ricevo chiamata RDT eseguo le azioni e torno in attesa.\n\n###### RDT 2.0 (BIT FLIP)\n**_Assumiamo di poter rilevare gli errori_**. \"Puoi ripetere?\". Ipotesi di stop-and-wait.\nSender: ora ho due stati: attesa dall'Applicazione o attesa ACK, NAK. Lambda è un modo per dire \"nessuna azione\".\nReceiver: sempre uno stato, ma ci sono due possibili frecce (Azioni): ACK e NAK.\nProblema: chi mi dice che ACK/NAK non sia corrotto? So solo quello che ricevo! in situazioni complicate potrei andare fuori sync perché non so cosa si aspettano gli altri. Sottoproblema: se invio ACK ma sender riceve NAK quello rimanda il pacchetto, e il destinatario per ora non sa che è lo stesso (si potrebbe mettere un numero di sequenza (che in questo caso è tipo un solo bit, perché faccio stop and wait))\nProblema2: potrei entrare in un loop infinito, ma è inevitabile\n\nConvenzione: il numero di riscontro (ack) indica sempre il numero di\nsequenza del prossimo pacchetto atteso dal destinatario\n###### RDT 2.1 (GESTIRE ACK E NAK CORROTTI)\nse ACK/NAK è corrotto non so cos'è, so che mi è stato detto qualcosa ma non so cosa. call 1 e call 0 si riferisce al bit del numero di sequenza (basta quello perché ho stop and wait).\n\n\n###### RDT 2.2 (solo con gli ACK)\nnon entriamo nel dettaglio. mi dici solo se hai capito, l'ACK ha un numero di sequenza esplicito. **_Lo implementa TCP._**.\nChe vantaggio ho ad essere privo di NAK?\n\n#### RDT 3.0 (PERDITE)\nServono dei timeout oltre i quali se non arriva risposta considero il pacchetto perso.\nQuesto potenzialmente mi fa perdere la sincronizzazione, a maggior ragione mi serve il numero di sequenza nell'ACK.\nSe assumo pacchetto perso ignoro controllo errori. Per semplificare protocollo posso trattare allo stesso modo pacchetti persi e corrotti (ovvero: se arriva un ACK corrotto lo ignoro, tanto scatterà il timer, ci rimette un po' in efficienza, TCP è stato migliorato in questo senso).\nSono ancora in regime stop-and-wait, e questo è un enorme spreco per le capacità del cavo. Allora faccio **_PIPELINING_**.\n\n\n#### Oltre RDT 3.0\nMando più pacchetti prima di aver ricevuto l'ACK del primo. Il protocollo va solo aggiustato per gestire più di un messaggio alla volta","x":-3276,"y":8672,"width":688,"height":1896},
		{"id":"621da05b43f27ecc","type":"text","text":"# Varie\n\nPosso manovrare ad hoc il checksum per far apparire un pacchetto autentico e fare injection","x":-2398,"y":9582,"width":617,"height":600},
		{"id":"4b0440947706cde0","type":"text","text":"\ncomuni con complicazioni sw. API socket -> mi servono i servizi del livello sotto per funzionare, sono interessato solo a cosa posso usare. creare un'app a questo livello ignora la complessità della rete (percorso pacchetti, reinvio in caso di perdita, ...). Anche i router ignorano il livello applicazione (non esiste http sui router).\n","x":-3680,"y":9606,"width":250,"height":484},
		{"id":"3c83dc58c55637a4","type":"text","text":"\n(Tendono ad essere più che altro descrittivi, un insieme di regole fenomenologiche che possono rompersi in qualsiasi momento.??????)\n\n\n\"avere protocolli aperti permette a tutti di competere\"\n\n\n\nIl livello N prende il payload (mole di dati) del livello N-1 e gli aggiunge le proprie etichette (header, ...)\n\nSwitch non fa niente, router fa entrambe le cose\n\nIP e MAC fanno riferimento a layer (protocolli) diversi.\n\n\nOSI bello ma mai stato implementato, la sicurezza sta all'applicazione","x":-3747,"y":10156,"width":385,"height":506},
		{"id":"ec189bfa1c37a5e8","type":"text","text":"Il trasporto TCP prevede il controllo di flusso e la gestione degli errori per garantire l'affidabilità. Esistono anche meccanismi di controllo di congestione per evitare sovraccarichi di rete.","x":-3680,"y":9276,"width":250,"height":307},
		{"id":"9b35587f0d6f95ff","type":"text","text":"# Selective Repeat\n\nniente ack cumulativi, faccio tutto individualmente. timeout per ogni pacchetto. migliora la congestione ma è più pesante da implementare. TCP usa l'ack cumulativo ma anche alcuni concetti di SR.\n\nmittente: finestra come prima\nreceiver: deve avere una finestra perché tiene in buffer la roba. potrebbe spostare la finestra ma il mittente potrebbe non ricevere gli ack e andare fuori sync.\n\nse la sequenza è in base 2m,la\nfinestra può essere al più grande 2m-1","x":-2828,"y":10933,"width":490,"height":641},
		{"id":"35a7e50dd8bbb651","type":"text","text":"# TCP","x":-2175,"y":11574,"width":250,"height":60},
		{"id":"dbda1bb853280987","type":"text","text":"# Principi di controllo congestione\n\nproblema attuale e difficile\n\npiù hop attraverso più cresce la probabilità di essere scartato. Ogni scarto si ripercuote sul traffico dell'intero sistema (devo ritrasmettere).\nSe saturo il throughput la probabilità di arrivo a destinazione tende a zero, e tutto il traffico è solo di ritrasmissioni inutili -> non funziona niente.\n\nquesto se ognuno \"urla\" continuamente i suoi dati incurante del resto del sistema. bisogna coordinare (storicamente, all'inizio non serviva poi si sono accorti sperimentalmente che si bloccava tutto)\n\nendtoend - niente feedback dalla rete, preferibile se temo leak di info struttura rete. se non mi arrivano ack posso dedurre che ci sia congestione.\n\nrete - più recente, i router lo sanno se sono sovraccarichi, lo dicono. non banale: se ho buffer pieno magari il pacchetto manco mi arriva, o non riesco a rispondere (figuriamoci rispondere a tutti). ","x":-2535,"y":11934,"width":441,"height":1000},
		{"id":"47339376d0be509e","type":"text","text":"# Controllo di congestione di TCP\n\nbasato sull'avere perdite e non su evitarle. \"se la gente si comporta così funziona\". \n\nAIMD algoritmo distribuito asincrono, non facile farlo meglio. così c'è fairness. dimezzare rate di invio -> dimezzare la finestra.\n\nin genere mando un pacchettone grande quanto la congestion window (cwnd). all'inizio è 1MSS, poi 2, poi 3, ... Poi perdo qualcosa e\n- dimezzo se è un fast recovery\n- riduco a 1 se è un timeout\n\nin realtà non si aumenta linearmente all'inizio, ma esponenzialmente.\n\n- anni 70 - TCP partiva al massimo (throughput = bitrate), e poi crashava tutto;\n- slow start è perché esponenziale all'inizio è basso\n\na un certo punto però devo smettere di crescere esponenziale e passare in AIMD. esiste una soglia di andamento variabile chiamata ssthresh.\n\ncome determino ssthresh? la inizializzo a un certo valore (tipo 8, parametro TCP che probabilmente dipende pure dalla versione), poi la aggiorno. Come? Dipende dalla versione. in genere è la metà della grandezza della finestra prima dell'ultimo salto catastrofico. Tahoe riparte esponenziale da 1, Reno riparte lineare dalla threshold.\n\novviamente i grafici sono campionati a ogni RTT\n\n\"è la fairness che non esiste nel nostro sistema economico\"\n\nfast recovery aumenta grandezza finestra di 1 a ogni ack duplicato (altrimenti resto bloccato): se perdo il primo pacchetto ma arrivano gli altri dovrei mandare solo il primo e aspettare l'ack, invece oltre a rimandarlo allargo la finestra\n\nvedi kurose per dettagli (e.g. se tolgo fast recovery e metto un or diventa tahoe)\n\nvedi nuove slides 14...... c'è un link\n\ni tcp \"classici\" sono tahoe reno cube","x":-1995,"y":11934,"width":617,"height":1034},
		{"id":"cb01800e5666feb6","type":"text","text":"# controllo congestione TCP 2\n\ninvece di cercare perdite tracciamo l'aumento del ritardo. se aumentando il rate di invio invece del throughput aumenta il ritardo, prima ancora di avere perdite, sto saturando le code (delay based)\n\nECN non è ancora implementato\npacchetto arriva al router (IP), quello aggiunge un bit di coda piena, il destinatario lo legge e gira l'info al mittente (a livello tcp)\n\n","x":-1258,"y":11934,"width":467,"height":354},
		{"id":"7b504cb84b196e7e","type":"text","text":"# Fairness\n\n","x":-1258,"y":12348,"width":467,"height":620},
		{"id":"f55770ab8bdeed44","type":"text","text":"# Go-Back-N\n\nl'ack è sempre cumulativo, sta al destinatario mandarlo bene (ogni volta che riceve un pacchetto, qualsiasi pacchetto).\nla sua implementazione è semplificata: non ha una finestra, deve solo tenere traccia di dove è arrivato. un vantaggio è infatti semplicità di applicazione.\n Se i pacchetti arrivano fuori ordine e non ho un buffer butto pacchetti (finestra destinatario > 1 = buffer).\n \nlato mittente quando arriva l'ack cumulativo scorro la finestra.\nse perdo anche solo il primo nella finestra (c'è il timer) nel dubbio rimando tutta la finestra\n\ncosa brutta: spreco un sacco di banda\ncosa bella:\n- faccio spesso dei refresh del protocollo (rimandando tutta la finestra in pratica lo faccio ricominciare)\n- ridondanza (che sembra una cosa negativa, ma se mi perdo gli ack che mi manda il destinatario non sposto la finestra e continuo a mandare roba che già ha, vedi SR)","x":-3574,"y":10925,"width":577,"height":641},
		{"id":"f0f623558b7a1bd2","type":"text","text":"# Cartacei","x":-3446,"y":12046,"width":514,"height":328,"color":"1"},
		{"id":"0d17add1cb774159","type":"text","text":" (\"se su TCP vado al massimo blocco anche me stesso\"). ","x":-4717,"y":9000,"width":250,"height":209},
		{"id":"7ef6e3a292cb6a28","type":"text","text":"Il Transmission Control Protocol (TCP) è un protocollo risiedente sul layer di\ntrasporto in grado di fornire trasporto affidabile, ossia senza perdita di alcun pac-\nchetto, e controllo del flusso e della congestione, in cambio di un’assenza di garanzie\ntemporali, di throughput e di sicurezza.\nInoltre, il protocollo TCP è orientato alla connessione, ossia richiedente una confi-\ngurazione (handshaking) tra il processo client e il processo server\nDefinizione 18: User Datagram Protocol (UDP)\nL’User Datagram Protocol (UDP) è un protocollo risiedente sul layer di traspor-\nto in grado di fornire trasporto veloce poiché non orientato alla connessione ed\nestremamente scarno, ossia sprovvisto di: trasporto affidabile, controllo del flusso e\ndella congestione e garanzie temporali, di throughput e di sicurezza","x":-2443,"y":8917,"width":708,"height":402},
		{"id":"9f731eac72823c6c","type":"text","text":"# Livello di Collegamento","x":-2033,"y":5835,"width":391,"height":50,"color":"6"},
		{"id":"8465cfdca6ef5866","type":"text","text":"# UDP\n\nUser Datagram Protocol (della serie, in pratica lavoro sui datagrammi)\n\nsnmp gestione router, devo mandare info asap\n\nchecksum molto rudimentale (somma complemento a 1), se trovo errore lo scarto (e lo richiedo? dipende dal protocollo applicazione).\n\nce n'è più d'uno, il che rende vagamente più sensato il fatto che sia molto grezzo","x":-3160,"y":8160,"width":367,"height":420},
		{"id":"07b851654a6db276","x":-420,"y":3340,"width":680,"height":1300,"type":"text","text":"# NAT\n\ngli indirizzo che vedo in rete locale non sono gli stessi che vedo dall'esterno. questo perché uso i NAT.\n\nCi sono specifiche subnet che rappresentano LAN (e.g. 192.xxxxxxx, 10.xxxxxxx), mentre dall'esterno vedo solo il router che poi se la gestisce all'interno.\n\nIl router \"NATtato\" spara in rete pacchetti che hanno tutti lo stesso indirizzo. E come li distinguo?? Sfrutto le porte.\n\nè una cosa un po' sporca: il router (che vive a livello di rete) così cambia la porta, che vive nel livello di trasporto.\nQuanti computer gestisco? $2^{16}$, quante sono le porte. Ma dipende anche da quali porte sono aperte dal router e dai computer.\n\nquesta cosa ha N vantaggi scritti sulle slides\n\nse il NAT non ha creato una connessione con il computer target, i pacchetti a lui diretti vengono scartati (sicurezza)\n\nSvantaggi: se apro un server non ho modo di comunicare il mio IP al mondo. Come si risolve? DNS dinamico.\n\nquesta roba funziona bene quando i computer dietro il nat sono quelli che aprono le connessioni (non se c'è invece un server in ascolto). In pratica cambio il nome della sorgente. In pratica, a ogni nuova connessione aggiungo una riga alla tabella NAT.\n\nPuò essere\n- SIMMETRICO se usa una nuova porta per ogni combinazione IP/PORTA, anche se la destinazione è la stessa (ma la porta cambia). Diventa difficile *bucare* il NAT, ovvero targettare correttamente un pc dietro il NAT di tipo 1;\n- asimmetrico?\n\nper ogni nuova connessione cambia porta, per bucare il NAT dovrei appoggiarmi a un server esterno (?)\n\nspesso la sicurezza viene gestita sapendo che esiste questo livello NAT da bucare. possono esserci anche più livelli di NAT annidati. UDP NAT Punching metodi per provare a bucare il NAT, ma a volte ci sono controlli. Se sono un admin di rete ho paura di chi buca i NAT, perché potenzialmente creo vulnerabilità, e spesso creo meccanismi di difesa per impedire questa cosa.\n\nnel router posso APRIRE LE PORTE, ovvero indicare una porta e associare un IP locale a cui inoltrare i pacchetti (non è più NAT, è una mia impostazione manuale)\n\nse apro tanti server dietro a un nat è ancora più complesso perché devo disambiguare"},
		{"id":"c46e0b69e7092d81","x":331,"y":3340,"width":569,"height":800,"type":"text","text":"# IPv6\n\nheader fisso (velocizzo, perché so già dove sta il payload e inizio a leggerlo in parallelo alle opzioni) e indirizzi a 128bit. identifico *ogni oggetto* su internet (e.g. una pagina ha un indirizzo fisso)\n\nelimina checksum e frammentazione\n\ncrea concetto di flusso a livello IP (e.g. VoIP, MultiplayerGaming) che vengono gestiti in modo particolare dai router (ma ancora non si usa molto) -> flow label\n\nimplementa bene l'anycast\n\nil problema è che quasi tutti i router sono ancora IPv4. Alcuni solo 6 altri ibridi. come faccio a farlo funzionare? Incapsulo! trasporto IPv6 come payload dell'IPv4 -> tunneling.\n\nse provo ad usare IPv6 palese non funziona niente, il DNS va lentissimo, ...\n\nPerché ci metto così tanto? PErché stiamo a livello di infrastruttura, ed è difficile cambiare tutto l'HW; poi è nato il NAT, quindi meno fretta. \"stiamo cambiando le fondamenta di una casa con gli abitanti ancora dentro\"\n\nsi può cambiare il concetto di cosa rappresenta un indirizzo: può diventare direttamente un URI di ogni oggetto che metto online (piuttosto che una destinazione!). Ovvero, è un hash che identifica l'oggetto. IPFS (Interplanetary Filesystem), molto carino per applicazioni p2p."},
		{"id":"88c9b35b0c391a8a","x":-420,"y":2500,"width":680,"height":713,"type":"text","text":"# Frammentazione\n\ni pacchetti di rete hanno una max_transfer_size a livello di collegamento, caratteristico del cavo/mezzo di comunicazione. Se mi arriva un pacchetto troppo grande devo spezzarlo (IPv4). Quando arrivano al destinatario, i vari pacchetti IP frammentati vengono riassemblati.\n\nIPv6 vieta la frammentazione, devo esplorare il livello di collegamento per capire quanto grande  posso mandare i pacchetti. notare che viola il principio di divisione dei layer."},
		{"id":"f51086f517d2e458","x":-1100,"y":5400,"width":680,"height":680,"type":"text","text":"# Forwarding Generalizzato\n\nquello normale è: guarda l'IP, scegli un'uscita guardando la forwarding table.\n\nil generalizzato guarda anche gli header di trasporto e collegamento, non solo l'IP Uso una flow table (forwarding table generalizzata).\n\n- modify - è un NAT\n- drop - è un firewall\n\nin pratica implemento delle *middleboxes*. si può bannare un MAC. con OpenFlow su un router posso implementare cose, compreso l'INSTRADAMENTO!\n\ncon le tabelle possiamo costruire un percorso."},
		{"id":"a69d18b26b90862d","type":"text","text":"# Algoritmi di Instradamento","x":-1776,"y":2450,"width":437,"height":50,"color":"6"},
		{"id":"352b4beb483d264e","x":465,"y":1570,"width":855,"height":370,"type":"text","text":"# Control Plane\n\nal di sopra delle tabelle c'è un algoritmo distribuito basato sulla trasmissione di messaggi. una volta che converge, modifica le tabelle.in realtà se possibile tendiamo a non renderlo distribuito, ma a usare un server centralizzato (remote controller). perché? se lascio ai router il compito di comunicare tra loro potrebbe metterci una vita. è una centralizzazione logica, ovviamente, a livello fisico ho ridondanza. il punto è che per ogni istante so l'informazione complessiva dello stato delle tabelle. idealmente.\n\ncome lo implemento? impongo ai router di comunicare in broadcast la propria tabella (?)\nin genere un algoritmo centralizzato è più potente di uno distribuito (ha più info). in entrambi i paradigmi possono girare entrambi i tipi di algoritmi.\n\n"},
		{"id":"dbc47f290845eb11","x":465,"y":2040,"width":855,"height":640,"type":"text","text":"# Protocolli di instradamento\n\ndevo trovare un buon collegamento tra Alice e Bob. cosa significa buono dipende molto dalle circostanze. lavoro su grafi. gli algoritmi si dividono in\n\n- centralizzati: link-state\n- decentralizzati - distance vector\n\npossono essere statici o dinamici (e.g. a seconda del costo). farlo troppo dinamico può rompere l'algoritmo. pensa a google maps. se aggiornasse ogni 10 secondi tutti prendono la strada veloce che diventa rapidamente quella lenta\n\n## Dijkstra\npercorso ottimale tra due nodi, ma mi servono tutte le info. quindi la premessa è che ogni router comunichi tutti i livelli di intasamento di tutte le porte. ci sono algoritmi intelligenti per questo (e.g. se un router riceve info da un altro router, inoltra entrambe le info)\nuna volta che ho le info globali, Ogni nodo risolve un dijkstra diverso (dal suo POV). potrebbe anche risolvere quelli degli altri, ma non gli serve a niente.\n\nproblemi: se k è grande la rete può collassare.\n\nil fatto che ogni router sappia tutto il percorso è una ridondanza, il singolo router deve solo aggiornare la sua tabella (per questo ha senso avere un control computer coso). "}
	],
	"edges":[
		{"id":"6ddf40dd3d233286","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"23227e82062b49bc","toSide":"right"},
		{"id":"f97b165cd5b79ca1","fromNode":"23227e82062b49bc","fromSide":"top","toNode":"06174ae2aacf2d26","toSide":"bottom"},
		{"id":"79cea350f5f65501","fromNode":"a569f47822207faf","fromSide":"left","toNode":"4f9f693b64bc0e3f","toSide":"right"},
		{"id":"6d5ee26096e39af5","fromNode":"06174ae2aacf2d26","fromSide":"left","toNode":"a569f47822207faf","toSide":"right"},
		{"id":"efca276162b37995","fromNode":"a569f47822207faf","fromSide":"right","toNode":"06174ae2aacf2d26","toSide":"left"},
		{"id":"a779e63db92ba963","fromNode":"06174ae2aacf2d26","fromSide":"top","toNode":"165209213bc6a130","toSide":"bottom"},
		{"id":"9f06416bd06bfdef","fromNode":"a569f47822207faf","fromSide":"top","toNode":"165209213bc6a130","toSide":"bottom"},
		{"id":"61b78f68c63f4e8a","fromNode":"23227e82062b49bc","fromSide":"left","toNode":"b72f299bae389d13","toSide":"right"},
		{"id":"6f94fecf4639c0f4","fromNode":"4958894e7197fe3c","fromSide":"bottom","toNode":"1ec4d0918042c205","toSide":"right"},
		{"id":"18732b858dd6d8e8","fromNode":"b72f299bae389d13","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"top"},
		{"id":"236fb80dc10bcb1c","fromNode":"795690d5ce7e1c11","fromSide":"top","toNode":"b72f299bae389d13","toSide":"bottom"},
		{"id":"08f8c4d75162bc70","fromNode":"1ec4d0918042c205","fromSide":"left","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"2ad6aae7b242e920","fromNode":"795690d5ce7e1c11","fromSide":"left","toNode":"c842e00522cec07d","toSide":"right"},
		{"id":"6231bef59e40ecfa","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"5cf8d16de6efff56","toSide":"top"},
		{"id":"7ddcd8cf952994b6","fromNode":"9ed19d6e9980b34b","fromSide":"left","toNode":"0276409902e40e9c","toSide":"right"},
		{"id":"b9f2cee56ecc6884","fromNode":"165209213bc6a130","fromSide":"top","toNode":"ed6dd0d5b788bd3e","toSide":"bottom"},
		{"id":"fceeaf4ae4ae9491","fromNode":"23227e82062b49bc","fromSide":"bottom","toNode":"795690d5ce7e1c11","toSide":"right"},
		{"id":"818a74c3caa1b0b6","fromNode":"5cf8d16de6efff56","fromSide":"bottom","toNode":"1bd86960d6e5a8e2","toSide":"top"},
		{"id":"c16c39c9b26ca69c","fromNode":"1ec4d0918042c205","fromSide":"right","toNode":"44898ee22f42afdc","toSide":"left"},
		{"id":"91f484736f73f3df","fromNode":"4958894e7197fe3c","fromSide":"top","toNode":"56958c816f8128f6","toSide":"bottom"},
		{"id":"49bc3d9146b806bb","fromNode":"665f35bd71acbb90","fromSide":"top","toNode":"44898ee22f42afdc","toSide":"bottom"},
		{"id":"4d323ae12dc8b711","fromNode":"44898ee22f42afdc","fromSide":"right","toNode":"c45a83a3705f7881","toSide":"left"},
		{"id":"7534cf6c10d8c863","fromNode":"5cf8d16de6efff56","fromSide":"right","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"fe0cb992b8bb8e89","fromNode":"0c876453e3807959","fromSide":"right","toNode":"665f35bd71acbb90","toSide":"left"},
		{"id":"9ab56fb991918b05","fromNode":"1ec4d0918042c205","fromSide":"bottom","toNode":"0c876453e3807959","toSide":"left"},
		{"id":"892fdf290715d14d","fromNode":"795690d5ce7e1c11","fromSide":"bottom","toNode":"9ed19d6e9980b34b","toSide":"top"},
		{"id":"ebcab486927cb5de","fromNode":"9ed19d6e9980b34b","fromSide":"right","toNode":"5cf8d16de6efff56","toSide":"left"},
		{"id":"6a0ae24e30667e00","fromNode":"665f35bd71acbb90","fromSide":"right","toNode":"981b264b7f7630c2","toSide":"left"},
		{"id":"7286f70c7c7e9e6f","fromNode":"981b264b7f7630c2","fromSide":"top","toNode":"c45a83a3705f7881","toSide":"bottom"},
		{"id":"9e27c5c48748361f","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"45a11294a8434cf8","toSide":"bottom"},
		{"id":"8af8a5f3e2ad1274","fromNode":"a569f47822207faf","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"4bc5fcb03b652768","fromNode":"4f9f693b64bc0e3f","fromSide":"top","toNode":"a3eaa4b44f0f3c44","toSide":"bottom"},
		{"id":"a0745a8a10aa21ec","fromNode":"c45a83a3705f7881","fromSide":"bottom","toNode":"981b264b7f7630c2","toSide":"top"},
		{"id":"1c2152fd9676e1e4","fromNode":"c45a83a3705f7881","fromSide":"top","toNode":"305c16fa5fcbfca6","toSide":"bottom"},
		{"id":"7d0ac71b97316b5b","fromNode":"44898ee22f42afdc","fromSide":"top","toNode":"0e49609704fa8c9e","toSide":"bottom"},
		{"id":"feab48c838e8a738","fromNode":"0e49609704fa8c9e","fromSide":"top","toNode":"d7a25775f996e167","toSide":"bottom"},
		{"id":"4def83e52862fb08","fromNode":"665f35bd71acbb90","fromSide":"bottom","toNode":"1b501ca1023c98e0","toSide":"top"},
		{"id":"7b97b8d400a17d62","fromNode":"56958c816f8128f6","fromSide":"top","toNode":"d7a25775f996e167","toSide":"bottom"},
		{"id":"ee61d1fcc7c2de03","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"f6c22dc935238119","toSide":"right"},
		{"id":"5edcd65f331c9876","fromNode":"1a0fe951bbf51b93","fromSide":"left","toNode":"472a39255272296f","toSide":"right"},
		{"id":"f14f75bb6f530e76","fromNode":"1bd86960d6e5a8e2","fromSide":"left","toNode":"4df27d69ac9764ca","toSide":"right"},
		{"id":"47a253347dc37b5d","fromNode":"1bd86960d6e5a8e2","fromSide":"bottom","toNode":"3881465ee755981e","toSide":"top"},
		{"id":"5d939219c7bb9a7a","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"34401d45639b449d","toSide":"top"},
		{"id":"7db3cb5e783eb5a1","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"179ce6b66f1a29fe","toSide":"right"},
		{"id":"51f9edd90972a19b","fromNode":"0c876453e3807959","fromSide":"bottom","toNode":"010165be9fd56b6c","toSide":"top","fromEnd":"arrow"},
		{"id":"f0bd2107ddee8ba5","fromNode":"3881465ee755981e","fromSide":"top","toNode":"010165be9fd56b6c","toSide":"bottom"},
		{"id":"121d6e0e6a0bbfac","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"9f731eac72823c6c","toSide":"left"},
		{"id":"cd673b03983e203e","fromNode":"4df27d69ac9764ca","fromSide":"left","toNode":"8ca68ef0d9cba75a","toSide":"right"},
		{"id":"208d0a9d82fd8425","fromNode":"56958c816f8128f6","fromSide":"top","toNode":"5b4bbd10c0ed915d","toSide":"bottom"},
		{"id":"75c0f24600072246","fromNode":"0c876453e3807959","fromSide":"bottom","toNode":"a69d18b26b90862d","toSide":"left"},
		{"id":"99483e5740adc372","fromNode":"010165be9fd56b6c","fromSide":"top","toNode":"a69d18b26b90862d","toSide":"left"},
		{"id":"048457974880d02b","fromNode":"179ce6b66f1a29fe","fromSide":"top","toNode":"ea111d8cb579b650","toSide":"bottom"},
		{"id":"86da5dab44bb03d1","fromNode":"bd9ffece9b4d9aa9","fromSide":"top","toNode":"f10a4ae200557701","toSide":"bottom"},
		{"id":"1255d2940ba86579","fromNode":"2df2877d35b32cbf","fromSide":"right","toNode":"621da05b43f27ecc","toSide":"left"},
		{"id":"51abe8e67cba8602","fromNode":"2df2877d35b32cbf","fromSide":"bottom","toNode":"f55770ab8bdeed44","toSide":"top"},
		{"id":"3d96f5c9da8b6ae3","fromNode":"2df2877d35b32cbf","fromSide":"bottom","toNode":"9b35587f0d6f95ff","toSide":"top"},
		{"id":"eee1f6d590c90e96","fromNode":"f55770ab8bdeed44","fromSide":"right","toNode":"9b35587f0d6f95ff","toSide":"left"},
		{"id":"7f22da68abb7dd48","fromNode":"34401d45639b449d","fromSide":"bottom","toNode":"6f3226cdbb9850aa","toSide":"top"},
		{"id":"fa4fd6ac27fede83","fromNode":"179ce6b66f1a29fe","fromSide":"bottom","toNode":"349ec5026bac8b92","toSide":"top"},
		{"id":"c229738031cda2ac","fromNode":"349ec5026bac8b92","fromSide":"top","toNode":"dff88af00a536f81","toSide":"left"},
		{"id":"94b6a91f71272017","fromNode":"dff88af00a536f81","fromSide":"right","toNode":"34401d45639b449d","toSide":"left"},
		{"id":"731f0ec0ddf99b38","fromNode":"ea111d8cb579b650","fromSide":"left","toNode":"52edf2e6ee84f9b0","toSide":"right"},
		{"id":"d980c1a93aafee90","fromNode":"4df27d69ac9764ca","fromSide":"top","toNode":"1a0fe951bbf51b93","toSide":"bottom"},
		{"id":"99ef61b1863659dc","fromNode":"1bd86960d6e5a8e2","fromSide":"bottom","toNode":"35235b872aeaab53","toSide":"top"},
		{"id":"5d8bfaab9287c038","fromNode":"35235b872aeaab53","fromSide":"right","toNode":"3881465ee755981e","toSide":"left"},
		{"id":"7766ada0b75b23b1","fromNode":"3881465ee755981e","fromSide":"left","toNode":"35235b872aeaab53","toSide":"right"},
		{"id":"3c0abd32c7fec049","fromNode":"8b3faa26de750a2c","fromSide":"bottom","toNode":"89560ca8221b899c","toSide":"top"},
		{"id":"ea054aef41b0cca0","fromNode":"8b3faa26de750a2c","fromSide":"bottom","toNode":"a30868312d411d98","toSide":"top"},
		{"id":"7ce23dadaa651095","fromNode":"89560ca8221b899c","fromSide":"left","toNode":"6ce8f85f78362603","toSide":"right"},
		{"id":"dbf52d276f427907","fromNode":"973215b7fd31a26a","fromSide":"bottom","toNode":"ee9aa768d32eb89f","toSide":"top"},
		{"id":"6b464d08ca48f405","fromNode":"a30868312d411d98","fromSide":"right","toNode":"55d3231875e83cc8","toSide":"left"},
		{"id":"bd3886a5bc77d5a0","fromNode":"89560ca8221b899c","fromSide":"bottom","toNode":"ff01e5961e252647","toSide":"top"},
		{"id":"8d5e2dc5232a299d","fromNode":"a30868312d411d98","fromSide":"bottom","toNode":"ff01e5961e252647","toSide":"top"},
		{"id":"3b7a2fa2471a6608","fromNode":"ff01e5961e252647","fromSide":"bottom","toNode":"16f174d47e0dd2b5","toSide":"top"},
		{"id":"4631afa28cad3105","fromNode":"ff01e5961e252647","fromSide":"bottom","toNode":"44ce1eef2a1a2afa","toSide":"top"},
		{"id":"684296b62490a2a4","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"973215b7fd31a26a","toSide":"top"},
		{"id":"81a09b69b0c5bbbf","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"ada1ce65a17b1ff7","toSide":"top"},
		{"id":"8348e2cf9fcc3177","fromNode":"6ce8f85f78362603","fromSide":"bottom","toNode":"be024ab3c20ae124","toSide":"left"},
		{"id":"d1500d777e5a6d46","fromNode":"acb4f16f12e3f2e9","fromSide":"bottom","toNode":"6694e27578406638","toSide":"top"},
		{"id":"70d68af1971fd88f","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"acb4f16f12e3f2e9","toSide":"top"},
		{"id":"8f627262a584f38a","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"b42a1d8cb55878e0","toSide":"bottom"},
		{"id":"8fbed3ff33aca630","fromNode":"c25570b5d51372e2","fromSide":"bottom","toNode":"77ddaf1188c7b900","toSide":"top"},
		{"id":"d3994aec3181fafe","fromNode":"77ddaf1188c7b900","fromSide":"bottom","toNode":"04b979f48c716c0b","toSide":"top"},
		{"id":"95a357d298fdd7b9","fromNode":"6694e27578406638","fromSide":"bottom","toNode":"f99413b00ff804a3","toSide":"top"},
		{"id":"1684ada3383a3b04","fromNode":"f99413b00ff804a3","fromSide":"bottom","toNode":"431962e65465019d","toSide":"top"},
		{"id":"757b6e2877809f77","fromNode":"f99413b00ff804a3","fromSide":"bottom","toNode":"dab2f7463a1544fc","toSide":"top"},
		{"id":"0a9dc2c060770823","fromNode":"431962e65465019d","fromSide":"left","toNode":"beb0fa9d0cb9609a","toSide":"right"},
		{"id":"9e73506530a57cb1","fromNode":"dab2f7463a1544fc","fromSide":"right","toNode":"431962e65465019d","toSide":"left"},
		{"id":"4f90efa6599cf187","fromNode":"431962e65465019d","fromSide":"left","toNode":"dab2f7463a1544fc","toSide":"right"},
		{"id":"94aba2fbbe97d827","fromNode":"305c16fa5fcbfca6","fromSide":"right","toNode":"e98fee2b8eb0a179","toSide":"left"},
		{"id":"5baefffd457f53a0","fromNode":"35a7e50dd8bbb651","fromSide":"bottom","toNode":"dbda1bb853280987","toSide":"top"},
		{"id":"ee51101ead52c17c","fromNode":"dbda1bb853280987","fromSide":"top","toNode":"47339376d0be509e","toSide":"top"},
		{"id":"ceca913f68fcea22","fromNode":"35a7e50dd8bbb651","fromSide":"bottom","toNode":"47339376d0be509e","toSide":"top"},
		{"id":"b91001174f697fce","fromNode":"0719791a80c12eb2","fromSide":"top","toNode":"d0bc31a12d2847f8","toSide":"bottom"},
		{"id":"581c8be36c8c5d8f","fromNode":"ff62151f49666864","fromSide":"left","toNode":"0b031d2a05976038","toSide":"right"},
		{"id":"e2c0b939a1c3a84e","fromNode":"2edbb402780f44c6","fromSide":"right","toNode":"8b3faa26de750a2c","toSide":"left"},
		{"id":"26db68dfe4ccff0c","fromNode":"b42a1d8cb55878e0","fromSide":"left","toNode":"ff62151f49666864","toSide":"right"},
		{"id":"19be112fc67481ac","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"a13ba86d0881bc3c","toSide":"top"},
		{"id":"502b754c3aa17464","fromNode":"a13ba86d0881bc3c","fromSide":"top","toNode":"c25570b5d51372e2","toSide":"top"},
		{"id":"56c3bb85acedb920","fromNode":"a13ba86d0881bc3c","fromSide":"top","toNode":"8235584e2a6409b7","toSide":"bottom"},
		{"id":"3e1856f5b89479ab","fromNode":"2edbb402780f44c6","fromSide":"left","toNode":"8235584e2a6409b7","toSide":"bottom"},
		{"id":"11b4f3af12879717","fromNode":"ea111d8cb579b650","fromSide":"top","toNode":"aa2f1768f7663ebf","toSide":"bottom"},
		{"id":"ed0981e47c518871","fromNode":"9b35587f0d6f95ff","fromSide":"bottom","toNode":"f0f623558b7a1bd2","toSide":"top"},
		{"id":"56aa05d9378116fb","fromNode":"f0f623558b7a1bd2","fromSide":"right","toNode":"35a7e50dd8bbb651","toSide":"left"},
		{"id":"0392c6a0826a8fab","fromNode":"dff88af00a536f81","fromSide":"top","toNode":"b81367aa9de6afb4","toSide":"bottom"},
		{"id":"6879b643affd1e0e","fromNode":"dff88af00a536f81","fromSide":"bottom","toNode":"a040ad793f9beeac","toSide":"top"},
		{"id":"4e88dd4229982007","fromNode":"a040ad793f9beeac","fromSide":"bottom","toNode":"e2750b6b7a2c01af","toSide":"top"},
		{"id":"0bd09d94413ca585","fromNode":"3881465ee755981e","fromSide":"left","toNode":"0719791a80c12eb2","toSide":"right"},
		{"id":"b1b50abed84b9191","fromNode":"4df27d69ac9764ca","fromSide":"bottom","toNode":"35235b872aeaab53","toSide":"top"},
		{"id":"175fce85c6410af9","fromNode":"acea343615dea605","fromSide":"bottom","toNode":"2edbb402780f44c6","toSide":"top"},
		{"id":"e0741c499f5a9599","fromNode":"349ec5026bac8b92","fromSide":"left","toNode":"acea343615dea605","toSide":"right"},
		{"id":"472c8c49ca90d2e6","fromNode":"40ee9c3447f7fb82","fromSide":"right","toNode":"0efd970a1119442f","toSide":"left"},
		{"id":"33280d80c35d33bf","fromNode":"acea343615dea605","fromSide":"top","toNode":"6efc85167597eec6","toSide":"right"},
		{"id":"1dd2b92926522dfc","fromNode":"acea343615dea605","fromSide":"top","toNode":"877a13b60a49c414","toSide":"left"},
		{"id":"ee99fc1ed31f00ef","fromNode":"877a13b60a49c414","fromSide":"top","toNode":"aa76e477e11e779d","toSide":"bottom"},
		{"id":"06b74f9e3f7e46bd","fromNode":"6efc85167597eec6","fromSide":"bottom","toNode":"2c357555847a692e","toSide":"top"},
		{"id":"bca4d744f7646067","fromNode":"0d69bbc0efaf38ce","fromSide":"top","toNode":"2a51de9d069e3b02","toSide":"bottom"},
		{"id":"cacccf6ae674edbe","fromNode":"0d69bbc0efaf38ce","fromSide":"right","toNode":"2c547fef2c5dcf45","toSide":"left"},
		{"id":"9dd973f761a8185c","fromNode":"6efc85167597eec6","fromSide":"top","toNode":"0d69bbc0efaf38ce","toSide":"bottom"},
		{"id":"102ce3f1c097fdbf","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"a0476a2b8399dc67","toSide":"top"},
		{"id":"a9b365d356249eaf","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"0bcac05d389026f2","toSide":"bottom"},
		{"id":"dfac2447c54a08cc","fromNode":"0d69bbc0efaf38ce","fromSide":"left","toNode":"d9218fbe64e55603","toSide":"bottom"},
		{"id":"500541804019d1c5","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"84caca764ec7fb4e","toSide":"right"},
		{"id":"02d34002b55f347e","fromNode":"6efc85167597eec6","fromSide":"left","toNode":"f4a58217f873b504","toSide":"top"},
		{"id":"60be2888bbfbe9f4","fromNode":"0bcac05d389026f2","fromSide":"top","toNode":"d9218fbe64e55603","toSide":"bottom"},
		{"id":"5de96e4cfcae595a","fromNode":"0bcac05d389026f2","fromSide":"bottom","toNode":"84caca764ec7fb4e","toSide":"right"},
		{"id":"8fb21869f7e78d8c","fromNode":"d9218fbe64e55603","fromSide":"left","toNode":"4694cc6e9478ff73","toSide":"right"},
		{"id":"d0a9712c0a098f37","fromNode":"d9218fbe64e55603","fromSide":"left","toNode":"b99dcc266569a95d","toSide":"right"},
		{"id":"d61c7aa7366222a9","fromNode":"d9218fbe64e55603","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"right"},
		{"id":"3b79b164037dce89","fromNode":"0bcac05d389026f2","fromSide":"left","toNode":"2cf0e73ceaebad33","toSide":"right"},
		{"id":"133dc4f16a496df4","fromNode":"807b9ea551e9eb4a","fromSide":"bottom","toNode":"2cf0e73ceaebad33","toSide":"left"},
		{"id":"cdcedae67dc73ef0","fromNode":"2cf0e73ceaebad33","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"bottom"},
		{"id":"48f18a94c4689c94","fromNode":"2cf0e73ceaebad33","fromSide":"right","toNode":"d9218fbe64e55603","toSide":"bottom"},
		{"id":"f80af4331101f38b","fromNode":"b99dcc266569a95d","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"right"},
		{"id":"78a251b841c56b27","fromNode":"4694cc6e9478ff73","fromSide":"left","toNode":"807b9ea551e9eb4a","toSide":"right"},
		{"id":"0f53cc5be936e481","fromNode":"d9194ed55437e184","fromSide":"left","toNode":"d9218fbe64e55603","toSide":"right"},
		{"id":"79b3fa714035a627","fromNode":"84caca764ec7fb4e","fromSide":"left","toNode":"bd9ffece9b4d9aa9","toSide":"right"},
		{"id":"71708495721d21ca","fromNode":"84caca764ec7fb4e","fromSide":"left","toNode":"60429356d103493a","toSide":"right"},
		{"id":"450556ccb0e0a941","fromNode":"f4a58217f873b504","fromSide":"right","toNode":"29e1d3a847d6212b","toSide":"left"},
		{"id":"695a1a8f662088cd","fromNode":"010165be9fd56b6c","fromSide":"right","toNode":"b356a8ba2ad031a0","toSide":"left"},
		{"id":"fc4622ed331d809a","fromNode":"b356a8ba2ad031a0","fromSide":"right","toNode":"7f27ffe9c326e924","toSide":"top"},
		{"id":"fb9863e64671e8bd","fromNode":"b356a8ba2ad031a0","fromSide":"right","toNode":"23a2937e757042d7","toSide":"left"},
		{"id":"b7720bdfc2befb1b","fromNode":"23a2937e757042d7","fromSide":"top","toNode":"447f8e71a756c709","toSide":"bottom"},
		{"id":"f55bde45de849d01","fromNode":"349ec5026bac8b92","fromSide":"bottom","toNode":"ba32fe7205e2606f","toSide":"left"},
		{"id":"be05070237675422","fromNode":"34401d45639b449d","fromSide":"right","toNode":"1a7e522c18045e6d","toSide":"left"},
		{"id":"3b9e95f989eb27a7","fromNode":"3881465ee755981e","fromSide":"bottom","toNode":"1a7e522c18045e6d","toSide":"top"},
		{"id":"f195684b063a3945","fromNode":"6f3226cdbb9850aa","fromSide":"bottom","toNode":"78a5ab219227020b","toSide":"top"},
		{"id":"5c4afc93813ef4ca","fromNode":"ba32fe7205e2606f","fromSide":"right","toNode":"78a5ab219227020b","toSide":"left"},
		{"id":"4dcd3d54d7b9e061","fromNode":"23a2937e757042d7","fromSide":"top","toNode":"88c9b35b0c391a8a","toSide":"bottom"},
		{"id":"93fbd42d72af9344","fromNode":"7f27ffe9c326e924","fromSide":"bottom","toNode":"f51086f517d2e458","toSide":"top"},
		{"id":"7bff8284b76c9231","fromNode":"a69d18b26b90862d","fromSide":"right","toNode":"352b4beb483d264e","toSide":"left"},
		{"id":"7ede39539c2cdd37","fromNode":"352b4beb483d264e","fromSide":"bottom","toNode":"dbc47f290845eb11","toSide":"top"}
	]
}