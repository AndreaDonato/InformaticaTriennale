{
	"nodes":[
		{"id":"a5db58697c7e9975","type":"text","text":"# Evoluzione dei DB e dei DBMS\n\nLa gestione dei dati si è resa necessaria fin dai primi utilizzi dei sistemi di calcolo, negli anni '50.\n\nI precursori dei DB (diciamo quindi semplicemente \"le prime grandi moli di dati\", in assenza delle caratteristiche tipiche di un DB per come lo intendiamo oggi) erano gestiti tramite linguaggi dedicati (e.g. *Fortran* per le applicazioni scientifiche, *COBOL* per le applicazioni commerciali, ma anche *Pascal* e *C*), e si appoggiavano sul _filesystem_ del SO sottostante, e quindi in un ambiente non-strutturato (dove per **_ambiente strutturato_** si intende la **_mediazione di un DBMS_**).\n\nI primi DBMS risalgono alla metà degli anni '60, stimolati da una società sempre più ricca di sfide tecnologiche (e.g. Progetto Apollo della NASA).\n\nLo sviluppo e la commercializzazione nei primi anni sono principalmente targati **_IBM_**, che implementa **_IMS (Information Management System)_**, il primo DB **_gerarchico_**.\n\nQuesto modello implementa una **_struttura ad albero_** in cui ogni unità logica di dati (**_record_**) costituisce un nodo, e i collegamenti padre-figlio definiscono le relazioni.\n\nUna generalizzazione del modello gerarchico è il _**modello reticolare**_, standardizzato dal comitato **_CODASYL_** (_Conference on Data Systems Languages_) tra gli anni '60 e '70, che rilassa la struttura ad albero in una struttura a **_grafo_** (ogni nodo può avere più padri).\n\n**_Importantissimo_** notare che tutti questi modelli sono implementati tramite **_puntatori a memoria_**, e che quindi ogni record è una struttura collegata che ha una campo che referenzia direttamente l'indirizzo fisico del record di destinazione.\n\nQuesto li rende fortemente dipendenti dalla struttura fisica del DB, nonché estremamente complicati in fase di manipolazione.\n\nIl 1970 è un anno rivoluzionario per i DBMS, perché viene introdotto in IBM il **_modello relazionale_**. Servono tuttavia una decina d'anni di lavoro per produrre le prime implementazioni commerciali (*Ingress*, *Oracle*, MySQL, ...).","x":-46,"y":400,"width":660,"height":956,"color":"4"},
		{"id":"50686229090c1bd0","type":"text","text":"# Modelli Concettuali e Modelli Logici\n\nPer realizzare un DBMS è necessario identificare, in ordine,\n\n- tutte e sole le informazioni rilevanti rispetto al problema (**_dati_**);\n- i vincoli che legano tra loro le informazioni (<span style=\"color:#7030a0\">***relazioni***</span>);\n- un modo univoco per risalire a una certa informazione (tramite un **_linguaggio di interrogazione _**).\n\nLa progettazione si può suddividere in tre fasi principali:\n\n- **_Analisi Concettuale_** - Si identifica cos'è un'**_entità_** (dato) e cos'è una **_relazione_** (vincolo tra dati). Si crea un **_modello concettuale_** che rappresenta un **_primo livello di astrazione_** del problema, e che fornendo una schematizzazione logica dei dati semplifica le comunicazioni circa il DB. Questa fase **non si occupa dei dettagli implementativi**, e resta astratta (appunto, concettuale);\n- ***Modellazione Logica*** - In questa fase si traduce la struttura logica dei dati identificata nella fase di analisi concettuale in un **_modello logico_**, ovvero si sceglie **come** implementare il modello concettuale (questo include l'uso di riferimenti, etichette, tabelle, ...). Definisce la **struttura organizzativa virtuale delle interconnessioni tra i dati** indipendentemente dall'effettiva implementazione sottostante;\n- **_Implementazione_** - Si crea il DB fisico, ovvero la struttura di dati che viene effettivamente memorizzata sul sistema di archiviazione.\n\nQuesta distinzione suggerisce che il primo step si occupi solo di identificare le entità e il secondo di definirne la struttura. La realtà non è così rigida. Ad esempio, ha senso che un albero genealogico sia rappresentato direttamente come albero nel modello concettuale, mentre nel caso in cui la struttura non sia così evidente sin da subito l'albero può essere implementato come scelta di design nel modello logico.\n\nA partire dagli anni '60/'70 nascono diverse tipologie di DBMS costruiti sui relativi modelli logici.\n\n- **_Gerarchico ('60)_** - Struttura di tipo albero, i dati sono i nodi e le relazioni gli archi genitore-figlio;\n- **_Reticolare ('70)_** - Struttura di tipo grafo, i dati sono i nodi e le relazioni gli archi;\n- **_Relazionale ('70, '80)_** - Basato sul modello concettuale Entità-Relazione;\n- _**A Oggetti ('80)**_ - I dati sono oggetti con dei metodi associati;\n- _**XML**_ - Rivisitazione del modello gerarchico con l'aggiunta di tag, attributi e altre cose fancy;\n- **_NoSQL_** - Genericamente, modelli non basati sul modello relazionale.\n\nAd ogni modello logico corrispondono diversi linguaggi di interrogazione progettati in modo specifico per un certo insieme di dati. L'unica eccezione è il **_Relazionale_**, che ha come linguaggio standard **_SQL_**.","x":-1160,"y":400,"width":880,"height":956,"color":"4"},
		{"id":"110d5abbb0f74fea","type":"text","text":"# Ambiente Strutturato o Dati Strutturati?\n\nNon va fatta confusione tra il concetto di **_ambiente strutturato_**, inteso come la presenza di un DBMS, e le caratteristiche dei dati memorizzati.\n\n- **_Dati non strutturati_**: testi scritti in un linguaggio naturale, per i quali è implementabile solo una ricerca di tipo sequenziale, con un tempo medio di accesso $\\sim O(n/2)$;\n- **_Dati strutturati_**: dati rappresentati da brevi stringhe di simboli o da numeri. Permettono di definire relazioni d'ordine e quindi ottimizzare gli algoritmi di ricerca. Ad esempio, la **_ricerca binaria_** arriva ad un tempo medio di accesso $O(log_2(n))$. Ci si può accedere singolarmente tramite interrogazioni.\n\nI moderni DB sono costituiti da **_soli_** dati strutturati.\n","x":760,"y":400,"width":760,"height":380,"color":"4"},
		{"id":"186012183c3f3ecd","type":"text","text":"# Linguaggi di Interrogazione\n\nAnche con l'avvento dei primi DBMS, nei primi anni non esisteva un **_linguaggio di interrogazione (query language)_** universale.\n\nIn **IMS**, ad esempio, la gestione avveniva tramite _Data Language/1_ (**DL/1**), un complesso linguaggio di interrogazione specifico che richiedeva una dettagliata conoscenza della struttura fisica del DB. In seguito questo venne ampliato con il Generalized Update Access Method (**GUAM**), che forniva funzionalità di più alto livello per semplificare la vita dei programmatori. \n\nNei DB standardizzati CODASYL esisteva il *Data Manipulation Language* (**DML**), che però è sempre rimasto specifico dei modelli a rete.\n\nIl primo linguaggio di interrogazione universale è lo **_Structured Query Language (SQL)_**, nato in IBM nei primi anni '70 insieme al **_modello relazionale_**.\n\nC'è da notare che ancora oggi alcune società potrebbero avere dei DB non standardizzati, perché i costi del porting superano i benefici.","x":760,"y":860,"width":760,"height":496,"color":"4"},
		{"id":"9d076c174e423d23","type":"text","text":"# Elementi del Modello Relazionale (Tabelle)\n\nDato un certo oggetto che si vuole rappresentare, si sceglie un sottoinsieme appropriato di attributi, li si dispongono in modo ordinato e gli si assegnano dei valori, realizzando una **tupla** (o **record**).\n\nTuple omogenee sono raggruppate in **istanze**, anche dette **relazioni (relations)**, realizzate al livello implementativo tramite tabelle.\n\nLe tuple possono rappresentare tanto **entità**, e quindi dati, quanto **relazioni (relationships)**, quindi correlazioni tra dati. Questo implica che le tabelle (anche dette *relazioni* nel senso di *istanze*) possono rappresentare sia entità che relazioni tra entità (*relationships*). Per niente convoluto, vero?\n\nDopo questo piccolo delirio di nomenclatura siamo arrivati alla faticosa conclusione che l'intero modello relazionale ha come **_unica struttura dati_** le **_tabelle_**.","x":-3500,"y":920,"width":880,"height":436,"color":"4"},
		{"id":"96639327a802451a","type":"text","text":"# Dati\n\nLa stragrande maggioranza dei DBMS usa il MODELLO RELAZIONALE. In pratica, tabelle con intestazione, attributi e record (dati). Servono quindi nome e struttura per la tabella, e tutti i dati devono essere omogenei a livello di struttura. Distinguo quindi\n\n- Aspetto INTENSIONALE, nomi e strutture delle tabelle (che non si modificano);\n- Aspetto ESTENISONALE, i dati che memorizzo nelle tabelle (parte dinamica).\n","x":-4504,"y":936,"width":520,"height":404},
		{"id":"757ece01c4e7854b","type":"text","text":"# tabelle\n\n\nservono file aggiuntivi ausiliari (indici) che permettono di accedere velocemente al file principale\nsu ogni tabella posso costruire più indici (magari su campi diversi)\n\nindici sono contenuti in altri file\n\nil linguaggio mette a disposizione dei tipi e delle operazioni sui tipi, ad esempio il tipo data ha metodi per estrarre giorno, mese e ora\n\nun'istanza vuota non può violare alcuna dipendenza funzionale, quindi è sempre \"buona\". per poter violare una regola deve contenere almeno due tuple! infatti molte dimostrazioni di BDD si mettono nel caso non restrittivo di istanza a due tuple. se rispetto tutte le dipendenze funzionali mi chiamo istanza LEGALE.\n","x":-5400,"y":966,"width":816,"height":395},
		{"id":"72567ad0e9b60184","type":"text","text":"# Vantaggi\n\n- multiuso\n- indipendenza dei dati dalle strutture fisiche\n- controllo centralizzato (DBMS)\n- ogni dato ha una sola rappresentazione (unico punto di accesso) a prescindere da quanti schemi esterni lo usano\n- minima ridondanza, se non assente\n- integrità, non devo preoccuparmi di modificare dati sensibili perché ho i vincoli di integrità\n- sicurezza, posso definire dei permessi","x":-4552,"y":456,"width":616,"height":438},
		{"id":"060659758b3f2bc8","type":"text","text":"# Su cosa si basa?","x":138,"y":2620,"width":292,"height":50,"color":"6"},
		{"id":"e8974e97e6a653e4","type":"text","text":"# Come mi assicuro che sia coerente?","x":2087,"y":2620,"width":562,"height":50,"color":"6"},
		{"id":"9988826790f856a8","type":"text","text":"# Come è fatto un RDBMS?\n\nIl DBMS si struttura tipicamente a più livelli.\n\n- **_Livello dei Dati (Schema Interno):_** livello a cui opera il DBMS in senso stretto. Include\n\t- gestione dello spazio su HDD e RAM. All'avvio il DBMS occupa una certa porzione di memoria (stabilita come stima massimale da chi lo ha progettato) che diventa inaccessibile per qualsiasi altra applicazione;\n\t- Gestione dei buffer, ovvero spostamento dei dati tra RAM e HDD;\n\t- Accesso ai dati fisici;\n\t- Operatori relazionali e di ottimizzazione ed esecuzione delle interrogazioni, *layer* che rendono le richieste quanto più veloci possibile;\n- **_Livello della Logica dell'Applicazione (Schema Logico):_** livello a cui operano le applicazioni utilizzate dagli utenti. Scambia dati con il DB e riceve input dall'interfaccia utente. Questi appunti sono riferiti allo Schema Logico del DBMS;\n- **_Livello della Presentazione (Schema Esterno):_** Spesso una certa categoria di utenti può accedere solo a uno schema esterno del DB, ovvero una rappresentazione del DB indipendente dal DB, senza sapere che esistono altri schemi e dati. Questo garantisce anche un layer di sicurezza. Si dice **_vista_** degli utenti, e se ne possono implementare molteplici, a seconda degli utenti a cui è destinata (e.g. se sono uno studente non vedrò gli stessi dati che vede un professore, ma il DB a cui facciamo riferimento è lo stesso). Spesso la vista è generata con delle query (e.g. *join*) che partono quando viene fatta richiesta dall'utente. Le tabelle visualizzate in questo livello possono quindi non rispettare la Terza Forma Normale, ma va tutto bene perché sono figlie di manipolazioni esterne al DB.\n\n\n","x":2008,"y":780,"width":720,"height":780,"color":"3"},
		{"id":"4010dbf8b74b33c3","type":"text","text":"# Perché serve un DBMS?\n\nIn assenza di un DBMS, dovrei costruire un DB a partire da un *filesystem* come *Excel*, o addirittura un semplice *file.txt*.\n\nChiaramente non ho garanzia di evitare **_duplicati_** o **_inconsistenze_**. Più ci si affida all'intervento umano e a diversi DB contenenti informazioni simili che non si parlano, più aumenta il rischio di duplicazione e inconsistenze, da cui rischio di estrarre dati e informazioni false.\n\nIn un DBMS, il tipo di dato può essere molto semplice (alfanumerico) o molto pesante (video). Il DB può essere grande sia in senso di numero di dati sia in senso di quanto occupa il singolo dato. Ma dove li metto tutti questi dati? La memoria centrale non basta, serve memoria secondaria. Il DBMS deve quindi trovare il dato sulla memoria secondaria e caricarlo in centrale. Uno dei problemi degli ultimi 30 anni è come velocizzare questo processo. Nessuno vuole aspettare 3 minuti per comprare un biglietto!","x":2860,"y":870,"width":686,"height":600,"color":"3"},
		{"id":"1559942f272c8467","type":"text","text":"# Come opera un DBMS \n\nil so apre un canale di comunicazione con il dbms che risponde su un certo socket (porta). I dati del DB hanno una codifica proprietaria, e sono decodificati solo tramite il dbms (leggi: se li apro con l'editor vedo roba insensata) che si occupa di virtualizzarli per l'utente.\n\n","x":3703,"y":870,"width":447,"height":680},
		{"id":"c257b123a2436672","type":"text","text":"# Caratteristiche di un DBMS\n\n- Gestisce collezioni di dati\n\t- Grandi: autoesplicativo;\n\t- Persistenti: i dati sono la risorsa più stabile (rispetto ai metodi, gli algoritmi e simili, che possono cambiare). Il DBMS gestisce processi di BACKUP e RECOVERY per minimizzare il rischio di perderli;\n\t- Condivise: accessibili ad altri sistemi e ad utenti. Questo porta a complicazioni nel momento in cui molti utenti accedono contemporaneamente al DBMS, il quale attua il CONTROLLO DI CONCORRENZA.\n\n- Garantisce (o dovrebbe garantire)\n\t- Privacy: il DBMS fa accedere ai dati (o a loro porzioni) solo gli utenti autorizzati. Gli admin possono accedere a tutti i dati in r/w. Ci sono definizioni molto dettagliate di cosa l'utente può o non può fare, tipicamente specificate al momento della richiesta;\n\t- Affidabilità: il DBMS fornisce risultati corretti;\n\t- Efficienza: i risultati vengono restituiti in un tempo ragionevole.\n\nEsempi di DMBS sono:\n\n- DB2, di IBM, per grandissime quantità di dati e grandi organizzazioni;\n- Oracle, il più diffuso poiché flessibile rispetto al piano tariffario;\n- SQLServer, di Microsoft, simile a Oracle ma \"un po' peggio\";\n- MySQL, MicrosoftAccess, DBMS \"giocattolo\";\n- PostgreSQL, non basato sulla logica relazionale.","x":4366,"y":730,"width":680,"height":740},
		{"id":"eba6d491c9cfc3d3","type":"text","text":"# MODELLO RELAZIONALE (ING INF)\n\nSi basa sul concetto di matematico di relazione e sui valori (niente oggetti, niente puntatori).\nUna RELAZIONE è un insieme di tuple omogenee, cioè definite sugli stessi attributi.\nDati n domini D_n (che possono essere interi, reali, date, stringhe, ore, personalizzato, ... spesso si usano tipi di dato astratti\npersonalizzati per mettere un vincolo sui possibili valori di quel campo), il loro prodotto cartesiano è ogni possibile tupla in cui\nd_i \\in D_i.\n\nESEMPIO\nSe D_1 = {a, b} e D_2 = {x, y, z} posso avere solo 6 tuple distinte. Un DB è un INSIEME, quindi ogni tupla compare una e una sola volta.\n\nUna relazione è un sottoinsieme del prodotto cartesiano dei domini.\n\n\t- Il GRADO di una relazione è il numero di domini (#colonne nella tabella);\n\t- La CARDINALITA' è il numero di tuple realizzabili (#righe nella tabella).\n\nRispetto alle tuple matematiche, le colonne delle tabelle hanno le ETICHETTE, quindi non devo rispettare per forza l'ordine\n(d_1, d_2, ...). Non ho più la relazione POSIZIONALE. L'etichetta dà la SEMANTICA al dato. Tutte le altre proprietà sono rispettate.\n\nTramite i valori definisco i collegamenti tra le tabelle. Se ad esempio ho una tabella con i codici dei corsi, non posso avere una\ntabella con i voti degli esami in cui compare un codice di corso non presente nell'altra tabella. Questo concetto prende il nome di\nVINCOLO DI INTEGRITA' REFERENZIALE. Si noti che differisce da un modello a puntatori, che farebbe direttamente riferimento al valore\ninserito nella prima tabella.\n\nSe devo inserire una riga, quanto mi costa la verifica che non ci sia già? O(n), ma posso migliorarlo? Sì, in due modi:\n\n\t- Introduco colonne privilegiate su cui effettuare i controlli. L'idea è che queste identifichino l'intera riga in modo univoco.\n\t\tAd esempio, in una tabella di studenti contenente nome, cognome, data di nascita e numero di matricola sarà sufficiente\n\t\tcontrollare quest'ultima. In una tabella con matricola, esame e voto sarà necessario prendere le colonne matricola e corso,\n\t\tin quanto non è possibile avere due voti positivi allo stesso esame;\n\n\t- Introduco un ordinamento, e quindi faccio ricerca binaria.\n\nSe non conosco un dato è possibile far inserire al DBMS il valore NULL. Con questa cosa bisogna stare molto attenti:\n\n\t- Se il dato che non conosco appartiene a una colonna privilegiata, non è ammissibile;\n\t- Se non appartiene a una colonna privilegiata, posso decidere in fase di progettazione se consentire o meno il NULL.\n\nNel momento in cui inserisco NULL, però, non so se quel dato non è stato inserito perché\n\n\t- non lo conosco al momento, ma potrei conoscerlo in futuro;\n\t- non esiste, e quindi non potrò mai conoscerlo;\n\nDa un lato, se non permettessi di inserire dati parziali risulterei troppo rigido. Dall'altro, ogni NULL abbassa la qualità del DB.\nInoltre, ogni vincolo di integrità introdotto corrisponde a un costo di ricerca e verifica su una enorme mole di dati.\n\nI vincoli possono essere\n\n\t- INTRARELAZIONALI, ovvero interni alla stessa tabella, e si distinguono in\n\n\t\t- Vincoli di Tupla, che verificano l'intera riga. Possono essere sia verifiche sul singolo campo (es: un voto deve essere\n\t\t\tcompreso tra 0 e 30) sia tra campi diversi (es: il campo lode può assumere solo valori vero/falso, ma può essere vero\n\t\t\tsolo se voto è uguale a 30);\n\n\t\t- Vincoli di Chiave, che verificano solo le colonne privilegiate. Se una tabella è grande, fare avanti e indietro tra RAM\n\t\t\te HDD è scomodo. Allora posso costruire una tabella più snella costituita dalle sole chiavi. Una SUPERCHIAVE è un\n\t\t\tinsieme di attributi al cui interno c'è una chiave. Segue che una chiave è una superchiave minimale. Non è detto che\n\t\t\tla chiave sia unica. Il MAX è il numero di attributi. In definitiva, il Vincolo di Chiave è un'asserzione che specifica\n\t\t\tche un insieme di attributi forma una chiave per una relazione. Se ho una relazione R(A, B, C, D), dichiarare un Vincolo\n\t\t\tdi Chiave su {A, B} significa dire che in R non possono esistere due tuple che coincidano negli attributi A e B.\n\t\t\tInoltre, incidentalmente, sto anche dicendo che nessun sottoinsieme di {A, B} è una chiave. Si noti che la tupla di per\n\t\t\tsé sarebbe una chiave (essendo un insieme), ma a livello pratico risulta un po' troppo lunga. Ogni tabella ha una e una\n\t\t\tsola CHIAVE PRIMARIA, per la quale non ha senso ammettere valori nulli (in tabella, si indica sottolineando l'intestazione\n\t\t\tdel campo), e poi opzionalmente N chiavi secondarie. L'importante, comunque, è che la tupla sia identificabile: vieto valori\n\t\t\tnulli in almeno una chiave (la primaria).\n\n\t- INTERRELAZIONALI, tra tabelle diverse\n\n\t\t- Vincoli di Integrità Referenziale (o di Foreign Key), lavora sulla chiave primaria di una tabella di riferimento. In particolare,\n\t\t\tdata la tabella R_1 e il suo campo X non chiave, il Vincolo di Integrità Refernziale impone che ogni valore che compare in X\n\t\t\tcompaia anche nel campo chiave Y della tabella R_2. Detta in modo diverso, l'insieme dei valori del campo REFERENZIANTE sono\n\t\t\tun sottoinsieme dell'insieme dei valori del campo REFERENZIATO.\n\nE'importante notare che è sempre meglio evitare campi ridondanti. Segue esempio.\n\n\tR_1 è una tabella di infrazioni stradali. I campi sono codice infrazione, data, matricola vigile, provincia, numero verbale. C'è\n\tun vincolo di foreign key sulla tabella dei vigili, R_2, che contiene matricola vigile (chiave primaria, quindi campo referenziato\n\tdall'omonimo referenziante di R_1), cognome e nome. Se nella tabella infrazioni volessi inserire il cognome del vigile (quindi un'\n\tinformazione ridondante) potrei effettuare un altro controllo di tipo foreign key sul cognome di R_2, ma è importante notare che\n\ti due vincoli sono indipendenti. Di conseguenza, potrei inserire in input di R_1 lo stesso codice vigile associato a due cognomi\n\tdiversi, e per i vincoli andrebbe bene. Porterebbe chiaramente a un'inconsistenza del DB.\n\n\t\t- Per ovviare al problema volendo mantenere il cognome dovrei usare la coppia, ma tecnicamente è più difficile da implementare.\n\t\t- In generale nella stessa tabella possono esserci più referenzianti.\n\nUn'istanza che rispetta tutti i vincoli è detta LEGALE. Un modo per assicurarsi che l'utente immetta in input una stringa corretta,\nè impostare una GUI per farlo scegliere tra i valori ammissibili piuttosto che lasciarlo libero di scrivere. Ad esempio, se voglio\nprenotare un aereo non è l'utente a immettere la data, ma sceglie dal calendario. Meglio prevenire che verificare.\n\nCosa succede se ho R con Squadra1 Squadra2 e Risultato? Qual è la chiave primaria? Squadra1 Squadra2. E se possono incontrarsi un\nnumero indefinito di volte? Ho diverse opzioni:\n\n\t- Aggiungo un attributo che funge da chiave primaria, come un codice partita;\n\t- Aggiungo un attributo che unito alla vecchia chiave primaria mi dia la nuova chiave primaria. Se ad esempio so che nella stessa\n\t\tdata due squadre si possono incontrare solo una volta, Sq1 Sq2 Data è la chiave primaria.\n\nNULL è un valore compatibile col foreign key. Mettere troppi vincoli può portare all'impossibilità di trovare una tupla che li\nsoddisfi tutti. Oltretutto, ognuno di essi introduce rallentamenti. Infine, se elimino una tupla referenziata potrebbero succedere\ndisastri. Vedremo dopo come ovviare a questi problemi.\n\n\nIn SQL NON ESISTE L'IF!! Devo gestirmela solo con la logica booleana. Questo potrebbe rendere particolarmente inefficienti alcuni\ntipi di verifiche, così come ","x":-8320,"y":1138,"width":1400,"height":2540,"color":"1"},
		{"id":"b1a5285caeae4130","type":"text","text":"# Modello Relazionale\n","x":104,"y":2009,"width":360,"height":50,"color":"6"},
		{"id":"21febace8b459e12","type":"text","text":"# DBMS Relazionali (RDBMS)","x":2145,"y":2009,"width":456,"height":50,"color":"6"},
		{"id":"5056013ae1ac0b85","type":"text","text":"# Legami con la Teoria degli Insiemi \n\nIl <span style=\"color:#cd0a0a\">***modello relazionale***</span> è un'applicazione di <span style=\"color:#00b050\">***teoria degli insiemi***</span>. In alcuni termini possono <span style=\"color:#ffc000\">***collassare i significati di entrambi i punti di vista***</span>.\n\nPer un dato insieme definisco un ***dominio***, ovvero la pool da cui posso pescare gli elementi.\n\nSe prendo gli insiemi che mi piacciono e li metto in fila posso scegliere a piacimento sequenze ordinate di valori presi dai rispettivi domini. Come indico tutti queste possibilità? Con il ***prodotto cartesiano***.\n$$\nD_1 \\times D_2 \\times ... \\times D_k \\Rightarrow \\{(v_1, v_2, ..., v_k)\\quad | \\quad v_1\\in D_1, v_2 \\in D_2, ..... V_k \\in D_k\\}\n$$\nQuesta operazione associa ogni elemento del dominio $D_1$ a ogni possibile combinazione di tutti gli elementi di tutti gli altri domini, realizzando tutte le possibili <span style=\"color:#00b050\">***tuple***</span> (<span style=\"color:#cd0a0a\">***record***</span>, <span style=\"color:#cd0a0a\">***tuple***</span> $\\Rightarrow$ <span style=\"color:#ffc000\">***tuple***</span>) $(v_1, v_2, ..., v_k)$. Qualsiasi sottoinsieme di tali <span style=\"color:#00b050\">***tuple***</span> è detto <span style=\"color:#00b050\">***relazione***</span> (<span style=\"color:#cd0a0a\">***istanza***</span>, <span style=\"font-style:italic; font-weight:bold; color:#cd0a0a\">***istanza di relazione***</span>, <span style=\"color:#cd0a0a\">***tabella***</span>, <span style=\"color:#cd0a0a\">***relazione***</span> $\\Rightarrow$ <span style=\"color:#ffc000\">***relazione***</span>), e $k$ è detto **grado della  <span style=\"color:#ffc000\">relazione</span>**.\n\nOk, ma quante tuple ci potranno mai essere? Ogni dominio ha una ***cardinalità***, che dà informazioni sul numero di elementi in esso contenuti.\n\n- **Cardinalità finita** - il dominio ha un numero finito di elementi (e.g. Alfabeto, $\\{0, 1\\}$, ...). In questo caso, la cardinalità si indica semplicemente con il numero di elementi dell'insieme;\n- **Cardinalità infinita ($\\aleph$)** - il dominio ha un numero infinito di elementi. Distinguo ulteriormente in\n\t- **Infinito numerabile** ($\\aleph_0$) - posso scrivere gli infiniti elementi in sequenza (e.g. $\\mathbb{N}$, $\\mathbb{Q}$, ...);\n\t- **Infinito non numerabile** ($\\aleph_1$ e successivi) - non posso scrivere gli infiniti elementi in sequenza (e.g. $\\mathbb{R}$ è $\\aleph_1$, l'insieme delle funzioni $f: \\mathbb{R}\\rightarrow \\mathbb{R}$ è $\\aleph_2$, ...).\n\nLa cardinalità del prodotto cartesiano è il prodotto delle cardinalità dei domini. Finché ci sono solo cardinalità del finito è un semplice prodotto (e.g. se $|A| = n$ e $|B| = m \\Rightarrow |A\\times B| = m\\cdot n$, ovvero se combino $n$ elementi con altri $m$ ottengo $m\\cdot n$ coppie), mentre se ho $\\aleph$ devo sommare gli indici (e.g. se $|C| = \\aleph_0$ e $|D| = \\aleph_1  \\Rightarrow |A\\times B \\times C \\times D| = \\aleph_{0+1} = \\aleph_1$). Notare che la cardinalità infinita letteralmente *divora* quella finita.\n\nSe a questi insiemi su cui faccio il prodotto cartesiano associo delle <span style=\"color:#cd0a0a\">***etichette***</span> che mi dicono cosa rappresentano (e.g. $A$ il cui dominio è $[15, 30] \\in \\mathbb{N}$ è un *voto*) creo degli <span style=\"color:#cd0a0a\">***attributi***</span>. Se poi scelgo un insieme di attributi (al quale magari associo un nome) ottengo uno <span style=\"font-weight:bold; color:#cd0a0a\">***schema di relazione $R$***</span> (e.g. se scelgo gli attributi *studente*, *corso* e *voto* posso chiamare questo insieme di attributi *esame* e renderlo uno schema di relazione) ***invariante nel tempo***. Questo indica in generale **tutti i possibili sottoinsiemi delle <span style=\"color:#cd0a0a\">tuple</span>** (e quindi tutte le possibili <span style=\"color:#cd0a0a\">***istanze $r$***</span>, che in pratica sono delle <span style=\"color:#00b050\">***relazioni***</span> in cui assegno un nome ai domini). In questo senso, una singola <span style=\"color:#cd0a0a\">***istanza***</span> (o <span style=\"color:#cd0a0a\">***tabella***</span>) è una ***tabella*** riempita secondo il suo <span style=\"color:#cd0a0a\">***schema***</span>.\n\nL'insieme degli <span style=\"font-weight:bold; color:#cd0a0a\">***schemi di relazione***</span> $(R_1, R_2 ..., R_n)$ è lo <span style=\"font-weight:bold; color:#cd0a0a\">***schema del DB relazionale***</span>.\n","x":-1160,"y":1564,"width":880,"height":976,"color":"4"},
		{"id":"6bb122e548f7283b","type":"text","text":"# Conseguenze\n\nLe <span style=\"color:#00b050\">***relazioni***</span>  sono rappresentate come <span style=\"color:#cd0a0a\">***tabelle***</span> di <span style=\"color:#cd0a0a\">***tuple***</span>.\n\n- In una <span style=\"color:#cd0a0a\">***tabella***</span> il numero di <span style=\"color:#cd0a0a\">***tuple***</span> è la cardinalità di quella specifica  <span style=\"color:#ffc000\">***relazione***</span>;\n- Non posso avere <span style=\"color:#ffc000\">***tuple***</span> duplicate;\n- Non ho (e di conseguenza non posso assumere) nessun ordinamento tra le <span style=\"color:#ffc000\">***tuple***</span>: sono elementi di insiemi!\n- A livello di logica matematica, posso scegliere arbitrariamente quali  <span style=\"color:#ffc000\">***tuple***</span> inserire nella mia <span style=\"color:#ffc000\">***relazione***</span>, a patto che rispettino lo <span style=\"font-weight:bold; color:#cd0a0a\">***schema di relazione***</span>;\n- A livello pratico non sempre posso scegliere tutte le possibili <span style=\"color:#ffc000\">***tuple***</span>: esistono dei <span style=\"color:#cd0a0a\">***vincoli***</span>.","x":-2340,"y":1564,"width":920,"height":316,"color":"4"},
		{"id":"9af72174f7185470","type":"text","text":"# Sistema Informativo\n\nNel momento in cui è necessario gestire dati e informazioni si introduce la nozione di **_Sistema Informativo_**, un'entità che si occupa di\n\n- raccolta e acquisizione delle informazioni;\n- archiviazione e conservazione delle informazioni;\n- elaborazione delle informazioni;\n- distribuzione delle informazioni.\n\nSi tratta di un modello indipendente dall'implementazione, e quindi dall'informatica: esempi di Sistemi Informativi possono essere infatti una biblioteca o un archivio.\n\nPuò essere visto come componente di un'**_organizzazione_** (nel senso letterale di _sistema organizzato_) che opera a supporto delle altre componenti.\n\nSicuramente l'informatica è un modo ottimale di implementare un SI.\n\nIn senso informatico, un SI è un complesso di dati organizzati fisicamente in una memoria secondaria e gestiti in maniera tale da consentirne facilmente la creazione, l’aggiornamento e l’**_interrogazione_** (leggi: reperire i dati conservativi).\n\n\n\n","x":-2190,"y":-774,"width":620,"height":688,"color":"6"},
		{"id":"26a4c1c0b1aebc3f","type":"text","text":"# Base di Dati (Database) e DBMS\n\nUna **_Base di Dati_** (o _**Database**_, _**DB**_) è un insieme di **_file (gruppi di dati) mutuamente connessi_** da relazioni definite in fase di progettazione.\n\nL'interconnessione è condizione necessaria per poter implementare degli algoritmi di ricerca più sofisticati (in assenza di collegamenti, non esiste un ordine).\n\nLe relazioni sono più importanti dei dati in sé, perché cruciali per garantire la consistenza delle informazioni (e.g. una possibile relazione può essere che a una corrispondenza di matricola corrisponda lo stesso nome studente) e l'efficienza nel reperirle.\n\nI dati si riferiscono a un contesto ben preciso: non è utile generalizzare un'implementazione del genere, ci si concentra sul problema specifico.\n\nIl software in grado di gestire e interrogare i DB (intesi come collezioni di dati strutturati, processabili e condivisi) è il **_DBMS (Data Base Management System)_**, fortunatamente già scritto da qualcun altro (si compra la licenza).\n\nIl DBMS viene installato su SO, ma di fatto è a sua volta un SO. Mentre il Kernel si occupa di allocare, il DBMS si occupa di come sono organizzati i file del DB. In quanto pseudo-SO, un linguaggio come C può mettere a disposizione delle chiamate a DBMS (scritte poi nel suo **_linguaggio di interrogazione_**) esattamente come le chiamate a sistema per il SO.\n","x":-1050,"y":-774,"width":660,"height":688,"color":"4"},
		{"id":"2b9f740ce09f9ba4","type":"text","text":"## Implementazione Informatica","x":-1530,"y":-455,"width":432,"height":50,"color":"6"},
		{"id":"21392b0e654238df","type":"text","text":"# Zona SI\n\ni dati (fatti grezzi, fenomenologia) devono essere interpretati e correlati per estrarre informazioni.\n\n\n## from slides\n\nIn una organizzazione ogni componente è interessata ad una porzione del Sistema Informativo\n•Queste porzioni possono sovrapporsi\n•Una base di dati è una risorsa integrata condivisa da diverse componenti\n•L’integrazione e la condivisione permettono di ridurre ridondanze (dati parzialmente o totalmente replicati) e conseguenti inconsistenze\n\nLa condivisione non è mai completa: controllo della privacy e regolamentazione degli accessi\n• La condivisione comporta la necessità di gestire accessi contemporanei agli stessi dati: controllo della concorrenza\n","x":-3175,"y":-1800,"width":780,"height":850},
		{"id":"b07c9a0115988648","type":"text","text":"# PRO e contro\n\n- I dati sono condivisi, unificati, privi di ridondanze e incoerenze;\n- Protezione da crash dei sistemi;\n- Ottimizzazione dell'accesso concorrente;\n- Facilità di interfacciamento con applicazioni esterne.\n\n#### CONTRO\n- Prodotto complesso e costoso;\n- Se il DB è piccolo, il gioco non vale la candela.","x":-3165,"y":-860,"width":770,"height":720},
		{"id":"c7400b10fa21ae78","type":"text","text":"# Storia","x":-46,"y":-86,"width":147,"height":50,"color":"6"},
		{"id":"e62ff9ade2624375","type":"text","text":"# Modello Entità-Relazioni (Entità-Associazioni)\n\nLa <span style=\"color:#cd0a0a\">***tabella***</span> (<span style=\"color:#ffc000\">***relazione***</span>) `studenti` che ha come attributi `matricola`, `nome` e `cognome` è perfettamente consistente di per sé, cioè ha senso di esistere indipendentemente dal resto del DB $\\Rightarrow$ ***Entità***.\n\nAnche la <span style=\"color:#cd0a0a\">***tabella***</span> (<span style=\"color:#ffc000\">***relazione***</span>) `corsi` avente come attributi `codice`, `titolo` e `professore` ha senso indipendentemente dal resto del DB $\\Rightarrow$ **Entità**.\n\nLa <span style=\"color:#cd0a0a\">***tabella***</span> (<span style=\"color:#ffc000\">***relazione***</span>) `esame` che ha come attributi `matricola`, `codice` e `voto` ha senso di esistere solo in quanto associazione di un elemento dell'entità `studenti` ad uno dell'entità `corsi` $\\Rightarrow$ <span style=\"color:#7030a0\">***Relazione***</span>.\n\nLa lingua italiana traduce allo stesso modo <span style=\"color:#ffc000\">***relation***</span> e <span style=\"color:#7030a0\">***relationship***</span>. Da qui in poi ci riferiremo alla <span style=\"color:#7030a0\">***relazione***</span> come <span style=\"color:#7030a0\">***associazione***</span> sperando di creare meno panico.\n\nQuindi, perché è importante distinguere entità e associazioni?\nIpotizziamo di non farlo: memorizzo nella stessa struttura i dati dello studente, del corso e dell'esame. Ogni volta che lo studente sostiene un nuovo esame sono costretto a ripetere i suoi dati. In modo analogo, se lo stesso esame è sostenuto da un altro studente sono costretto a ripetere i dati del corso.\n\nIn pratica, la definizione del ruolo degli elementi quando costruisco il modello concettuale è cruciale per evitare la produzione di ridondanze.\n\n","x":-2340,"y":820,"width":920,"height":536,"color":"4"},
		{"id":"bdfda8f59f454594","type":"text","text":"## Esempio: Modello Reticolare\n\nL'implementazione dell'esempio sotto in un modello reticolare prevede che i riferimenti dell'<span style=\"color:#7030a0\">***associazione***</span> `esami` siano puntatori alle zone di memoria delle entità `studenti` e `corsi`, referenziando in pratica l'intero record. \"Capite bene che il porting di un DB del genere era un bagno di sangue\".","x":-2340,"y":600,"width":920,"height":160,"color":"4"},
		{"id":"8fc1cdfff9089b77","type":"text","text":"# Perché il Modello Relazionale è \"rivoluzionario\"?\n\nAnzitutto perché non ci sono riferimenti espliciti (puntatori a memoria), ed è pertanto **_indipendente dalla memorizzazione fisica dei dati_**. Questo di fatto risolve tutti i problemi di portabilità e semplifica di molto il lavoro dei programmatori, che non dovendo preoccuparsi della struttura sottostante possono manipolare il DB in modo logico (il che ovviamente porta a un'accelerazione nello sviluppo dell'intero campo).\n\nCiò accade perché sia dati che relazioni sono rappresentati come valori (**_riferimento per valore_**), e l'intero modello si basa sulla possibilità di costruire dei valori speciali (**_chiavi_**) che identificano univocamente le tuple nelle istanze.\n\nIn questo senso possiamo definire\n\n- tutte e sole le informazioni rilevanti rispetto al problema - **Attributi**;\n- i **vincoli** che legano tra loro le informazioni;\n- un modo univoco per risalire a una certa informazione - **Chiavi**.\n","x":-2340,"y":100,"width":920,"height":435,"color":"4"},
		{"id":"e6f895d6dfd08caf","type":"text","text":"\nnon è detto che tutte le combinazioni di valori di questi domini abbiano un senso, e da qui vengono fuori i vincoli.\n\ndal punto di vista operativo, questo si traduce in una tabella\n\ni domini si possono ripetere, sono le etichette associate che danno l'unicità\n","x":-5052,"y":1722,"width":250,"height":380},
		{"id":"d978bd83e81a4684","type":"text","text":"# Glossario illogico del Modello Relazionale I\n\nIl modello relazionale fa casino con i nomi. Vediamo di capirci qualcosa.\n\n- **_Entità_** - Schematizzazione logica dell'oggetto di interesse da memorizzare;\n- **_Attributi_** - Caratteristiche che definiscono l'entità, sono associati a un **_dominio_** di valori che gli possono essere assegnati (e.g. gli attributi `colore`, `marca` e `modello` possono essere attributi che definiscono l'entità `macchina`, e non posso scegliere il valore `15` per l'attributo `colore` perché sono fuori dal suo dominio). In generale sono definiti da un nome e da un dominio;\n- **_Campo_** - A volte usato come sinonimo di attributo, può riferirsi allo specifico  valore assegnatogli (e.g. il campo dell'attributo `colore` può essere `rosso`);\n- **_Record (Tupla, t)_** - Un set di campi $\\Rightarrow$ uno specifico set di valori assegnati agli attributi che in pratica definisce un'entita o una relazione (*relationship*);\n- **_Schema ($R$)_** - L'inseme di tutti e soli gli attributi e del nome della relazione (e.g. `nome = studente` e attributi `nome`, `cognome` e `matricola` sono lo schema della relazione). Si può dire che un'istanza è una tabella riempita secondo il suo schema. A rigore nello schema rientrano anche i tipi e i domini degli attributi (e.g. `matricola` è un intero positivo), nonché le **_chiavi_**, i _**vincoli d'integrità**_, ... \n- **_Istanza ($r$)_** - Un insieme di tuple omogenee ($\\Rightarrow$ aventi tutte gli stessi attributi) a cui è associato un nome (e.g. `nome = studente` e tuple i cui campi sono i valori di `nome`, `cognome` e `matricola`). Usato talvolta per indicare una singola tupla (e.g. un'istanza specifica all'interno di una tabella);\n- **_Tabella_** - Implementazione effettiva delle istanze: le istanze sono rappresentate mediante tabelle;\n- **_Relazione_** - Termine in cui collassano due distinti termini inglesi:\n\t- **_Relation_** - Usato come sinonimo di **Tabella (Istanza di Relazione, aspetto intensionale)** e di **Tupla (Schema di Relazione, aspetto estensionale)**, per intendere l'implementazione del concetto matematico di relazione; Se volessimo essere precisi MI SA che dovremmo chiamare la Tabella RELAZIONI.\n\t- **_Relationship_** - Si riferisce a una connessione logica tra tabelle (e.g. se due tabelle rappresentano le entità `studenti` e `corsi`, `esame` è una *relationship* che associa un elemento `studente` a un elemento `corso`, potenzialmente aggiungendo l'informazione `voto`). Il guaio è che una *relationship* è a sua volta una *relation* (perché poi ovviamente questa informazione viene implementata come tabella), quindi in italiano si usa *relazione* dando per scontato tutto questo buco nero di significati. Per diminuire la confusione possiamo chiamare la *relationship* ***associazione***.\n\n","x":-4802,"y":1549,"width":880,"height":920,"color":"3"},
		{"id":"9f75da23c1fde580","type":"text","text":"# Glossario illogico del Modello Relazionale II\n\n- Vincoli d'Integrità \n- dipendenze funzionali - vincoli in scritti in matematichese su attributi definiti all'inizio, e.g. prescrive che se una coppia di tuple ha un certo valore uguale allora deve avere altri valori uguali (e.g. se ho stesso CF avrò anche stesso nome e cognome). vale sia su coppie di attributi sia su coppie di insiemi di attributi. si definisce sullo schema. a --> b si legge \"a determina b\". Una tupla che viene inserita in un'istanza (un insieme di tuple) deve rispettare le dipendenze funzionali (di quell'istanza? o generali?)\n- chiusure (degli insiemi di attributi e degli insiemi di dipendenze funzionali)","x":-6660,"y":2706,"width":686,"height":605},
		{"id":"9ac131662f9a9040","type":"text","text":"##### circa le dipendenze funzionali\na --> b = se le tuple sono uguali su a devono esserlo anche su b. se ho valori diversi su a non mi interesso di b.","x":-5870,"y":2809,"width":420,"height":400},
		{"id":"bfd96ba22ace7d31","type":"file","file":"Screenshot from 2024-04-13 20-40-23.png","x":-240,"y":1564,"width":400,"height":227},
		{"id":"07503dab96a8215c","type":"text","text":"\nLe singole tuple sono funzioni che associano ad ogni attributo $A$ dello schema di relazione $R$ un elemento preso dal dominio di $A$.\nNella tupla ($t$) trovo il valore associato all'i-esimo come $t[i]$. Ma la notazione posizionale non ci piace. Allora uso le etichette. tipo $t[etichetta]$. -> posso riordinare le colonne come mi pare.\n\n\nNel nostro caso facciamo i prodotti cartesiani di relazioni, dove ognuna è un insieme di tuple (ogni tupla del primo insieme combinata con ogni tupla del secondo). NB: ogni tupla è a sua volta un sottoinsieme del prodotto cartesiano dei domini. è l'operazione di base per combinare le informazioni. ","x":-2432,"y":2621,"width":796,"height":357},
		{"id":"610f11a1cc17db76","type":"text","text":"# Vincoli d'Integrità\n\nDalle ***dipendenze funzionali*** (e.g. uno studente risiede in una sola città) seguono i vincoli d'integrità\n\n- un voto è un intero positivo compreso tra 18 e 30 (***vincoli di dominio***)\n- Vincoli di tupla, ossia delle proprietà che devono essere rispettate da ogni tupla appartenente ad un’istanza di una relazione\n- Vincoli di unicità, ossia l’impossibilità di avere due tuple con lo stesso valore per un determinato attributo (si impone con la direttiva `unique`)\n- Vincoli di esistenza del valore, ossia l’impossibilità per un attributo di una tupla di poter essere impostato su Null (direttiva `Not Null`)\n\t- la matricola identifica univocamente uno studente, non possono esserci valori duplicati per la matricola, né può avere valori nulli (***vincoli di chiave***)\n- lo straordinario di un impiegato è dato dal prodotto del numero di ore per la paga oraria; lo stipendio di un impiegato non può diminuire (***vincoli dinamici***)\n\nUn DB è corretto se soddisfa tutti i vincoli.\n\nDalle dipendenze funzionali seguono le chiavi.\n\nse non ho chiavi ne inserisco una artificiale (e.g. contatore autoincrementante)","x":-2996,"y":2504,"width":476,"height":679},
		{"id":"24c928c1146b9fc6","type":"text","text":"# Dipendenze funzionali\n\nse due tuple hanno lo stesso valore sull'attributo ***determinante*** devono avere lo stesso valore anche sull'attributo ***dipendente*** (e.g. matricola determina provincia di residenza)\n$$X\\rightarrow Y$$\nnon \"implica\", che ha un valore logico-matematico di verità! X e Y in generale sono insiemi (e.g. codice fiscale determina nome e cognome, nome e cognome determinano iniziali)\n\nposso costruire una catena di dipendenze in cui se provincia determina regione allora matricola determina regione. Nella chiusura dell'attributo matricola ci finisce anche regione: la chiusura di un attributo è data da tutti gli attributi che questo determina direttamente e indirettamente.\n\ndi per sé sono limitate ad attributi dello stesso schema (non posso fare \"foreign dipendenza funzionale\"). formalmente si dice che $X\\rightarrow Y$ è applicabile ad R, nel senso che X e Y sono sottoinsiemi di R.","x":-3781,"y":2504,"width":562,"height":679},
		{"id":"1fe2b64d43eb657f","type":"text","text":"qui si fanno solo vincoli intrarelazionali, ovvero dentro la stessa relazione, non interrelazionali\n\n\nlei specifica \n\n- uno studente risiede in una sola città (dipendenze funzionali)\n- la matricola identifica univocamente uno studente (vincoli di chiave)\n- un voto è un intero positivo compreso tra 18 e 30 (vincoli di dominio)\n- lo straordinario di un impiegato è dato dal prodotto del numero di ore per la paga oraria; lo stipendio di un impiegato non può diminuire (vincoli dinamici cioè del mio sistema specifico)","x":-2340,"y":3038,"width":600,"height":600},
		{"id":"d870b420ba88c947","type":"text","text":"# IL LOG\nEsempio: Ritiro al bancomat, ma poco prima che eroghi i soldi salta la luce. Ho perso i soldi?\nPur essendo ogni transazione costituita da molte micro-operazioni, in un DBMS viene trattata come unica entità, seguendo un principio di \"o tutto o niente\". Come faccio ad esserne certo? Intanto non succede sempre. Può essere ABORTITA per qualche motivo (deadlock o banalmente mancanza di elettricità). Allora come riparo? Annullo le operazioni parziali fatte. La transazione deve arrivare a dare il comando di COMMIT per non essere annullata. Ma in pratica fare recovery in qualsiasi momento richiederebbe un backup in tempo reale, idea inverosimile. Allora, invece di scrivere nel DB scrivo nel LOG delle transazioni sia il vecchio che il nuovo valore per ogni micro-operazione, e ogni tot aggiorno il DB. In questo modo il DB resta sempre consistente (è in uno STATO LEGALE), e se una transazione si interrompe nel log è sufficiente riavviare il log. In pratica il log è il foglio di brutta e il DB è la bella.","x":5200,"y":2139,"width":697,"height":453},
		{"id":"db149c6dcc328f3d","type":"text","text":"# CONTROLLO DI CONCORRENZA\nVoglio che ogni accesso sia sicuro e coerente, permettendo a ogni utente di fare le operazioni. Se ad esempio devo comprare un biglietto, il DBMS deve garantirmi che mentre lo faccio non ci sia qualcun altro che lo compra in contemporanea. Ogni utente deve avere l'impressione di essere l'unico utente sul sistema e che le operazioni avvengano in NEAR-REAL_TIME. Per fare questo, il DBMS non può mettere le richieste degli utenti (TRANSAZIONI) in fila, ma deve parallelizzarle quanto più possibile. Gli accessi al disco sono frequenti e lenti, motivo per cui deve sfruttare quanto più possibile la CPU. Ogni transazione deve sempre e comunque rispettare i VINCOLI DI INTEGRITA', ovvero vincoli che impongono di lasciare il DB in uno stato consistente.\n\n- Esempio: Mario e Anna guadagnano 1000, e il vincolo è che debbano guadagnare entrambi la stessa cifra. Due dirigenti usano il DBMS per alzare loro lo stipendo, in particolare\n\t- Il primo dirigente (X) vuole eseguire l'operazione +100;\n\t- Il secondo dirigente (Y) vuole eseguire l'operazione \\*2;\n\tX e Y accedono contemporaneamente. X inizia a modificare Mario, portandolo a 1100. Y trova Mario occupato, ed esegue la sua operazione su Anna, portandola a 2000. Poi liberano i rispettivi record e passano al successivo, portando in definitiva Marco a guadagnare 2200 e Anna 2100. Inconsistenza con il vincolo! Il DBMS non deve permetterlo.\n\nIl DBMS impedisce che esistano errori di questo tipo nel seguente modo: va bene fare operazioni in contemporanea, ma solo a patto che\nesista una qualche successione di operazioni non parallele che portino il DB nello stesso risultato.\n\n- Nell'esempio di prima, se agisse prima X e poi Y avrei entrambi gli stipendi a 2200, ed entrambi a 2100 viceversa. Non esiste quindi alcuna esecuzione seriale che permetta a Mario di guadagnare 2200 e Anna 2100. E' importante ricordare che il DBMS non sa qual è lo stipendio giusto. Se dovesse verificarsi un accesso in contemporanea, il DBMS sceglierebbe casualmente l'esecuzione seriale associata garantendo il rispetto del vincolo (entrambi hanno lo stesso stipendio).\n\nLa garanzia più robusta è il protocollo di STRICT TWO PHASE LOCKING (Strict 2PL).\n\n- Prima di leggere e/o scrivere uno o più oggetti, la transazione X richiede al DBMS un LOCK su tali oggetti. Ovvero, un qualsiasi altra transazione Y che vuole interagire con questi oggetti dovrà aspettare l'esecuzione della prima;\n- I lock vengono rilasciati al termine dell'esecuzione di X;\n- Y potrà accedere agli oggetti, e a sua volta richiederà un lock.\n\nQuesto chiaramente può portare a tempi di attesa lunghi. Ci sono sistemi più sofisticati che rilasciano i lock in modo graduale (rilassano la condizione STRICT), ma a quel punto si rischia un DEADLOCK (in cui due oggetti sono necessari per il prosieguo delle transazioni X e Y ma sono bloccati dall'altra transazione), situazione che richiede il riavvio di una delle due transazioni.\n","x":5046,"y":2620,"width":1052,"height":931},
		{"id":"eac6417a6b7e152d","type":"text","text":"# Con che logica lo scrivo?","x":2860,"y":1678,"width":408,"height":50,"color":"6"},
		{"id":"23afcf5b45f8bffc","type":"text","text":"# Algebra Relazionale","x":104,"y":3000,"width":360,"height":50,"color":"6"},
		{"id":"7f387917126a1ab6","type":"text","text":"- attributi = domini + etichette\n- schema di relazione = insieme di attributi (tant'è che si scrive $R(A_1, A_2, ...)$) = generica relazione in senso matematico + etichette sui domini\n\t- descrive la struttura della relazione in senso dei DB (aspetto intensionale)\n\t- in pratica dice quali sono le possibili tuple che possono esistere, e conseguentemente ingloba tutti i possibili subset di queste tuple\n- Istanza di relazione = insieme di tuple che definiscono valori sugli attributi dello schema di relazione = specifica relazione in senso matematico + etichette sui domini\n\t- specifico set tra tutti i possibili set che posso creare con le tuple consentite dallo schema di relazione (aspetto estensionale)\n\t- ***in ogni istante, in un DB ho una sola istanza di relazione sullo schema di relazione corrispondente!!!***. per convenienza nelle operazioni uso il nome dello schema, ma in pratica uso l'istanza (tanto c'è corrispondenza 1 a 1)\n- le dipendenze funzionali dipendono dal significato delle etichette degli attributi. per questo si dice A DETERMINA B (non implica!), perché non è una roba matematica, è una cosa concreta che faccio a posteriori del significato delle etichette che uso.\n- esiste anche lo schema del DB, che è gli insieme degli schemi di relazione.","x":-3400,"y":1503,"width":560,"height":920},
		{"id":"83365c31bb5de31f","type":"text","text":"# Appunti\n\nle cose che posso calcolare non le salvo\n\nsi costruiscono degli indici, a loro volta delle tabelle, costruito sulle chiavi. più grosso è più faccio fatica, perché devo accedere alla memoria. \n\nle chiavi alternative si scoprono con le dipendenze funzionali. sono quelle la cui chiusura include tutti gli elementi dello schema.\n\ntransazione: insieme di operazioni che nel complesso risulta atomica sul DB (se ci riesco commit, altrimenti se vengo interrotto roll back). Lo storico delle modifiche si chiama LOG, ogni tot viene fatta una copia di backup del DB detto DUMP.\n\ncontrollo di concorrenza: non voglio rompere lo pseudoparallelismo, non metto in batch.\n\n\nDB attivi: a ogni operazione controlla tutti i vincoli complessi\n\n","x":3297,"y":2520,"width":653,"height":1596},
		{"id":"256ee83c51638bab","type":"text","text":"se dichiaro una roba primary key il sistema mi impedisce di inserire duplicati, altrimenti si fa con unique.\n\ntabelle master sono le entità, slave le relationship (e.g. studente e corso sono master, esame è slave)","x":2777,"y":3422,"width":391,"height":330},
		{"id":"3aec0d0f14f7cf5c","type":"text","text":"# Zona Sicurezza\n\n\n\nin una bdd è possibile centralizzare i dati e poi dividere in moduli a seconda dei privilegi di accesso e/o simili --> evito ridondanze e anomalie (e.g. se faccio database di tutte info docenti, gli studenti possono accedere solo ad alcune info, senza fare due bdd diverse)\n\ncontrollo della consistenza via controllo della concorrenza --> sincronizzazione\n\n\n\n#### rischio inconsistenze\n\nridondanza era bestia nera delle bdd, rischi inconsistenze (altra cosa è il mirroring, che ogni tot fa un backup dei dati e ci sono master e slave)\n\n- ridondanza (si risolve con buona progettazione)\n- concorrenza (si risolve con meccanismi di sincronizzazione, che però stanno al DBMS esattamente come stanno al Kernel nel SO)\n\n","x":2892,"y":4222,"width":811,"height":726},
		{"id":"e0ca754560103232","type":"text","text":"# Come si interagisce con un RDBMS?\n\nIl *linguaggio di interrogazione* *ad-hoc* per i DBMS relazionali è **_SQL (Structured Query Language)._** Si può accedere anche con i linguaggi canonici (C, Java, ...) se al loro interno includono i comandi di SQL. Questo si distingue in due linguaggi formali:\n\n- **_DDL (Data Definition Language):_** Definisce gli schemi del DBMS. Serve nella fase di progettazione.\n- **_DML (Data Manipulation Language):_** Gestisce le richieste sui dati (**_query_**);\n\n\nIl potere espressivo (ovvero ciò che posso calcolare con un linguaggio) è dato dalla classe di query calcolabili, ed è diverso da quello di un normale linguaggio Touring-completo. I motivi per la scrittura ad hoc di un linguaggio di interrogazione rispetto a uno classico sono \n- Maggiore semplicità di utilizzo per il compito specifico;\n- Costante ottimizzazione per le interrogazioni.\n\nTra un'operazione ottimizzata e una non ottimizzata ci possono essere differenze di svariati ordini di grandezza. Poi moltiplica per il numero di operazioni e il disastro è compiuto. Dentro SQL ci sono due linguaggi equivalenti:\n\n - Algebra relazionale: linguaggio procedurale (fornisce la procedura per ottenere il risultato);\n- Calcolo relazionale (che non si studia, ma alcune cose di SQL si basano su di esso): linguaggio dichiarativo, descrivo in modo formale le caratteristiche del risultato che voglio senza darne la procedura.\n\nCi focalizziamo sull'algebra. Costituita da\n\n- Operandi: tabelle relazionali;\n- Operatori: unari o binari su operandi.\n\nE' chiusa rispetto al risultato e gode di tutte le proprietà delle algebre (associativa, commutativa, ...). Seguono gli operatori ad hoc per operare sulle tabelle:\n\n- Insiemistici\n\t- Unione\n\t- Intersezione\n\t- Differenza (presenti nella prima ma non nella seconda), non simmetrica e quindi non commutativa.\n\t\n- Ridenominazione, puramente sintattico, forma P(R(F), E) dove (($\\rho_{\\text{new}\\leftarrow\\text{old}}$))\n\t- P è l'operatore Ridenominazione;\n\t- R è il risultato;\n\t- F è la LISTA DI RIDENOMINAZIONE nella forma (vecchio nome -> nuovo nome; posizione -> nuovo nome; ...);\n\t- E è l'istanza di input.\n\n- Prodotto cartesiano, che invero è insiemistico vabb. Permette di creare nuove tuple modificando quelle esistenti. Se faccio RxS ottengo tutte le possibili combinazioni delle tuple di R con tutte quelle di S. Quindi se R ha campi ABC e S DE RxS ha ABCDE. Molto importante ottimizzare questa operazione perché il risultato esplode. Raramente, infatti, lo si usa. Si usa il JOIN. Se unisco tabelle aventi campi con lo stesso nome, nel risultato NON avranno nome, le devo rinominare con la posizione.\n\t\n- Selezione, la condizione è booleana. Taglia le righe.\n\n- Proiezioni, taglia le colonne, nuova tabella contiene colonne specificate nella condizione. Le tuple sono <= (= se prendo la chiave, se \tnon la prendo non è detto che sia strettamente minore). Bisogna stare attenti alle chiavi. Non c'è l'oggetto tupla, ma solo i valori\n\t\tche contiene. In genere è l'ultimo operatore applicato, seppure l'algebra sia commutativa. Questo perché prima costruisco il risultato senza rischiare di tagliare fuori le chiavi (e quindi far collassare tuple diverse nella stessa tupla, e quindi perdere informazione);\n\nPoi operatori derivati, ma un paio sono così utilizzati che vale la pena menzionarli\n\n- Join (o theta-join): perno delle query, prodotto cartesiano + selezione. Costruisce solo le tuple utili del prodotto cartesiano. Il DBMS implementa i Join, non il cartesiano. I più interessanti sono con condizione di uguaglianza (EQUI-JOIN) con campi di cui uno\n\t\tdei due è chiave, l'altro è foreign key. Perché?\n\t\n- Join Naturale, ovvero equi-join in cui specifico una condizione per ogni attributo comune alle due tabelle. IN SQL NON ESISTE!!;\n\n- Divisione, introdotta per cose del tipo \"dimmi gli studenti che hanno fatto tutti gli esami\". Sia A una relazione con due campi, x e y. Sia B una relazione con il solo campo y. A/B contiene i valori x in A associati a tutti gli elementi y che compaiono in B. Concettualmente, si opera trovando tutti i valori x che NON vanno bene e si sottraggono.\n\nLa compatibilità delle interrogazioni è puramente sintattica (e non semantica). Sta a chi scrive assicurarsi che abbiano senso concettuale. Per convenzione, se unisco due tabelle i nomi delle colonne sono quelli della prima tabella. E qui entra in gioco Ridenominazione.\n\nIn algebra relazionale (e quindi in SQL) non ho modo di confrontare tuple diverse. Se devo fare un confronto, mi servono i valori da confrontare scritti nella stessa tupla. Non ci sono variabili, blocchi condizionali o cicli.\n\n- Se ad esempio devo trovare un minimo di una colonna, piuttosto che confrontarli elimino a coppie quelli più grandi.\n\nIn generale succede sempre così quando mi servirebbe un ciclo. In algebra relazionale non si possono ricostruire catene di riferimenti o alberi genealogici. Se facendo operazioni incontro un valore NULL, il sistema non lo includerà nel risultato se non diversamente specificato.\n\n","x":1064,"y":2922,"width":1200,"height":1658},
		{"id":"c44ff0137238f8c0","type":"text","text":"# Vincoli\n\nPerché nelle applicazioni pratiche parliamo di <span style=\"color:#cd0a0a\">***istanze***</span> (e quindi solo di sottoinsiemi) invece di considerare tutti i possibili risultati?\n\n- è quasi sempre impossibile prendere in considerazione tutte le possibili <span style=\"color:#ffc000\">***tuple***</span> per motivi di spazio: la cardinalità del ***prodotto cartesiano*** scala esponenzialmente con il numero di <span style=\"color:#cd0a0a\">***attributi***</span>. Questo di per sé è già un problema con domini a cardinalità finita, figuriamoci se anche solo uno di questi è $\\aleph$;\n- certe combinazioni non esistono nella realtà, oppure sono io a imporre che non devono esistere. Da questa considerazione nasce il concetto di  <span style=\"color:#cd0a0a\">***vincolo***</span>.\n\n\ncon i vincoli di dominio limito la cardinalità (e.g. parto dagli interi ma poi dico solo quelli positivi e minori di 30).\n\n","x":-2340,"y":1999,"width":920,"height":541},
		{"id":"72db887a0fb2db34","type":"text","text":"in una tupla t con X attributi, se scelgo $Y \\subset X$ e chiedo y\\[Y\\] questa è detta RESTRIZIONE della tupla","x":724,"y":3280,"width":250,"height":455},
		{"id":"c359660dca023913","x":-3010,"y":3423,"width":510,"height":597,"type":"text","text":"# Anomalie\n\n\nSe uno schema relazionale è mal progettato, potrebbero verificarsi le seguenti ano-\nmalie:\n• Anomalie di inserimento, dove non è possibile inserire un dato senza inserire\naltre informazioni non vere o non disponibili\n• Anomalie di cancellazione, dove la cancellazione di un record potrebbe portare\nalla perdita di altre informazioni importanti\n• Anomalie di aggiornamento: dove l’aggiornamento di un attributo potreb-\nbe richiedere un costo elevato in quanto andrebbe aggiornato per ogni tupla\ncontenente lo stesso valore in tale attributo\n• Ridondanza dei dati, dove vi sono molti dati ripetuti"},
		{"id":"887dab4eb92293c9","type":"text","text":"$\\underset{\\text{sotto}}{\\overset{\\text{sopra}}{=}}$","x":-1560,"y":3340,"width":250,"height":60},
		{"id":"a2b5fda883cdac87","type":"text","text":"# Operazioni dell'Algebra Relazionale\n\nè il linguaggio formale che sottende al linguaggio di interrogazione SQL. Di fatto, non viene eseguito da nessuna macchina, è descrittivo (ma procedurale, nel senso che descrivo la procedura). Quando faccio le operazioni uso come operandi gli elementi persistenti del DB, e metto i risultati in variabili relazionali non persistenti. Due tipi di operatori:\n\n- Unari\n\t- proiezione ($\\pi$, sulle colonne): si mangia un'istanza e sputa fuori una nuova istanza avente come colonne (attributi) solo le colonne selezionate. ATTENZIONE! Se non includo una chiave potrei perdermi informazioni. Se due matricole diverse corrispondono a due persone con lo stesso nome, $\\pi_{nome}(studente)$ restituisce un solo nome, senza ripeterlo (... perché quella nuova formalmente è una relazione). diminuisce la cardinalità (sarà $\\leq$ della relazione di partenza)\n\t- selezione ($\\sigma$, sulle righe): si mangia un'istanza e ne sputa fuori una nuova avente come righe (record) solo le righe che rispettano la condizione di selezione. $\\sigma_{città = Roma}(studente)$ restituisce solo i dati degli studenti nati a Roma. La condizione è un'espressione booleana tra un attributo e una costante o un attributo e un altro attributo con lo stesso dominio. Le stringhe costanti sono tra singoli apici. anche qui cardinalità finale $\\leq$ cardinalità di partenza, stavolta pure 0. non ho problema dei duplicati\n\t- ridenominazione Sia R una relazione con istanza r e schema R(A1 , . . . , Ak ). Una ridenominazione su R è un operatore unario che restituisce una nuova relazione R′ con istanza r′ e schema R′ (B1 , . . . , Bk ), dove le tuple di r′ sono identiche alle tuple di r: ρB1 ,...,Bk ←A1 ,...,Ak (R) := {t′ | t′ [Bi ] = t[Ai ], t ∈ r, ∀i ∈ [1, k]} In altre parole, una ridenominazione modifica il nome di un attributo della relazione.\n- binari - tra istanze di schemi diversi. in ogni istante esiste una e una sola istanza per schema di relazione. ovviamente posso farne una copia e creare `studente_2`. Non posso applicare queste operazioni come voglio, ma avrò delle restrizioni.\n\t- Unione - costruisce una tabella con le tuple che sono almeno in una delle due tabelle di partenza, le quali devono avere lo ***stesso numero di attributi e, in ordine, gli stessi domini sugli attributi***. domini compatibili perché abbia senso a livello matematico, dopodiché ***perché abbia senso logico devono significare le stesse cose*** (anche differenza funziona così). tutto questo si chiama ***union-compatibilità*** Con l'unione possono saltarmi le chiavi! ∀i ∈ [1, k], dom(R1 .Ai ) = dom(R2 .Ai ), R1 ∪ R2 := {t | t ∈ r1 ∨ t ∈ r2 }\n\t- differenza - devono essere union compatibili R1 − R2 := {t | t ∈ r1 ∧ t ∈ / r2 }\n\t- intersezione idem ma commutativa R1 ∩ R2 := {t | t ∈ r1 ∧ t ∈ r2 }\n\t- prodotto cartesiano - quello di teoria degli insiemi, attenzione che esplode rapidamente. non serve la union-compatibilità. a volte ha senso farlo di un'istanza con se stessa (e.g. devo trovare il massimo valore su una colonna. non posso farlo direttamente, posso confrontare valori solo su una singola tupla. allora faccio il cartesiano e mi escono due stipendi sulla stessa riga). da solo non ha senso, devo abbinargli una selezione. e poi magari proietto per eliminare le colonne sovrabbondanti. si può fare così, ma c'è un modo più sensato\n\t- join naturale - si mangia due istanze che abbiano almeno un attributo con lo stesso nome. Ipotizziamo sia il primo attributo per entrambe, quindi $A_{11}$ per la prima e $A_{21}$ per la seconda. Fa il prodotto cartesiano e restituisce una nuova istanza con tutte le tuple tali che $A_{11} = A_{21}$. in pratica evita di creare colonne duplicate. Ovviamente vale in generale  qualsiasi sia la posizione dell'attributo ($A_{1i} = A_{2j}$) e possono esserci più condizioni in parallelo ($A_{11} = A_{21}\\quad \\& \\quad A_{12} = A_{22}\\quad \\& \\quad...$).\n\t\t- $r_1 \\bowtie r_2 = \\pi_{XY}(\\sigma_C(r_1\\times r_2))$, dove $C$ è la condizione sugli attributi uguali, $X$ sono le colonne di $r_1$ e $Y$ sono le colonne di $r_2$ che non sono incluse in $r_1$ (ovvero quelle escluse dal join?);\n\t\t- Se R1 ed R2 hanno un insieme di attributi in comune ma nessun valore in comune per tali attributi, allora il risultato sarà un insieme vuoto;\n\t\t- Se R1 ed R2 non hanno degli attributi in comune, allora il join naturale degenererà in un prodotto cartesiano;\n\t- theta-join - (join-on) unico che esiste in SQL. via di mezzo tra cartesiano e naturale. Combino attributi che non hanno lo stesso nome. In $A\\theta B$, A e B sono attributi presi rispettivamente dalla prima e dalla seconda istanza e $\\theta$ è un operatore di confronto (e.g. $=$, $\\leq$, ...). Ovviamente A e B devono avere lo stesso dominio.\n\t\t- $r_1\\underset{A\\theta B}{\\bowtie}r_2 = \\sigma_{A\\theta B}(r_1\\times r_2)$ -  Se il DBMS non lo implementa, è equivalente al prodotto cartesiano + WHERE (proiezione).\n\t\t- si usa un tot de morgan...\n\t\t- nor non è nella formulazione originale, meglio or + not\n\t\t- In alcuni casi può essere necessario effettuare il join tra una relazione e se stessa (self join), in modo da ottenere combinazioni di tuple della stessa relazione.\n\n\n\ngli operatori sono le istanze. \nnon ha primitive di definizione e inizializzazione perché è un linguaggio astratto e non concreto (...)\n\nsql esistono i comandi perché è la sua implementazione\n\n","x":-1260,"y":3620,"width":920,"height":1856},
		{"id":"bb49ea3219faaace","x":-146,"y":3620,"width":806,"height":740,"type":"text","text":"# quantificazione universale e differenza\n\nnon posso assumere ordine tra tuple. trova clienti che non hanno mai ordinato oggetti che costano più di 10. la negazione di perogni è esiste almeno uno."},
		{"id":"fc48c5d8376ed8ab","x":-1200,"y":2844,"width":463,"height":194,"color":"6","type":"text","text":"# Teoria della Normalizzazione"},
		{"id":"5d507a27940298a8","x":891,"y":4966,"width":250,"height":60,"type":"text","text":"# rec 8"}
	],
	"edges":[
		{"id":"8244132c0918415c","fromNode":"a5db58697c7e9975","fromSide":"bottom","toNode":"b1a5285caeae4130","toSide":"top"},
		{"id":"53615e184984119f","fromNode":"9af72174f7185470","fromSide":"right","toNode":"26a4c1c0b1aebc3f","toSide":"left"},
		{"id":"04199cd57310519f","fromNode":"a5db58697c7e9975","fromSide":"right","toNode":"186012183c3f3ecd","toSide":"left"},
		{"id":"605a908ff8a064ac","fromNode":"a5db58697c7e9975","fromSide":"right","toNode":"110d5abbb0f74fea","toSide":"left"},
		{"id":"00164a5b40b396d1","fromNode":"50686229090c1bd0","fromSide":"right","toNode":"a5db58697c7e9975","toSide":"left"},
		{"id":"1d0c6513134fc948","fromNode":"a5db58697c7e9975","fromSide":"left","toNode":"50686229090c1bd0","toSide":"right"},
		{"id":"dfc5c734b7cb48f2","fromNode":"9f75da23c1fde580","fromSide":"right","toNode":"9ac131662f9a9040","toSide":"left"},
		{"id":"e1f50179b1ccf9c5","fromNode":"26a4c1c0b1aebc3f","fromSide":"right","toNode":"a5db58697c7e9975","toSide":"top"},
		{"id":"b366dee568d9bd2e","fromNode":"21febace8b459e12","fromSide":"top","toNode":"9988826790f856a8","toSide":"bottom"},
		{"id":"f3aee058f7397368","fromNode":"9d076c174e423d23","fromSide":"left","toNode":"96639327a802451a","toSide":"right"},
		{"id":"7155398d9f3dcc20","fromNode":"b1a5285caeae4130","fromSide":"right","toNode":"21febace8b459e12","toSide":"left"},
		{"id":"127c13588a0a862e","fromNode":"21febace8b459e12","fromSide":"left","toNode":"b1a5285caeae4130","toSide":"right"},
		{"id":"55f749bca076997a","fromNode":"50686229090c1bd0","fromSide":"left","toNode":"e62ff9ade2624375","toSide":"right"},
		{"id":"8e7fd85be4572932","fromNode":"060659758b3f2bc8","fromSide":"left","toNode":"5056013ae1ac0b85","toSide":"right"},
		{"id":"bb5a8560773f45aa","fromNode":"b1a5285caeae4130","fromSide":"bottom","toNode":"060659758b3f2bc8","toSide":"top"},
		{"id":"06dca09b1fea0dcf","fromNode":"060659758b3f2bc8","fromSide":"bottom","toNode":"23afcf5b45f8bffc","toSide":"top"},
		{"id":"722a7f35b9cefb82","fromNode":"21febace8b459e12","fromSide":"bottom","toNode":"e8974e97e6a653e4","toSide":"top"},
		{"id":"f5da9053cba8635b","fromNode":"24c928c1146b9fc6","fromSide":"right","toNode":"610f11a1cc17db76","toSide":"left"},
		{"id":"07555a4e9e645afd","fromNode":"21febace8b459e12","fromSide":"right","toNode":"eac6417a6b7e152d","toSide":"left"},
		{"id":"2ec4f3bb919c822b","fromNode":"5056013ae1ac0b85","fromSide":"left","toNode":"6bb122e548f7283b","toSide":"right"},
		{"id":"99ad67dee95acb9a","fromNode":"6bb122e548f7283b","fromSide":"bottom","toNode":"c44ff0137238f8c0","toSide":"top"},
		{"id":"cd370e13dce09069","fromNode":"6bb122e548f7283b","fromSide":"top","toNode":"e62ff9ade2624375","toSide":"bottom"},
		{"id":"9ebd6be9d9a21b5c","fromNode":"50686229090c1bd0","fromSide":"left","toNode":"8fc1cdfff9089b77","toSide":"right"},
		{"id":"3a9289be4ce79f3f","fromNode":"e62ff9ade2624375","fromSide":"top","toNode":"bdfda8f59f454594","toSide":"bottom"},
		{"id":"141ef4e1b66fffb9","fromNode":"23afcf5b45f8bffc","fromSide":"bottom","toNode":"a2b5fda883cdac87","toSide":"top"},
		{"id":"71efc24f7af5d0d9","fromNode":"060659758b3f2bc8","fromSide":"left","toNode":"fc48c5d8376ed8ab","toSide":"right"}
	]
}