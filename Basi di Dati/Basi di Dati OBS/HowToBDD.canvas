{
	"nodes":[
		{"id":"ec389554aea482c8","type":"text","text":"","x":-12802,"y":11204,"width":250,"height":60},
		{"id":"a5db58697c7e9975","type":"text","text":"# Evoluzione dei DB e dei DBMS\n\nLa gestione dei dati si è resa necessaria fin dai primi utilizzi dei sistemi di calcolo, negli anni '50.\n\nI precursori dei DB (diciamo quindi semplicemente \"le prime grandi moli di dati\", in assenza delle caratteristiche tipiche di un DB per come lo intendiamo oggi) erano gestiti tramite linguaggi dedicati (e.g. *Fortran* per le applicazioni scientifiche, *COBOL* per le applicazioni commerciali, ma anche *Pascal* e *C*), e si appoggiavano sul _filesystem_ del SO sottostante, e quindi in un ambiente non-strutturato (dove per **_ambiente strutturato_** si intende la **_mediazione di un DBMS_**).\n\nI primi DBMS risalgono alla metà degli anni '60, stimolati da una società sempre più ricca di sfide tecnologiche (e.g. Progetto Apollo della NASA).\n\nLo sviluppo e la commercializzazione nei primi anni sono principalmente targati **_IBM_**, che implementa **_IMS (Information Management System)_**, il primo DB **_gerarchico_**.\n\nQuesto modello implementa una **_struttura ad albero_** in cui ogni unità logica di dati (**_record_**) costituisce un nodo, e i collegamenti padre-figlio definiscono le relazioni.\n\nUna generalizzazione del modello gerarchico è il _**modello reticolare**_, standardizzato dal comitato **_CODASYL_** (_Conference on Data Systems Languages_) tra gli anni '60 e '70, che rilassa la struttura ad albero in una struttura a **_grafo_** (ogni nodo può avere più padri).\n\n**_Importantissimo_** notare che tutti questi modelli sono implementati tramite **_puntatori a memoria_**, e che quindi ogni record è una struttura collegata che ha una campo che referenzia direttamente l'indirizzo fisico del record di destinazione.\n\nQuesto li rende fortemente dipendenti dalla struttura fisica del DB, nonché estremamente complicati in fase di manipolazione.\n\nIl 1970 è un anno rivoluzionario per i DBMS, perché viene introdotto in IBM il **_modello relazionale_**. Servono tuttavia una decina d'anni di lavoro per produrre le prime implementazioni commerciali (*Ingress*, *Oracle*, MySQL, ...).","x":-46,"y":400,"width":660,"height":956,"color":"4"},
		{"id":"50686229090c1bd0","type":"text","text":"# Modelli Concettuali e Modelli Logici\n\nPer realizzare un DBMS è necessario identificare, in ordine,\n\n- tutte e sole le informazioni rilevanti rispetto al problema (**_dati_**);\n- i vincoli che legano tra loro le informazioni (<span style=\"color:#7030a0\">***relazioni***</span> o <span style=\"color:#7030a0\">***associazioni***</span>);\n- un modo univoco per risalire a una certa informazione (tramite un ***linguaggio di interrogazione ***).\n\nLa progettazione si può suddividere in tre fasi principali:\n\n- **_Analisi Concettuale_** - Si identifica cos'è un'**_entità_** (dato) e cos'è una **_relazione_** (vincolo tra dati). Si crea un **_modello concettuale_** che rappresenta un **_primo livello di astrazione_** del problema, e che fornendo una schematizzazione logica dei dati semplifica le comunicazioni circa il DB. Questa fase **non si occupa dei dettagli implementativi**, e resta astratta (appunto, concettuale);\n- ***Modellazione Logica*** - In questa fase si traduce la struttura logica dei dati identificata nella fase di analisi concettuale in un **_modello logico_**, ovvero si sceglie **come** implementare il modello concettuale (questo include l'uso di riferimenti, etichette, tabelle, ...). Definisce la **struttura organizzativa virtuale delle interconnessioni tra i dati** indipendentemente dall'effettiva implementazione sottostante;\n- **_Implementazione_** - Si crea il DB fisico, ovvero la struttura di dati che viene effettivamente memorizzata sul sistema di archiviazione.\n\nQuesta distinzione suggerisce che il primo step si occupi solo di identificare le entità e il secondo di definirne la struttura. La realtà non è così rigida. Ad esempio, ha senso che un albero genealogico sia rappresentato direttamente come albero nel modello concettuale, mentre nel caso in cui la struttura non sia così evidente sin da subito l'albero può essere implementato come scelta di design nel modello logico.\n\nA partire dagli anni '60/'70 nascono diverse tipologie di DBMS costruiti sui relativi modelli logici.\n\n- **_Gerarchico ('60)_** - Struttura di tipo albero, i dati sono i nodi e le relazioni gli archi genitore-figlio;\n- **_Reticolare ('70)_** - Struttura di tipo grafo, i dati sono i nodi e le relazioni gli archi;\n- **_Relazionale ('70, '80)_** - Basato sul modello concettuale Entità-Relazione;\n- _**A Oggetti ('80)**_ - I dati sono oggetti con dei metodi associati;\n- _**XML**_ - Rivisitazione del modello gerarchico con l'aggiunta di tag, attributi e altre cose *fancy*;\n- **_NoSQL_** - Genericamente, modelli non basati sul modello relazionale.\n\nAd ogni modello logico corrispondono diversi linguaggi di interrogazione progettati in modo specifico per un certo insieme di dati. L'unica eccezione è il **_Relazionale_**, che ha come linguaggio standard **_SQL_**.","x":-1160,"y":400,"width":880,"height":956,"color":"4"},
		{"id":"b1a5285caeae4130","type":"text","text":"# Modello Relazionale\n","x":104,"y":2009,"width":360,"height":71,"color":"6"},
		{"id":"bfd96ba22ace7d31","type":"file","file":"CartesianoRelazione.png","x":-240,"y":1564,"width":400,"height":227},
		{"id":"5056013ae1ac0b85","type":"text","text":"# Legami con la Teoria degli Insiemi \n\nIl <span style=\"color:#cd0a0a\">***modello relazionale***</span> è un'applicazione di <span style=\"color:#00b050\">***teoria degli insiemi***</span>. In alcuni termini possono <span style=\"color:#ffc000\">***collassare i significati di entrambi i punti di vista***</span>.\n\nPer un dato insieme definisco un ***dominio***, ovvero la pool da cui posso pescare gli elementi.\n\nSe prendo gli insiemi che mi piacciono e li metto in fila posso scegliere a piacimento sequenze ordinate di valori presi dai rispettivi domini. Come indico tutti queste possibilità? Con il ***prodotto cartesiano***.\n$$\nD_1 \\times D_2 \\times ... \\times D_k \\Rightarrow \\{(v_1, v_2, ..., v_k)\\quad | \\quad v_1\\in D_1, v_2 \\in D_2, ..... V_k \\in D_k\\}\n$$\nQuesta operazione associa ogni elemento del dominio $D_1$ a ogni possibile combinazione di tutti gli elementi di tutti gli altri domini, realizzando tutte le possibili <span style=\"color:#00b050\">***tuple***</span> (<span style=\"color:#cd0a0a\">***record***</span>, <span style=\"color:#cd0a0a\">***tuple***</span> $\\Rightarrow$ <span style=\"color:#ffc000\">***tuple***</span>) $(v_1, v_2, ..., v_k)$. Qualsiasi sottoinsieme di tali <span style=\"color:#00b050\">***tuple***</span> è detto <span style=\"color:#00b050\">***relazione***</span> (<span style=\"color:#cd0a0a\">***istanza***</span>, <span style=\"font-style:italic; font-weight:bold; color:#cd0a0a\">***istanza di relazione***</span>, <span style=\"color:#cd0a0a\">***tabella***</span>, <span style=\"color:#cd0a0a\">***relazione***</span> $\\Rightarrow$ <span style=\"color:#ffc000\">***relazione***</span>), e $k$ è detto **grado della  <span style=\"color:#ffc000\">relazione</span>**.\n\nOk, ma quante tuple ci potranno mai essere? Ogni dominio ha una ***cardinalità***, che dà informazioni sul numero di elementi in esso contenuti.\n\n- **Cardinalità finita** - il dominio ha un numero finito di elementi (e.g. Alfabeto, $\\{0, 1\\}$, ...). In questo caso, la cardinalità si indica semplicemente con il numero di elementi dell'insieme;\n- **Cardinalità infinita ($\\aleph$)** - il dominio ha un numero infinito di elementi. Distinguo ulteriormente in\n\t- **Infinito numerabile** ($\\aleph_0$) - posso scrivere gli infiniti elementi in sequenza (e.g. $\\mathbb{N}$, $\\mathbb{Q}$, ...);\n\t- **Infinito non numerabile** ($\\aleph_1$ e successivi) - non posso scrivere gli infiniti elementi in sequenza (e.g. $\\mathbb{R}$ è $\\aleph_1$, l'insieme delle funzioni $f: \\mathbb{R}\\rightarrow \\mathbb{R}$ è $\\aleph_2$, ...).\n\nLa cardinalità del prodotto cartesiano è il prodotto delle cardinalità dei domini. Finché ci sono solo cardinalità del finito è un semplice prodotto (e.g. se $|A| = n$ e $|B| = m \\Rightarrow |A\\times B| = m\\cdot n$, ovvero se combino $n$ elementi con altri $m$ ottengo $m\\cdot n$ coppie), mentre se ho $\\aleph$ devo sommare gli indici (e.g. se $|C| = \\aleph_0$ e $|D| = \\aleph_1  \\Rightarrow |A\\times B \\times C \\times D| = \\aleph_{0+1} = \\aleph_1$). Notare che la cardinalità infinita letteralmente *divora* quella finita.\n\nSe a questi insiemi su cui faccio il prodotto cartesiano associo delle <span style=\"color:#cd0a0a\">***etichette***</span> che mi dicono cosa rappresentano (e.g. $A$ il cui dominio è $[15, 30] \\in \\mathbb{N}$ è un *voto*) creo degli <span style=\"color:#cd0a0a\">***attributi***</span>. Se poi scelgo un insieme di attributi (al quale magari associo un nome) ottengo uno <span style=\"font-weight:bold; color:#cd0a0a\">***schema di relazione $R$***</span> (e.g. se scelgo gli attributi *studente*, *corso* e *voto* posso chiamare questo insieme di attributi *esame* e renderlo uno schema di relazione) ***invariante nel tempo***. Questo indica in generale **tutti i possibili sottoinsiemi delle <span style=\"color:#cd0a0a\">tuple</span>** (e quindi tutte le possibili <span style=\"color:#cd0a0a\">***istanze $r$***</span>, che in pratica sono delle <span style=\"color:#00b050\">***relazioni***</span> in cui assegno un nome ai domini). In questo senso, una singola <span style=\"color:#cd0a0a\">***istanza***</span> (o <span style=\"color:#cd0a0a\">***tabella***</span>) è una ***tabella*** riempita secondo il suo <span style=\"color:#cd0a0a\">***schema***</span>.\n\nL'insieme degli <span style=\"font-weight:bold; color:#cd0a0a\">***schemi di relazione***</span> $(R_1, R_2 ..., R_n)$ è lo <span style=\"font-weight:bold; color:#cd0a0a\">***schema del DB relazionale***</span>.\n","x":-1160,"y":1557,"width":880,"height":976,"color":"4"},
		{"id":"26a4c1c0b1aebc3f","type":"text","text":"# Base di Dati (Database) e DBMS\n\nUna **_Base di Dati_** (o _**Database**_, _**DB**_) è un insieme di **_file (gruppi di dati) mutuamente connessi_** da relazioni definite in fase di progettazione.\n\nL'interconnessione è condizione necessaria per poter implementare degli algoritmi di ricerca più sofisticati (in assenza di collegamenti, non esiste un ordine).\n\nLe relazioni sono più importanti dei dati in sé, perché cruciali per garantire la consistenza delle informazioni (e.g. una possibile relazione può essere che a una corrispondenza di matricola corrisponda lo stesso nome studente) e l'efficienza nel reperirle.\n\nI dati si riferiscono a un contesto ben preciso: non è utile generalizzare un'implementazione del genere, ci si concentra sul problema specifico.\n\nIl software in grado di gestire e interrogare i DB (intesi come collezioni di dati strutturati, processabili e condivisi) è il **_DBMS (Data Base Management System)_**, fortunatamente già scritto da qualcun altro (si compra la licenza).\n\nIl DBMS viene installato su SO, ma di fatto è a sua volta un SO. Mentre il Kernel si occupa di allocare, il DBMS si occupa di come sono organizzati i file del DB. In quanto pseudo-SO, un linguaggio come C può mettere a disposizione delle chiamate a DBMS (scritte poi nel suo **_linguaggio di interrogazione_**) esattamente come le chiamate a sistema per il SO.\n","x":-46,"y":-749,"width":660,"height":688,"color":"4"},
		{"id":"9af72174f7185470","type":"text","text":"# Sistema Informativo\n\nNel momento in cui è necessario gestire dati e informazioni si introduce la nozione di **_Sistema Informativo_**, un'entità che si occupa di\n\n- raccolta e acquisizione delle informazioni;\n- archiviazione e conservazione delle informazioni;\n- elaborazione delle informazioni;\n- distribuzione delle informazioni.\n\nSi tratta di un modello indipendente dall'implementazione, e quindi dall'informatica: esempi di Sistemi Informativi possono essere infatti una biblioteca o un archivio.\n\nPuò essere visto come componente di un'**_organizzazione_** (nel senso letterale di _sistema organizzato_) che opera a supporto delle altre componenti.\n\nSicuramente l'informatica è un modo ottimale di implementare un SI.\n\nIn senso informatico, un SI è un complesso di dati organizzati fisicamente in una memoria secondaria e gestiti in maniera tale da consentirne facilmente la creazione, l’aggiornamento e l’**_interrogazione_** (leggi: reperire i dati conservativi).\n\n\n\n","x":-1160,"y":-749,"width":620,"height":688,"color":"6"},
		{"id":"2b9f740ce09f9ba4","type":"text","text":"## Implementazione Informatica","x":-500,"y":-430,"width":415,"height":50,"color":"6"},
		{"id":"c7400b10fa21ae78","type":"text","text":"# Storia Implementativa","x":99,"y":160,"width":370,"height":50,"color":"6"},
		{"id":"8fc1cdfff9089b77","type":"text","text":"# Perché il Modello Relazionale è \"rivoluzionario\"?\n\nAnzitutto perché non ci sono riferimenti espliciti (puntatori a memoria), ed è pertanto **_indipendente dalla memorizzazione fisica dei dati_**. Questo di fatto risolve tutti i problemi di portabilità e semplifica di molto il lavoro dei programmatori, che non dovendo preoccuparsi della struttura sottostante possono manipolare il DB in modo logico (il che ovviamente porta a un'accelerazione nello sviluppo dell'intero campo).\n\nCiò accade perché sia dati che relazioni sono rappresentati come valori (**_riferimento per valore_**), e l'intero modello si basa sulla possibilità di costruire dei valori speciali (**_chiavi_**) che identificano univocamente le tuple nelle istanze.\n\nIn questo senso possiamo definire\n\n- tutte e sole le informazioni rilevanti rispetto al problema - ***Attributi***;\n- i ***vincoli*** che legano tra loro le informazioni - ***Dipendenze Funzionali***;\n- un modo univoco per risalire ad una certa informazione - ***Chiavi***.\n","x":-2340,"y":400,"width":920,"height":435,"color":"4"},
		{"id":"e62ff9ade2624375","type":"text","text":"# Modello Entità-Relazioni (Entità-Associazioni)\n\nLa <span style=\"color:#cd0a0a\">***tabella***</span> (<span style=\"color:#ffc000\">***relazione***</span>) `studenti` che ha come attributi `matricola`, `nome` e `cognome` è perfettamente consistente di per sé, cioè ha senso di esistere indipendentemente dal resto del DB $\\Rightarrow$ ***Entità***.\n\nAnche la <span style=\"color:#cd0a0a\">***tabella***</span> (<span style=\"color:#ffc000\">***relazione***</span>) `corsi` avente come attributi `codice`, `titolo` e `professore` ha senso indipendentemente dal resto del DB $\\Rightarrow$ **Entità**.\n\nLa <span style=\"color:#cd0a0a\">***tabella***</span> (<span style=\"color:#ffc000\">***relazione***</span>) `esame` che ha come attributi `matricola`, `codice` e `voto` ha senso di esistere solo in quanto associazione di un elemento dell'entità `studenti` ad uno dell'entità `corsi` $\\Rightarrow$ <span style=\"color:#7030a0\">***Relazione***</span>.\n\nLa lingua italiana traduce allo stesso modo <span style=\"color:#ffc000\">***relation***</span> e <span style=\"color:#7030a0\">***relationship***</span>. Da qui in poi ci riferiremo alla <span style=\"color:#7030a0\">***relazione***</span> come <span style=\"color:#7030a0\">***associazione***</span> sperando di creare meno panico.\n\nQuindi, perché è importante distinguere entità e associazioni?\n\nIpotizziamo di non farlo: memorizzo nella stessa struttura i dati dello studente, del corso e dell'esame. Ogni volta che lo studente sostiene un nuovo esame sono costretto a ripetere i suoi dati. In modo analogo, se lo stesso esame è sostenuto da un altro studente sono costretto a ripetere i dati del corso.\n\n***La definizione del ruolo degli elementi quando costruisco il modello concettuale è cruciale per evitare la produzione di ridondanze***.","x":-2340,"y":1088,"width":920,"height":536,"color":"4"},
		{"id":"bdfda8f59f454594","type":"text","text":"## Esempio: Modello Reticolare\n\nL'implementazione dell'esempio sotto in un modello reticolare prevede che i riferimenti dell'<span style=\"color:#7030a0\">***associazione***</span> `esami` siano puntatori alle zone di memoria delle entità `studenti` e `corsi`, referenziando in pratica l'intero record. \"Capite bene che il porting di un DB del genere era un bagno di sangue\".","x":-2340,"y":878,"width":920,"height":160,"color":"4"},
		{"id":"6bb122e548f7283b","type":"text","text":"# Conseguenze\n\nLe <span style=\"color:#00b050\">***relazioni***</span>  sono rappresentate come <span style=\"color:#cd0a0a\">***tabelle***</span> di <span style=\"color:#cd0a0a\">***tuple***</span>.\n\n- In una <span style=\"color:#cd0a0a\">***tabella***</span> il numero di <span style=\"color:#cd0a0a\">***tuple***</span> è la cardinalità di quella specifica  <span style=\"color:#ffc000\">***relazione***</span>;\n- Non posso avere <span style=\"color:#ffc000\">***tuple***</span> duplicate, né ho (e di conseguenza non posso assumere) ordinamento tra le <span style=\"color:#ffc000\">***tuple***</span>: sono elementi di insiemi!\n- A livello di logica matematica, posso scegliere arbitrariamente quali  <span style=\"color:#ffc000\">***tuple***</span> inserire nella mia <span style=\"color:#ffc000\">***relazione***</span>, a patto che rispettino lo <span style=\"font-weight:bold; color:#cd0a0a\">***schema di relazione***</span>;\n- A livello pratico non sempre posso scegliere tutte le possibili <span style=\"color:#ffc000\">***tuple***</span>: esistono dei <span style=\"color:#cd0a0a\">***vincoli***</span>.","x":-2340,"y":1887,"width":920,"height":316,"color":"4"},
		{"id":"fe75c4290f5a2e39","type":"text","text":"# Teoria della Normalizzazione\n\nVi sono schemi di relazione notevoli che rispettano determinate proprietà, detti in ***forma normale***.\n\n- **Prima Forma Normale** (**1NF**) - Uno schema di relazione è 1NF se lo stesso attributo non può assumere più valori diversi su una singola tupla;\n- **Seconda Forma Normale** (**2NF**) - Uno schema di relazione è 2NF se rispetta la 1NF e non esistono in $F^+$ dipendenze funzionali da un pezzo di chiave (***dipendenze parziali***);\n- ***Terza Forma Normale*** (***3NF***) - Uno schema di relazione è 3NF se rispetta la 2NF e non esistono in $F^+$ ***dipendenze transitive***.\n- **Forma Normale di Boyce-Codd** (**BCNF**) - Più stringente della 3NF, e per questo meno usata.","x":2050,"y":4093,"width":820,"height":340,"color":"6"},
		{"id":"c687ba503efe3e68","type":"text","text":"# Terza Forma Normale (3NF)\n\nUno ***Schema di Relazione*** è in ***Terza Forma Normale*** (***3NF***) se $$∀\\,\\{X → A\\} ∈ F^+, \\,\\text{dove} \\, A \\notin X,\\, ∃K ⊆ R : K ⊆ X ∨ A ∈ K$$Bene, come si legge?\n\n- $∀\\,\\{X → A\\} ∈ F^+$ - \"Per ogni possibile dipendenza funzionale con determinato singleton...\"\n\t- Uso $F^+$ perché mi fa comodo che il **dipendente** sia **singleton**.\n\t\t- Posso prendere solo quelle con dipendente singleton grazie alle **Regole Secondarie di Armstrong**, in particolare alla **Decomposizione**;\n\t\t- Lo faccio perché così la definizione è semplice (se al posto di A singleton usassi X insieme di attributi dovrei formalizzarlo in modo più complesso)\n- $A \\notin X$ - \"... non banale...\"\n\t- Se $A\\in X$ la dipendenza funzionale $\\{X → A\\}$ è per definizione banale;\n- $∃K ⊆ R :$ - \"... esiste una chiave $K$ sullo schema di relazione $R$ tale che, alternativamente, ...\"\n- $K ⊆ X\\, ∨ A ∈ K$ - \"... il determinante ***X è superchiave*** oppure il determinato ***A è primo***.\"\n\nQuindi per verificare che uno schema $R$ con dipendenze $F$ sia in 3NF bisogna\n\n- Individuare le chiavi;\n- Costruire $F^+$;\n- Controllare tute le sue dipendenze non banali aventi dipendente singleton della forma $\\{X → A\\}$\n- Verificare alternativamente che\n\t- $X$ sia superchiave;\n\t- $A$ sia primo.\n","x":2050,"y":4804,"width":820,"height":758,"color":"4"},
		{"id":"e61e8cd5a61d08b7","type":"text","text":"# Euristica per l'Algoritmo di Verifica\n\nL'idea dell'***algoritmo per verificare se una decomposizione è lossless*** è trovare, se esiste, almeno un sottoschema $R_i$ in grado di determinare univocamente tutti gli attributi di partenza, e quindi l'istanza originale $r$. Ad esempio, se prendiamo$$R = ABCD\\text{, }\\, F = \\{A\\to B,\\,B\\to CD\\}\\,\\text{ e }\\,\\rho = \\{AB,\\,BCD\\}$$notiamo che $A$ è chiave e che i sottoschemi sono tali che nel primo $A\\to B$, e nel secondo la chiave ha \"effetto transitivo\" tramite $B$. Quindi è il sottoschema $AB$ che finisce per determinare univocamente $R$.\n\nCome si generalizza questa cosa? $R$ ha $n$ attributi $A_j$ e scomposizione $\\rho$ in $k$ sottoschemi $R_i$. Definiamo$$\nr_{ij} = \\begin{cases}\na & \\text{se } A_j\\in R_i \\\\\nb_i & \\text{altrimenti}\n\\end{cases}\n$$Il valore $a$ indica che ***il sottoschema $i$ determina l'attributo $j$***, mentre $b_i$ indica che l'attributo $j$ nell'$i-$esimo sottoschema può assumere qualsiasi valore (i.e. è libero da vincoli). Inizialmente, quindi,\n\n- il sottoschema $AB$ ha il valore $a$ sugli attributi $A$ e $B$, e $b_1$ sugli attributi $C$ e $D$;\n- il sottoschema $BCD$ ha il valore $a$ sugli attributi $BCD$, e $b_2$ su $A$.\n\nA questo punto vado a guardare le dipendenze funzionali, e in particolare quelle tali che il determinante ha il valore $a$ su entrambe le tuple. L'unico attributo che vale $a$ su entrambe le righe è $B$, che fortunatamente compare in $B\\to CD$. Per definizione di dipendenza funzionale, se $B\\to CD$ sulla seconda riga, allora deve valere anche sulla prima. Quindi aggiorniamo la prima riga in modo tale che anche $C$ e $D$ valgano $a$.\n\nA questo punto la prima riga ha $a$ come valore per tutti gli attributi, ovvero li ha determinati tutti. L'algoritmo è concluso, e possiamo affermare che questa $\\rho$ è una decomposizione lossless.\n\nQuesto è un caso particolarmente semplice in cui basta una sola iterazione. In generale, quando eseguo queste operazioni e modifico la tabella proseguo facendo un altro check sulle dipendenze funzionali finché l'algoritmo smette di produrre modifiche (i.e. la situazione è stabile). Solo a quel punto controllo se esiste una riga in cui tutti i valori sono $a$.","x":-246,"y":8280,"width":880,"height":866,"color":"4"},
		{"id":"a14acb36286e841a","type":"text","text":"# Preservare le Dipendenze\n\nDecomporre significa proiettare ogni tupla dell'istanza originaria $R$ sugli attributi dei sottoschemi della decomposizione $R_i$, eliminando i duplicati.\n\nE le dipendenze funzionali? Posso proiettare anche quelle. In particolare, nella proiezione su $R_i$ ($\\pi_{R_i}(F)$) valgono tutte le dipendenze di $F^+$ che hanno sia come determinante che come determinato dei sottoinsiemi di attributi di $R_i$.\n\nDa questo concetto si può dimostrare un ***teorema***: $\\rho$ ***preserva*** $F$ se $F$ è equivalente all'unione di tutte le proiezioni sui vari $R_i$, ovvero$$F\\equiv G := \\bigcup_{i = 0}^k \\pi_{R_i}(F)$$o, equivalentemente visto che $F \\subseteq G^+ \\Leftrightarrow F^+ \\subseteq G^+$, come ***corollario*** abbiamo che $\\rho$ preserva $F$ se $F\\subseteq G^+$ (ovviamente, per definizione di $\\pi$, $F\\supseteq G^+$).","x":870,"y":8475,"width":660,"height":477,"color":"4"},
		{"id":"8cb30aba3fde68bf","type":"text","text":"Corollario Sia R uno schema di relazione, F un insieme di dipendenze funzionali su R e r={R1, R2} una decomposizione di R. Se R1ÇR2®R1-R2 o R1ÇR2®R2-R1 allora r ha un join senza perdita.","x":-1302,"y":8545,"width":789,"height":203},
		{"id":"99c39d53bd14d250","type":"text","text":"# Commenti all'Algoritmo di Verifica\n\nChiamo `rho_R` la tabella avente come righe i sottoschemi `r` e come colonne gli attributi.\n\n- `unchanged = False`, `while not unchanged` e `unchanged = True` - Questo inizializza il ciclo `while` per fermare le iterazioni se cessano le modifiche;\n- `for X → Y ∈ F`, `for r1 in rho_R` e `for r2 in rho_R` - Ad ogni iterazione scandaglio tutte le possibili dipendenze funzionali e tutte le possibili coppie di sottoschemi;\n- `if r1 [X] == r2 [X] && r1 [Y] != r2 [Y]:` - Se il determinante è uguale per entrambi i sottoschemi ma il determinato è diverso tocca cambiare lo schema per renderli uguali, il che si traduce nel provare a propagare il valore `a`;\n\t- Dico provare perché in una situazione in cui ci sono due righe tali che la coppia $(X, Y)$ assume valori $(b_1, b_1)$ sulla prima e $(b_1, b_2)$ sulla seconda è inutile fare alcunché;\n\t- Questo significa che non importa dove sia `a` tra le due tuple, è l'unico valore che viene propagato (da cui l'`if`-`else` sulla condizione `r1 [Aj] == \"a\"`);\n- `if ∃ r ∈ rho_R | r = (\"a\", . . ., \"a\")` - Una volta uscito dal ciclo `while` controllo se esiste un sottoschema che determina tutti gli attributi.\n\nEsiste un teorema che dimostra la correttezza di questo algoritmo, ometto dimostrazione.","x":-1366,"y":9254,"width":800,"height":559,"color":"4"},
		{"id":"54145b0b67f0bdd7","type":"text","text":"# Algoritmo di Verifica per Decomposizione Lossless\n```\nunchanged = False\nwhile not unchanged:\n\tunchanged = True\n\tfor X → Y ∈ F:\n\t\tfor r1 in rho_R:\n\t\t\tfor r2 in rho_R:\n\t\t\t\tif r1 [X] == r2 [X] && r1 [Y] != r2 [Y]:\n\t\t\t\t\tunchanged = False\n\t\t\t\t\tfor Aj ∈ Y:\n\t\t\t\t\t\tif r1 [Aj] == \"a\":\n\t\t\t\t\t\t\tr2 [Aj] := r1 [Aj]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tr1 [Aj] := r2 [Aj]\n\nif ∃ t ∈ r | t = (\"a\", . . ., \"a\"):\n\treturn True\nelse:\n\treturn False\n```","x":-246,"y":9254,"width":880,"height":559,"color":"#4545ff"},
		{"id":"d6f242e8f74be88a","type":"text","text":"# Algoritmi di Verifica per Preservazione\n\n- ***Verifica*** di $F\\subseteq G^+$ (***Preservazione delle Dipendenze***) - Dal teorema $F^+ = F^A$ so di potere usare le chiusure degli insiemi di Attributi al posto di quelli di Dipendenze ($Y ⊆ X^+_F \\Leftrightarrow \\{X → Y\\} ∈ F^+$), quindi in pratica parto da $X\\to Y \\in F$ e verifico se $Y\\subseteq X_G^+$. A livello di codice è semplice:\n\t- `for` $X\\to Y \\in F$:\n\t\t- `if` $Y \\not\\subseteq X^+_{G}$ `: return False`\n\t- `return True`\n- Per calcolare $X_G^+$ tramite l'algoritmo per la chiusura degli insiemi di Attributi dovrei conoscere $G$, ma per definizione questo richiede il calcolo di $F^+$. Questo ha un costo esponenziale, e non ci piace. Per questo motivo esiste un ***modo alternativo per calcolare $X_G^+$ a partire da $F$***:\n\t- non penso mi vada di capirlo adesso.","x":870,"y":9254,"width":660,"height":559,"color":"3"},
		{"id":"73226aa690f89469","type":"text","text":"# Copertura Minimale\n\nDato uno schema $R$ con decomposizione $\\rho$ e dipendenze funzionali $F$, un insieme $G$ è una possibile ***copertura minimale per $F$*** se $G\\equiv F$ e se\n\n- ***Ogni determinato*** delle dipendenze $X\\to A \\in G$ ***è un singleton***, o alternativamente il membro destro di ogni dipendenza è ***non-ridondante*** (i.e. non lo si può rimuovere preservando la dipendenza);\n\t- Questo è ottenibile tramite ***decomposizione***;\n- ***Ogni determinante*** delle dipendenze $X\\to A \\in G$ è ***non-ridondante***, ovvero non posso rimpiazzare nessuna dipendenza con una $X_r\\to A$ con $X_r\\subseteq X$ tale che l'insieme di dipendenze ridotto $G_r$ sia $G_r\\equiv G$;\n\t- Per costruire questa condizione devo procedere in modo ricorsivo. Per ogni dipendenza $X\\to A \\in G$ ne cerco una $X_r\\to A\\in G_r$ con $X_r\\subseteq X$ tale che $G_r\\equiv G$, se la trovo sostituisco $X\\to A$ con $X_r\\to A$ (o semplicemente la elimino, se $X_r\\to A$ è già presente in $G$);\n\t\t- Se esistono sia $X\\to A$ che $Y\\to A$ con $Y\\subset X$, è ovvio che basta eliminare $X\\to A$;\n\t- ***Per verificare se $G_r\\equiv G$*** (e quindi $G_r^+ = G^+$), so che questi due insiemi differiscono per una sola dipendenza, mi basta controllare quella.\n\t\t- $X\\to A \\in G^+$ è sicuramente anche $\\in G_r^+$. Infatti $X_r\\to A\\in G_r^+$, e per l'assioma di aumento $X\\to X_r$. Questo significa che $X\\to A\\in G_r^+$;\n\t\t\t- È ovvio che $X\\to A$ se $X_r\\to A$, essendo $X = X_r + \\text{qualcosa}$;\n\t\t- Non è ovvio invece il contrario: ***devo verificare $X_r\\to A\\in G^+$***, ovvero $A\\in (X_r)^+_G$;\n\t\t\t- Non è ovvio che $X_r\\to A$ se $X\\to A$, perché magari ho tolto proprio il pezzo non ridondante che serviva a determinare $A$;\n\t- Notare che, essendo un procedimento ricorsivo, **ogni volta che riesco a ridurre mantengo invariate tutte le chiusure di tutti gli insiemi di attributi** (sto solo togliendo quelli ridondanti!). ***Non devo ricalcolare le chiusure***;\n- ***Ogni dipendenza è non ridondante***, ovvero nessuna $X\\to A$ è ottenibile dalle altre (tipo una base nel senso dell'algebra).\n\t- Se $G_r$ è l'insieme in cui ho eliminato una dipendenza, è ovvio che $G_r\\subseteq G$, quindi che $G^+_r \\subseteq G^+$. Per avere $G = G_r$ devo verificare che $G^+ \\subseteq G^+_r$, ovvero che $G \\subseteq G^+_r$. Questo si traduce nel verificare che la dipendenza eliminata sia in $G_r^+$, ovvero che $X\\to A \\in G^+_r$, o equivalentemente $A\\in X^+_{G_r}$;\n\t- Avendo però tolto una dipendenza $X_{G_r}^+ \\neq X_G^+$. In questo step ***devo ricalcolare le chiusure***;\n\t- Se ho $X\\to A$ ma non esiste $Y\\to A$ con $Y\\neq X$ è inutile pensare di poter togliere $X\\to A$, perché so già che $A$ non ha nessun altro modo per essere determinato.","x":2563,"y":7499,"width":818,"height":953,"color":"4"},
		{"id":"ae1c7d941584d813","type":"text","text":"# Decomposizione Lossless\n\nIntuitivamente, una decomposizione è lossless se facendo il join naturale di tutte le istanze $r_i$ dei sottoschemi $R_i$ ottenuti per proiezione si ottiene ancora un'istanza legale $r$ di $R$, ovvero$$r = m_\\rho(r) := \\pi_{R_1}(r)\\bowtie\\,...\\,\\bowtie\\pi_{R_k}(r)\\quad \\forall\\,r\\text{ istanza legale di } R$$Da ciò seguono una serie di proposizioni dimostrabili:\n\n- $r \\subseteq m_\\rho(r)$ - Dal momento che il join naturale usa il prodotto cartesiano, $m_\\rho$ potrebbe in generale contenere più elementi di quelli originariamente contenuti in $r$ (da cui il rischio di perdita di informazione);\n- $π_{R_i} (m_ρ (r)) = π_{R_i} (r)\\,\\, ∀R_i ∈ ρ$ - Questo è banale, discende dalla definizione di $m_\\rho$. I vari $R_i$ sono schemi indipendenti (intuitivamente, nel senso dell'algebra lineare);\n- $m_ρ (m_ρ (r)) = m_ρ (r)$ - Discende direttamente dall'affermazione precedente, in pratica $m_\\rho$ è idempotente.\n\nBene, che me ne faccio di tutto questo?","x":-246,"y":7760,"width":880,"height":431,"color":"4"},
		{"id":"2f6f31d4b022c8a5","type":"text","text":"# Decomposizione\n\nSe uno schema non è 3NF o se si può migliorare l'efficienza degli accessi, si definisce ***decomposizione*** di $R$ un insieme di ***sottoschemi*** $\\rho = R_1,\\,...\\,R_n$ ***che ricoprono*** $R$, ossia tali che $$R = \\bigcup_{i = 0}^n\\,R_i$$\nSi noti che non è unica. Gli schemi risultanti devono ***preservare le dipendenze*** e ***non portare alla perdita di informazione***.","x":923,"y":7825,"width":554,"height":300,"color":"6"},
		{"id":"782d4f36963c0fc7","type":"text","text":"# Algoritmi di Decomposizione\n\nEsistono algoritmi in grado di ***restituire una tra le possibili decomposizioni lossless che preservano le dipendenze***.\n\nLa variabilità è data dalla scelta potenzialmente non univoca della ***copertura minimale*** data in input all'algoritmo.","x":1773,"y":7826,"width":554,"height":300,"color":"6"},
		{"id":"d187fd7c52585352","type":"text","text":"# Algoritmo di Decomposizione\n\nIl seguente algoritmo, dato lo schema di relazione $R$ e una ***copertura minimale*** $F$, restituisce una decomposizione $\\rho$ 3NF che ***preserva le dipendenze*** (ma ***non garantisce che sia lossless***!).\n\n```\nS, ρ = ∅\nfor A ∈ R | ∄ X → B ∈ F, A ∈ X ∨ A = B: S = S ∪ A\nif S is not empty:\n\tR = R - S\n\tρ = ρ ∪ {S}\nif ∃ X → A ∈ F | X ∪ A = R:\n\tρ := ρ ∪ {R}\nelse:\n\tfor X → A ∈ F:\n\t\tρ := ρ ∪ {XA}\nreturn ρ\n```","x":2563,"y":8545,"width":818,"height":455,"color":"#4545ff"},
		{"id":"337ec409043d12f1","type":"text","text":"# Commenti all'Algoritmo di Decomposizione\n\n- Uso `S` per raccogliere tutti gli attributi non coinvolti in nessuna dipendenza funzionale (`A ∈ R | ∄ X → B ∈ F, A ∈ X ∨ A = B`). Questo, se non è vuoto, sarà il primo sottoschema di $\\rho$. Sottraggo `S` ad `R` e procedo;\n- Se esiste una singola dipendenza funzionale che coinvolge tutti gli attributi di $R$ (`if ∃ X → A ∈ F | X ∪ A = R`), allora tutti gli attributi che restano formeranno un secondo ed ultimo sottoschema di $\\rho$. Se così non è, procedo;\n- Per ogni dipendenza $X\\to A \\in F$ aggiungo un sottoschema $R_i = XA$.\n\nViene eseguito in un ***tempo polinomiale***. Questo ***non garantisce che $\\rho$ sia lossless***.\n\n***$\\rho$ è anche lossless se uno dei sottoschemi*** così ottenuti ***contiene una chiave***, ***altrimenti è necessario aggiungerla esplicitamente al risultato dell'algoritmo***.\n\n$\\sigma = \\rho \\cup \\{K\\}$ è una ***decomposizione lossless che preserva le dipendenze***.","x":3571,"y":8545,"width":707,"height":455,"color":"4"},
		{"id":"4873f8d0b1727773","type":"text","text":"# Non sempre la 3NF  è sufficiente!\n\nUno schema non 3NF può essere decomposto in più modi per ottenere sottoschemi 3NF. Alcuni hanno proprietà interessanti. Prendiamo ad esempio$$R = ABC\\quad F = \\{A\\to B,\\, B\\to C\\}$$\nQuesto non è 3NF, devo decomporlo. Come?\n\n- $R_1 = AB, \\,\\, F_1 = \\{A\\to B\\}$ e $R_2 = AC, \\,\\, F_2 = \\{A\\to C\\}$\n\t- Nonostante sia 3NF, mi sono perso la dipendenza $B\\to C$. Detta in modo formale, $F_1$ ed $F_2$ ***non hanno la stessa chiusura*** di $F$;\n- $R_1 = AB, \\,\\, F_1 = \\{A\\to B\\}$ e $R_2 = BC, \\,\\, F_2 = \\{B\\to C\\}$\n\t- È 3NF, inoltre $F_1$ ed $F_2$ hanno la stessa chiusura di $F$.\n\nPreservare le dipendenze ***NON*** significa in automatico che se inserisco delle istanze legali in $R_1$ ed $R_2$, tramite join naturale $R_1 \\bowtie R_2$ ottengo istanze legali di $R$. Questo è un altro problema a cui stare attenti. Consideriamo ad esempio$$R = ABC\\quad F = \\{A\\to B,\\, C\\to B\\}$$\nLa chiave è $AC$, e lo schema non è 3NF ($B$ non è né primo né determinato da una superchiave). Posso ottenere una scomposizione 3NF $$R_1 = AB, \\,\\, F_1 = \\{A\\to B\\} \\text{ e } R_2 = BC, \\,\\, F_2 = \\{A\\to C\\}$$\nQuesto rispetta le dipendenze originali, ma non è soddisfacente. Se si parte ad esempio da un'istanza legale di $R$ che contiene solo `a1 b1 c1` e `a2 b1 c2` dovrò decomporlo in schemi $R_1$ contenente `a1 b1` e `a2 b1` ed $R_2$ contenente `b1 c1` e `b1 c2`. Se però faccio il ***join naturale*** $R_1 \\bowtie R_2$ ottengo oltre alle tuple di partenza anche `a1 b1 c2` e `a2 b1 c1`. Ma queste tuple non esistevano in origine! ***Ho degradato l'informazione***.\n\nDa questo capiamo che tra le varie scomposizioni 3NF, quella scelta deve\n\n- ***preservare le dipendenze funzionali*** dello schema originario;\n- ***non portare alla perdita*** (= aggiunta) ***di informazione*** se si prova a ricostruire un'istanza legale dello schema originario $R$ mediante join naturale di $R_1$ ed $R_2$.","x":870,"y":5710,"width":660,"height":978,"color":"4"},
		{"id":"f80c8aae48ac23d3","type":"text","text":"# Esempio 3NF\n\n$$R = ABCD \\quad F = \\{AB \\to CD,\\,BC \\to A,\\,D \\to AC\\}$$\n\n- Individuiamo anzitutto le chiavi.\n\t- Nessun attributo da solo è chiave;\n\t- $AB$ è certamente una chiave, in modo banale determina $A$ e $B$ e in $F$ determina $CD$ (quindi anche singolarmente $C$ e $D$);\n\t- $BC$ determina $A$, ma determina anche D? Sì, perché aumentando la seconda con la dipendenza banale $B\\to B$ ottengo $BC\\to AB$, la quale è chiave. Ma se $BC$ determina una chiave, allora è a sua volta chiave (non può essere superchiave, perché in questo caso nessun attributo da solo è chiave);\n\t- $D$ determina $AC$, gli manca B. Basta aggiungerlo: $DB\\to ACB$;\n\t- Quindi le ***chiavi*** sono ***AB***, ***BC*** e ***DB***.\n- Costruiamo le dipendenze singleton non banali di $F^+$.\n\t- $A$ da solo è determinato da $BC$ e $D$,  ma non ci interessa guardare le singole dipendenze perché in ogni caso $A$ è ***primo***;\n\t- $B$ da solo non è determinato da niente, ma anche se fosse è ***primo***;\n\t- $C$ da solo è determinato da $AB$ e $D$, ma anche qui $C$ è ***primo***;\n\t- $D$ da solo è determinato da $AB$, ma di nuovo $D$ è ***primo***.\n\nPer farla breve, qui bastava notare che tutti i singoli attributi dello schema sono parte di una chiave, quindi in ogni caso la definizione di 3NF è rispettata.\n\nNon era necessario che $D$ fosse primo, in quanto $AB$ è (super)chiave.","x":1720,"y":5710,"width":660,"height":673,"color":"4"},
		{"id":"3af5fb39864d9810","type":"text","text":"# Esempi Non-3NF\n###### Primo Esempio Non-3NF\n\n$$\nR = ABCD \\quad F = \\{A\\to B,\\, B\\to CD\\}\n$$\n\n- Individuiamo le chiavi.\n\t- $C$ e $D$ da soli di certo non determinano niente;\n\t- $B$ da solo non determina $A$. Gli si può aggiungere creando $AB\\to CD$, quindi sappiamo che $AB$ è almeno superchiave;\n\t- $A$ da solo determina $B$ in $F$ e per **transitività** $CD$ in $F^+$, quindi $A$ è chiave e $AB$ resta una banale superchiave;\n\t- La ***chiave*** è solo ***A***. Ci posso arrivare anche costruendo la chiusura di $A$ tramite gli Assiomi di Armstrong.\n- Costruiamo le dipendenze singleton non banali di $F^+$.\n\t- $A$ da solo non è determinato da niente, ed è anche primo;\n\t- Tutti gli altri singleton sono determinati sia da $A$ che da $B$, ma le due dipendenze $B\\to C$ e $B\\to D$ non hanno né una superchiave a sinistra né un primo a destra. Segue che questo schema non è in 3NF.\n###### Secondo Esempio Non-3NF\n\n$$\nR = ABCD \\quad F = \\{AC\\to B,\\, B\\to AD\\}\n$$\n\n- Individuiamo le chiavi.\n\t- Nessun attributo da solo è chiave;\n\t- La chiusura di $AC$ è sicuramente $ABC$ (dalla prima dipendenza), ma tramite $B$ raggiunge anche $D$ (dalla seconda dipendenza). Giacché nessun attributo da solo è chiave, $AC$ è chiave (e non superchiave);\n\t- $B$ raggiunge $AD$, manca $C$. Basta aggiungerlo a sinistra e a destra. La chiusura di $BC$ è allora tutto lo schema, quindi $BC$ è chiave;\n\t- Le ***chiavi*** sono ***AC*** e ***BC***.\n- Costruiamo le dipendenze singleton non banali di $F^+$.\n\t- $A$ da solo è determinato da $B$. $B$ non è superchiave, ma $A$ è ***primo***;\n\t- $B$ è ***primo***, e $AC$ è pure chiave;\n\t- $C$ è ***primo***, ma tanto non ci sono dipendenze con $C$ singleton;\n\t- $D$ ***non è primo***, ed è determinato da $B$ che ***non è chiave***. Questa dipendenza rompe la 3NF.","x":2540,"y":5710,"width":660,"height":978,"color":"4"},
		{"id":"2b6f2a89d041bb3b","type":"text","text":"# Conclusioni (credo)\n\nA partire da ogni Dipendenza Funzionale di $F$ posso costruire una superchiave (il cui numero è quindi $\\geq$ del numero di Dipendenze Funzionali).","x":1720,"y":6430,"width":660,"height":258},
		{"id":"524878ec1680396b","type":"text","text":"# Rischi delle cose Non-3NF\n\nSe faccio uno schema gigante in cui metto sia i dati di `studente` che di `corso`, la nuova chiave è `matricola`, `codice corso`.\n\nIl guaio è che le cose determinate univocamente da `matricola` come dipendenza funzionale non hanno nessuna garanzia, perché `matricola` non è più chiave. Ad esempio, le tuple\n\n```\nmatricola    CF    cognome   codice_corso   nome_corso   voto\n   10        VR     Rossi         50         Fisica       28\n   10        GV     Verdi         60         Fisica       18\n   20        GV     Verdi         50         Analisi      30\n```\n\nsono legali in quanto la chiave {`matricola`, `codice corso`} non si ripete, ma non c'è alcun controllo su\n- `Codice Fiscale` e  `cognome` (è legale associare alla stessa matricola persone diverse);\n- `nome corso` (è legale associare nomi diversi allo stesso `codice corso`).\n\nQuesto avviene perché singolarmente `matricola`$\\to$ `CF` e `codice corso`$\\to$ `nome corso` violano la 3NF.\n\nLa soluzione è fare due tabelle separate per `studente` e per `corso` e poi creare con un join la tabella `esame`.","x":3381,"y":5870,"width":660,"height":659,"color":"4"},
		{"id":"60e48c54e851b219","type":"text","text":"# Chiavi\n\nUn sottoinsieme di attributi $K$ per lo schema di relazione $R$ è ***chiave*** di $R$ se\n\n- $\\{K\\rightarrow R\\} \\in F^+$, ovvero (per definizione) la chiave deve determinare tutti gli attributi dello schema. Non necessariamente questa dipendenza funzionale è esplicita (quindi in $F$), ma sicuramente sarà in $F^+$;\n- $\\nexists \\,K'\\subset K : \\{K'\\rightarrow R\\} \\in F^+$. Infatti, se esistesse $K'$ sottoinsieme di $K$ che determina tutto lo schema, la chiave sarebbe proprio $K'$, rendendo $K$ una ***superchiave***, ovvero un insieme di attributi che contiene una chiave. Nel caso limite $K'\\equiv K$, $K$ è sia chiave che superchiave;\n\nNon è detto che la chiave sia unica. Se prendo un $K''$ che ha almeno un elemento non appartenente a $K$ che rispetta le due proprietà sopra, questo è chiave tanto quanto $K$ (e.g. in una relazione `studente` sono valide come chiavi sia `matricola` che `codice fiscale`);\n- Se ho ***più chiavi*** per uno schema di relazione, queste ***si determinano a vicenda***.\n- Segue che qualsiasi cosa che determina una (super)chiave è a sua volta (super)chiave;\n\nOgni attributo $A\\in K$ è detto ***primo***, e si può dimostrare la seguente proposizione:$$∄\\{X → Y\\} ∈ F\\,\\text{ t.c. }\\,A ∈ Y ⇒ A ∈ K ⊆ R\\,\\text{ t.c. K è chiave di R}$$ovvero ***se $A$ non è determinato da nessuna dipendenza funzionale in $R$, allora è primo***. Banalmente, stiamo dicendo che per far parte di $R$ in qualche modo $A$ deve essere determinato da qualcosa. Se non c'è nient'altro che lo determina resta solo $A\\to A$, motivo per cui $A$ deve per forza far parte di tutte le chiavi che posso costruire in $R$.\n\nQuesta osservazione permette di sfruttare l'***algoritmo di costruzione di $X_F^+$ per trovare le chiavi***. È infatti sufficiente porre come insieme $X(A)$ di partenza tutti gli attributi non determinati da niente, perché sono certo che faranno parte di tutte le chiavi. Gli attributi che restano fuori da $X_F^+(A)$ vanno scelti tra i determinanti delle dipendenze di $F$. È più difficile a dirsi che a farsi, in sostanza per trovare le chiavi puoi usare o gli $A$ non determinati da niente o quelli che determinano qualcosa, aggiungendo via via attributi per far coincidere la chiusura con tutto $R$.\n\nTrovata una chiave, è possibile verificare se sia unica tramite un ***test di unicità***: definiamo$$X = \\bigcap_{\\{V\\to W\\}\\in F} R − (W − V)$$Se $X^+ = R$, allora $X$ è l'unica chiave per $R$ secondo $F$, altrimenti ne esiste più di una.\nQuesta chiave è praticamente quella costruita a partire dagli attributi non determinati da niente, quindi è comodo partire da questi e fare un rapido check per verificare se posso fermarmi.","x":-1162,"y":4691,"width":880,"height":984,"color":"4"},
		{"id":"10deabbbff89afa9","type":"text","text":"Quando decompongo devo preservare le dipendenze funzionali di partenza.\nserve a decomporre uno schema non 3nf in schemi più piccoli 3nf. in realtà si può decomporre anche schemi già in 3nf. perché? se ho record lunghi porto in ram un botto di roba inutile, allora li scompongo per ottimizzare i tempi.\n**se uso una chiave come determinante, non c'è modo di violare le dipendenze funzionali!**\nAltrimenti in SQL definisco un attributo che non si può ripetere `unique`\n\n- eh ma ci stanno le dipendenze banali che non hanno la chiave come determinante! risposta: le ignoro, tanto sono sempre vere :)\n\n\nun'istanza legale si valuta sulle tuple\nuno SCHEMA è in 3NF\nPosso avere un'istanza legale che non rispetta la 3NF, perché sono proprio cose diverse\n\nNON vale la transitività: se ho R = ABCD e F = {A$\\to$ B, B$\\to$ CD} con A chiave, questa roba non è in 3NF. A determina B, ma B non è una (super)chiave. Posso avere ad esempio situazioni in cui diversi A determinano lo stesso B\n\nse un insieme di attributi contiene la chiave non possono esserci ripetizioni. se uno schema è 3nf non posso avere violazioni delle dipendenze funzionali, quindi non servono vincoli aggiuntivi\n\nho problemi se i sono schemi di relazione con un sacco di attributi (potrebbero esserci dipendenze funzionali non determinate dalle chiavi, aka non è 3NF). la soluzione è dividere bene entità e relazioni.\n\nse faccio i vari join non rischio di violare dipendenze funzionali (?)","x":-296,"y":3525,"width":1156,"height":622},
		{"id":"9076d8b16b92da58","type":"text","text":"# Dipendenze Parziali e Transitive\n\nSi dicono ***parziali*** quelle dipendenze che hanno come determinante un pezzo di una chiave, ovvero $X\\to A$ con $A\\notin X$ tali che $X\\subset K$ con $K$ chiave. Segue ovviamente che $A$ non può essere primo.\n\nFormalmente, $A$ **dipende parzialmente da** $K$ se$$\\exists\\,X \\subset K \\subset R\\,\\,\\,\\text{t.c.}\\,\\,\\,\\{X\\to A\\}\\in F^+,\\quad A\\notin X\\,\\,(\\Rightarrow A \\notin K)$$\nSi dicono ***transitive*** quelle dipendenze che permettono la transitività (e.g. se ho $D\\to B$ e $B \\to C$ la dipendenza transitiva è $B\\to C$, e fa in modo che $C$ dipenda transitivamente dalla chiave $D$). Formalmente questa cosa si traduce in diversi step. Perché $X\\to A$ con $A\\notin X$ sia transitiva\n\n- $\\forall \\,K\\in R$ si deve avere che $X\\not\\subset K$ e $K-X \\neq \\emptyset$, che in pratica significa che ogni $K$ ed $X$ o sono disgiunti o sono parzialmente sovrapposti;\n\t- Il caso ovvio è quello in cui i due insiemi sono disgiunti. $B$ è il \"ponte\" determinato da $D$ (chiave) che determina $C$;\n\t- In $X$ ci possono pure stare elementi di una certa chiave $K$, basta che non sia né *esattamente* $K$ né un suo sottoinsieme. Perché?\n\t\t- Se è un sottoinsieme di $K$ torniamo alle dipendenze parziali;\n\t\t- Se è $K$ ho semplicemente una dipendenza da una chiave.\n- $A$ **non deve essere primo**. Non è automatico come nelle parziali, devo imporlo io. E perché mai? Se $A$ fosse primo, non servirebbe costruire questo concetto di dipendenze transitive per dire che $A$ dipende da $K$;\n\t- Per lo stesso motivo $X$ deve avere almeno un elemento fuori da $K$.\n\n$A$ **dipende transitivamente da** $K$ se\n\n$$\\exists\\,\\, X \\subset R\\,\\,\\,\\text{t.c.}\\,\\,\\,\\{K\\to X\\}\\in F^+,\\quad A\\notin X,\\,\\, A \\notin K$$ \n ","x":-46,"y":4804,"width":660,"height":758,"color":"4"},
		{"id":"c28978adeeb9f559","type":"text","text":"# Forma Normale di Boyce-Codd (BCNF)\n\nNon c'è la parte $∨ A ∈ K$. Non sempre è possibile portare uno schema in BCNF. Perché farlo? Risolve un tot di problemi della 3NF.\n\nNon sempre è possibile decomporre in sottoschemi BCNF rispettando tutte le dipendenze, per cui in genere si usa 3NF (per cui invece è sempre possibile).","x":870,"y":4804,"width":660,"height":201,"color":"3"},
		{"id":"190cdeaceae81db7","type":"text","text":"# Definizione Equivalente di 3NF\n\nSi può dare una ***definizione alternativa di Terza Forma Normale***:\n$$\\text{Nessuna dipendenza}\\,\\{X → A\\} ∈ F^+ \\,(\\text{dove} \\, A \\notin X)\\,\\,\\text{è parziale o transitiva.}$$\nC'è un ***teorema*** che dimostra l'equivalenza delle due definizioni.\n\nNon riporto dimostrazione.","x":870,"y":5067,"width":660,"height":232,"color":"4"},
		{"id":"060659758b3f2bc8","type":"text","text":"# Su cosa si basa?","x":136,"y":2905,"width":292,"height":60,"color":"6"},
		{"id":"477470d0e3fa461a","type":"text","text":"\"Vogliamo che sia tutto in 3NF. Se non lo è, ce lo portiamo\".","x":22,"y":3105,"width":520,"height":50,"color":"5"},
		{"id":"4a7bf20ad214cee2","type":"text","text":"# Dipendenze Funzionali ($F$)\n\nUna ***dipendenza funzionale ($F$)*** è un ***vincolo*** definito su una coppia ordinata di attributi in base al loro significato. Scritto $A \\rightarrow B$,  significa che il valore dell'attributo $A$, detto ***determinante***, ***determina*** il valore dell'attributo $B$, detto ***dipendente*** (e.g. ad un dato `codice fiscale` deve corrispondere univocamente uno e un solo `cognome`). Vale anche su coppie di insiemi di attributi $X \\rightarrow Y$ (e.g. `codice fiscale` determina `nome`, `cognome`).\n\n- Se **nella stessa istanza** ho due tuple con lo stesso valore sul determinante, dovranno avere lo stesso valore anche sul dipendente: $t_1[X] = t_2[X] \\Rightarrow t_1[Y] = t_2[Y] \\quad \\forall \\, t_1, t_2 \\in r$;\n- Dato uno schema $R$ e un insieme $F$ di dipendenze funzionali definite su $R$, diciamo che un’istanza $r$ di $R$ è ***legale su $F$*** se soddisfa tutte le dipendenze funzionali in $F$.","x":-2282,"y":4093,"width":800,"height":340,"color":"6"},
		{"id":"e44b6de59ebb2aa9","type":"text","text":"# Teorema $F^+ = F^A$\n\nImportantissimo, perché di $F^+$ conosco le proprietà e di $F^A$ conosco un modo per costruirlo. Non riporto la dimostrazione in questi appunti, ma solo che si basa su\n- Induzione;\n- Tutte le dipendenze di $F^A$ hanno la proprietà di essere soddisfatte da ogni istanza legale, e quindi sono in $F^+$;\n- Non può esistere una dipendenza in $F^+$ che non stia in $F^A$;\n- ***Lemma***: $\\{X → Y\\} ∈ F^A \\Leftrightarrow Y ⊆ X^+_F$, ovvero \"$X$ determina $Y$ secondo $F$\" $\\Leftrightarrow$ \"$Y$ è contenuto nella chiusura di $X$ secondo $F$\".\n\nIn generale, le dimostrazioni di teoria relazionale si basano su due principi cardine:\n\n- Se vedo $F^+$ significa che posso sfruttare le istanze legali;\n- Visto che $F^+ = F^A$, ho un legame tra la chiusura di un insieme di attributi e la chiusura di un insieme di dipendenze: $$\\bigg\\{\\{X → Y\\} ∈ F^A \\Leftrightarrow Y ⊆ X^+_F\\bigg\\} \\Leftrightarrow \\bigg\\{\\{X → Y\\} ∈ F^+ \\Leftrightarrow Y ⊆ X^+_F\\bigg\\}$$Questo mi permette di dimostrare $Y ⊆ X^+_F$ invece di $\\{X → Y\\} ∈ F^+$.","x":-3223,"y":5095,"width":691,"height":580,"color":"4"},
		{"id":"93b7d0d27b51e813","type":"text","text":"# Chiusura di un insieme di Attributi $X$ ($X^+_F$)\n\nSia $X \\subseteq R$ ed $F$ l'insieme delle dipendenze funzionali su $R$. La chiusura di $X$ rispetto ad $F$ è $X^+_F = \\{B\\text{ t.c. }\\{X\\rightarrow B\\} \\in F^A\\}$, ovvero $X^+_F$ include tutti gli attributi determinati da $X$ secondo $F$.\n\n- Da questo segue che $X ⊆ X^+_F \\subseteq R$. Come casi limite abbiamo\n\t- $X = X^+_F$ significa che $X$ \"non determina niente\", ovvero non compare mai come determinante in una dipendenza funzionale di $F^+$;\n\t- $X^+_F = R$ significa che $X$ determina tutto lo schema, ovvero $X$ è ***superchiave***. Formalmente, $X ⊆ R$ è superchiave di $R \\Leftrightarrow X^+_F = R$;\n\t\t- Se poi $X^+_F = R\\,∧\\,∄Y ⊂ X\\,|\\,Y^+_F = R \\Leftrightarrow X ⊆ R$ è ***chiave*** di $R$; \n- ***Lemma***: $\\{X → Y\\} ∈ F^A \\Leftrightarrow Y ⊆ X^+_F$, ovvero \"$X$ determina $Y$ secondo $F$\" $\\Leftrightarrow$ \"$Y$ è contenuto nella chiusura di $X$ secondo $F$\".\n\t- ***Corollario***: $X → X ∈ F^A \\Leftrightarrow X ⊆ X^+_F$, ovvero ogni insieme di attributi è un elemento della sua chiusura (vedi \"Inclusione iniziale\" degli Assiomi di Armstrong).\n \nIn queste definizioni si usa $F^A$, ma il suo calcolo ha costo esponenziale.  Quindi anche calcolare $X^+_F$ ha costo esponenziale? No, esiste un algoritmo che lo calcola in tempo polinomiale.","x":-2282,"y":5095,"width":800,"height":580,"color":"4"},
		{"id":"95f267d89205cab7","type":"text","text":"# Algoritmo per la Costruzione di $X^+_F$\n\nDati uno schema di relazione $R$, un set di dipendenze funzionali $F$ ed un sottoinsieme di attributi $X \\subset R$ si può calcolare $X^+_F$ secondo il seguente algoritmo. In parallelo portiamo un esempio con$$R = ABCDEHL,\\quad F = \\{AB → C,\\, B → D,\\, AD → E,\\, CE → H\\}, \\quad AB^+ =\\,\\,\\, ?$$\n- I tre insiemi $R$, $F$ e $AB$ di cui voglio calcolare $AB^+$ sono l'input dell'algoritmo;\n- Partiamo con il definire\n\t- un insieme di attributi $Z$ che inizializzo $= X$;\n\t\t- Inizialmente quindi $Z \\subset R$, ma questa sarà la *\"variabile d'appoggio\"* che alla fine dell'algoritmo diventerà $X^+_F$ (quindi con senno di poi $Z\\subseteq R$);\n\t\t- Inizialmente, $Z = AB$;\n\t- un insieme $S$ formato da tutti gli attributi $A\\in V\\subseteq R$ che possono essere determinati da $Y ⊆ Z\\subseteq R$ tramite $F$, formalmente $S = \\{A\\,\\,\\text{t.c.}\\,\\,∃\\,(Y → V) ∈ F, \\text{ con }A ∈ V ⊆ R \\text{ e } Y ⊆ Z \\}$.\n\t\t- Cos'è tutto questo delirio di nuovi insiemi?\n\t\t\t- $V$ è un insieme di appoggio per trovare quali sottoinsiemi di $R$ sono volta per volta determinati dalla corrente definizione di $Y$. Non posso usare direttamente $R$ al posto di $V$ perché non è detto che la chiusura coinciderà con $R$. Se così non è, $Y\\to R$ è falsa già al primo passaggio;\n\t\t\t- $Y$ è in realtà un insieme che si definisce per comodità computazionale, perché concettualmente potrei usare direttamente $Z$.\n\t\t- Inizialmente $S$ contiene gli attributi determinati dalla definizione iniziale di $Z$, quindi in questo caso $S = CD$;\n- Facciamo un ciclo `while` con condizione $S \\nsubseteq Z$ (ovvero finché $S$ ha elementi fuori da $Z$);\n\t- Come prima cosa, se sono entrato qui dentro significa che $S$ ha elementi fuori da $Z$. Li aggiungo a $Z$ facendo un'unione $Z = X ∪ S$. Adesso $Z = ABCD$;\n\t- Ma un nuovo $Z$ significa un nuovo $S$. Riapplico la definizione, trovando che $ABCD$ determinano anche $E$;\n\t- Alla seconda iterazione ho ancora un elemento di $S$ che non è in $Z$ ($E$). Lo aggiungo, ricalcolo $S$ e trovo che $ABCDE$ determinano anche $H$;\n\t- Alla terza iterazione aggiungo $H$ a $Z$, ma $ABCDEH$ non determinano nulla di nuovo;\n- Uscito dal ciclo, chiamo $X^+ = Z$.\n\nQuesto algoritmo viene eseguito in ***tempo polinomiale***.","x":-2282,"y":5871,"width":800,"height":904,"color":"#4545ff"},
		{"id":"5fd5e7044929afce","type":"text","text":"# Chiusura di un insieme di Dipendenze $F$ ($F^+$)\n\nSe in $R = ABC$ ho $F = \\{\\,A \\rightarrow B,\\,\\,B \\rightarrow C\\}$, implicitamente sto dicendo che $A \\rightarrow C$ (che però non è definita in $F$). In generale, la definizione delle dipendenze funzionali $F$ può implicare l'esistenza di altre dipendenze funzionali. L'insieme di tutte le dipendenze funzionali (esplicite in $F$ e implicate da $F$) è detto ***chiusura di $F$***, e si indica con $F^+$.\n\n- Ogni istanza legale rispetta tutte le dipendenze funzionali di $F^+$;\n- Due insiemi di dipendenze $F$ e $G$ si dicono ***equivalenti*** ($F \\equiv G$) se $F^+ = G^+$;\n\t- Insiemi di dipendenze equivalenti hanno le stesse istanze legali;\n\t- ***Lemma*** (di ***inclusione delle chiusure***): $F \\subseteq G^+ \\Leftrightarrow F^+ \\subseteq G^+$ (ometto dimostrazione). Ha senso se si pensa che $F\\subseteq G \\Rightarrow F\\subseteq G^+$ e che $F\\subseteq G \\Rightarrow F^+\\subseteq G^+$.","x":-2282,"y":4665,"width":800,"height":345,"color":"4"},
		{"id":"c44ff0137238f8c0","type":"text","text":"# Vincoli\n\nPerché nelle applicazioni pratiche parliamo di <span style=\"color:#cd0a0a\">***istanze***</span> (e quindi solo di sottoinsiemi) invece di considerare tutti i possibili risultati?\n\n- È quasi sempre impossibile prendere in considerazione tutte le possibili <span style=\"color:#ffc000\">***tuple***</span> per motivi di spazio: la cardinalità del ***prodotto cartesiano*** scala esponenzialmente con il numero di <span style=\"color:#cd0a0a\">***attributi***</span>. Questo di per sé è già un problema con domini a cardinalità finita, figuriamoci se anche solo uno di questi è $\\aleph$;\n- Certe combinazioni non esistono nella realtà, oppure sono io a imporre che non devono esistere. Da questa considerazione nasce il concetto di  <span style=\"color:#cd0a0a\">***vincolo***</span>.\n\nTutti i vincoli hanno come effetto quello di ridurre la cardinalità dell'insieme risultante. Ne esistono due tipi:\n\n- Vincoli di Dominio (e.g. `voto` è un intero positivo e minori di 30).\n\n","x":-2342,"y":2840,"width":920,"height":525,"color":"3"},
		{"id":"61cb737e4d3fe669","type":"text","text":"# Assiomi e Chiusura di Armstrong ($F^A$)\n\nLa proprietà transitiva non è l'unica ad ampliare $F$ in $F^+$. Possiamo costruire la ***chiusura di Armstrong $F^A$*** secondo la seguente procedura:\n\n- **Inclusione iniziale**: $F\\subseteq F^A$, ovvero $X \\rightarrow Y \\,\\in F \\Rightarrow X \\rightarrow Y \\,\\in F^A$;\n- **Assioma di Riflessività**: $Y \\subseteq X \\subseteq R \\Rightarrow X \\rightarrow Y \\in F^A$ (e.g. `nome`$\\subseteq$ {`nome`, `cognome`} $\\subseteq$ `studente` $\\Rightarrow$ {`nome`, `cognome`} $\\rightarrow$ `nome`, che è una dipendenza funzionale di $F^A$). Ma è ovvio, no? Sì, infatti si chiamano ***dipendenze banali***. Si intuisce che $F^A$ è inutilmente grande. Per dire, $\\{A \\rightarrow A\\} \\in F^A$;\n- **Assioma di Aumento**: $Z \\subseteq R,\\, \\{X \\rightarrow Y\\} \\in F^A \\Rightarrow \\{XZ\\rightarrow YZ\\} \\in F^A$. Prendi una dipendenza funzionale e aggiungigli l'attributo $Z$ per determinare anche l'attributo $Z$. Non so perché, ma non rientra nelle dipendenze banali;\n- **Assioma di Transitività**: $\\{X \\rightarrow Y\\} \\in F^A ∧ \\{Y → Z\\} ∈ F^A ⇒ X → Z \\in F^A$.\n\nDa questi assiomi si possono dimostrare le ***regole secondarie di Armstrong***.\n\n- **Unione**: $\\{X → Y\\} ∈ F^A ∧ \\{X → Z\\} ∈ F^A ⇒ X → YZ ∈ F^A$. Se $X$ determina separatamente due attributi, allora li determina anche come coppia;\n- **Decomposizione**: $Z ⊆ Y,\\, \\{X → Y\\} ∈ F^A ⇒ \\{X → Z\\} ∈ F^A$, ovvero l'opposto dell'Unione;\n\t- Questa roba vale qualsiasi sia $Z ⊆ Y$, ergo $\\{X → Y\\} ∈ F^A \\Leftrightarrow ∀B ∈ Y, \\,\\{X → B\\} ∈ F^A$;\n- **Pseudo-transitività**: $\\{X → Y\\} ∈ F^A ∧ \\{W Y → Z\\} ∈ F^A ⇒ \\{W X → Z\\} ∈ F^A$, che è una specie di aumento + transitività.\n\t- ***Corollario (utile per definizione 3NF)***: non è restrittivo considerare dipendenze funzionali con soli ***singleton*** (singoli attributi) piuttosto che insiemi di attributi;\n\t- Riempire $F^A$ ha ***costo computazionale esponenziale***. Basti pensare che un insieme con $n$ elementi ha $2^n$ possibili sottoinsiemi.","x":-4244,"y":4501,"width":771,"height":702,"color":"4"},
		{"id":"89ae6e18040f3465","type":"text","text":"# Foreign Key\n\nIl ***vincolo di chiave esterna***, pur inizialmente non previsto dal modello relazionale, risulta molto utile.\n\nAd esempio, nell'associazione `esame` contenente la voce `candidato`, questa è vincolata ad assumere solo valori che compaiono nello schema `studente` alla voce `matricola`.","x":-1162,"y":5871,"width":880,"height":170,"color":"4"},
		{"id":"eba6d491c9cfc3d3","type":"text","text":"# MODELLO RELAZIONALE (ING INF)\n\nSi basa sul concetto di matematico di relazione e sui valori (niente oggetti, niente puntatori).\n\nUna ***relazione*** è un insieme di tuple omogenee, cioè definite sugli stessi attributi. Dati $n$ domini $D_n$ (che possono essere interi, reali, date, stringhe, ore, spesso si usano tipi di dato astratti personalizzati per mettere un vincolo sui possibili valori di quel campo), il loro prodotto cartesiano è ogni possibile tupla in cui $d_i \\in D_i$.\n\nESEMPIO\nSe $D_1 = \\{a, b\\}$ e $D_2 = \\{x, y, z\\}$ posso avere solo 6 tuple distinte. Una relazione è un ***insieme***, quindi ogni tupla compare una e una sola volta.\n\nUna relazione è un sottoinsieme del prodotto cartesiano dei domini.\n\n- Il ***grado*** di una relazione è il numero di domini (#colonne nella tabella);\n- La ***cardinalità*** è il numero di tuple realizzabili (#righe nella tabella).\n\nRispetto alle tuple matematiche, le colonne delle tabelle hanno le ***etichette***, quindi non devo rispettare per forza l'ordine ($d_1$, $d_2$, ...). Non ho più la relazione ***posizionale***. L'etichetta dà la ***semantica*** al dato. Tutte le altre proprietà sono rispettate.\n\nSe devo inserire una riga, quanto mi costa la verifica che non ci sia già? $O(n)$, ma posso migliorarlo? Sì, in due modi:\n\n- Introduco ***colonne privilegiate*** su cui effettuare i controlli. L'idea è che queste identifichino l'intera riga in modo univoco. Ad esempio, in una tabella di studenti contenente nome, cognome, data di nascita e numero di matricola sarà sufficiente controllare quest'ultima. In una tabella con matricola, esame e voto sarà necessario prendere le colonne matricola e corso, in quanto non è possibile avere due voti positivi allo stesso esame;\n- Introduco un ***ordinamento***, e quindi faccio ricerca binaria.\n\nSe non conosco un dato è possibile far inserire al DBMS il valore ***NULL***. Con questa cosa bisogna stare molto attenti:\n\n- Se il dato che non conosco appartiene a una colonna privilegiata, non è ammissibile;\n- Se non appartiene a una colonna privilegiata, posso decidere in fase di progettazione se consentire o meno il `NULL` (***vincolo*** `not NULL`).\n\nNel momento in cui inserisco `NULL`, però, non so se quel dato non è stato inserito perché\n\n- non lo conosco al momento, ma potrei conoscerlo in futuro (e.g. `unknown attribute`);\n- non esiste, e quindi non potrò mai conoscerlo (e.g. `inapplicable attribute`);\n\nDa un lato, se non permettessi di inserire dati parziali risulterei troppo rigido. Dall'altro, ogni `NULL` abbassa la qualità del DB. Inoltre, ogni ***vincolo di integrità*** introdotto corrisponde a un costo di ricerca e verifica su una enorme mole di dati.\n\nI vincoli possono essere\n\n- ***Vincoli Intrarelazionali***, ovvero interni alla stessa tabella, e si distinguono in\n\t- ***Vincoli di Tupla***, che verificano l'intera riga. Possono essere\n\t\t- verifiche sul singolo campo (e.g. un `voto` deve essere compreso tra 0 e 30) - ***Vincoli di Dominio***;\n\t\t- verifiche tra campi diversi (e.g. il campo `lode` può assumere solo valori `vero`/`falso`, ma può essere `vero` solo se `voto` è uguale a 30) - ***Dipendenze Funzionali***;\n\t- ***Vincoli di Chiave***, che verificano solo le colonne privilegiate. Un Vincolo di Chiave specifica che un insieme di attributi forma una ***chiave*** per una relazione.\n\t\t- Se ho una relazione $R = ABCD$, dichiarare un Vincolo di Chiave su $AB$ significa dire che in $R$ non possono esistere due tuple che coincidano negli attributi $A$ e $B$\n\t\t\t- Per realizzare un Vincolo di Chiave mi servono le Dipendenze Funzionali;\n\t\t\t- Implicitamente sto anche dicendo che nessun sottoinsieme di $AB$ è chiave. Se lo fosse, $AB$ sarebbe una ***superchiave***, cioè un insieme di attributi al cui interno c'è una chiave. Segue che una chiave è una superchiave minimale.\n\t\t- Non è detto che la scelta della chiave sia unica. Il $max$ è il numero di attributi.\n\t\t\t- La tupla di per sé è chiaramente una chiave, ma a livello pratico risulta un po' troppo lunga.\n\t\t- Ogni tabella ha una e una sola ***chiave primaria*** (indicata graficamente sottolineando gli attributi che la formano), per la quale non ha senso ammettere valori nulli. Poi, opzionalmente, può avere $N$ chiavi secondarie.\n\t\t\t- L'importante, comunque, è che la tupla sia identificabile: devo vietare valori nulli in almeno una chiave (la primaria).\n\t\t- Se una tabella è grande, fare avanti e indietro tra RAM e HDD è scomodo. Allora posso costruire una tabella più snella costituita dalle sole chiavi.\n\n- ***Vincoli Interrelazionali***, tra tabelle diverse. Tramite i valori definisco i collegamenti tra le tabelle. Se ad esempio ho una tabella con i vari `codice corso`, non posso avere una tabella con i `voti` degli esami in cui compare un `codice corso` non presente nell'altra tabella. Questo concetto prende il nome di ***Vincolo di Integrità Referenziale***. Si noti che differisce da un modello a puntatori, che farebbe direttamente riferimento al valore inserito nella prima tabella.\n\n\t- ***Vincoli di Integrità Referenziale*** (o di ***Foreign Key***) - lavora sulla ***chiave primaria*** di una tabella di riferimento. In particolare, data la tabella $R_1$ e il suo campo $A$ non chiave, il Vincolo di Integrità Referenziale impone che ogni valore che compare in $A$ compaia anche nei campi chiave $X$ della tabella $R_2$.\n\t\t- L'insieme dei valori del ***campo referenziante*** sono un ***sottoinsieme*** dei valori del ***campo referenziato***.\n\nUn'istanza che rispetta tutti i vincoli è detta ***legale***. Un modo per assicurarsi che l'utente immetta in input una stringa corretta è impostare una GUI per farlo scegliere tra i valori ammissibili piuttosto che lasciarlo libero di scrivere. Ad esempio, se voglio prenotare un aereo non è l'utente a immettere la data, ma sceglie dal calendario. Meglio prevenire che verificare.\n\nCosa succede se ho $R$ con `squadra1` `squadra2` e `risultato`? Qual è la chiave primaria? `Squadra1 Squadra2`. E se possono incontrarsi un\nnumero indefinito di volte? Ho diverse opzioni:\n\n- Aggiungo un attributo che funge da chiave primaria, come un codice partita;\n- Aggiungo un attributo che unito alla vecchia chiave primaria mi dia la nuova chiave primaria. Se ad esempio so che nella stessa data due squadre si possono incontrare solo una volta, `Sq1 Sq2 Data` è la chiave primaria.\n\n`NULL` è un valore compatibile col foreign key. Mettere troppi vincoli può portare all'impossibilità di trovare una tupla che li soddisfi tutti. Oltretutto, ognuno di essi introduce rallentamenti. Infine, se elimino una tupla referenziata potrebbero succedere disastri. Vedremo dopo come ovviare a questi problemi.\n\nIn SQL NON ESISTE L'IF!! Devo gestirmela solo con la logica booleana. Questo potrebbe rendere particolarmente inefficienti alcuni tipi di verifiche.","x":-4558,"y":2197,"width":1400,"height":1812,"color":"5"},
		{"id":"23afcf5b45f8bffc","type":"text","text":"# Algebra Relazionale\n\nLinguaggio formale che sottende al linguaggio di interrogazione SQL.\n\nDi fatto non viene eseguito da nessuna macchina, è descrittivo (ma procedurale, nel senso che descrivo la procedura).\n\nQuando faccio le operazioni uso come operandi gli elementi persistenti del DB, e metto i risultati in variabili relazionali non persistenti.","x":3320,"y":1925,"width":680,"height":255,"color":"6"},
		{"id":"d978bd83e81a4684","type":"text","text":"# Glossario illogico del Modello Relazionale e Sintesi dei Concetti Fondamentali\n\nIl modello relazionale fa casino con i nomi.\n\n- **_Entità_** - Schematizzazione logica dell'oggetto di interesse da memorizzare;\n- **_Attributi_** - Caratteristiche che definiscono l'entità. Ogni nome di queste caratteristiche (***etichetta***) è associata ad un **_dominio_** di valori che può assumere. Ad esempio, `colore`, `marca`, `modello` e `cilindrata` possono essere attributi che definiscono l'entità `macchina`.\n\t- Se il dominio di `cilindrata` è un numero reale positivo, non posso scegliere come valore `media` $\\Rightarrow$ ***vincolo di dominio***;\n\t- La logica potrebbe dirmi che non ha senso definire una `macchina` senza specificare il `modello` (e.g. usando il valore \"*jolly*\" `NULL`) $\\Rightarrow$ ***vincolo di esistenza del valore***;\n\t- Convenzionalmente, per indicare i *singoli attributi* si usano le prime lettere dell'alfabeto (A, B, ...), mentre le ultime (X, Y) si riferiscono ad *insiemi di attributi*;\n- **_Campo_** - A volte usato come sinonimo di attributo, può riferirsi allo specifico  valore assegnatogli (e.g. il campo dell'attributo `colore` può essere `rosso`);\n- **_Record (Tupla, t)_** - Un set di campi $\\Rightarrow$ uno specifico set di valori assegnati agli attributi;\n- **_Relazione_** - Vedi \"***Legami con la Teoria degli Insiemi***\". Termine in cui collassano due distinti termini inglesi:\n\t- **_Relation_** - Usato come sinonimo di **tabella** e **istanza** (o al limite **tupla**), per intendere l'implementazione del concetto matematico di <span style=\"color:#00b050\">***relazione***</span>;\n\t- **_Relationship_** - Si riferisce a una connessione logica tra tabelle (e.g. se due tabelle rappresentano le entità `studenti` e `corsi`, `esame` è una *relationship* che associa un elemento `studente` a un elemento `corso`, potenzialmente aggiungendo l'informazione `voto`). Il guaio è che una *relationship* è a sua volta una *relation* (perché poi ovviamente questa informazione viene implementata come tabella), quindi in italiano si usa *relazione* dando per scontato tutto questo buco nero di significati. Per diminuire la confusione possiamo chiamare la *relationship* ***associazione***.\n- **_Schema di Relazione ($R$)_** - L'inseme di tutti e soli gli attributi d'interesse a cui associo un **nome della relazione** (e.g. `nome_della_relazione = studente` e attributi `nome`, `cognome` e `matricola` sono lo ***schema*** della relazione).\n\t- In generale, è la ***struttura logica*** (o ***intensione***) della relazione. Possono rientrare nello schema anche i tipi e i domini degli attributi (e.g. `matricola` è un intero positivo), nonché le **_chiavi_** e i _**vincoli d'integrità**_.\n\t- L'insieme di tutti gli schemi di relazione è detto ***Schema del Database***;\n- **_Istanza di Relazione ($r$)_** - Un insieme di tuple omogenee ($\\Rightarrow$ aventi tutte gli stessi attributi) a cui è associato un nome (e.g. `nome = studente` e tuple i cui campi sono i valori di `nome`, `cognome` e `matricola`).\n\t- In generale, è una ***specifica implementazione dello schema di relazione*** (o ***estensione***), ovvero un insieme di dati effettivamente memorizzati nel DB;\n\t- Il termine \"*istanza*\" è usato talvolta per indicare una singola tupla (e.g. un'istanza specifica all'interno di una tabella), *probabilmente* perché come caso limite anche una sola tupla forma un'istanza;\n\t- In ogni istante, in un DB ho una sola istanza di relazione $r$ sullo schema di relazione $R$ corrispondente. \n- **_Tabella_** - Implementazione operativa delle istanze: le istanze sono rappresentate mediante tabelle. Un'istanza è una tabella riempita secondo il suo schema. \n- ***Dipendenza funzionale ($F$)***  - ***vincolo*** definito su una coppia ordinata di attributi in base al loro significato ($\\Rightarrow$ etichette). Scritto $A \\rightarrow B$,  significa che il valore dell'attributo $A$, detto **determinante**, ***determina*** il valore dell'attributo $B$, detto **dipendente** (e.g. ad un dato `codice fiscale` deve corrispondere univocamente uno e un solo `cognome`).\n\t- ***Chiusura di $F$ ($F^+$)*** - L'insieme di tutte le dipendenze funzionali (esplicite in $F$ e implicate da $F$). Equivalente alla ***chiusura di Armstrong $F^A$***;\n\t- ***Chiave*** - Il più piccolo sottoinsieme di attributi $K$ dello schema $R$ che determina funzionalmente tutti gli attributi dello schema stesso. In generale non è unica.\n\t\t- ***Primo*** - Qualsiasi attributo $A\\in K$;\n\t\t- ***Superchiave*** - Sottoinsieme di attributi $K'$ dello schema $R$ che contiene una chiave $K$ ($\\Rightarrow K'\\subseteq K$). Come conseguenze\n\t\t\t- una superchiave determina ancora tutti gli attributi di $R$;\n\t\t\t- ogni chiave è anche una superchiave.\n\t- ***Chiusura di un insieme di attributi $X$ ($X^+_F$)*** - L'insieme di tutti gli attributi esplicitamente contenuti in $X \\subseteq R$ e determinati funzionalmente da $X$ secondo $F$.\n\t\t- Spesso è più comodo usare $X^+_F$ al posto di $F^+$ o $F^A$ in quanto più semplice da calcolare;","x":1220,"y":2100,"width":1416,"height":1120,"color":"4"},
		{"id":"7f387917126a1ab6","type":"text","text":"# Cose in ordine sparso credo\n\n- attributi = domini + etichette\n- schema di relazione = insieme di attributi (tant'è che si scrive $R(A_1, A_2, ...)$) = generica relazione in senso matematico + etichette sui domini\n\t- descrive la struttura della relazione in senso dei DB (aspetto intensionale)\n\t- in pratica dice quali sono le possibili tuple che possono esistere, e conseguentemente ingloba tutti i possibili subset di queste tuple\n- Istanza di relazione = insieme di tuple che definiscono valori sugli attributi dello schema di relazione = specifica relazione in senso matematico + etichette sui domini\n\t- specifico set tra tutti i possibili set che posso creare con le tuple consentite dallo schema di relazione (aspetto estensionale)\n\t- ***in ogni istante, in un DB ho una sola istanza di relazione sullo schema di relazione corrispondente!!!***. per convenienza nelle operazioni uso il nome dello schema, ma in pratica uso l'istanza (tanto c'è corrispondenza 1 a 1)\n- le dipendenze funzionali dipendono dal significato delle etichette degli attributi. per questo si dice A DETERMINA B (non implica!), perché non è una roba matematica, è una cosa concreta che faccio a posteriori del significato delle etichette che uso.\n- esiste anche lo schema del DB, che è gli insieme degli schemi di relazione.","x":2680,"y":2300,"width":560,"height":920,"color":"3"},
		{"id":"903aad68a5ec5667","type":"text","text":"# Foreign Key: Associazioni Univoche, Totali e Parziali\n\nQuando faccio foreign key posso avere che\n\n- ad ogni tupla di una relazione **può essere associata** una ed una sola tupla di un'altra. Se ogni `studente` può avere uno ed un solo `piano di studi`, l'associazione è ***univoca*** rispetto a `studente`;\n\t- Si noti che non è biunivoca: lo stesso piano di studi potrebbe essere scelto da più studenti.\n\t- In situazioni in cui una singola tupla può essere associata a più tuple dell'altra relazione abbiamo un'associazione **non-univoca** (**molti-a-uno** o **uno-a-molti**).\n- ad ogni tupla di una relazione **è effettivamente associata** una ed una sola tupla di un'altra. Se tutte le tuple di partenza e di arrivo sono legate da corrispondenza biunivoca, l'associazione è detta ***totale***;\n\t- Al contrario, se esistono tuple nell'istanza di partenza e/o di arrivo che non hanno corrispondenza con tuple dell'altra istanza, l'associazione è detta ***parziale***.","x":-5640,"y":2638,"width":872,"height":404,"color":"4"},
		{"id":"47a35105b19345b4","type":"text","text":"# Contro le Ridondanze (ING INF)\n\nÈ sempre meglio evitare campi ridondanti. Segue esempio.\n\n$R_1$ è una tabella di infrazioni stradali. I campi sono `codice infrazione`, `data`, `matricola vigile`, `provincia`, `numero verbale`. C'è un vincolo di foreign key sulla tabella dei vigili, $R_2$, che contiene `matricola vigile` (chiave primaria, quindi campo referenziato dall'omonimo referenziante di $R_1$), `cognome` e `nome`. Se nella tabella infrazioni volessi inserire il cognome del vigile (quindi un'informazione ridondante) potrei effettuare un altro controllo di tipo foreign key sul cognome di $R_2$, ma i due vincoli sono indipendenti. Di conseguenza, potrei inserire in input di $R_1$ lo stesso codice vigile associato a due cognomi\tdiversi, e per i vincoli andrebbe bene. Porterebbe chiaramente a un'inconsistenza del DB.\n\n- Per ovviare al problema volendo mantenere il cognome dovrei usare la coppia, ma tecnicamente è più difficile da implementare.\n- In generale nella stessa tabella possono esserci più referenzianti.","x":-5640,"y":3163,"width":872,"height":404,"color":"5"},
		{"id":"110d5abbb0f74fea","type":"text","text":"# Ambiente Strutturato o Dati Strutturati?\n\nNon va fatta confusione tra il concetto di **_ambiente strutturato_**, inteso come la presenza di un DBMS, e le caratteristiche dei dati memorizzati.\n\n- **_Dati non strutturati_**: testi scritti in un linguaggio naturale, per i quali è implementabile solo una ricerca di tipo sequenziale, con un tempo medio di accesso $\\sim O(n/2)$;\n- **_Dati strutturati_**: dati rappresentati da brevi stringhe di simboli o da numeri. Permettono di definire relazioni d'ordine e quindi ottimizzare gli algoritmi di ricerca. Ad esempio, la **_ricerca binaria_** arriva ad un tempo medio di accesso $O(log_2(n))$. Ci si può accedere singolarmente tramite interrogazioni.\n\nI moderni DB sono costituiti da **_soli_** dati strutturati.\n","x":860,"y":400,"width":760,"height":380,"color":"4"},
		{"id":"186012183c3f3ecd","type":"text","text":"# Linguaggi di Interrogazione\n\nAnche con l'avvento dei primi DBMS, nei primi anni non esisteva un **_linguaggio di interrogazione (query language)_** universale.\n\nIn **IMS**, ad esempio, la gestione avveniva tramite _Data Language/1_ (**DL/1**), un complesso linguaggio di interrogazione specifico che richiedeva una dettagliata conoscenza della struttura fisica del DB. In seguito questo venne ampliato con il Generalized Update Access Method (**GUAM**), che forniva funzionalità di più alto livello per semplificare la vita dei programmatori. \n\nNei DB standardizzati CODASYL esisteva il *Data Manipulation Language* (**DML**), che però è sempre rimasto specifico dei modelli a rete.\n\nIl primo linguaggio di interrogazione universale è lo **_Structured Query Language (SQL)_**, nato in IBM nei primi anni '70 insieme al **_modello relazionale_**.\n\nC'è da notare che ancora oggi alcune società potrebbero avere dei DB non standardizzati, perché i costi del porting superano i benefici.","x":860,"y":860,"width":760,"height":496,"color":"4"},
		{"id":"c391c5b931a474b1","type":"text","text":"# Controllo di Concorrenza tramite Lock\n\nSe devo comprare un biglietto, il DBMS deve garantirmi che mentre lo faccio non ci sia qualcun altro che lo compra in contemporanea.\n\nOgni utente deve avere l'impressione di essere l'unico utente sul sistema e che le operazioni avvengano in ***near-real-time***.\n\nQualsiasi tipo di di ***scheduling delle transazioni*** (i.e. la **sequenza ordinata delle operazioni eseguite** sul DB) deve sapere *cosa* sincronizzare (e.g. l'unità da bloccare, in caso di lock).\n\nUno schedule ***legale*** è tale se ogni transazione $T$ al suo interno\n\n- ***attende*** di poter acquisire il ***lock*** su tutte le risorse che intende utilizzare (i.e. che nessun altra transazione abbia un lock su una di esse);\n- ***acquisisce*** il lock su tutte le risorse che intende utilizzare;\n- terminate le operazioni, ***rilascia*** il lock su tutte le risorse utilizzate.\n\nGli ***item*** fondamentali utilizzati dipendono dall'uso che si fa del DB (e.g. se l'azione tipica è la ricerca tramite indice gli item sono **tuple**, se invece sono join tra istanze si usano le **tabelle**).\n\nLa dimensione degli item è detta ***granularità***.\n- Grandi dimensioni ottimizzano il controllo ma riducono il parallelismo;\n- Piccole dimensioni aumentano il parallelismo ma sovraccaricano il sistema.","x":3305,"y":-734,"width":710,"height":659,"color":"6"},
		{"id":"680466b4da71866a","type":"text","text":"# Lock a Due Fasi e Schedule Serializzabili\n\n\nIl caso più semplice è quello di ***lock binario*** (o ***a due fasi***), in cui una transazione effettua **prima tutti i lock** sulle singole risorse **e poi tutti gli unlock**. Se tutte le $T$ implementano lock a due fasi, ogni schedule da esse ottenuto è ***serializzabile***.\n\n\nDue schedule si dicono ***equivalenti*** se l'espressione analitica finale delle azioni sul DB è la stessa per entrambi (i.e. se $S_1(DB) = S_2(DB)$).\n\nUno schedule si dice ***serializzabile*** se è equivalente allo schedule in cui si eseguono le singole transazioni in serie.\n\nÈ possibile verificare la serializzabilità di uno schedule tramite un ***algoritmo*** che fa uso di un grafo orientato, detto ***grafo di serializzazione***. I nodi sono le transazioni, e le frecce indicano lo spostamento del lock. Se in questo grafo è presente un ***ciclo***, allora lo ***schedule non è serializzabile***.","x":4160,"y":-600,"width":853,"height":391,"color":"4"},
		{"id":"93b81e4cccf632f5","type":"text","text":"# Protocollo di Lock a Due Fasi Stretto\n\n- La transazione non scrive sul DB finché non raggiunge un nuovo stato coerente. Nel frattempo scrive in un \"foglio di brutta\" (il ***log***). I checkpoint in cui scrive sul DB sono detti ***punti di commit***;\n\t- Questo ***previene stati inconsistenti*** dati da abort accidentali come un calo di corrente.\n- La transazione acquisisce il lock su tutte le risorse che potrebbe dover utilizzare (anche se poi di fatto non le utilizza), rilasciandolo solo quando ha terminato tutte le operazioni.\n\t- Questo ***previene il deadlock*** ma non il livelock, creando liste di attesa potenzialmente lunghe.","x":4160,"y":-1160,"width":853,"height":254,"color":"4"},
		{"id":"0cba8c1e45400c14","type":"text","text":"# Deadlock e Protocolli di Gestione degli Abort\n\nSe si verifica un ***deadlock*** posso recuperare da esso tramite uno o più ***roll-back***: abortisco le transazioni eseguendo a ritroso tutte le operazioni svolte fino a quel momento, facendo poi ripartire lo schedule.\n\nMa il deadlock (e/o il ***livelock***) non è l'unica situazione in cui possono verificarsi degli abort. Un malfunzionamento HW (e.g. un calo di corrente) rischia di lasciare il DB in uno stato inconsistente (***dati sporchi***).\n\nIn generale, per ***recuperare*** da uno stato inconsistente devo eseguire roll-back in cascata, ma posso ***prevenire***  usando degli accorgimenti, ad esempio con un ***protocollo di lock a due fasi stretto***.\n\nIn generale, distinguiamo due macrocategorie di protocolli di gestione:\n\n- ***Conservativi*** - Cercano di ***evitare*** situazioni di deadlock, convengono quando la probabilità che due $T$ richiedano il lock sulla stessa risorsa è alta, in quanto riducono l'overhead di sistema per il recupero dai deadlock;\n- ***Aggressivi*** - Puntano a ***recuperare*** da situazioni di deadlock, se si verificano. Se la probabilità che due $T$ richiedano la stessa risorsa è bassa, questo riduce l'overhead di sistema dovuto alla gestione dei meccanismi di lock.","x":3305,"y":-1860,"width":710,"height":556,"color":"4"},
		{"id":"4c38e6c1c366af16","type":"text","text":"# Lock a Tre Valori e (nuovi) Schedule Serializzabili\n\nIl ***lock a tre valori*** nasce per ***aumentare il grado di concorrenza***. Introduciamo due lock distinti:\n\n- `rlock` - il lock di lettura impedisce solo la modifica;\n- `wlock` - il lock di scrittura è il lock \"classico\", nessuno può accedere alla risorsa.\n\nEntrambi vengono rilasciati con una sola primitiva, la classica `unlock`.\n\nQuesta distinzione modifica leggermente la definizione di ***schedule equivalenti***, che ora necessita di due condizioni. Due schedule che applicano lock a tre valori sono equivalenti se\n\n- L'espressione analitica finale è la stessa per ogni risorsa coinvolta in un `wlock`;\n- Ogni `rlock` legge lo stesso valore della risorsa in entrambi.\n\nAnche in questo caso, esiste una ***variante del precedente algoritmo*** che sfrutta un ***grafo di serializzazione*** per determinare se uno schedule è serializzabile. In particolare, da un singolo nodo possono partire più archi (sulla stessa risorsa posso effettuare diversi `rlock`).\n\nQuesto meccanismo di lock però modifica la definizione di serializzabilità data in precedenza (***view serializability***). Bisogna introdurre la ***conflict serializability***, che si basa su una ***nuova definizione di equivalenza tra due schedule*** che prevede quattro vincoli:\n\n- Se in $S$ $T_2$ legge l'item $x$ scritto da $T_1$, allora in $S'$ $T_1$ deve precedere $T_2$;\n- Se in $S$ vi è infine $T_3$ che scrive quello stesso item $x$, allora in $S'$ $T_3$ deve precedere $T_1$ o seguire $T_2$;\n- Se in $S$ una certa $T$ legge il valore iniziale di un item $x$, in $S'$ deve precedere ogni $T'$ che scrive $x$;\n- Se in $S$ una certa $T$ scrive il valore finale di un item $x$, in $S'$ deve seguire ogni $T'$ che scrive $x$.\n\nSi noti che le ultime due condizioni vengono riassorbite nei primi due vincoli se si assume l'esistenza di una $T_0$ iniziale che scrive tutti valori iniziali senza leggerne nessuno, e una $T_f$ che legge tutti valori finali senza scriverne nessuno. Che me pare strano ad una prima lettura me non ho tempo di capirlo :)","x":5360,"y":-781,"width":853,"height":754,"color":"4"},
		{"id":"56193193b904926e","type":"text","text":"# Timestamp\n\nUn timestamp è tipicamente l'***istante temporale*** di inizio delle operazioni di una transazione, o comunque il ***valore di un counter*** che la identifica univocamente.\n\nUno schedule è serializzabile se è equivalente allo schedule in cui le transazioni compaiono ordinate in base al loro timestamp.\n\nAd ogni item $x$ sono associati due timestamp:\n\n- ***read timestamp*** - il più grande tra tutti i timestamp delle $T$ che hanno letto $x$;\n- ***write timestamp*** - il più grande tra tutti i timestamp delle $T$ che hanno scritto $x$.\n\nNon avrebbe senso associare l'ultimo timestamp in ordine cronologico, perché l'ordine di esecuzione che mi interessa è quello delle transazioni. Infatti, ogni volta che una transazione $T$ prova a fare operazioni su $x$ eseguo un confronto:\n\n- Se provo ad eseguire `write(x)` ho tre casi:\n\t- `read_TS(x) > TS(T)` - Roll-Back, l'ordine di esecuzione è sbagliato (una $T$ che viene dopo di me ha già letto $x$ senza che io lo scrivessi);\n\t- `write_TS(x) > TS(T)` - Non eseguo la `write(x)`, perché un'altra $T$ con timestamp maggiore ha già eseguito la sua;\n\t- Altrimenti, eseguo `write(x)` e aggiorno `write_TS(x) = TS(T)`.\n- Se provo ad eseguire `read(x)` ho tre casi:\n\t- `write_TS(x) > TS(T)` - Roll-Back, l'ordine di esecuzione è sbagliato (una $T$ che viene dopo di me ha già scritto $x$);\n\t- `write_TS(x) <= TS(T)` - Eseguo `read(x)`, dopodiché\n\t\t- se `read_TS(X) < TS(T)` allora aggiorno `read_TS(x) = TS(T)` (i.e. se sono la $T$ con il timestamp più alto ad aver letto devo aggiornare $x$).","x":3305,"y":223,"width":710,"height":734,"color":"4"},
		{"id":"1559942f272c8467","type":"text","text":"# Come opera un DBMS \n\nil so apre un canale di comunicazione con il dbms che risponde su un certo socket (porta). I dati del DB hanno una codifica proprietaria, e sono decodificati solo tramite il dbms (leggi: se li apro con l'editor vedo roba insensata) che si occupa di virtualizzarli per l'utente.\n\n","x":9261,"y":-4860,"width":447,"height":680},
		{"id":"e8974e97e6a653e4","type":"text","text":"# Come mi assicuro che sia coerente?","x":9325,"y":-3109,"width":562,"height":50,"color":"6"},
		{"id":"21febace8b459e12","type":"text","text":"# DBMS Relazionali (RDBMS)","x":9383,"y":-3720,"width":456,"height":50,"color":"6"},
		{"id":"eac6417a6b7e152d","type":"text","text":"# Con che logica lo scrivo?","x":10098,"y":-4051,"width":408,"height":50,"color":"6"},
		{"id":"c257b123a2436672","type":"text","text":"# Caratteristiche di un DBMS\n\n- Gestisce collezioni di dati\n\t- Grandi: autoesplicativo;\n\t- Persistenti: i dati sono la risorsa più stabile (rispetto ai metodi, gli algoritmi e simili, che possono cambiare). Il DBMS gestisce processi di BACKUP e RECOVERY per minimizzare il rischio di perderli;\n\t- Condivise: accessibili ad altri sistemi e ad utenti. Questo porta a complicazioni nel momento in cui molti utenti accedono contemporaneamente al DBMS, il quale attua il CONTROLLO DI CONCORRENZA.\n\n- Garantisce (o dovrebbe garantire)\n\t- Privacy: il DBMS fa accedere ai dati (o a loro porzioni) solo gli utenti autorizzati. Gli admin possono accedere a tutti i dati in r/w. Ci sono definizioni molto dettagliate di cosa l'utente può o non può fare, tipicamente specificate al momento della richiesta;\n\t- Affidabilità: il DBMS fornisce risultati corretti;\n\t- Efficienza: i risultati vengono restituiti in un tempo ragionevole.\n\nEsempi di DMBS sono:\n\n- DB2, di IBM, per grandissime quantità di dati e grandi organizzazioni;\n- Oracle, il più diffuso poiché flessibile rispetto al piano tariffario;\n- SQLServer, di Microsoft, simile a Oracle ma \"un po' peggio\";\n- MySQL, MicrosoftAccess, DBMS \"giocattolo\";\n- PostgreSQL, non basato sulla logica relazionale.","x":9924,"y":-5000,"width":680,"height":740},
		{"id":"9988826790f856a8","type":"text","text":"# Come è fatto un RDBMS?\n\nIl DBMS si struttura tipicamente a più livelli.\n\n- **_Livello dei Dati (Schema Interno):_** livello a cui opera il DBMS in senso stretto. Include\n\t- gestione dello spazio su HDD e RAM. All'avvio il DBMS occupa una certa porzione di memoria (stabilita come stima massimale da chi lo ha progettato) che diventa inaccessibile per qualsiasi altra applicazione;\n\t- Gestione dei buffer, ovvero spostamento dei dati tra RAM e HDD;\n\t- Accesso ai dati fisici;\n\t- Operatori relazionali e di ottimizzazione ed esecuzione delle interrogazioni, *layer* che rendono le richieste quanto più veloci possibile;\n- **_Livello della Logica dell'Applicazione (Schema Logico):_** livello a cui operano le applicazioni utilizzate dagli utenti. Scambia dati con il DB e riceve input dall'interfaccia utente. Questi appunti sono riferiti allo Schema Logico del DBMS;\n- **_Livello della Presentazione (Schema Esterno):_** Spesso una certa categoria di utenti può accedere solo a uno schema esterno del DB, ovvero una rappresentazione del DB indipendente dal DB, senza sapere che esistono altri schemi e dati. Questo garantisce anche un layer di sicurezza. Si dice **_vista_** degli utenti, e se ne possono implementare molteplici, a seconda degli utenti a cui è destinata (e.g. se sono uno studente non vedrò gli stessi dati che vede un professore, ma il DB a cui facciamo riferimento è lo stesso). Spesso la vista è generata con delle query (e.g. *join*) che partono quando viene fatta richiesta dall'utente. Le tabelle visualizzate in questo livello possono quindi non rispettare la Terza Forma Normale, ma va tutto bene perché sono figlie di manipolazioni esterne al DB.\n\n\n","x":7566,"y":-4950,"width":720,"height":780,"color":"3"},
		{"id":"088b9e9e5ed435f3","type":"text","text":"# Organizzazione Logica","x":8142,"y":-3694,"width":445,"height":213,"color":"6"},
		{"id":"4010dbf8b74b33c3","type":"text","text":"# Perché serve un DBMS?\n\nIn assenza di un DBMS, dovrei costruire un DB a partire da un *filesystem* come *Excel*, o addirittura un semplice *file.txt*.\n\nChiaramente non ho garanzia di evitare **_duplicati_** o **_inconsistenze_**. Più ci si affida all'intervento umano e a diversi DB contenenti informazioni simili che non si parlano, più aumenta il rischio di duplicazione e inconsistenze, da cui rischio di estrarre dati e informazioni false.\n\nIn un DBMS, il tipo di dato può essere molto semplice (alfanumerico) o molto pesante (video). Il DB può essere grande sia in senso di numero di dati sia in senso di quanto occupa il singolo dato. Ma dove li metto tutti questi dati? La memoria centrale non basta, serve memoria secondaria. Il DBMS deve quindi trovare il dato sulla memoria secondaria e caricarlo in centrale. Uno dei problemi degli ultimi 30 anni è come velocizzare questo processo. Nessuno vuole aspettare 3 minuti per comprare un biglietto!","x":8418,"y":-4860,"width":686,"height":600,"color":"3"},
		{"id":"72db887a0fb2db34","type":"text","text":"in una tupla t con X attributi, se scelgo $Y \\subset X$ e chiedo y\\[Y\\] questa è detta RESTRIZIONE della tupla","x":8985,"y":-3999,"width":250,"height":455},
		{"id":"83365c31bb5de31f","type":"text","text":"# Appunti\n\nle cose che posso calcolare non le salvo\n\nsi costruiscono degli indici, a loro volta delle tabelle, costruito sulle chiavi. più grosso è più faccio fatica, perché devo accedere alla memoria. \n\nle chiavi alternative si scoprono con le dipendenze funzionali. sono quelle la cui chiusura include tutti gli elementi dello schema.\n\ntransazione: insieme di operazioni che nel complesso risulta atomica sul DB (se ci riesco commit, altrimenti se vengo interrotto roll back). Lo storico delle modifiche si chiama LOG, ogni tot viene fatta una copia di backup del DB detto DUMP.\n\ncontrollo di concorrenza: non voglio rompere lo pseudoparallelismo, non metto in batch.\n\n\nDB attivi: a ogni operazione controlla tutti i vincoli complessi\n\n","x":8261,"y":-3208,"width":653,"height":471},
		{"id":"e0ca754560103232","type":"text","text":"# Come si interagisce con un RDBMS?\n\nIl *linguaggio di interrogazione* *ad-hoc* per i DBMS relazionali è **_SQL (Structured Query Language)._** Si può accedere anche con i linguaggi canonici (C, Java, ...) se al loro interno includono i comandi di SQL. Questo si distingue in due linguaggi formali:\n\n- **_DDL (Data Definition Language):_** Definisce gli schemi del DBMS. Serve nella fase di progettazione.\n- **_DML (Data Manipulation Language):_** Gestisce le richieste sui dati (**_query_**);\n\n\nIl potere espressivo (ovvero ciò che posso calcolare con un linguaggio) è dato dalla classe di query calcolabili, ed è diverso da quello di un normale linguaggio Touring-completo. I motivi per la scrittura ad hoc di un linguaggio di interrogazione rispetto a uno classico sono \n- Maggiore semplicità di utilizzo per il compito specifico;\n- Costante ottimizzazione per le interrogazioni.\n\nTra un'operazione ottimizzata e una non ottimizzata ci possono essere differenze di svariati ordini di grandezza. Poi moltiplica per il numero di operazioni e il disastro è compiuto. Dentro SQL ci sono due linguaggi equivalenti:\n\n - Algebra relazionale: linguaggio procedurale (fornisce la procedura per ottenere il risultato);\n- Calcolo relazionale (che non si studia, ma alcune cose di SQL si basano su di esso): linguaggio dichiarativo, descrivo in modo formale le caratteristiche del risultato che voglio senza darne la procedura.\n\nCi focalizziamo sull'algebra. Costituita da\n\n- Operandi: tabelle relazionali;\n- Operatori: unari o binari su operandi.\n\nE' chiusa rispetto al risultato e gode di tutte le proprietà delle algebre (associativa, commutativa, ...). Seguono gli operatori ad hoc per operare sulle tabelle:\n\n- Insiemistici\n\t- Unione\n\t- Intersezione\n\t- Differenza (presenti nella prima ma non nella seconda), non simmetrica e quindi non commutativa.\n\t\n- Ridenominazione, puramente sintattico, forma P(R(F), E) dove (($\\rho_{\\text{new}\\leftarrow\\text{old}}$))\n\t- P è l'operatore Ridenominazione;\n\t- R è il risultato;\n\t- F è la LISTA DI RIDENOMINAZIONE nella forma (vecchio nome -> nuovo nome; posizione -> nuovo nome; ...);\n\t- E è l'istanza di input.\n\n- Prodotto cartesiano, che invero è insiemistico vabb. Permette di creare nuove tuple modificando quelle esistenti. Se faccio RxS ottengo tutte le possibili combinazioni delle tuple di R con tutte quelle di S. Quindi se R ha campi ABC e S DE RxS ha ABCDE. Molto importante ottimizzare questa operazione perché il risultato esplode. Raramente, infatti, lo si usa. Si usa il JOIN. Se unisco tabelle aventi campi con lo stesso nome, nel risultato NON avranno nome, le devo rinominare con la posizione.\n\t\n- Selezione, la condizione è booleana. Taglia le righe.\n\n- Proiezioni, taglia le colonne, nuova tabella contiene colonne specificate nella condizione. Le tuple sono <= (= se prendo la chiave, se \tnon la prendo non è detto che sia strettamente minore). Bisogna stare attenti alle chiavi. Non c'è l'oggetto tupla, ma solo i valori\n\t\tche contiene. In genere è l'ultimo operatore applicato, seppure l'algebra sia commutativa. Questo perché prima costruisco il risultato senza rischiare di tagliare fuori le chiavi (e quindi far collassare tuple diverse nella stessa tupla, e quindi perdere informazione);\n\nPoi operatori derivati, ma un paio sono così utilizzati che vale la pena menzionarli\n\n- Join (o theta-join): perno delle query, prodotto cartesiano + selezione. Costruisce solo le tuple utili del prodotto cartesiano. Il DBMS implementa i Join, non il cartesiano. I più interessanti sono con condizione di uguaglianza (EQUI-JOIN) con campi di cui uno\n\t\tdei due è chiave, l'altro è foreign key. Perché?\n\t\n- Join Naturale, ovvero equi-join in cui specifico una condizione per ogni attributo comune alle due tabelle. IN SQL NON ESISTE!!;\n\n- Divisione, introdotta per cose del tipo \"dimmi gli studenti che hanno fatto tutti gli esami\". Sia A una relazione con due campi, x e y. Sia B una relazione con il solo campo y. A/B contiene i valori x in A associati a tutti gli elementi y che compaiono in B. Concettualmente, si opera trovando tutti i valori x che NON vanno bene e si sottraggono.\n\nLa compatibilità delle interrogazioni è puramente sintattica (e non semantica). Sta a chi scrive assicurarsi che abbiano senso concettuale. Per convenzione, se unisco due tabelle i nomi delle colonne sono quelli della prima tabella. E qui entra in gioco Ridenominazione.\n\nIn algebra relazionale (e quindi in SQL) non ho modo di confrontare tuple diverse. Se devo fare un confronto, mi servono i valori da confrontare scritti nella stessa tupla. Non ci sono variabili, blocchi condizionali o cicli.\n\n- Se ad esempio devo trovare un minimo di una colonna, piuttosto che confrontarli elimino a coppie quelli più grandi.\n\nIn generale succede sempre così quando mi servirebbe un ciclo. In algebra relazionale non si possono ricostruire catene di riferimenti o alberi genealogici. Se facendo operazioni incontro un valore NULL, il sistema non lo includerà nel risultato se non diversamente specificato.\n\n","x":11951,"y":-2606,"width":1200,"height":1658,"color":"5"},
		{"id":"256ee83c51638bab","type":"text","text":"se dichiaro una roba primary key il sistema mi impedisce di inserire duplicati, altrimenti si fa con unique.\n\ntabelle master sono le entità, slave le relationship (e.g. studente e corso sono master, esame è slave)","x":11560,"y":-4685,"width":391,"height":330},
		{"id":"3aec0d0f14f7cf5c","type":"text","text":"# Zona Sicurezza\n\n\n\nin una bdd è possibile centralizzare i dati e poi dividere in moduli a seconda dei privilegi di accesso e/o simili --> evito ridondanze e anomalie (e.g. se faccio database di tutte info docenti, gli studenti possono accedere solo ad alcune info, senza fare due bdd diverse)\n\ncontrollo della consistenza via controllo della concorrenza --> sincronizzazione\n\n\n\n#### rischio inconsistenze\n\nridondanza era bestia nera delle bdd, rischi inconsistenze (altra cosa è il mirroring, che ogni tot fa un backup dei dati e ci sono master e slave)\n\n- ridondanza (si risolve con buona progettazione)\n- concorrenza (si risolve con meccanismi di sincronizzazione, che però stanno al DBMS esattamente come stanno al Kernel nel SO)\n\n","x":11675,"y":-3885,"width":811,"height":726},
		{"id":"2d896a06311319c3","type":"text","text":"# Operatori Unari\n\nIntuitivamente, gli operatori unari lavorano su una sola istanza creandone una nuova.\n\n- ***Proiezione sulle colonne*** ($\\pi$) - si mangia un'istanza e ne sputa fuori una nuova avente come colonne (attributi) solo quelle selezionate;\n\t- **Se non includo una chiave potrei perdere informazioni**. Se a due `matricole` diverse corrispondono due persone con lo stesso `nome`, $\\pi_{nome}(studente)$ restituirà una sola tupla, perché $\\pi$ crea una nuova relazione (quindi un insieme in cui gli elementi non possono ripetersi);\n\t- In virtù di quanto detto, $\\pi$ è un operatore che restituisce una relazione avente **cardinalità minore o uguale della relazione di partenza**, ma sempre $> 0$;\n- ***Selezione sulle righe*** ($\\sigma$) - si mangia un'istanza e ne sputa fuori una nuova avente come righe solo quelle che rispettano la condizione di selezione;\n\t- $\\sigma_{città = Roma}(studente)$ restituisce solo i dati degli studenti nati a Roma;\n\t- La condizione è un'espressione booleana tra\n\t\t- un attributo e una costante (e.g. stringhe costanti tra singoli apici);\n\t\t- un attributo e un altro attributo della stessa relazione con lo stesso dominio.\n\t- Anche $\\sigma$ è un operatore che restituisce una relazione avente **cardinalità minore o uguale della relazione di partenza**, anche $= 0$ se la selezione non produce risultati;\n\t- In questo caso non ho il problema dei duplicati, perché non posso eliminare le chiavi;\n- ***Ridenominazione*** ($\\rho$) - Si mangia un'istanza e ne sputa fuori una nuova identica alla precedente, ma con i nomi cambiati;\n\t- $\\rho_{codice \\leftarrow matricola}(studente)$ cambia l'etichetta dell'attributo `matricola` di `studente` in `codice`;\n\t- E a che mi serve? È solo una cosa *fancy*? No, l'algebra relazionale non prevede una selezione banale sulle colonne. La query `restituisci lo studente con la media più alta` richiede di creare di un'istanza di appoggio `studente_temp` (in ogni istante, ***per ogni schema di relazione $R$ esiste sempre una ed una sola istanza di relazione*** $r$, quindi devo creare $R'$ ed $r'$ ) e confrontare a coppie tutti i campi `media` e `media_temp`. ","x":4438,"y":957,"width":1000,"height":774,"color":"4"},
		{"id":"a2b5fda883cdac87","type":"text","text":"# Operatori Binari\n\nGli operatori binari agiscono tra istanze di schemi diversi.\n\n- ***Unione*** ($r_1 \\cup r_2$) - costruisce una tabella con le tuple che sono almeno in una delle due tabelle di partenza. Queste devono necessariamente essere ***union-compatibili***, ovvero\n\t- devono avere lo stesso numero di attributi e, in ordine, gli stessi domini sugli attributi. Se così non fosse, non avrebbe senso a livello matematico;\n\t- perché abbia senso logico, gli attributi devono significare le stesse cose;\n- ***Differenza*** ($r_1 - r_2$) - costruisce una tabella con le tuple di $r_1$ che non sono in $r_2$;\n\t- Condizione necessaria è che $r_1$ ed $r_2$ siano ***union compatibili***;\n- ***Intersezione*** ($r_1 \\cap r_2$) - costruisce una tabella con le tuple comuni ad $r_1$ ed $r_2$;\n\t- Condizione necessaria è che $r_1$ ed $r_2$ siano ***union compatibili***;\n- ***Prodotto Cartesiano*** ($r_1 \\times r_2$) - costruisce una tabella combinando ogni tupla di $r_1$ con ogni tupla di $r_2$;\n\t- Non serve union-compatibilità, ma il numero di tuple della tabella risultante esplode rapidamente;\n\t- A volte ha senso farlo di un'istanza con se stessa. Problema tipico da risolvere in questo modo è ***trovare il massimo valore su una colonna***. Non esistono operazioni in grado di farlo direttamente, posso confrontare valori solo su una singola tupla. Facendo il cartesiano ottengo due attributi da confrontare sulla stessa riga.\n\t\t- Chiaramente da solo non ha senso, di norma gli si abbina una selezione e magari una proiezione per eliminare le colonne in eccesso. Questa cosa si chiama ***Join Naturale***;\n- ***Join Naturale*** ($r_1 \\bowtie r_2$) - si mangia due istanze che abbiano almeno un attributo con lo stesso nome. Ipotizziamo sia il primo attributo per entrambe, quindi $A_1^1$ per la prima e $A_{2}^1$ per la seconda. Il Join Naturale fa il Prodotto Cartesiano e restituisce una nuova istanza con tutte le tuple tali che $A_{1}^1 = A_{2}^1$, senza creare una colonna duplicata per gli attributi $A$.\n\t- L'azione del Join Naturale si può scrivere come $r_1 \\bowtie r_2 = \\pi_{XY}(\\sigma_C(r_1\\times r_2))$, dove $C$ è la condizione sugli attributi uguali, $X$ sono le colonne di $r_1$ e $Y$ sono le colonne di $r_2$ che non sono incluse in $r_1$\n\t- Vale in generale, qualsiasi sia la posizione dell'attributo ($A_{1i} = A_{2j}$), e possono esserci più condizioni in parallelo;\n\t- Come casi limite abbiamo che\n\t\t- se $r_1$ ed $r_2$ hanno un insieme di attributi in comune ma nessun valore in comune per tali attributi, allora il risultato sarà un insieme vuoto;\n\t\t- se $r_1$ ed $r_2$ non hanno un insieme di attributi in comune, allora il Join Naturale degenererà in un Prodotto Cartesiano;\n- ***Theta-Join*** ( $r_1\\underset{A\\theta B}{\\bowtie}r_2$) - Generalizzazione del Join Naturale. Impone una generica condizione di confronto su attributi che non hanno lo stesso nome. In $A\\theta B$, $A$ e $B$ sono attributi presi rispettivamente dalla prima e dalla seconda istanza e $\\theta$ è un operatore di confronto (e.g. $=$, $\\leq$, ...). Ovviamente A e B devono avere lo stesso dominio.\n\t- L'azione del Theta Join si può scrivere come $r_1\\underset{A\\theta B}{\\bowtie}r_2 = \\sigma_{A\\theta B}(r_1\\times r_2)$\n\t- È l'unico Join che esiste sicuramente in SQL. Se il DBMS per qualche motivo non lo implementa, è equivalente al Prodotto Cartesiano + `WHERE` (Proiezione);\n\n","x":4438,"y":2400,"width":1000,"height":998,"color":"4"},
		{"id":"60a871f97787e783","type":"text","text":"altre cose che ho scritto sotto il theta join\n\n - si usa un tot de morgan...\n- nor non è nella formulazione originale, meglio or + not\n- In alcuni casi può essere necessario effettuare il join tra una relazione e se stessa (self join), in modo da ottenere combinazioni di tuple della stessa relazione.\n\ngli operatori sono le istanze. \nnon ha primitive di definizione e inizializzazione perché è un linguaggio astratto e non concreto (...)\n\nsql esistono i comandi perché è la sua implementazione\n","x":4438,"y":3460,"width":1000,"height":395},
		{"id":"3f5bed2a25101916","type":"text","text":"# SQL\n\nSQL è un linguaggio dichiarativo in cui le tabelle manovrate sono ***multinsiemi***, poiché possono esistere tuple duplicate. E cosa cambia?\n\nAlcuni operatori possono (non) mantenere i duplicati, e in generale il comportamento di alcuni di essi cambia un po' rispetto all'algebra.\n\nQua vedremo solo la parte di SQL per fare le ***query*** (DML).","x":5876,"y":1925,"width":624,"height":255,"color":"6"},
		{"id":"374dc424f5326223","type":"text","text":"# Operatori Binari in SQL\n\n- ***Unione*** - Clausola `UNION`;\n- ***Differenza*** - Clausola `EXCEPT`;\n- ***Intersezione*** - Clausola `INTERSECT`.\n\nGli operatori insiemistici eliminano automaticamente i duplicati. Se non voglio che succeda, devo aggiungere la clausola `ALL` (e.g. `R1 UNION ALL R2`).\n\n- ***Prodotto Cartesiano*** - Clausola `CROSS JOIN`;\n- ***Join Naturale*** - Clausola `NATURAL JOIN`;\n\t- `JOIN USING` - Se il join naturale viene eseguito sulle colonne con lo stesso nome, con questa formula posso specificare io quali attributi confrontare. Ad esempio, mi interessa sapere quali `dipendenti` e `manager` guadagnano la stessa cifra, e non mi interessa se hanno lo stesso nome. Allora limito il join naturale all'attributo che mi interessa: `dipendenti JOIN manager USING stipendio`;\n- ***Theta-Join*** - Clausola `JOIN ON`;\n\t- `dipendenti JOIN manager ON dipendenti.stipendio > manager.stipendio.","x":5876,"y":2606,"width":624,"height":586,"color":"4"},
		{"id":"6915a75b535e3062","type":"file","file":"Screenshot from 2024-07-08 15-49-23.png","x":6720,"y":1240,"width":718,"height":209},
		{"id":"98966c16e4c394c5","type":"text","text":"# Query SQL II - `SELECT` Annidate ed `EXISTS`\n\nAlla voci `Tabella` e `Condizione` posso in realtà eseguire qualsiasi operazione che mi restituisce una tabella o una condizione (e.g. `dipendente JOIN manager ON dipendente.stipendio > manager.stipendio`). Questo può portare anche all'uso di una o più `SELECT` ***annidate***.\n\n```\nSELECT C.Nome\nFROM Clienti C\nWHERE EXISTS (\n\tSELECT *\n\tFROM Ordini O JOIN Agenti A ON O.CodiceAgente = A.CodiceAgente\n\tWHERE O.CodiceCliente = C.CodiceCliente AND A.CodiceAgente = ’A01’);\n```\n\nIn questo caso la `SELECT` interna\n\n- Come `Tabella` fa un `JOIN` tra l'entità `Ordini` e l'entità `Agenti` sull'attributo `CodiceAgente`. Questo restituisce un'istanza in cui tutti gli `Ordini` sono associati all'`Agente` che li ha effettuati.\n\t- Notare l'uso degli ***alias***, ovvero `C` per `Clienti`, `O` per `Ordini` e `A` per `Agenti`;\n\t- È equivalente a scrivere `Ordini O JOIN Agenti A USING CodiceAgente`;\n- La clausola `WHERE` impone che debba coincidere anche il `CodiceCliente` con la tabella `Clienti C`, e che l'`Agente` che ha fatto da tramite debba essere proprio `A01`;\n- In pratica, restituisce tutti gli `Ordini` effettuati dall'`Agente` `A01`.\n\nA questo punto la clausola `EXISTS` restituisce `TRUE` se la `SELECT` interna ha prodotto una tabella con almeno una tupla, quindi ***iterativamente*** (i.e. iterando sulle tuple di `Clienti` della `SELECT` esterna) si costruisce il risultato della query: nel complesso mi vengono restituiti i nomi (`SELECT C.Nome`) di tutti i `Clienti C` che hanno fatto acquisti con l'`Agente` `A01` (`SELECT` interna).","x":7640,"y":1688,"width":800,"height":731,"color":"4"},
		{"id":"cac7e795d09f2772","type":"text","text":"# Ma era proprio necessario?\n\nNon c'è un modo univoco di fare le query, e in generale annidare le `SELECT` e/o usare `EXISTS` è un metodo un po' contorto. Spesso si può formulare in modo equivalente.\n\n```\nSELECT DISTINCT C.Nome\nFROM Clienti C\n\tJOIN Ordini O ON O.CodiceCliente = C.CodiceCliente\n\tJOIN Agenti A ON O.CodiceAgente = A.CodiceAgente\nWHERE A.CodiceAgente = ’A01’);\n```\n\nQuesto codice fa la stessa cosa di quello sotto, ma in modo diverso.\n\n- Prima crea la `Tabella`. In ordine, il DBMS esegue prima il `JOIN` tra `Clienti` e `Ordini` su `CodiceCliente`, poi tra il risultato e `Agenti` su `CodiceAgente`. Il risultato è una istanza le cui tuple rappresentano gli ordini di tutti i clienti tramite i rispettivi agenti;\n- A questo punto si esegue `SELECT DISTINCT` con clausola `WHERE`.","x":7640,"y":1111,"width":800,"height":468,"color":"4"},
		{"id":"48a105008e92c4ab","type":"text","text":"# Esempi\n\n```\nSELECT *\nFROM dipendenti\n```\nRestituisce tutta la tabella `dipendenti`. Query base, non posso scrivere meno di così.\n\n```\nSELECT *\nFROM dipendenti\nWHERE stipendio > 1000;\n```\nRestituisce i `dipendenti` che guadagnano più di `1000`.\n\n```\nSELECT DISTINCT Nome, Città\nFROM dipendenti;\n```\nRestituisce tutte le coppie non ripetute `nome, città` da `dipendenti`.\n\n```\nSELECT Clienti.CodiceCliente AS Cliente, Ordini.Ammontare AS Ammontare\nFROM Clienti JOIN Ordini ON Clienti.CodiceCliente = Ordini.CodiceCliente;\n```\nPrima viene costruita la tabella $Clienti\\underset{Clienti.CodiceCliente=Ordini.CodiceCliente}{\\bowtie}Ordini$, poi su di essa fa una proiezione sugli attributi `Clienti.CodiceCliente, Ordini.Ammontare` rinominandoli rispettivamente `Cliente` e `Ammontare`.\n ","x":6720,"y":2560,"width":720,"height":679,"color":"4"},
		{"id":"c504d5d4466412b3","type":"text","text":"# Query SQL II-bis - `ALL`, `ANY` e `SELECT` Annidate\n\nLa `SELECT` annidata permette di fare dei controlli su tutte le tuple di una relazione.\n\n- `ALL` - L'espressione `Attributo > ALL(SELECT AttributoDiConfronto FROM [...])` verifica che `Attributo` sia ***maggiore di tutti i valori*** assunti da `AttributoDiConfronto` nelle tuple dell'istanza restituita dalla `SELECT`;\n- `ANY` -  L'espressione `Attributo > ANY(SELECT AttributoDiConfronto FROM [...])` verifica che `Attributo` sia ***maggiore di almeno un valore*** assunto da `AttributoDiConfronto` nelle tuple dell'istanza restituita dalla `SELECT`.\n\nCome per la direttiva `EXISTS`, anche qui ottengo `TRUE` o `FALSE`. Posso ovviamente usare un qualsiasi operatore di confronto $\\theta$.\n","x":7640,"y":2560,"width":800,"height":463,"color":"4"},
		{"id":"372c828acb9cb8b4","type":"text","text":"# Query SQL III - Quantificatori Universali\n\nSe il quantificatore esistenziale è esplicitamente dato dalla direttiva `EXISTS`, ***non esiste in SQL il quantificatore universale***. E quindi che si fa? ***Si usa la doppia negazione!***\n\n```\nClienti che hanno fatto ordini da tutti gli agenti di Pisa\n```\n \n è identico a dire\n\n```\nClienti tali che non esiste un agente di Pisa che non ha fatto almeno un ordine per quel Cliente\n```\n\nOvvero\n\n```\nSELECT C.CodiceCliente\nFROM   Clienti C\nWHERE  NOT EXISTS (\n\t   SELECT *\n\t   FROM Agenti A\n\t   WHERE A.Zona = ‘Pisa’ AND NOT EXISTS (\n\t\t SELECT ∗\n\t\t FROM Ordini O\n\t\t WHERE A.CodiceAgente = O.CodiceAgente AND O.CodiceCliente = C.CodiceCliente))\n\t\t \n\tAND EXISTS (\n\t   SELECT ∗\n\t   FROM Agenti A\n\t   WHERE A.Zona = ‘Pisa’);\n```","x":8580,"y":1688,"width":920,"height":731,"color":"4"},
		{"id":"b34754e616d06a6b","type":"text","text":"# Analisi della Query\n\nPossiamo vedere i `SELECT` annidati come cicli annidati. Il più esterno sta iterando sui `Clienti`, quello intermedio sugli `Agenti` e quello interno sugli `Ordini`. Partiamo da quest'ultimo, che restituisce un'istanza contenente tutti gli `Ordini` effettuati dal `Cliente` corrente tramite l'`Agente` corrente.\n\nInutile dire che se già questa istanza è vuota è inutile andare avanti. Infatti, il `NOT EXISTS` di questa istanza produrrà un `TRUE`, che porterà il `SELECT` intermedio sugli `Agenti` ad essere non-vuoto, e quindi a cascata a far restituire al primo `NOT EXISTS` il valore `FALSE`, ovvero scartare quel cliente.\n\nNota che tutto questo ***funziona solo se esistono `Agenti` a `Pisa`***, perché **se così non fosse** non verrebbe soddisfatto l'altro pezzo del `WHERE` (`A.Zona = Pisa`), e **la query produrrebbe sempre in risposta i nomi di tutti i `Clienti` del DB**. ***Per questo motivo aggiungo l'`AND EXISTS` finale***.\n\nSe invece esiste una corrispondenza di almeno un ordine che coinvolge quel `Cliente` e quell'`Agente`, il `NOT EXISTS` più interno produce un `FALSE`, che in ogni caso fa produrre all'`AND` un `FALSE`. E vado avanti ad iterare sugli `Agenti`. Se alla fine dell'iterazione non ho prodotto alcuna tupla, il `NOT EXISTS` esterno restituirà un `TRUE`, aggiungendo quel `Cliente` al risultato della query.","x":8580,"y":2560,"width":920,"height":463,"color":"4"},
		{"id":"6d1aeb8c9e754fe7","type":"text","text":"# Query SQL I - `SELECT`\n\nLa base delle query SQL è la clausola `SELECT`.\n\n```\nSELECT Attributi\nFROM Tabella\nWHERE Condizione;\n```\n\nNel complesso, `SELECT` seleziona gli attributi delle righe della `Tabella` (specificata dalla clausola `FROM`) che soddisfano una certa `Condizione` booleana (specificata dalla clausola `WHERE` usando operatori come `AND`, `NOT` e `OR`).\n\nConcettualmente, l'ordine è `FROM`, `WHERE`, `SELECT`.\n\n- Anzitutto si prende in considerazione la `Tabella`. `FROM` carica l'operando;\n- Poi si valuta iterativamente (i.e. tupla per tupla) la `Condizione`. `WHERE` fa le veci dell'operatore di selezione $\\sigma$;\n- Infine si selezionano gli `Attributi` (`SELECT` agisce come un operatore di proiezione $\\pi$). Posso usare due scritture speciali:\n\t- La clausola `DISTINCT` elimina i duplicati;\n\t- Il valore `*` indica tutti gli attributi dell'istanza in ingresso.\n\nDa come è definita `DISTINCT` (un controllo tra righe) capiamo che in realtà non c'è propriamente corrispondenza tra la `SELECT` e l'operatore $\\pi$, ma *famo finta de sì*.\n\n***Non sono necessarie parentesi in SQL, né è necessaria indentatura***. Potrei scrivere tutta la query su una sola riga, ma in pratica si preferisce mandare a capo per questioni di leggibilità.","x":6720,"y":1687,"width":720,"height":731,"color":"4"},
		{"id":"91a94733b3961240","type":"text","text":"# Query SQL IV - Ordinamento, Aggregazione, Raggruppamento\n\nAlla fine della query posso aggiungere la clausola `ORDER BY Attributo DESC`, che ***ordina le tuple*** in modo discendente secondo l'`Attributo` scelto. Se ometto `DESC`, l'ordine sarà ascendente.\n\nNella `SELECT` posso specificare semplici operazioni aritmetiche sugli `Attributi`, nello specifico\n\n- ` MAX(Ammontare)` - Restituisce il ***massimo*** della colonna `Ammontare`;\n- ` MIN(Ammontare)` - Restituisce il ***minimo*** della colonna `Ammontare`;\n- ` AVG(Ammontare)` - Restituisce la ***media*** della colonna `Ammontare`;\n- ` SUM(Ammontare)` - Restituisce la ***somma*** della colonna `Ammontare`;\n- ` COUNT(*)` - Restituisce il ***numero di tuple ottenute dalla query;***\n\t- ` COUNT (DISTINCT Ammontare)` Restituisce il ***numero di tuple con un diverso valore*** per `Ammontare`;\n\n Se specifico almeno uno di questi ***operatori di aggregazione*** il risultato sarà ***una singola tupla***. Posso scriverne diversi in una singola query (e.g. `SELECT MAX(Ammontare), MIN(Ammontare), AVG(Ammontare)`), ma ***non posso  usarli insieme a singoli Attributi*** (e.g. è scorretto scrivere `SELECT NumOrdine, MIN(Ammontare), MAX(Ammontare)`). Oltretutto non ha senso, ***perché il singolo `Attributo` può selezionare più di una tupla***.\n\nC'è un'unica ***eccezione***: gli ***operatori di raggruppamento*** (`GROUP BY [...] HAVING`), in cui il risultato può avere più tuple, ma su ognuna di esse posso eseguire un'aggregazione. *\"Vediamo per esempio un esempio.\"*\n\n```\nSELECT A.CodiceAgente, A.Nome, SUM(Ammontare), AVG(Ammontare)\nFROM Ordini O JOIN Agenti A ON A.CodiceAgente = O.CodiceAgente\nWHERE O.Data = ’01032019’\nGROUP BY O.CodiceAgente, A.Nome\nHAVING COUNT(∗) > 5;\n```\n\n","x":9660,"y":1688,"width":920,"height":731,"color":"4"},
		{"id":"963cdd000a934fc7","type":"text","text":"# Analisi della Query\n\nConcettualmente, i primi passaggi sono sempre le clausole `FROM` e `WHERE`. Quindi partiamo col dire che abbiamo una `Tabella` con tutti gli `Ordini` di tutti gli `Agenti` effettuati in `Data` $01/03/2019$.\n\nA questo punto `GROUP BY` sceglie degli `Attributi` su cui eseguire la ***funzione di aggregazione*** specificata in `HAVING`. Questo significa che per ogni diversa coppia (`CodiceAgente`, `Nome`) questa direttiva si crea una \"sotto-tabella\" di tuple in cui verifica la condizione espressa in `HAVING`.\n\nSe la condizione è soddisfatta, la `SELECT` provvederà ad includere nel risultato ***quantomeno*** gli `Attributi` scelti dalla clausola `GROUP BY`. Eventualmente può aggiungere a sua volta delle funzioni di aggregazione (ricordiamo sempre che concettualmente è come se ogni coppia (`CodiceAgente`, `Nome`) fosse una tabella a sé stante).\n\n***La `SELECT` deve contenere almeno gli `Attributi` di `GROUP BY`***. Per assurdo, se così non fosse mi perderei la chiave con cui ho distinto le tuple ed eseguito il raggruppamento.","x":9660,"y":2560,"width":920,"height":463,"color":"4"},
		{"id":"1281574a686cf54b","type":"text","text":"# Heap\n\nIl mucchio è proprio quello che si pensa: ogni inserimento è una nuova riga aggiunta in modo sequenziale, senza alcun ordinamento. Per trovare qualcosa devo scorrerlo tutto.\n\n- La ***ricerca richiede $\\langle b/2\\rangle$ accessi*** ($b$ numero di blocchi): in assenza di ordinamento devo scandagliare tutta la lista;\n- Se ammetto duplicati è il metodo più veloce per l'inserimento (in coda, solo due accessi).\n\t- Ma onestamente, quando mai posso ammettere duplicati?\n- Se voglio inserire non in coda, o cancellare e riutilizzare un blocco, questo oltre a costare un sacco mi pone un problema. Se non sono tutti della stessa lunghezza? Devo spostare tutto l'heap (e quindi tutti i puntatori).","x":-6672,"y":-3986,"width":807,"height":393,"color":"4"},
		{"id":"2a1fbd738374b30a","type":"text","text":"# Hashing\n\nUn algoritmo di hashing converte la chiave nell'indice di un contenitore in cui inserire il record associato, detto ***bucket***. In generale, a chiavi diverse corrispondono diversi bucket secondo la funzione di hashing, e ogni bucket contiene più record collegati tra loro come una lista ($\\simeq$ **heap**).\n\nUna buona funzione di hashing divide divide equamente $n$ blocchi in $B$ bucket (spesso viene realizzata con la funzione modulo, e.g. `h(key) = key % M`). Mediamente ognuno ne avrà $n/B$. Ogni operazione sul DB richiederà di valutare `h(key)` per individuare il bucket, dopodiché si ricade nel caso dell'heap (con il vantaggio di avere $(1/B)$-esimo dei record tra cui cercare).\n\nL'accesso ai bucket avviene tramite una ***bucket directory***, in cui viene salvato l'indirizzo del primo blocco del bucket corrispondente. La tabella di corrispondenze è indicizzata dal valore di hash della chiave.\n\nSe si mappano in uno stesso bucket più record di quanti ne possa contenere si verifica un ***overflow***, gestito tramite ***indirizzamento aperto*** (i.e. i record in eccesso vengono salvati nel primo slot disponibile);\n\nL'efficienza di un algoritmo di hashing si misura con il tempo impiegato a raggiungere\n- i record non-overflow (tipicamente un RBA ed $n$ SBA, a seconda della posizione);\n- i record overflow, il cui tempo è molto variabile.\n\nAumentare la grandezza del bucket diminuisce gli overflow ma aumenta gli SBA necessari mediamente a trovare un record, per cui è necessario un trade-off.","x":-6672,"y":-3458,"width":807,"height":635,"color":"4"},
		{"id":"20cb7adc69dea990","type":"file","file":"BadHashing20GoodHashing23.png","x":-7272,"y":-3025,"width":400,"height":332},
		{"id":"4bb40df35fc271b9","type":"file","file":"GoodHashing.png","x":-7272,"y":-3589,"width":400,"height":332},
		{"id":"479930361d7113c1","type":"text","text":"# Efficienza\n\nGli HDD sono lenti, essendo ogni accesso $O(ms)$ (per la cronaca, un SSD ci mette circa 50 volte di meno). Prima di poter leggere (o scrivere) un blocco di memoria bisogna attendere che\n\n- la testina si posizioni sulla ***traccia*** richiesta (radiale, ritardo di posizionamento o seek time);\n\t- Una volta posizionata, le testine accedono in parallelo all'intero ***cilindro***, cioè l'insieme di tutte le tracce (circonferenze di raggio esattamente $r$);\n- il disco ruoti per allinearla all'inizio del ***blocco*** (angolare, ritardo di rotazione);\n\t- Il concetto di blocco viene dal linguaggio dei DB, e significa un certo gruppo consecutivo di ***settori***;\n- i dati vengano letti/scritti (tempo di trasferimento), il che dipende dal ***Block Size*** (***BS***) e dal ***Transfer Rate*** (***TR***), proporzionale in qualche modo all'intensità del campo magnetico sul disco.\n\nIl tempo totale di accesso è detto ***Service Time***. Ma potrebbero esserci altre operazioni in queue, quindi il tempo complessivo sarà maggiore ed è detto ***Response Time***.\n\nQualcuno distingue ***Random Block Access*** (***RBA***) in cui c'è anche in seek time e ***Sequential Block Access*** (***SBA***), in cui non c'è (sto leggendo banalmente il blocco successivo, sono già posizionato giusto).\n\nQualsiasi operazione si voglia eseguire sui dati (***inserimento***, ***cancellazione*** o ***modifica***) necessita anzitutto che il dato venga trovato all'interno del DB. Quindi è importante ottimizzare la ***ricerca***, in quanto dichiaratamente è l'operazione più frequente che mai verrà svolta.\n\nLa ricerca (che quindi è ***la*** cosa da ottimizzare) avviene tramite un ***campo chiave*** o ***chiave di ricerca***. Seppure sia concettualmente simile al concetto di chiave del modello relazionale, ***sono cose diverse***. Qui la chiave serve ad identificare univocamente un record all'interno del ***file*** in cui è salvato, che ***non necessariamente coincide con l'istanza*** del modello relazionale a cui appartiene la tupla associata al record.","x":-6719,"y":-2287,"width":901,"height":675,"color":"4"},
		{"id":"6a076667fdf061aa","type":"text","text":"# Organizzazione dei File\n\nDevo cercare di limitare il numero di accessi.\n\nSe la chiave di ricerca ammette un ordinamento significativo (e.g. un intero, una stringa con relazione d'ordine lessico-grafica) posso implementare algoritmi ottimali.","x":-5633,"y":-3257,"width":465,"height":232,"color":"6"},
		{"id":"2e29205b54e81c20","type":"text","text":"# File Sequenziali\n\nRecord in ordine (de)crescente rispetto al valore della chiave. questo permette di implementare la ricerca binaria, portando il tempo di ricerca a $O(log_2(N))$.\n\nDispendioso aggiornare il DB, perché bisogna riordinare tutti i record in base alla chiave.","x":-4825,"y":-3257,"width":820,"height":232,"color":"4"},
		{"id":"b36c6f51ca3d1a8e","type":"text","text":"# Blocchi (o Partizioni)\n\nGruppi di record sono organizzati in ***blocchi*** (o ***partizioni***), che constano di ***uno o più settori fisici su HDD***.\n\nCome per i record con i campi, risulta utile inserire un incipit in cui vengono raccolti\n\n- Tutti gli ***offset*** per raggiungere i vari record;\n\t- Semplice se hanno lunghezza fissa, c'è un file con gli offset espliciti in caso contrario.\n- Tutti i ***bit di validità*** associati ai vari record, per ottimizzare la ricerca di uno spazio libero;\n\t- Questa sezione è preceduta da un campo che ne indica la grandezza (fissa), e termina con l'escape character `0`.","x":-4825,"y":-2740,"width":820,"height":337,"color":"4"},
		{"id":"a6f456ad07ee9d3f","type":"text","text":"# Record\n\nLe tuple (entità logiche) vengono salvate nei ***record*** (entità fisiche). Oltre ai campi del modello logico, un record fisico può contenere **informazioni su se stesso** (e.g. quanti campi contiene) o **puntatori altri record** (i.e. all'indirizzo del primo byte di un altro record).\n\nUn modello a puntatori è però sconsigliabile in quanto poco flessibile. Se voglio spostare un record senza aggiornare tutti i riferimenti ad esso diventa un grosso problema. Come \"puntatore\" si usa quindi un ***modello blocco-chiave***, ovvero una coppia $(b, k)$ in cui\n\n- $b$ è l’indirizzo del ***blocco*** che contiene il record;\n- $k$ è il valore di uno o più campi che fungono da ***chiave*** nel file a cui il record appartiene\n\nTipicamente, un record inizia con una sequenza di byte utili a specificare\n\n- il tipo del record (i.e. a quale schema di relazione appartiene);\n- la lunghezza del record, se ha campi a lunghezza variabile;\n- validità e/o cancellazione (i.e. se il record è allocato).\n\nPer accedere ad uno specifico campo è necessario specificare il suo ***offset*** rispetto al primo byte del record. Questo è particolarmente semplice se tutti i campi hanno la stessa lunghezza, ma se non è così posso attuare due strategie:\n\n- All'inizio di ogni campo riservo dei bit per dire quanto è lungo. Poco efficiente: per accedere al campo $n+1$ devo controllare le $n$ lunghezze precedenti;\n- All'inizio del record specifico gli offset per raggiungere i vari campi.","x":-4825,"y":-2287,"width":820,"height":675,"color":"4"},
		{"id":"3160396b5a7e9638","type":"text","text":"# Organizzazione Fisica\n\nNonostante la situa non sia propriamente questa, assumiamo di lavorare facendo sempre accessi a memoria secondaria di tipo HDD e che essi abbiano costo costante.","x":-5601,"y":-2040,"width":401,"height":181,"color":"6"},
		{"id":"020fe60541153c51","type":"text","text":"# Progettazione di un DB\n\nLa progettazione di un DB passa attraverso diversi step di raffinamenti successivi.\n\nLa ***progettazione fisica*** riguarda l'organizzazione dei dati a livello di ***memoria***.\n\nL'***analisi dei requisiti*** identifica i bisogni generali, cioè ***cosa*** devo fare con questo DB (***attività***) e ***chi*** deve eseguirle (***unità organizzative***). Stima inoltre un piano di fattibilità a livello di costi e tempi.\n\nL'analisi dei requisiti viene implementata in fase di ***progettazione concettuale***, in cui si definiscono entità, associazioni e dipendenze funzionali creando uno schema di riferimento comprensibile anche a chi non ha dato questo meraviglioso esame.\n\n","x":-5780,"y":-575,"width":760,"height":343,"color":"6"},
		{"id":"659ef6753251fa38","type":"text","text":"# Progettazione di un Modello Relazionale\n\nPer realizzare un modello relazionale a partire da un modello concettuale occorre valutare cose.\n\n- ***Decomporre gli attributi ai minimi termini*** - Se inizialmente `modello` mi sembrava un buon attributo ma poi scopro che `Classe C 220` e `Classe C 200` differiscono solo per la cilindrata, potrei inserire un attributo `cilindrata` in modo da separare `Classe C` da `200` e `220`. In questo modo, ad esempio, è più facile raggruppare tutte le `macchine` con la stessa carrozzeria o con lo stesso motore. O, più intuitivamente, divido `indirizzo` in `via`, `civico` e `città`;\n\t- ***Attributi multivalore*** - Se `Classe C 220` e `Classe C 200` sono proprio tuple diverse, posso invece avere situazioni in cui, ad esempio, un singolo `manager` ha più di un `numero di telefono`. In quel caso ho due opzioni:\n\t\t- Se il numero di alternative è limitato o se avere più valori è obbligatorio/usuale posso ***aggiungere degli attributi*** allo schema originale (e.g. `recapito1`, `recapito2`);\n\t\t- Altrimenti ***creo un nuovo schema*** `recapiti` con `ID_manager` che fa da foreign key.\n- ***Foreign Keys*** - Devo valutare i vincoli tra diversi schemi di relazione. Posso avere\n\t- ***Uno-a-uno*** - Corrispondenza biunivoca tra le tuple di due distinte relazioni (e.g. ogni `persona` ha uno ed un solo `passaporto`). Possiamo aggiungere l'attributo che fa da foreign key sia in `persona` (e.g. `ID_passaporto` che fa riferimento all'attributo `numero seriale` dell'entità `passaporto`) sia in `passaporto` (e.g. `ID_persona` che fa riferimento a `codice fiscale` della relazione `persona`);\n\t- ***Uno-a-molti*** - Se uno implica molti, l'attributo per la foreign key va aggiunto nella relazione \"molti\". Ad esempio, se un `cliente` può fare diversi `ordini` (quindi ad un `cliente` corrispondono diversi `ordini`, e ad un `ordine` corrisponde un solo `cliente`) bisogna inserire la chiave nella relazione `ordini` (e.g. `ID_cliente`). Poi il DBMS andrà a controllare se compare nella relazione `cliente`;\n\t- ***Molti-a-molti*** - Ad ogni `studente` possono corrispondere diversi `corsi`, e ad ogni `corso` possono corrispondere più `studenti`. *Nonetheless*, uno `studente` esiste indipendentemente dai `corsi`, e un `corso` esiste indipendentemente da `studente`.\n\t\t- Le mappature molti-a-molti sono le ***relationship***. Devo quindi creare una relazione `esame` contenente una foreign key per il campo `studente` (e.g. `matricola`) ed una per il campo `corso` (e.g. `codice corso`), che faranno riferimento alle rispettive entità.\n- ***Gerarchia*** - Devo stabilire come gestire le informazioni di tipo gerarchico. Ho più opzioni.\n\t- ***Relazione unica*** - Faccio collassare la gerarchia in una singola relazione, \"***me ne frego***\" (è la scelta preferita di chi indossa una camicia nera). Ad esempio, pur essendo cosciente che un `manager` è gerarchicamente più importante di un `impiegato` valuto che tutto sommato anche il `manager` in un certo senso è un `impiegato`;\n\t- ***Partizionamento verticale*** - Mi è utile dividere le ***informazioni gerarchiche***, in particolare voglio che sia chiaro ad esempio che un `impiegato` deve avere uno e un solo `manager` come capo. Torniamo ai vincoli di foreign key, quindi creiamo una tabella `manager` e una tabella `impiegato` avente tra i campi un `ID_manager`;\n\t- ***Partizionamento orizzontale*** - Salvo le informazioni generali di tutto il `personale` in una sola tabella, poi creo delle tabelle parallele aventi il ruolo di ***sottoclassi***.\n\t\t- `impiegato` ha una foreign key `ID_personale` (l'`impiegato` fa chiaramente parte del `personale`) e specifica ad esempio il `settore` in cui lavora;\n\t\t- `manager` ha anch'esso una foreign key `ID_personale`, ma attributi d'interesse per un dirigente (e.g. il `gruppo` di lavoro di cui è a capo).","x":-5810,"y":111,"width":820,"height":1211,"color":"4"},
		{"id":"51bb3436d69bb68f","type":"text","text":"# B-Tree\n\nGeneralizzazione degli indici sparsi, implementa un modello gerarchico.\n\n- In cima alla gerarchia c'è un unico blocco, che possiamo assumere essere in RAM;\n- Ogni step dentro l'albero è praticamente un ISAM che punta ad un altro ISAM. In altre parole, ad ogni livello si possono trovare due tipi di corrispondenze:\n\t- un file principale, il che significa che sono arrivato. Passo alla ricerca sequenziale dentro di esso;\n\t- un file indice, il che significa che seguirò un puntatore che mi porterà ad un altro blocco, che potrà essere a sua volta un file indice o un file principale.\n- Se il file principale contiene $n$ record, ogni partizione ne contiene almeno $e$ ed ogni partizione del file indice ne contiene almeno $d$, è possibile stimare che il ***costo di ricerca*** è $O(log_d(n/e))$.\n\nSe nell'esempio a fianco voglio ***inserire*** un record con chiave `25` sono costretto a richiedere al sistema un nuovo blocco. Ma non basta, perché ***è necessario che ogni blocco sia pieno almeno per metà***, quindi devo riorganizzare l'intero albero. Questo può comportare un aumento della profondità dell'albero, aumentando i costi medi per tutte le operazioni successive.\n\nSe viceversa voglio ***cancellare*** un record e come conseguenza il suo blocco non è più pieno per metà devo riorganizzare nuovamente il B-Tree. In questo caso però la profondità può solo diminuire.\n\nNella ***modifica*** non ci sono commenti particolari se non che, come per ISAM, se coinvolge la chiave costa come **cancellazione + inserimento**.","x":-4825,"y":-5103,"width":820,"height":611,"color":"4"},
		{"id":"c61805cabef941a5","type":"text","text":"# Indice Denso\n\nCerco di unire il meglio dell'heap (non ci sono spazi vuoti) e degli altri metodi (implemento una ricerca efficiente). Il ***file indice*** contiene un ***puntatore ad ogni record del file principale*** (non ad una partizione!), nel quale invece non c'è nessun ordinamento. La ricerca sul file indice è molto più breve, poiché dipende dalla dimensione del record (che in quel caso è la coppia chiave-puntatore).\n\nIn questo modo evito anche i puntatori all'interno dei record (all'interno del blocco erano organizzarti tipo lista, così essendo tutti puntati dal file indice non ce n'è bisogno).\n\n","x":-4825,"y":-4247,"width":820,"height":261,"color":"4"},
		{"id":"21e4b7f7d6cf42e4","type":"text","text":"# Record Nidificati\n\nIl modello con le chiavi non rispecchia il concetto di entity-relationship. Se ho i dati di un `cliente` vorrei accedere facilmente agli `ordini` che ha effettuato. Per questo entra in gioco il concetto di ***pattern***: dopo ogni record di `cliente` salvo tutti gli `ordini` da lui effettuati (***repeating group***), oppure un puntatore al blocco che li contiene.\n\nEssendo record disomogenei salvati vicino, non è possibile usare hashing o indice sparso. È invece necessario usare un ***indice denso***.","x":-4825,"y":-3789,"width":820,"height":261,"color":"4"},
		{"id":"400558d331fb8f8c","type":"file","file":"B-Tree.png","x":-3785,"y":-5103,"width":578,"height":237},
		{"id":"df7363b7e9237fef","type":"file","file":"B-Tree_Reorganized_Inserimento25.png","x":-3785,"y":-4768,"width":577,"height":276},
		{"id":"06747e06930e5894","type":"text","text":"# Indici Secondari\n\nISAM assume di lavorare con il ***campo chiave***, ovvero con un ***indice primario***.\n\nPosso però implementare una ricerca su un ***campo non chiave***, ovvero su un ***indice secondario***.","x":-5840,"y":-5506,"width":880,"height":141,"color":"4"},
		{"id":"f2c93058a3441fae","type":"text","text":"# ISAM (Indexed Sequential Access Method)\n\nOrdino il ***file principale*** contenente $n$ record di una singola istanza di relazione secondo il valore della chiave fisica, quindi lo divido in $m$ ***partizioni*** (i.e. **blocchi**), ognuna corrispondente ad un blocco di memoria (ogni blocco contiene record omogenei). Ogni partizione contiene $n/m$ record ed un ulteriore spazio vuoto (e.g. un ulteriore $20\\%$, se $n/m = 100$ la partizione avrà $120$ slot) per aggiungerne di nuovi.\n\nTali partizioni sono identificate dalle righe di un ***file indice***, che constano di `indirizzo fisico` del primo record del blocco (quindi puntatore) e valore di `chave` più piccolo in esso contenuto. In questo modo è possibile individuare subito il blocco in cui trovare un certo record, data la chiave (e.g. se so che in ordine le chiavi più piccole sono `100` e `200`, il record con chiave `130` sarà nel primo blocco). Queste informazioni sono a loro volta ordinate secondo il valore della chiave. Si può quindi implementare\n\n- ***ricerca binaria***, con costo $O(log_2(n))$);\n- ***ricerca per interpolazione***, in cui assumo di conoscere la pdf dei valori delle chiavi e dato un certo valore inizio dalla locazione più probabile. Questa cosa ha costo $O(log_2(log_2(n)))$, ma non è banale stimare la pdf e può cambiare nel tempo.\n\nQuindi, riassumendo, l'indicizzazione avviene in due step: una prima fase di ricerca sul file indice ed una seconda all'interno della partizione. È un metodo ad ***indici sparsi***, cioè avente indici su più livelli.\n\nQuesto per quanto riguarda la ***ricerca***. Se faccio un ***inserimento*** di un record ho un ulteriore accesso (in scrittura). Ma la partizione in cui dovrei metterlo potrebbe essere piena. Che faccio in quel caso?\n\n- Provo ad inserire lui o l'ultimo record della partizione $n$ in quella $n+1$, scalando gli indici del file indice;\n- Analogo con la partizione $n-1$;\n- Se non trovo spazio richiedo al filesystem l'allocazione di un nuovo blocco $n'$ dividendo i record tra i due blocchi $n$ ed $n'$. Aggiorno il file indice per includere il nuovo blocco.\n\nSe faccio una ***cancellazione*** di un record ho un ulteriore accesso, e devo modificare i bit di validità.\n- Se rimuovo il record di indice minore devo modificare il file indice, il che richiede un ulteriore accesso.\n- Se rimuovo l'ultimo record di un blocco, restituisco la memoria al filesystem e rimuovo il riferimento dal file indice. Sono necessari ulteriori accessi.\n\nSe faccio una ***modifica*** che non coinvolge la chiave, devo fare un solo ulteriore accesso.\n- Se invece la modifica coinvolge la chiave devo contare i costi di **cancellazione + inserimento**.\n\nSe invece i blocchi non si identificano con la chiave ma con un puntatore dal blocco precedente, è evidente che non si possono fare riordinamenti o spostare record in un blocco successivo.","x":-5840,"y":-5286,"width":880,"height":978,"color":"4"},
		{"id":"d7282788ef30fb92","type":"text","text":"# Analisi dei Requisiti\n\n1. Si analizza il sistema informativo esistente raccogliendo una ***prima versione dei requisiti***, espressa ***in linguaggio naturale*** (Leggi: ***il cliente ti deve descrivere che vuole fare***);\n2. Si rivedono i requisiti espressi in linguaggio naturale, per eliminare ambiguità, imprecisioni e disuniformità linguistiche (Leggi: devi ***scremare quello che dice il cliente***);\n3. Si raggruppano le frasi relative a categorie diverse di dati, vincoli e operazioni (Leggi: ***devi dare un'organizzazione logica a quello che ha detto***);\n4. Si costruisce un ***glossario dei termini*** per evitare sinonimi e omonimi;\n\t- Leggi: devi iniziare a capire quali possono essere gli attributi, le entità e le associazioni;\n5. Si definisce uno schema preliminare di settore, detto ***schema scheletro***, con il quale si individuano ad un primo livello di dettaglio le classi e le associazioni fra le classi più significative.\n\t- Leggi: devi definire una ***bozza di entità, associazioni, attributi e di dipendenze funzionali***;\n\t- Questa è appunto solo una bozza. Potrebbe accadere che uno schema che avevi in mente è in realtà un'associazione ricavabile da altre entità, e viceversa.\n\t- Potrebbe essere utile aggiungere delle sottoclassi (e.g. le `delibere` si dividono ulteriormente in `bozze` e `approvate`), dove per \"classi\" *credo* si intenda entità e/o associazioni;\n6. Si specificano le ***operazioni*** degli utenti (Leggi: cosa devono poter fare coloro che interrogano il DB?).\n7. Si procede con ***due verifiche***:\n\t1. ***Completezza*** - Ci stiamo perdendo qualcosa che dovremmo considerare?\n\t2. ***Consistenza***\n\t\t- Tutti i concetti usati sono stati definiti? Tutte le operazioni fanno riferimento a dati definiti?\n\t\t- I dati definiti sono tutti usati dalle operazioni?","x":-8680,"y":-748,"width":877,"height":688,"color":"4"},
		{"id":"176a9102faf365f0","type":"text","text":"# Analisi Preliminari\n\nPrima di implementare un DB bisogna avere chiari alcuni punti.\n\n- Gli obiettivi, cioè a quali bisogni intende rispondere. Abbiamo due fasi:\n\t- ***Analisi dei Dati***, cioè cosa devo salvare nel DB;\n\t- ***Analisi Funzionale***, cioè cosa devo poter fare con i dati in mio possesso.\n- I gruppi di utilizzatori (potenzialmente di ambiti differenti), con le rispettive attività;\n\t- Può capitare, ad esempio, che il gruppo dei `fisici` e dei `filosofi` utilizzino lo stesso termine per intendere significati diversi (omonimi) o termini diversi per intendere la stessa cosa (sinonimi);\n- Uno studio di fattibilità per valutarne l'effettiva convenienza.\n- Il grado di sicurezza/privacy;\n\nSe l'***analisi dei requisiti*** analizza i bisogni dei singoli gruppi, l'***analisi concettuale*** cerca di farne una sintesi. Questa sintesi sarà il cardine di tutto, poiché ***completa ma indipendente dalla specifica implementazione*** del DB. L'analisi concettuale prende in input uno ***schema scheletro*** individuato in analisi dei requisiti e lo implementa in due possibili modi:\n\n- ***Particolarizzazione*** - Parto dai dati comuni a tutti i gruppi e poi sviluppo separatamente per ogni gruppo. Utilizzato in situazioni semplici;\n- ***Integrazione*** - Parto dagli schemi per i singoli gruppi e poi identifico i punti comuni. In questo caso potrei ritrovarmi a dover gestire dei ***conflitti***, che possono essere\n\t- ***espliciti*** (e.g. per un certo gruppo `esame` è un'entità, per un altro un'associazione);\n\t- ***impliciti*** (e.g. ci sono casi di omonimia, lo stesso nome è usato per cose diverse).","x":-7623,"y":-748,"width":777,"height":688,"color":"4"},
		{"id":"575e5710ff960bb0","type":"text","text":"# Commenti\n\nQuesto esempio è utile a notare problemi tipici:\n\n- `editori` era inizialmente trattato\n\t- come associazione, nel primo schema;\n\t- come attributo, nel secondo.\n- `argomenti` e `descrittori` erano sinonimi;","x":-8003,"y":370,"width":440,"height":400,"color":"4"},
		{"id":"bd9a88211b1b1d71","type":"file","file":"SchemiDaIntegrare.png","x":-7434,"y":280,"width":400,"height":180},
		{"id":"f5451f3aac19cbe2","type":"file","file":"SchemiIntegrati.png","x":-7434,"y":680,"width":400,"height":180},
		{"id":"c84ab1dd45991f86","type":"file","file":"SchemiUniformati.png","x":-7434,"y":480,"width":400,"height":180},
		{"id":"f0e00d6c4be06ffd","type":"text","text":"# Cenni di Modulo II\nAhahahahahahahahahahahahahporcodio\n\n","x":-3280,"y":-446,"width":310,"height":85,"color":"6"},
		{"id":"9d076c174e423d23","type":"text","text":"# Elementi del Modello Relazionale (Tabelle)\n\nDato un certo oggetto che si vuole rappresentare, si sceglie un sottoinsieme appropriato di attributi, li si dispongono in modo ordinato e gli si assegnano dei valori, realizzando una **tupla** (o **record**).\n\nTuple omogenee sono raggruppate in **istanze**, anche dette **relazioni (relations)**, realizzate al livello implementativo tramite tabelle.\n\nLe tuple possono rappresentare tanto **entità**, e quindi dati, quanto **relazioni (relationships)**, quindi correlazioni tra dati. Questo implica che le tabelle (anche dette *relazioni* nel senso di *istanze*) possono rappresentare sia entità che relazioni tra entità (*relationships*). Per niente convoluto, vero?\n\nDopo questo piccolo delirio di nomenclatura siamo arrivati alla faticosa conclusione che l'intero modello relazionale ha come **_unica struttura dati_** le **_tabelle_**.","x":2660,"y":-6816,"width":880,"height":436,"color":"4"},
		{"id":"41865100c4b249bd","type":"text","text":"se ho più chiavi potenziali uso solo quella che ha più senso e metto sulle altre (chiavi alternative) il vincolo `unique`. Se ho `matricola` e `codice fiscale` non ha senso mettere la coppia come chiave, perché significa che a parità di `matricola` posso avere diversi valori per `codice fiscale`. Metto `key matricola` e `unique codice fiscale`","x":2699,"y":-7913,"width":635,"height":363},
		{"id":"610f11a1cc17db76","type":"text","text":"# Vincoli d'Integrità\n\nDalle ***dipendenze funzionali*** (e.g. uno studente risiede in una sola città) seguono i vincoli d'integrità\n\n- un voto è un intero positivo compreso tra 18 e 30 (***vincoli di dominio***)\n- Vincoli di tupla, ossia delle proprietà che devono essere rispettate da ogni tupla appartenente ad un’istanza di una relazione\n- Vincoli di unicità, ossia l’impossibilità di avere due tuple con lo stesso valore per un determinato attributo (si impone con la direttiva `unique`)\n- Vincoli di esistenza del valore, ossia l’impossibilità per un attributo di una tupla di poter essere impostato su Null (direttiva `Not Null`)\n\t- la matricola identifica univocamente uno studente, non possono esserci valori duplicati per la matricola, né può avere valori nulli (***vincoli di chiave***)\n- lo straordinario di un impiegato è dato dal prodotto del numero di ore per la paga oraria; lo stipendio di un impiegato non può diminuire (***vincoli dinamici***)\n\nUn DB è corretto se soddisfa tutti i vincoli.\n\nDalle dipendenze funzionali seguono le chiavi.\n\nse non ho chiavi ne inserisco una artificiale (e.g. contatore autoincrementante)","x":2709,"y":-8640,"width":615,"height":685},
		{"id":"07503dab96a8215c","type":"text","text":"\nLe singole tuple sono funzioni che associano ad ogni attributo $A$ dello schema di relazione $R$ un elemento preso dal dominio di $A$.\nNella tupla ($t$) trovo il valore associato all'i-esimo come $t[i]$. Ma la notazione posizionale non ci piace. Allora uso le etichette. tipo $t[etichetta]$. -> posso riordinare le colonne come mi pare.\n\n\nNel nostro caso facciamo i prodotti cartesiani di relazioni, dove ognuna è un insieme di tuple (ogni tupla del primo insieme combinata con ogni tupla del secondo). NB: ogni tupla è a sua volta un sottoinsieme del prodotto cartesiano dei domini. è l'operazione di base per combinare le informazioni. ","x":3741,"y":-6816,"width":796,"height":357},
		{"id":"1fe2b64d43eb657f","type":"text","text":"qui si fanno solo vincoli intrarelazionali, ovvero dentro la stessa relazione, non interrelazionali\n\n\nlei specifica \n\n- uno studente risiede in una sola città (dipendenze funzionali)\n- la matricola identifica univocamente uno studente (vincoli di chiave)\n- un voto è un intero positivo compreso tra 18 e 30 (vincoli di dominio)\n- lo straordinario di un impiegato è dato dal prodotto del numero di ore per la paga oraria; lo stipendio di un impiegato non può diminuire (vincoli dinamici cioè del mio sistema specifico)","x":3741,"y":-6436,"width":600,"height":600},
		{"id":"887dab4eb92293c9","type":"text","text":"$\\underset{\\text{sotto}}{\\overset{\\text{sopra}}{=}}$","x":4365,"y":-6157,"width":250,"height":60},
		{"id":"757ece01c4e7854b","type":"text","text":"# tabelle\n\n\nservono file aggiuntivi ausiliari (indici) che permettono di accedere velocemente al file principale\nsu ogni tabella posso costruire più indici (magari su campi diversi)\n\nindici sono contenuti in altri file\n\nil linguaggio mette a disposizione dei tipi e delle operazioni sui tipi, ad esempio il tipo data ha metodi per estrarre giorno, mese e ora\n\nun'istanza vuota non può violare alcuna dipendenza funzionale, quindi è sempre \"buona\". per poter violare una regola deve contenere almeno due tuple! infatti molte dimostrazioni di BDD si mettono nel caso non restrittivo di istanza a due tuple. se rispetto tutte le dipendenze funzionali mi chiamo istanza LEGALE.\n","x":760,"y":-6770,"width":816,"height":395},
		{"id":"72567ad0e9b60184","type":"text","text":"# Vantaggi\n\n- multiuso\n- indipendenza dei dati dalle strutture fisiche\n- controllo centralizzato (DBMS)\n- ogni dato ha una sola rappresentazione (unico punto di accesso) a prescindere da quanti schemi esterni lo usano\n- minima ridondanza, se non assente\n- integrità, non devo preoccuparmi di modificare dati sensibili perché ho i vincoli di integrità\n- sicurezza, posso definire dei permessi","x":1608,"y":-7280,"width":616,"height":438},
		{"id":"96639327a802451a","type":"text","text":"# Dati\n\nLa stragrande maggioranza dei DBMS usa il MODELLO RELAZIONALE. In pratica, tabelle con intestazione, attributi e record (dati). Servono quindi nome e struttura per la tabella, e tutti i dati devono essere omogenei a livello di struttura. Distinguo quindi\n\n- Aspetto INTENSIONALE, nomi e strutture delle tabelle (che non si modificano);\n- Aspetto ESTENISONALE, i dati che memorizzo nelle tabelle (parte dinamica).\n","x":1656,"y":-6800,"width":520,"height":404},
		{"id":"24c928c1146b9fc6","type":"text","text":"# Dipendenze funzionali\n\nse due tuple hanno lo stesso valore sull'attributo ***determinante*** devono avere lo stesso valore anche sull'attributo ***dipendente*** (e.g. matricola determina provincia di residenza)\n$$X\\rightarrow Y$$\nnon \"implica\", che ha un valore logico-matematico di verità! X e Y in generale sono insiemi (e.g. codice fiscale determina nome e cognome, nome e cognome determinano iniziali)\n\nposso costruire una catena di dipendenze in cui se provincia determina regione allora matricola determina regione. Nella chiusura dell'attributo matricola ci finisce anche regione: la chiusura di un attributo è data da tutti gli attributi che questo determina direttamente e indirettamente.\n\ndi per sé sono limitate ad attributi dello stesso schema (non posso fare \"foreign dipendenza funzionale\"). formalmente si dice che $X\\rightarrow Y$ è applicabile ad R, nel senso che X e Y sono sottoinsiemi di R.","x":1934,"y":-8640,"width":726,"height":685},
		{"id":"e6f895d6dfd08caf","type":"text","text":"\nnon è detto che tutte le combinazioni di valori di questi domini abbiano un senso, e da qui vengono fuori i vincoli.\n\ndal punto di vista operativo, questo si traduce in una tabella\n\ni domini si possono ripetere, sono le etichette associate che danno l'unicità\n","x":1406,"y":-6157,"width":250,"height":380},
		{"id":"21392b0e654238df","type":"text","text":"# Zona SI\n\ni dati (fatti grezzi, fenomenologia) devono essere interpretati e correlati per estrarre informazioni.\n\n\n## from slides\n\nIn una organizzazione ogni componente è interessata ad una porzione del Sistema Informativo\n•Queste porzioni possono sovrapporsi\n•Una base di dati è una risorsa integrata condivisa da diverse componenti\n•L’integrazione e la condivisione permettono di ridurre ridondanze (dati parzialmente o totalmente replicati) e conseguenti inconsistenze\n\nLa condivisione non è mai completa: controllo della privacy e regolamentazione degli accessi\n• La condivisione comporta la necessità di gestire accessi contemporanei agli stessi dati: controllo della concorrenza\n","x":5473,"y":-7891,"width":780,"height":850},
		{"id":"b07c9a0115988648","type":"text","text":"# PRO e contro\n\n- I dati sono condivisi, unificati, privi di ridondanze e incoerenze;\n- Protezione da crash dei sistemi;\n- Ottimizzazione dell'accesso concorrente;\n- Facilità di interfacciamento con applicazioni esterne.\n\n#### CONTRO\n- Prodotto complesso e costoso;\n- Se il DB è piccolo, il gioco non vale la candela.","x":5483,"y":-6951,"width":770,"height":720},
		{"id":"db149c6dcc328f3d","type":"text","text":"# CONTROLLO DI CONCORRENZA\n\nVoglio che ogni accesso sia sicuro e coerente, permettendo a ogni utente di fare le operazioni. Se ad esempio devo comprare un biglietto, il DBMS deve garantirmi che mentre lo faccio non ci sia qualcun altro che lo compra in contemporanea. Ogni utente deve avere l'impressione di essere l'unico utente sul sistema e che le operazioni avvengano in NEAR-REAL_TIME. Per fare questo, il DBMS non può mettere le richieste degli utenti (TRANSAZIONI) in fila, ma deve parallelizzarle quanto più possibile. Gli accessi al disco sono frequenti e lenti, motivo per cui deve sfruttare quanto più possibile la CPU. Ogni transazione deve sempre e comunque rispettare i VINCOLI DI INTEGRITA', ovvero vincoli che impongono di lasciare il DB in uno stato consistente.\n\n- Esempio: Mario e Anna guadagnano 1000, e il vincolo è che debbano guadagnare entrambi la stessa cifra. Due dirigenti usano il DBMS per alzare loro lo stipendo, in particolare\n\t- Il primo dirigente (X) vuole eseguire l'operazione +100;\n\t- Il secondo dirigente (Y) vuole eseguire l'operazione \\*2;\n\tX e Y accedono contemporaneamente. X inizia a modificare Mario, portandolo a 1100. Y trova Mario occupato, ed esegue la sua operazione su Anna, portandola a 2000. Poi liberano i rispettivi record e passano al successivo, portando in definitiva Marco a guadagnare 2200 e Anna 2100. Inconsistenza con il vincolo! Il DBMS non deve permetterlo.\n\nIl DBMS impedisce che esistano errori di questo tipo nel seguente modo: va bene fare operazioni in contemporanea, ma solo a patto che esista una qualche successione di operazioni non parallele che portino il DB nello stesso risultato.\n\n- Nell'esempio di prima, se agisse prima X e poi Y avrei entrambi gli stipendi a 2200, ed entrambi a 2100 viceversa. Non esiste quindi alcuna esecuzione seriale che permetta a Mario di guadagnare 2200 e Anna 2100. E' importante ricordare che il DBMS non sa qual è lo stipendio giusto. Se dovesse verificarsi un accesso in contemporanea, il DBMS sceglierebbe casualmente l'esecuzione seriale associata garantendo il rispetto del vincolo (entrambi hanno lo stesso stipendio).\n\nLa garanzia più robusta è il protocollo di STRICT TWO PHASE LOCKING (Strict 2PL).\n\n- Prima di leggere e/o scrivere uno o più oggetti, la transazione X richiede al DBMS un LOCK su tali oggetti. Ovvero, un qualsiasi altra transazione Y che vuole interagire con questi oggetti dovrà aspettare l'esecuzione della prima;\n- I lock vengono rilasciati al termine dell'esecuzione di X;\n- Y potrà accedere agli oggetti, e a sua volta richiederà un lock.\n\nQuesto chiaramente può portare a tempi di attesa lunghi. Ci sono sistemi più sofisticati che rilasciano i lock in modo graduale (rilassano la condizione STRICT), ma a quel punto si rischia un DEADLOCK (in cui due oggetti sono necessari per il prosieguo delle transazioni X e Y ma sono bloccati dall'altra transazione), situazione che richiede il riavvio di una delle due transazioni.\n","x":1094,"y":-2047,"width":1052,"height":931,"color":"5"},
		{"id":"d870b420ba88c947","type":"text","text":"# IL LOG\nEsempio: Ritiro al bancomat, ma poco prima che eroghi i soldi salta la luce. Ho perso i soldi?\nPur essendo ogni transazione costituita da molte micro-operazioni, in un DBMS viene trattata come unica entità, seguendo un principio di \"o tutto o niente\". Come faccio ad esserne certo? Intanto non succede sempre. Può essere ABORTITA per qualche motivo (deadlock o banalmente mancanza di elettricità). Allora come riparo? Annullo le operazioni parziali fatte. La transazione deve arrivare a dare il comando di COMMIT per non essere annullata. Ma in pratica fare recovery in qualsiasi momento richiederebbe un backup in tempo reale, idea inverosimile. Allora, invece di scrivere nel DB scrivo nel LOG delle transazioni sia il vecchio che il nuovo valore per ogni micro-operazione, e ogni tot aggiorno il DB. In questo modo il DB resta sempre consistente (è in uno STATO LEGALE), e se una transazione si interrompe nel log è sufficiente riavviare il log. In pratica il log è il foglio di brutta e il DB è la bella.","x":2334,"y":-1808,"width":697,"height":453,"color":"5"},
		{"id":"46633b2542fae4a5","type":"text","text":"# Anomalie\n\n- anomalie di aggiornamento\n\t- se faccio un errore non so più qual è il dato giusto\n\t- se cambia un dato devo cambiarlo in tutte le tuple ridondanti\n- anomalie di inserimento - se faccio una tabella `curriculum` con i dati dello studente e degli esami sostenuti (-> la chiave è la coppia `matricola`, `codice corso`) non posso inserire uno studente che non ha fatto esami.\n- anomalia di cancellazione - l'esame *scienze delle merendine* è stato sostenuto solo da *Alfredo*, ed è grazie a lui che il mio DB sa che esiste quell'esame. Se *Alfredo* abbandona gli studi e cancello la sua tupla perdo l'informazione dell'esistenza di quell'esame.\n\nAttenzione alle superchiavi, se metto due chiavi alternative a formare una superchiave le singole non sono uniche!","x":3381,"y":4913,"width":660,"height":540,"color":"2"},
		{"id":"fcad795cf2171a3a","type":"text","text":"# Terza Forma Normale\n\ndi norma dovrebbe essere rispettata già dalla fase di progettazione, ma se non lo è possono verificarsi anomalie.\n\nla 3NF mette usually determinante = chiave, quindi le dipendenze funzionali sono automaticamente verificate sulle istanze\n\ne se l'istanza non è in 3NF? c'è un algoritmo che mi permette di scomporla in tabelle più piccole che sono in 3NF.","x":3381,"y":4264,"width":684,"height":540},
		{"id":"e6f14cae4b409dce","type":"text","text":"# Query SQL V - Valore `NULL` e Outer Join\n\n`NULL` modifica un po' le definizioni viste in precedenza.\n\n- Gli ***operatori logici*** restituiscono il valore `NULL` (o in alcuni casi `boolean UNKNOWN`) quando il loro risultato dipende da un valore `NULL`. Un `AND` in cui già il primo operando è `FALSE` restituisce `FALSE`, altrimenti `NULL`. Discorso analogo per `OR` e operatori più complessi come `ANY` (se trova una tupla che soddisfa la condizione restituisce `TRUE`, se invece dipende da un valore `NULL` restituisce `NULL`);\n- Nelle clausole ***`WHERE` ed `HAVING`*** un valore `NULL` ***viene trattato come fosse un `FALSE`***;\n- ***Gli operatori di aggregazione ignorano i `NULL`***, ad eccezione di `COUNT(*)` che conta tutte le tuple;\n- Gli operatori insiemistici trattano i valori `NULL` come duplicati, e in caso li eliminano.\n\nEsistono anche operatori che agiscono esplicitamente sui valori `NULL`.\n\n- `Attributo IS NULL` controlla che l'espressione `Attributo` sia `NULL`, restituendo `TRUE` o `FALSE`;\n- `Attributo1 IS DISTINCT FROM Attributo2` ritorna `FALSE` anche se le due espressioni per gli `Attributi` sono entrambe `NULL`, e ritorna `TRUE` anche se una delle due è `NULL`;\n\t- È immediata la negazione per entrambi questi operatori mettendo un `NOT` davanti;\n- La direttiva `COALESCE(Lista)` valuta una lista di `Attributi` e restituisce il primo valore non `NULL`;\n\t- Usata per convertire valori `NULL` in valori significativi.\n\nLa gestione del valore `NULL` porta all'aggiunta di alcune opzioni per le operazioni di `JOIN` (***Outer Join***).\n\n- `LEFT JOIN` - Aggiunge al risultato le tuple della `Tabella` di sinistra che non dovrebbero far parte del `JOIN`. Naturalmente, se sono escluse dal `JOIN` significa che non hanno trovato una corrispondenza con la `Tabella` di destra, e che quindi non esistono dei valori per gli `Attributi` che dovrebbero venire da quest'ultima. Per questo motivo, il `LEFT JOIN` riempie questi campi con valori `NULL`;\n- `RIGHT JOIN` - Fa esattamente quello che fa il `LEFT JOIN`, ma al contrario;\n- `FULL JOIN` - Esegue sia un `LEFT JOIN` che un `RIGHT JOIN`.","x":10740,"y":1688,"width":920,"height":731,"color":"4"},
		{"id":"35ce2c11ec870cc9","type":"text","text":"# Query SQL VI - Aggiungere, Modificare ed Eliminare i Dati\n\nSi può aggiungere una nuova tupla tramite le direttive\n\n```\nINSERT INTO Clienti\nVALUES (‘A03’, ‘Rossi Mario’, ‘Roma’, 10);\n```\n\nLa modifica si effettua invece con le direttive\n\n```\nUPDATE Agenti\n\tSET Supervisore = ‘s2’\n\tWHERE Supervisore = ‘s1’;\n```\n\nLa cancellazione si effettua invece con le direttive\n\n```\nDELETE FROM Ordini\nWHERE Data < ‘01012018‘;\n```","x":11840,"y":1688,"width":920,"height":731,"color":"4"},
		{"id":"b019a69fc3c920fc","type":"text","text":"# Potere Espressivo\n\n***SQL non è un linguaggio Touring-Completo***, motivo per cui quando è necessario richiedere funzioni più complesse (e.g. la varianza di una colonna di valori) è necessario inglobarlo all'interno di un linguaggio Touring-Equivalente.\n\nSeguono esempi di cose che non si possono fare con SQL di per sé.\n\n- Calcolare funzioni statistiche complesse come moda e varianza;\n- Valutare le funzioni di aggregazione su altre funzioni (e.g. `SUM(AVG(Stipendio))`);\n- Se i `Supervisori` degli `Agenti` hanno a loro volta un `Supervisore`, non esiste un modo di risalire a tutti i `Supervisori` in linea gerarchica di un certo `Agente`;\n- \\[...\\]","x":6722,"y":680,"width":718,"height":361,"color":"4"},
		{"id":"105f0b4fc185a788","type":"text","text":"# Nuovi Operatori in SQL\n\nRispetto agli operatori unari dell'algebra, ci sono alcune differenze.\n\n- ***Proiezione con duplicati***  - $\\pi_X^d(I)$ proietta sugli attributi $X$ dell'istanza $I$, ma il risultato è un multinsieme;\n- ***Eliminazione dei duplicati*** - $\\delta(I)$ sputa fuori $I' = I$ senza duplicati;\n- ***Ordinamento*** - $\\tau_X(I)$ restituisce $I'$ multinsieme ordinato;\n\nAlcuni operatori hanno un effetto diverso dato dai duplicati. Se una tupla $t$ si ripete $n$ volte in $I_1$ ed $m$ volte in $I_2$\n\n- ***Unione*** - $t$ appare $n+m$ volte nel multinsieme $I_1\\bigcup^d I_2$;\n- ***Intersezione*** - $t$ appare $min(n,m)$ volte nel multinsieme $I_1\\bigcap^d I_2$;\n- ***Differenza*** - $t$ appare $max(0,n-m)$ volte nel multinsieme $I_1\\bigcap^d I_2$.\n\nCi sono altre cosucce tipo che ***non vale la proprietà distributiva***.","x":5640,"y":957,"width":624,"height":445,"color":"4"},
		{"id":"0d05691f55ed1af1","type":"text","text":"# Query SQL IV bis - Altre Direttive\n\n- La scrittura `a BETWEEN b AND c` è uno ***shortcut*** per `a >= b AND a <= B`;\n- Posso ***confrontare due stringhe*** tramite la direttiva `Attributo LIKE Stringa`.\n\t- Il carattere `_` sta per \"qualsiasi lettera\";\n\t- Il carattere `%` sta per \"qualsiasi sequenza di lettere\".\n- La direttiva `Attributo IN {Valori}` controlla che `Attributo` compaia nella lista di `Valori`, restituendo `TRUE` in caso positivo e `FALSE` in caso negativo;\n- La negazione di tutte le clausole precedenti si fa anteponendo un `NOT`.\n\nPer vedere l'ordine effettivo di esecuzione delle operazioni, basta anteporre alla query la clausola `EXPLAIN`.","x":9660,"y":1183,"width":920,"height":325,"color":"4"},
		{"id":"91fe0d09a2bc6249","type":"text","text":"# TL, DR\n\nParto dagli attributi $X$ di cui voglio calcolare $X^+_F$, e mi costruisco iterativamente $Z$ come $X$ più tutti gli attributi determinati da $Z$. Quando $Z$ smette di aggiornarsi, esco dal ciclo `while`.","x":-3223,"y":6248,"width":691,"height":151,"color":"4"},
		{"id":"1e16a7b5713914dc","type":"text","text":"# Tipi di Indici\n\nSia il file indice che il principale sono ordinati in base ai valori delle chiavi. Il file indice però può essere\n\n- ***Denso*** - Ha un'entrata per ogni possibile chiave;\n- ***Sparso*** - Ha un'entrata per ogni partizione, dunque ogni chiave corrisponde ad un gruppo di record.\n\n","x":-6519,"y":-4919,"width":501,"height":244,"color":"4"}
	],
	"edges":[
		{"id":"8244132c0918415c","fromNode":"a5db58697c7e9975","fromSide":"bottom","toNode":"b1a5285caeae4130","toSide":"top"},
		{"id":"53615e184984119f","fromNode":"9af72174f7185470","fromSide":"right","toNode":"26a4c1c0b1aebc3f","toSide":"left"},
		{"id":"04199cd57310519f","fromNode":"a5db58697c7e9975","fromSide":"right","toNode":"186012183c3f3ecd","toSide":"left"},
		{"id":"605a908ff8a064ac","fromNode":"a5db58697c7e9975","fromSide":"right","toNode":"110d5abbb0f74fea","toSide":"left"},
		{"id":"00164a5b40b396d1","fromNode":"50686229090c1bd0","fromSide":"right","toNode":"a5db58697c7e9975","toSide":"left"},
		{"id":"1d0c6513134fc948","fromNode":"a5db58697c7e9975","fromSide":"left","toNode":"50686229090c1bd0","toSide":"right"},
		{"id":"e1f50179b1ccf9c5","fromNode":"26a4c1c0b1aebc3f","fromSide":"bottom","toNode":"a5db58697c7e9975","toSide":"top"},
		{"id":"b366dee568d9bd2e","fromNode":"21febace8b459e12","fromSide":"top","toNode":"9988826790f856a8","toSide":"bottom"},
		{"id":"55f749bca076997a","fromNode":"50686229090c1bd0","fromSide":"left","toNode":"e62ff9ade2624375","toSide":"right"},
		{"id":"8e7fd85be4572932","fromNode":"b1a5285caeae4130","fromSide":"left","toNode":"5056013ae1ac0b85","toSide":"right"},
		{"id":"bb5a8560773f45aa","fromNode":"b1a5285caeae4130","fromSide":"bottom","toNode":"060659758b3f2bc8","toSide":"top"},
		{"id":"722a7f35b9cefb82","fromNode":"21febace8b459e12","fromSide":"bottom","toNode":"e8974e97e6a653e4","toSide":"top"},
		{"id":"f5da9053cba8635b","fromNode":"24c928c1146b9fc6","fromSide":"right","toNode":"610f11a1cc17db76","toSide":"left"},
		{"id":"07555a4e9e645afd","fromNode":"21febace8b459e12","fromSide":"right","toNode":"eac6417a6b7e152d","toSide":"left"},
		{"id":"2ec4f3bb919c822b","fromNode":"5056013ae1ac0b85","fromSide":"left","toNode":"6bb122e548f7283b","toSide":"right"},
		{"id":"99ad67dee95acb9a","fromNode":"6bb122e548f7283b","fromSide":"bottom","toNode":"c44ff0137238f8c0","toSide":"top"},
		{"id":"cd370e13dce09069","fromNode":"6bb122e548f7283b","fromSide":"top","toNode":"e62ff9ade2624375","toSide":"bottom"},
		{"id":"9ebd6be9d9a21b5c","fromNode":"50686229090c1bd0","fromSide":"left","toNode":"8fc1cdfff9089b77","toSide":"right"},
		{"id":"3a9289be4ce79f3f","fromNode":"e62ff9ade2624375","fromSide":"top","toNode":"bdfda8f59f454594","toSide":"bottom"},
		{"id":"141ef4e1b66fffb9","fromNode":"23afcf5b45f8bffc","fromSide":"right","toNode":"2d896a06311319c3","toSide":"left"},
		{"id":"d1f1ad1ab29b3a11","fromNode":"c687ba503efe3e68","fromSide":"bottom","toNode":"f80c8aae48ac23d3","toSide":"top"},
		{"id":"6562403890d9b0df","fromNode":"c687ba503efe3e68","fromSide":"bottom","toNode":"3af5fb39864d9810","toSide":"top"},
		{"id":"6014e6c47c39a935","fromNode":"f80c8aae48ac23d3","fromSide":"bottom","toNode":"2b6f2a89d041bb3b","toSide":"top"},
		{"id":"b990987ba19e0b3e","fromNode":"3af5fb39864d9810","fromSide":"left","toNode":"2b6f2a89d041bb3b","toSide":"right"},
		{"id":"c6ced5b99eaa1a91","fromNode":"c687ba503efe3e68","fromSide":"left","toNode":"4873f8d0b1727773","toSide":"top"},
		{"id":"d3f7fd0b11254f87","fromNode":"2b6f2a89d041bb3b","fromSide":"left","toNode":"4873f8d0b1727773","toSide":"right"},
		{"id":"fc0d702fc42fc1bd","fromNode":"4873f8d0b1727773","fromSide":"bottom","toNode":"2f6f31d4b022c8a5","toSide":"top"},
		{"id":"1fd63af8dafbf776","fromNode":"4a7bf20ad214cee2","fromSide":"bottom","toNode":"5fd5e7044929afce","toSide":"top"},
		{"id":"50e1cfacaf37cdd5","fromNode":"5fd5e7044929afce","fromSide":"right","toNode":"60e48c54e851b219","toSide":"left"},
		{"id":"b0efd9397f86e191","fromNode":"5fd5e7044929afce","fromSide":"bottom","toNode":"93b7d0d27b51e813","toSide":"top"},
		{"id":"4c1b7d14305d32eb","fromNode":"5fd5e7044929afce","fromSide":"left","toNode":"61cb737e4d3fe669","toSide":"right"},
		{"id":"a7f1316dd268a665","fromNode":"61cb737e4d3fe669","fromSide":"right","toNode":"e44b6de59ebb2aa9","toSide":"top"},
		{"id":"5bd184aa006ae9fb","fromNode":"5fd5e7044929afce","fromSide":"left","toNode":"e44b6de59ebb2aa9","toSide":"top"},
		{"id":"562c58de69e3fa05","fromNode":"e44b6de59ebb2aa9","fromSide":"right","toNode":"93b7d0d27b51e813","toSide":"left"},
		{"id":"7823aefc8da0fc32","fromNode":"93b7d0d27b51e813","fromSide":"left","toNode":"e44b6de59ebb2aa9","toSide":"right"},
		{"id":"d7fd4b4959d528e7","fromNode":"93b7d0d27b51e813","fromSide":"bottom","toNode":"95f267d89205cab7","toSide":"top"},
		{"id":"7bda89f4288d3007","fromNode":"93b7d0d27b51e813","fromSide":"right","toNode":"60e48c54e851b219","toSide":"left"},
		{"id":"c1b0181026fd3b4d","fromNode":"4a7bf20ad214cee2","fromSide":"right","toNode":"fe75c4290f5a2e39","toSide":"left"},
		{"id":"3f253c77318e6ee0","fromNode":"fe75c4290f5a2e39","fromSide":"bottom","toNode":"c687ba503efe3e68","toSide":"top"},
		{"id":"90ec86e6badda6f8","fromNode":"4a7bf20ad214cee2","fromSide":"right","toNode":"9076d8b16b92da58","toSide":"top"},
		{"id":"da5e868ea28c9df9","fromNode":"9076d8b16b92da58","fromSide":"top","toNode":"fe75c4290f5a2e39","toSide":"left"},
		{"id":"c50bd3b2ed274843","fromNode":"60e48c54e851b219","fromSide":"right","toNode":"9076d8b16b92da58","toSide":"left"},
		{"id":"7b029f7dd064bf95","fromNode":"9076d8b16b92da58","fromSide":"right","toNode":"190cdeaceae81db7","toSide":"left"},
		{"id":"54381d9e24e763c2","fromNode":"c687ba503efe3e68","fromSide":"left","toNode":"190cdeaceae81db7","toSide":"right"},
		{"id":"9bec38f885795072","fromNode":"fe75c4290f5a2e39","fromSide":"bottom","toNode":"c28978adeeb9f559","toSide":"top"},
		{"id":"03dc793253b9bbb1","fromNode":"c44ff0137238f8c0","fromSide":"bottom","toNode":"4a7bf20ad214cee2","toSide":"top"},
		{"id":"a097ecc54d3e7d00","fromNode":"060659758b3f2bc8","fromSide":"left","toNode":"4a7bf20ad214cee2","toSide":"top"},
		{"id":"bbb1aa50bda0782a","fromNode":"060659758b3f2bc8","fromSide":"right","toNode":"fe75c4290f5a2e39","toSide":"top"},
		{"id":"eddfef370f979685","fromNode":"088b9e9e5ed435f3","fromSide":"right","toNode":"21febace8b459e12","toSide":"left"},
		{"id":"c6f75771a78c6324","fromNode":"b1a5285caeae4130","fromSide":"right","toNode":"23afcf5b45f8bffc","toSide":"left"},
		{"id":"001506678d3e4b07","fromNode":"23afcf5b45f8bffc","fromSide":"right","toNode":"a2b5fda883cdac87","toSide":"left"},
		{"id":"38d632d97eadc627","fromNode":"2f6f31d4b022c8a5","fromSide":"bottom","toNode":"a14acb36286e841a","toSide":"top"},
		{"id":"8f63f13caf8ce827","fromNode":"2f6f31d4b022c8a5","fromSide":"left","toNode":"ae1c7d941584d813","toSide":"right"},
		{"id":"6bd156eee93b2d77","fromNode":"ae1c7d941584d813","fromSide":"bottom","toNode":"e61e8cd5a61d08b7","toSide":"top"},
		{"id":"af2e1321afc0713a","fromNode":"e61e8cd5a61d08b7","fromSide":"bottom","toNode":"54145b0b67f0bdd7","toSide":"top"},
		{"id":"69d3b819622185a2","fromNode":"54145b0b67f0bdd7","fromSide":"left","toNode":"99c39d53bd14d250","toSide":"right"},
		{"id":"a83a34100eb837dc","fromNode":"a14acb36286e841a","fromSide":"bottom","toNode":"d6f242e8f74be88a","toSide":"top"},
		{"id":"7966685a269252c2","fromNode":"2f6f31d4b022c8a5","fromSide":"right","toNode":"782d4f36963c0fc7","toSide":"left"},
		{"id":"eb67504cf59a9f6b","fromNode":"060659758b3f2bc8","fromSide":"bottom","toNode":"477470d0e3fa461a","toSide":"top"},
		{"id":"d573fef8471c71ff","fromNode":"73226aa690f89469","fromSide":"left","toNode":"782d4f36963c0fc7","toSide":"right"},
		{"id":"b73096bf881c6961","fromNode":"782d4f36963c0fc7","fromSide":"right","toNode":"73226aa690f89469","toSide":"left"},
		{"id":"6f97dcf00033d96c","fromNode":"3af5fb39864d9810","fromSide":"right","toNode":"524878ec1680396b","toSide":"left"},
		{"id":"06c328a7dd1093e4","fromNode":"782d4f36963c0fc7","fromSide":"bottom","toNode":"d187fd7c52585352","toSide":"left"},
		{"id":"a11ffc6fff3ad8b3","fromNode":"d187fd7c52585352","fromSide":"right","toNode":"337ec409043d12f1","toSide":"left"},
		{"id":"9169558d9a7265f5","fromNode":"3160396b5a7e9638","fromSide":"left","toNode":"479930361d7113c1","toSide":"right"},
		{"id":"4dbf3bd17a5c4fa1","fromNode":"a6f456ad07ee9d3f","fromSide":"top","toNode":"b36c6f51ca3d1a8e","toSide":"bottom"},
		{"id":"d5a36313113ba27a","fromNode":"3160396b5a7e9638","fromSide":"right","toNode":"a6f456ad07ee9d3f","toSide":"left"},
		{"id":"754cf38b4bc1d154","fromNode":"9af72174f7185470","fromSide":"left","toNode":"f0e00d6c4be06ffd","toSide":"right"},
		{"id":"dd9041a12e8d6474","fromNode":"f0e00d6c4be06ffd","fromSide":"left","toNode":"020fe60541153c51","toSide":"right"},
		{"id":"4be349ec21f68438","fromNode":"176a9102faf365f0","fromSide":"left","toNode":"d7282788ef30fb92","toSide":"right"},
		{"id":"9977e14a846f24a7","fromNode":"176a9102faf365f0","fromSide":"bottom","toNode":"bd9a88211b1b1d71","toSide":"top"},
		{"id":"91d4bcc0020f7a4f","fromNode":"bd9a88211b1b1d71","fromSide":"bottom","toNode":"c84ab1dd45991f86","toSide":"top"},
		{"id":"59fd5bc374d5b71a","fromNode":"c84ab1dd45991f86","fromSide":"bottom","toNode":"f5451f3aac19cbe2","toSide":"top"},
		{"id":"15830b701f0e1a62","fromNode":"f5451f3aac19cbe2","fromSide":"left","toNode":"575e5710ff960bb0","toSide":"right"},
		{"id":"024838761404e40b","fromNode":"c84ab1dd45991f86","fromSide":"left","toNode":"575e5710ff960bb0","toSide":"right"},
		{"id":"b45884764bd373fe","fromNode":"bd9a88211b1b1d71","fromSide":"left","toNode":"575e5710ff960bb0","toSide":"right"},
		{"id":"810d14560ba0ceea","fromNode":"60e48c54e851b219","fromSide":"bottom","toNode":"89ae6e18040f3465","toSide":"top"},
		{"id":"e6b91f8cba5bb404","fromNode":"c44ff0137238f8c0","fromSide":"left","toNode":"eba6d491c9cfc3d3","toSide":"right"},
		{"id":"2bf6fbab45fbd37c","fromNode":"eba6d491c9cfc3d3","fromSide":"left","toNode":"47a35105b19345b4","toSide":"right"},
		{"id":"a9a0494e6c947ecb","fromNode":"eba6d491c9cfc3d3","fromSide":"left","toNode":"903aad68a5ec5667","toSide":"right"},
		{"id":"99b0ad86422880d0","fromNode":"2a1fbd738374b30a","fromSide":"left","toNode":"4bb40df35fc271b9","toSide":"right"},
		{"id":"de26ce7cf0fb5ba1","fromNode":"2a1fbd738374b30a","fromSide":"left","toNode":"20cb7adc69dea990","toSide":"right"},
		{"id":"92c49a776cece611","fromNode":"6a076667fdf061aa","fromSide":"left","toNode":"2a1fbd738374b30a","toSide":"right"},
		{"id":"e3e3d131b452d635","fromNode":"6a076667fdf061aa","fromSide":"top","toNode":"1281574a686cf54b","toSide":"right"},
		{"id":"9636568a3a7b6b9c","fromNode":"6a076667fdf061aa","fromSide":"right","toNode":"2e29205b54e81c20","toSide":"left"},
		{"id":"076f9bbf65b35c38","fromNode":"6a076667fdf061aa","fromSide":"top","toNode":"f2c93058a3441fae","toSide":"bottom"},
		{"id":"f5b783eb61c3f344","fromNode":"479930361d7113c1","fromSide":"top","toNode":"6a076667fdf061aa","toSide":"bottom"},
		{"id":"daca28351aa677ca","fromNode":"b36c6f51ca3d1a8e","fromSide":"left","toNode":"6a076667fdf061aa","toSide":"bottom"},
		{"id":"09a3997ec4f07ddc","fromNode":"1281574a686cf54b","fromSide":"bottom","toNode":"2a1fbd738374b30a","toSide":"top"},
		{"id":"f9a1da8a4461a7e3","fromNode":"f2c93058a3441fae","fromSide":"right","toNode":"51bb3436d69bb68f","toSide":"left"},
		{"id":"0df5ab9c37322738","fromNode":"400558d331fb8f8c","fromSide":"bottom","toNode":"df7363b7e9237fef","toSide":"top"},
		{"id":"df2d64492dd7d764","fromNode":"51bb3436d69bb68f","fromSide":"right","toNode":"400558d331fb8f8c","toSide":"left"},
		{"id":"23194061d85c3aa4","fromNode":"51bb3436d69bb68f","fromSide":"right","toNode":"df7363b7e9237fef","toSide":"left"},
		{"id":"2771ba336ef54764","fromNode":"6a076667fdf061aa","fromSide":"top","toNode":"c61805cabef941a5","toSide":"left"},
		{"id":"bb4cdd9a150cdfb0","fromNode":"f2c93058a3441fae","fromSide":"top","toNode":"06747e06930e5894","toSide":"bottom"},
		{"id":"5dfa133a602ccb14","fromNode":"6a076667fdf061aa","fromSide":"top","toNode":"21e4b7f7d6cf42e4","toSide":"left"},
		{"id":"bd456de92f2d51cc","fromNode":"c61805cabef941a5","fromSide":"bottom","toNode":"21e4b7f7d6cf42e4","toSide":"top"},
		{"id":"beb2189c989dc48f","fromNode":"26a4c1c0b1aebc3f","fromSide":"right","toNode":"c391c5b931a474b1","toSide":"left"},
		{"id":"18bb20175a6032d8","fromNode":"680466b4da71866a","fromSide":"top","toNode":"93b81e4cccf632f5","toSide":"bottom"},
		{"id":"9b5ba2c89aa96c37","fromNode":"c391c5b931a474b1","fromSide":"right","toNode":"680466b4da71866a","toSide":"left"},
		{"id":"245ae00c09dfa2a9","fromNode":"93b81e4cccf632f5","fromSide":"left","toNode":"0cba8c1e45400c14","toSide":"bottom"},
		{"id":"17d86fcef005c14e","fromNode":"c391c5b931a474b1","fromSide":"top","toNode":"0cba8c1e45400c14","toSide":"bottom"},
		{"id":"b1a654016dc51d50","fromNode":"0cba8c1e45400c14","fromSide":"bottom","toNode":"93b81e4cccf632f5","toSide":"left"},
		{"id":"b0f3f5ba9c334326","fromNode":"c391c5b931a474b1","fromSide":"bottom","toNode":"56193193b904926e","toSide":"top"},
		{"id":"5b5c8c23988cc3b2","fromNode":"680466b4da71866a","fromSide":"right","toNode":"4c38e6c1c366af16","toSide":"left"},
		{"id":"ffd31e65eebd4fe8","fromNode":"020fe60541153c51","fromSide":"left","toNode":"176a9102faf365f0","toSide":"right"},
		{"id":"c74fedc9c1f7860c","fromNode":"3160396b5a7e9638","fromSide":"top","toNode":"6a076667fdf061aa","toSide":"bottom"},
		{"id":"d4188396a52bbd88","fromNode":"020fe60541153c51","fromSide":"top","toNode":"3160396b5a7e9638","toSide":"bottom"},
		{"id":"c11d620cdc9fd7b4","fromNode":"020fe60541153c51","fromSide":"bottom","toNode":"659ef6753251fa38","toSide":"top"},
		{"id":"597cb54e47505e2a","fromNode":"176a9102faf365f0","fromSide":"bottom","toNode":"659ef6753251fa38","toSide":"left"},
		{"id":"ff02bdca5ee4664b","fromNode":"23afcf5b45f8bffc","fromSide":"right","toNode":"3f5bed2a25101916","toSide":"left"},
		{"id":"4de89ad3e32ebdae","fromNode":"2d896a06311319c3","fromSide":"right","toNode":"3f5bed2a25101916","toSide":"left"},
		{"id":"e622548b08641b80","fromNode":"a2b5fda883cdac87","fromSide":"right","toNode":"3f5bed2a25101916","toSide":"left"},
		{"id":"e41a45211a3bfde4","fromNode":"a2b5fda883cdac87","fromSide":"right","toNode":"374dc424f5326223","toSide":"left"},
		{"id":"4544c0eaa9c55e77","fromNode":"3f5bed2a25101916","fromSide":"bottom","toNode":"374dc424f5326223","toSide":"top"},
		{"id":"34023d3e171b048a","fromNode":"3f5bed2a25101916","fromSide":"right","toNode":"6d1aeb8c9e754fe7","toSide":"left"},
		{"id":"2547a8cd0c585e60","fromNode":"6d1aeb8c9e754fe7","fromSide":"bottom","toNode":"48a105008e92c4ab","toSide":"top"},
		{"id":"71ef1c25cac56e94","fromNode":"6d1aeb8c9e754fe7","fromSide":"top","toNode":"6915a75b535e3062","toSide":"bottom"},
		{"id":"31b830cd7f7d626a","fromNode":"6d1aeb8c9e754fe7","fromSide":"right","toNode":"98966c16e4c394c5","toSide":"left"},
		{"id":"d686cca3847836b5","fromNode":"98966c16e4c394c5","fromSide":"top","toNode":"cac7e795d09f2772","toSide":"bottom"},
		{"id":"55fc65fae991b7a0","fromNode":"98966c16e4c394c5","fromSide":"bottom","toNode":"c504d5d4466412b3","toSide":"top"},
		{"id":"aa58c6bb87a2174e","fromNode":"98966c16e4c394c5","fromSide":"right","toNode":"372c828acb9cb8b4","toSide":"left"},
		{"id":"278546590522c683","fromNode":"372c828acb9cb8b4","fromSide":"bottom","toNode":"b34754e616d06a6b","toSide":"top"},
		{"id":"7ce61199e3996707","fromNode":"372c828acb9cb8b4","fromSide":"right","toNode":"91a94733b3961240","toSide":"left"},
		{"id":"b0c860cba09d8c0b","fromNode":"91a94733b3961240","fromSide":"bottom","toNode":"963cdd000a934fc7","toSide":"top"},
		{"id":"6dc47822835c64a1","fromNode":"524878ec1680396b","fromSide":"top","toNode":"46633b2542fae4a5","toSide":"bottom"},
		{"id":"a500a40da095c5f1","fromNode":"91a94733b3961240","fromSide":"top","toNode":"0d05691f55ed1af1","toSide":"bottom"},
		{"id":"a50741a06110b815","fromNode":"91a94733b3961240","fromSide":"right","toNode":"e6f14cae4b409dce","toSide":"left"},
		{"id":"7ee12c9dcbe5ca0c","fromNode":"e6f14cae4b409dce","fromSide":"right","toNode":"35ce2c11ec870cc9","toSide":"left"},
		{"id":"4abf751ccf4479bc","fromNode":"3f5bed2a25101916","fromSide":"top","toNode":"b019a69fc3c920fc","toSide":"left"},
		{"id":"7f4c31927960e1e1","fromNode":"3f5bed2a25101916","fromSide":"top","toNode":"105f0b4fc185a788","toSide":"bottom"},
		{"id":"df819bd899d88f73","fromNode":"2d896a06311319c3","fromSide":"right","toNode":"105f0b4fc185a788","toSide":"left"},
		{"id":"10b27603cb8cd43f","fromNode":"f0e00d6c4be06ffd","fromSide":"bottom","toNode":"50686229090c1bd0","toSide":"top"},
		{"id":"20eef84aceba9c45","fromNode":"95f267d89205cab7","fromSide":"left","toNode":"91fe0d09a2bc6249","toSide":"right"},
		{"id":"90892b18e5732f5b","fromNode":"73226aa690f89469","fromSide":"bottom","toNode":"d187fd7c52585352","toSide":"top"}
	]
}