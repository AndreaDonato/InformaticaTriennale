{
	"nodes":[
		{"id":"b449fb1b90baad5c","type":"text","text":"# Obiettivo di una BDD relazionale\nfacilitare l'elaborazione dei dati in base alle loro relazioni\n\n# Metodi \nIndividuare tutte e sole le informazioni rilevanti (attributi del record, riempiti poi con valori detti campi (sicuri??)) e che rendono univoco il dato (chiavi). Questo determina lo schema.\n\nle relazioni sono mantenute in una struttura dei record\n\nin una bdd è possibile centralizzare i dati e poi dividere in moduli a seconda dei privilegi di accesso e/o simili --> evito ridondanze e anomalie (e.g. se faccio database di tutte info docenti, gli studenti possono accedere solo ad alcune info, senza fare due bdd diverse)\n\ncontrollo della consistenza via controllo della concorrenza --> sincronizzazione","x":300,"y":440,"width":816,"height":439},
		{"id":"2721bfeb685c4f97","type":"text","text":"## from slides\n\nIn una organizzazione ogni componente è interessata ad una porzione del Sistema Informativo\n•Queste porzioni possono sovrapporsi\n•Una base di dati è una risorsa integrata condivisa da diverse componenti\n•L’integrazione e la condivisione permettono di ridurre ridondanze (dati parzialmente o totalmente replicati) e conseguenti inconsistenze\n\nLa condivisione non è mai completa: controllo\ndella privacy e regolamentazione degli accessi\n• La condivisione comporta la necessità di\ngestire accessi contemporanei agli stessi dati:\ncontrollo della concorrenza","x":1160,"y":440,"width":460,"height":439},
		{"id":"757ece01c4e7854b","type":"text","text":"# tabelle\n\nsono l'unica struttura dati in una bdd relazionale. è un insieme di record dello stesso tipo.\n\nogni riga ha la stessa struttura (elementi di BDD sono aggregati di informazioni omogenee). Ad ogni file corrisponde una struttura (tabella) specifica. è come un record (Pascal), una struct (C), volendo un dizionario o un oggetto (Python). Un record (riga della tabella) è un insieme di valori presi ordinatamente da una serie di domini definiti in fase di progettazione, quindi l'insieme dei record (omogenei?) è una tabella (o più in generale un'istanza o schema, definito come \"insieme degli attributi scelti per definire un certo oggetto, ogni attributo avrà un tipo, una tupla è un'assegnazione di valori agli attributi dello schema, un'istanza di relazione è un'insieme di tuple costruite su questo schema)\n\nservono file aggiuntivi ausiliari (indici) che permettono di accedere velocemente al file principale\nsu ogni tabella posso costruire più indici (magari su campi diversi)\n\nindici sono contenuti in altri file\n\nil linguaggio mette a disposizione dei tipi e delle operazioni sui tipi, ad esempio il tipo data ha metodi per estrarre giorno, mese e ora\n\nun'istanza vuota non può violare alcuna dipendenza funzionale, quindi è sempre \"buona\". per poter violare una regola deve contenere almeno due tuple! infatti molte dimostrazioni di BDD si mettono nel caso non restrittivo di istanza a due tuple. se rispetto tutte le dipendenze funzionali mi chiamo istanza LEGALE.\n","x":300,"y":960,"width":816,"height":740},
		{"id":"05708e117bdbf7b6","type":"text","text":"# Dati/informazioni\n\ni dati (fatti grezzi, fenomenologia) devono essere interpretati e correlati per estrarre informazioni.\n\ni dati sono contenuti in record omogenei\n\nquando voglio memorizzare info devo capire quali sono quelle rilevanti, poi decido i vincoli opportuni","x":1160,"y":960,"width":460,"height":740},
		{"id":"ca4707cbac6b8e5d","type":"text","text":"#### rischio inconsistenze\n\n- ridondanza (si risolve con buona progettazione)\n- concorrenza (si risolve con meccanismi di sincronizzazione, che però stanno al DBMS esattamente come stanno al Kernel nel SO)\n\n","x":-460,"y":440,"width":720,"height":439},
		{"id":"d978bd83e81a4684","type":"text","text":"# concetti di base\n\n- attributi - autoesplicativo, sono associati a un **_dominio_** di valori che gli posso assegnare\n- schema - inseme di attributi (non necessariamente in una tupla! sono quelli complessivi, \"tutte e sole le informazioni rilevanti\") e del nome della relazione (e.g. nome: studente, attributi nome cognome matricola sono lo schema della relazione). a rigore nello schema rientrano anche i tipi degli attributi (e.g. matricola è un intero)\n- dipendenze funzionali - vincoli in scritti in matematichese su attributi definiti all'inizio, e.g. prescrive che se una coppia di tuple ha un certo valore uguale allora deve avere altri valori uguali (e.g. se ho stesso CF avrò anche stesso nome e cognome). vale sia su coppie di attributi sia su coppie di insiemi di attributi. si definisce sullo schema. a --> b si legge \"a determina b\".\n- tupla - insieme di valori assegnati agli attributi dello schema. una t. che viene inserita in un'istanza (un insieme di tuple) deve rispettare le dipendenze funzionali (di quell'istanza? o generali?)\n- chiusure (degli insiemi di attributi e degli insiemi di dipendenze funzionali)","x":1734,"y":960,"width":686,"height":740},
		{"id":"0295d553a4a8e914","type":"text","text":"# Introduzione","x":-1460,"y":-648,"width":246,"height":50,"color":"6"},
		{"id":"a5db58697c7e9975","type":"text","text":"# Storia\n\nmetà anni ’60: primi sistemi\n- gerarchici, puntamenti a indirizzi fisici\n\t- Generalized Update Access Method (IBM (ex BigBlue, Progetto Apollo, 1964)\n\t- DL/1 (Data Language 1) (IBM, (il primo ad essere messo) in commercio nel 1966)\n\t- IMS (Information Management System)\n\n- a rete, ogni nodo può avere più di un genitore\n\t- I-D-S (Integrated Data Store) (General Electric)\n\t- sistemi CODASYL / DBTG / a rete\n\n1970: E.F. Codd (IBM) introduce il modello relazionale\n\nanni ’70: prototipi sistemi relazionali (System R, IBM) hanno risolto diversi problemi dei precedenti modelli\nanni ’80: sistemi relazionali commerciali (Ingress, Oracle, … ci è voluto un po' perché era una teoria bella e rivoluzionaria ma difficile da implementare. più facile ad alto livello ma più difficile a livello di architettura (e penso intenda del software))","x":-460,"y":-1608,"width":720,"height":520},
		{"id":"186012183c3f3ecd","type":"text","text":"# Modello gerarchico\n• Tipo ristretto di modello reticolare (leggi: è un albero e non un grafo):\n– Gerarchia = reticolo composto da una collezione di alberi (foresta)\n– Ogni nodo ha un solo genitore","x":-1100,"y":-1484,"width":520,"height":273},
		{"id":"1598beef6ffacd53","type":"text","text":"# Modello Reticolare\n\nGrafo! I dati sono rappresentati come una collezione di record di tipo omogeneo\n• Le relazioni binarie sono rappresentate come link\n(implementati come puntatori = dipendenza dalla\nstruttura fisica della base di dati). Un campo del record esame è un puntatore al record studente, un altro al record del corso;\n• Il modello è rappresentato come una struttura a grafo\ndove :\n– Nodi = record\n– Archi = link\n• Il più popolare modello reticolare: CODASYL","x":400,"y":-1538,"width":520,"height":380},
		{"id":"b1a5285caeae4130","type":"text","text":"# modello relazionale\n\nrivoluzionario introduce il riferimento per valore\n\nDati e relazioni sono rappresentati come valori\n• Non ci sono riferimenti espliciti, cioè puntatori come nei modelli reticolare e gerarchico. si basa sul poter costruire un valore che identifica univocamente la tupla/record dall'altra parte (istanza) --> CHIAVI\n• => rappresentazione di livello più alto\n\n","x":-380,"y":-928,"width":560,"height":560},
		{"id":"9ac131662f9a9040","type":"text","text":"a --> b = se le tuple sono uguali su a devono esserlo anche su b. se ho valori diversi su a non mi interesso di b.","x":2561,"y":960,"width":250,"height":400},
		{"id":"bf2d64e4e1b8b08e","type":"text","text":"# a livello pratico (qua ha bevuto qualcosa)\n\nsi parla solo di tabella identificando la tabella con lo schema. la chiameremo relazione.\nlo schema di relazione identifica gli attributi, le tuple sono i valori assegnati agli attributi, l'insieme delle tuple è l'istanza.\n\ndiciamo che istanza è il termine tecnico di quello che nel DBMS vediamo come tabella","x":-460,"y":960,"width":720,"height":740},
		{"id":"2340907f4f1d1778","type":"file","file":"0 - Introduzione.txt","x":-2100,"y":-1128,"width":400,"height":400},
		{"id":"ca224ad83572f9ba","type":"file","file":"modelli_logici.txt","x":-1660,"y":-1128,"width":400,"height":400},
		{"id":"9af72174f7185470","type":"text","text":"# Sistema Informativo\n\nNel momento in cui è necessario gestire dati e informazioni si introduce la nozione di **_Sistema Informativo_**, un'entità che si occupa di\n\n- raccolta e acquisizione delle informazioni;\n- archiviazione e conservazione delle informazioni;\n- elaborazione delle informazioni;\n- distribuzione delle informazioni.\n\nSi tratta di un modello indipendente dall'implementazione, e quindi dall'informatica: esempi di Sistemi Informativi possono essere infatti una biblioteca o un archivio.\n\nPuò essere visto come componente di un'**_organizzazione_** (nel senso letterale di _sistema organizzato_) che opera a supporto delle altre componenti.\n\nSicuramente l'informatica è un modo ottimale di implementare un SI.\n\nIn questo senso, un SI è un complesso di dati organizzati fisicamente in una memoria secondaria e gestiti in maniera tale da consentirne la creazione, l’aggiornamento e l’interrogazione.\n\n\n\n","x":-2080,"y":-320,"width":620,"height":578,"color":"4"},
		{"id":"2b9f740ce09f9ba4","type":"text","text":"## Implementazione Informatica","x":-1420,"y":-56,"width":432,"height":50,"color":"6"},
		{"id":"26a4c1c0b1aebc3f","type":"text","text":"# Base di Dati (Database)\n\nUna **_Base di Dati_** (o _**Database**_, _**DB**_) è un insieme di **_file mutuamente connessi_** da relazioni definite in fase di progettazione.\n\n\n\nI dati al suo interno sono omogenei, nel senso che le informazioni si riferiscono a un contesto ben preciso (non è utile generalizzare un'implementazione del genere, ci si concentra sul problema specifico).\n\nIl software in grado di interrogare le basi di dati è il **_DBMS (Data Base Management System)_**, fortunatamente già scritto da qualcun\naltro (si compra la licenza).\n\nCaratteristiche di un DBMS:\n\n\nIncrocia questi appunti con i txt\nLectio II m 41","x":-940,"y":-320,"width":620,"height":578,"color":"3"},
		{"id":"56af8c1b4ccfa833","type":"text","text":"# pre-BDD relazionali\n\nera tutto sequenziale (non strutturati) scritti in linguaggi dedicati (Cobol, Fortran, alcune società stanno ancora così perché il porting costa, questo crea enormi problemi di portabilità) e gestiti dal filesystem\n\n\nDBMS viene installato su SO ma è di fatto a sua volta un SO. Mentre il Kernel si occupa di allocare, il DBMS si occupa di come sono organizzati i file della BDD\n\nridondanza era bestia nera delle bdd, rischi inconsistenze (altra cosa è il mirroring, che ogni tot fa un backup dei dati e ci sono master e slave)\n\n estremamente complicato quando si usavano gli indirizzi per referenziare i dati. il collegamento studente-esame veniva fatto inserendo nel campo esame l'indirizzo fisico del record studente. appena si spostava qualcosa era un delirio. cstudenteon bdd relazionale basta metterci la matricola e poi ci pensa il dbms a raggiungere lo studente\n\n","x":-1240,"y":340,"width":580,"height":578},
		{"id":"21392b0e654238df","type":"text","text":"# definizioni\n\n• Una Base di Dati (Database – DB) è un insieme di file **_mutuamente connessi_** (non basta avere tabelle, la cosa più importante sono le relazioni).\n\n- Gli insiemi di dati sono organizzati in diverse strutture di dati che ne facilitano la creazione, l’accesso e l’aggiornamento ed ottimizzano la gestione delle risorse fisiche.\n\n• I Sistemi di Gestione di Basi di Dati (Database Management System – DBMS) sono strumenti software per la gestione di grandi masse (strutturate, processabili, condivise) di dati residenti su memoria secondaria\n\n\n• Dati strutturati: gli oggetti sono rappresentati da brevi stringhe di simboli e da numeri, si processano e gestiscono meglio (niente accessi sequenziali O(n/2), alla peggio ho O(log_2(n))). ci si può accedere singolarmente tramite interrogazioni o query\n• Dati non strutturati: testi scritti in un linguaggio naturale, solo ricerca sequenziale","x":-120,"y":-320,"width":700,"height":648},
		{"id":"50686229090c1bd0","type":"text","text":"# modelli logici e concettuali (coesistenti!!)\n\nmodelli logici: indipendenti dalle strutture fisiche ma disponibili nei DBMS: es. reticolare (network), gerarchico (hierarchical), relazionale (relational), ad oggetti (object, pare che ancora non ci sia uno standard, mentre per relazionale se io dbms dico di essere standard sql significa che metto a disposizione un certo insieme di tipi e metodi)\n\n• modelli concettuali: fase di progettazione. non si limitano al concetto di tabella ma possono esprimere cose più complesse, non posso avere un voto di un esame senza un corso a cui è riferito, o senza uno studente, il che significa che non è un'entità ma un'associazione (tra lo studente e il corso). è concettualmente sbagliato memorizzare nella stessa struttura dati dello studente, del corso e dell'esame, perché concettualmente l'esame è una relazione e non un'entità. se faccio una riga del genere, ogni volta che lo studente fa un altro esame devo ripetere i suoi dati, così come se  lo fa un altro studente ripeto i dati del corso!! in pratica devo definire il ruolo degli elementi per poi tradurli in tabelle o quello che è (altrimenti produco ridondanze). infatti sono indipendenti dalle modalità di realizzazione, e hanno lo scopo di rappresentare le entità del mondo reale e le loro relazioni nelle prime fasi della progettazione: es. entità-relazioni (entity-relationship). se faccio bene il modello concettuale poi la traduzione ","x":300,"y":-820,"width":1320,"height":380},
		{"id":"a2b5fda883cdac87","type":"text","text":"# Algebra Relazionale\n\nnon ha primitive di definizione e inizializzazione perché è un linguaggio astratto e non concreto (...)\n\nsql esistono i comandi perché è la sua implementazione","x":-1020,"y":-814,"width":497,"height":333}
	],
	"edges":[
		{"id":"84235431ee1da6c0","fromNode":"b449fb1b90baad5c","fromSide":"right","toNode":"2721bfeb685c4f97","toSide":"left"},
		{"id":"a62b5f0f41bb52a5","fromNode":"a5db58697c7e9975","fromSide":"left","toNode":"186012183c3f3ecd","toSide":"right"},
		{"id":"8244132c0918415c","fromNode":"a5db58697c7e9975","fromSide":"bottom","toNode":"b1a5285caeae4130","toSide":"top"},
		{"id":"a59de5f8c1641319","fromNode":"a5db58697c7e9975","fromSide":"right","toNode":"1598beef6ffacd53","toSide":"left"},
		{"id":"52e4b381b229f7db","fromNode":"d978bd83e81a4684","fromSide":"right","toNode":"9ac131662f9a9040","toSide":"left"},
		{"id":"f0ff4c79000d8a9f","fromNode":"b1a5285caeae4130","fromSide":"left","toNode":"a2b5fda883cdac87","toSide":"right"},
		{"id":"4e30351a201e84ee","fromNode":"0295d553a4a8e914","fromSide":"top","toNode":"2340907f4f1d1778","toSide":"bottom"},
		{"id":"d59e78ba21f6519a","fromNode":"2340907f4f1d1778","fromSide":"right","toNode":"ca224ad83572f9ba","toSide":"left"},
		{"id":"53615e184984119f","fromNode":"9af72174f7185470","fromSide":"right","toNode":"26a4c1c0b1aebc3f","toSide":"left"}
	]
}