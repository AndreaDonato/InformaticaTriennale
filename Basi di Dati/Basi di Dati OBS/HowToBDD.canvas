{
	"nodes":[
		{"id":"a5db58697c7e9975","type":"text","text":"# Evoluzione dei DB e dei DBMS\n\nLa gestione dei dati si è resa necessaria fin dai primi utilizzi dei sistemi di calcolo, negli anni '50.\n\nI precursori dei DB (diciamo quindi semplicemente \"le prime grandi moli di dati\", in assenza delle caratteristiche tipiche di un DB per come lo intendiamo oggi) erano gestiti tramite linguaggi dedicati (e.g. *Fortran* per le applicazioni scientifiche, *COBOL* per le applicazioni commerciali, ma anche *Pascal* e *C*), e si appoggiavano sul _filesystem_ del SO sottostante, e quindi in un ambiente non-strutturato (dove per **_ambiente strutturato_** si intende la **_mediazione di un DBMS_**).\n\nI primi DBMS risalgono alla metà degli anni '60, stimolati da una società sempre più ricca di sfide tecnologiche (e.g. Progetto Apollo della NASA).\n\nLo sviluppo e la commercializzazione nei primi anni sono principalmente targati **_IBM_**, che implementa **_IMS (Information Management System)_**, il primo DB **_gerarchico_**.\n\nQuesto modello implementa una **_struttura ad albero_** in cui ogni unità logica di dati (**_record_**) costituisce un nodo, e i collegamenti padre-figlio definiscono le relazioni.\n\nUna generalizzazione del modello gerarchico è il _**modello reticolare**_, standardizzato dal comitato **_CODASYL_** (_Conference on Data Systems Languages_) tra gli anni '60 e '70, che rilassa la struttura ad albero in una struttura a **_grafo_** (ogni nodo può avere più padri).\n\n**_Importantissimo_** notare che tutti questi modelli sono implementati tramite **_puntatori a memoria_**, e che quindi ogni record è una struttura collegata che ha una campo che referenzia direttamente l'indirizzo fisico del record di destinazione.\n\nQuesto li rende fortemente dipendenti dalla struttura fisica del DB, nonché estremamente complicati in fase di manipolazione.\n\nIl 1970 è un anno rivoluzionario per i DBMS, perché viene introdotto in IBM il **_modello relazionale_**. Servono tuttavia una decina d'anni di lavoro per produrre le prime implementazioni commerciali (*Ingress*, *Oracle*, MySQL, ...).","x":-166,"y":400,"width":660,"height":956,"color":"4"},
		{"id":"50686229090c1bd0","type":"text","text":"# Modelli Concettuali e Modelli Logici\n\nPer realizzare un DBMS è necessario identificare, in ordine,\n\n- tutte e sole le informazioni rilevanti rispetto al problema (**_dati_**);\n- i vincoli che legano tra loro le informazioni (**_relazioni_**);\n- un modo univoco per risalire a una certa informazione (**_linguaggio di interrogazione ?????_**).\n\nLa progettazione si può suddividere in tre fasi principali:\n\n- **_Analisi Concettuale_** - Si identifica cos'è un'**_entità_** (dato) e cos'è una **_relazione_** (vincolo tra dati). Si crea un **_modello concettuale_** che rappresenta un **_primo livello di astrazione_** del problema, e che fornendo una schematizzazione logica dei dati semplifica le comunicazioni circa il DB. Questa fase **non si occupa dei dettagli implementativi**, e resta astratta (appunto, concettuale);\n- ***Modellazione Logica*** - In questa fase si traduce la struttura logica dei dati identificata nella fase di analisi concettuale in un **_modello logico_**, ovvero si sceglie **come** implementare il modello concettuale (questo include l'uso di riferimenti, etichette, tabelle, ...). Definisce la **struttura organizzativa virtuale delle interconnessioni tra i dati** indipendentemente dall'effettiva implementazione sottostante;\n- **_Implementazione_** - Si crea il DB fisico, ovvero la struttura di dati che viene effettivamente memorizzata sul sistema di archiviazione.\n\nQuesta distinzione suggerisce che il primo step si occupi solo di identificare le entità e il secondo di definirne la struttura. La realtà non è così rigida. Ad esempio, ha senso che un albero genealogico sia rappresentato direttamente come albero nel modello concettuale, mentre nel caso in cui la struttura non sia così evidente sin da subito l'albero può essere implementato come scelta di design nel modello logico.\n\nA partire dagli anni '60/'70 nascono diverse tipologie di DBMS costruiti sui relativi modelli logici.\n\n- **_Gerarchico ('60)_** - Struttura di tipo albero, i dati sono i nodi e le relazioni gli archi genitore-figlio;\n- **_Reticolare ('70)_** - Struttura di tipo grafo, i dati sono i nodi e le relazioni gli archi;\n- **_Relazionale ('70, '80)_** - Basato sul modello concettuale Entità-Relazione;\n- _**A Oggetti ('80)**_ - I dati sono oggetti con dei metodi associati;\n- _**XML**_ - Rivisitazione del modello gerarchico con l'aggiunta di tag, attributi e altre cose fancy;\n- **_NoSQL_** - Genericamente, modelli non basati sul modello relazionale.\n\nAd ogni modello logico corrispondono diversi linguaggi di interrogazione progettati in modo specifico per un certo insieme di dati. L'unica eccezione è il **_Relazionale_**, che ha come linguaggio standard **_SQL_**.","x":-1160,"y":400,"width":880,"height":956,"color":"3"},
		{"id":"26a4c1c0b1aebc3f","type":"text","text":"# Base di Dati (Database) e DBMS\n\nUna **_Base di Dati_** (o _**Database**_, _**DB**_) è un insieme di **_file (gruppi di dati) mutuamente connessi_** da relazioni definite in fase di progettazione.\n\nL'interconnessione è condizione necessaria per poter implementare degli algoritmi di ricerca più sofisticati (in assenza di collegamenti, non esiste un ordine).\n\nLe relazioni sono più importanti dei dati in sé, perché cruciali per garantire la consistenza delle informazioni (e.g. una possibile relazione può essere che a una corrispondenza di matricola corrisponda lo stesso nome studente) e l'efficienza nel reperirle.\n\nI dati si riferiscono a un contesto ben preciso: non è utile generalizzare un'implementazione del genere, ci si concentra sul problema specifico.\n\nIl software in grado di gestire e interrogare i DB (intesi come collezioni di dati strutturati, processabili e condivisi) è il **_DBMS (Data Base Management System)_**, fortunatamente già scritto da qualcun altro (si compra la licenza).\n\nIl DBMS viene installato su SO, ma di fatto è a sua volta un SO. Mentre il Kernel si occupa di allocare, il DBMS si occupa di come sono organizzati i file del DB. In quanto pseudo-SO, un linguaggio come C può mettere a disposizione delle chiamate a DBMS (scritte poi nel suo **_linguaggio di interrogazione_**) esattamente come le chiamate a sistema per il SO.\n","x":-1050,"y":-374,"width":660,"height":688,"color":"4"},
		{"id":"9af72174f7185470","type":"text","text":"# Sistema Informativo\n\nNel momento in cui è necessario gestire dati e informazioni si introduce la nozione di **_Sistema Informativo_**, un'entità che si occupa di\n\n- raccolta e acquisizione delle informazioni;\n- archiviazione e conservazione delle informazioni;\n- elaborazione delle informazioni;\n- distribuzione delle informazioni.\n\nSi tratta di un modello indipendente dall'implementazione, e quindi dall'informatica: esempi di Sistemi Informativi possono essere infatti una biblioteca o un archivio.\n\nPuò essere visto come componente di un'**_organizzazione_** (nel senso letterale di _sistema organizzato_) che opera a supporto delle altre componenti.\n\nSicuramente l'informatica è un modo ottimale di implementare un SI.\n\nIn senso informatico, un SI è un complesso di dati organizzati fisicamente in una memoria secondaria e gestiti in maniera tale da consentirne facilmente la creazione, l’aggiornamento e l’**_interrogazione_** (leggi: reperire i dati conservativi).\n\n\n\n","x":-2190,"y":-374,"width":620,"height":688,"color":"6"},
		{"id":"2b9f740ce09f9ba4","type":"text","text":"## Implementazione Informatica","x":-1530,"y":-55,"width":432,"height":50,"color":"6"},
		{"id":"e62ff9ade2624375","type":"text","text":"## Esempio: Modello Entità-Relazioni\n\nLa tabella `studenti` che ha come attributi `matricola`, `nome` e `cognome` è perfettamente consistente di per sé, cioè ha senso di esistere indipendentemente dal resto del DB $\\Rightarrow$ **Entità**.\n\nAnche la tabella `corsi` avente come attributi `codice`, `titolo` e `professore` ha senso indipendentemente dal resto del DB $\\Rightarrow$ **Entità**.\n\nLa tabella `esame` che ha come attributi `matricola`, `codice` e `voto` ha senso di esistere solo in quanto associazione di un elemento dell'entità `studenti` ad uno dell'entità `corsi` $\\Rightarrow$ **Relazione (Relationship).**\n\nSarebbe concettualmente sbagliato memorizzare nella stessa struttura i dati dello studente, del corso e dell'esame.\n\nSe faccio una cosa del genere, ogni volta che lo studente sostiene un altro esame sono costretto a ripetere i suoi dati, così come se lo stesso esame è sostenuto da un altro studente sono costretto a ripetere i dati del corso.\n\nIn pratica, la definizione del ruolo degli elementi quando costruisco il modello concettuale è cruciale per evitare la produzione di ridondanze.\n\n## Esempio: Modello Reticolare\n\nL'implementazione dell'esempio di prima in un modello reticolare prevede che i riferimenti della *relationship* `esami` siano puntatori alle zone di memoria delle entità `studenti` e `corsi`, referenziando in pratica l'intero record. \"Capite bene che il porting di un DB del genere era un bagno di sangue\".","x":-2190,"y":488,"width":620,"height":780,"color":"4"},
		{"id":"21392b0e654238df","type":"text","text":"# Zona SI\n\ni dati (fatti grezzi, fenomenologia) devono essere interpretati e correlati per estrarre informazioni.\n\n\n## from slides\n\nIn una organizzazione ogni componente è interessata ad una porzione del Sistema Informativo\n•Queste porzioni possono sovrapporsi\n•Una base di dati è una risorsa integrata condivisa da diverse componenti\n•L’integrazione e la condivisione permettono di ridurre ridondanze (dati parzialmente o totalmente replicati) e conseguenti inconsistenze\n\nLa condivisione non è mai completa: controllo della privacy e regolamentazione degli accessi\n• La condivisione comporta la necessità di gestire accessi contemporanei agli stessi dati: controllo della concorrenza\n","x":-3120,"y":-1400,"width":780,"height":850},
		{"id":"110d5abbb0f74fea","type":"text","text":"# Ambiente Strutturato o Dati Strutturati?\n\nNon va fatta confusione tra il concetto di **_ambiente strutturato_**, inteso come la presenza di un DBMS, e le caratteristiche dei dati memorizzati.\n\n- **_Dati non strutturati_**: testi scritti in un linguaggio naturale, per i quali è implementabile solo una ricerca di tipo sequenziale, con un tempo medio di accesso $\\sim O(n/2)$;\n- **_Dati strutturati_**: dati rappresentati da brevi stringhe di simboli o da numeri. Permettono di definire relazioni d'ordine e quindi ottimizzare gli algoritmi di ricerca. Ad esempio, la **_ricerca binaria_** arriva ad un tempo medio di accesso $O(log_2(n))$. Ci si può accedere singolarmente tramite interrogazioni.\n\nI moderni DB sono costituiti da **_soli_** dati strutturati.\n","x":640,"y":400,"width":760,"height":380,"color":"4"},
		{"id":"186012183c3f3ecd","type":"text","text":"# Linguaggi di Interrogazione\n\nAnche con l'avvento dei primi DBMS, nei primi anni non esisteva un **_linguaggio di interrogazione (query language)_** universale.\n\nIn **IMS**, ad esempio, la gestione avveniva tramite _Data Language/1_ (**DL/1**), un complesso linguaggio di interrogazione specifico che richiedeva una dettagliata conoscenza della struttura fisica del DB. In seguito questo venne ampliato con il Generalized Update Access Method (**GUAM**), che forniva funzionalità di più alto livello per semplificare la vita dei programmatori. \n\nNei DB standardizzati CODASYL esisteva il *Data Manipulation Language* (**DML**), che però è sempre rimasto specifico dei modelli a rete.\n\nIl primo linguaggio di interrogazione universale è lo **_Structured Query Language (SQL)_**, nato in IBM nei primi anni '70 insieme al **_modello relazionale_**.\n\nC'è da notare che ancora oggi alcune società potrebbero avere dei DB non standardizzati, perché i costi del porting superano i benefici.","x":640,"y":860,"width":760,"height":496,"color":"4"},
		{"id":"db149c6dcc328f3d","type":"text","text":"# CONTROLLO DI CONCORRENZA\nVoglio che ogni accesso sia sicuro e coerente, permettendo a ogni utente di fare le operazioni. Se ad esempio devo comprare un biglietto, il DBMS deve garantirmi che mentre lo faccio non ci sia qualcun altro che lo compra in contemporanea. Ogni utente deve avere l'impressione di essere l'unico utente sul sistema e che le operazioni avvengano in NEAR-REAL_TIME. Per fare questo, il DBMS non può mettere le richieste degli utenti (TRANSAZIONI) in fila, ma deve parallelizzarle quanto più possibile. Gli accessi al disco sono frequenti e lenti, motivo per cui deve sfruttare quanto più possibile la CPU. Ogni transazione deve sempre e comunque rispettare i VINCOLI DI INTEGRITA', ovvero vincoli che impongono di lasciare il DB in uno stato consistente.\n\n- Esempio: Mario e Anna guadagnano 1000, e il vincolo è che debbano guadagnare entrambi la stessa cifra. Due dirigenti usano il DBMS per alzare loro lo stipendo, in particolare\n\t- Il primo dirigente (X) vuole eseguire l'operazione +100;\n\t- Il secondo dirigente (Y) vuole eseguire l'operazione \\*2;\n\tX e Y accedono contemporaneamente. X inizia a modificare Mario, portandolo a 1100. Y trova Mario occupato, ed esegue la sua operazione su Anna, portandola a 2000. Poi liberano i rispettivi record e passano al successivo, portando in definitiva Marco a guadagnare 2200 e Anna 2100. Inconsistenza con il vincolo! Il DBMS non deve permetterlo.\n\nIl DBMS impedisce che esistano errori di questo tipo nel seguente modo: va bene fare operazioni in contemporanea, ma solo a patto che\nesista una qualche successione di operazioni non parallele che portino il DB nello stesso risultato.\n\n- Nell'esempio di prima, se agisse prima X e poi Y avrei entrambi gli stipendi a 2200, ed entrambi a 2100 viceversa. Non esiste quindi alcuna esecuzione seriale che permetta a Mario di guadagnare 2200 e Anna 2100. E' importante ricordare che il DBMS non sa qual è lo stipendio giusto. Se dovesse verificarsi un accesso in contemporanea, il DBMS sceglierebbe casualmente l'esecuzione seriale associata garantendo il rispetto del vincolo (entrambi hanno lo stesso stipendio).\n\nLa garanzia più robusta è il protocollo di STRICT TWO PHASE LOCKING (Strict 2PL).\n\n- Prima di leggere e/o scrivere uno o più oggetti, la transazione X richiede al DBMS un LOCK su tali oggetti. Ovvero, un qualsiasi altra transazione Y che vuole interagire con questi oggetti dovrà aspettare l'esecuzione della prima;\n- I lock vengono rilasciati al termine dell'esecuzione di X;\n- Y potrà accedere agli oggetti, e a sua volta richiederà un lock.\n\nQuesto chiaramente può portare a tempi di attesa lunghi. Ci sono sistemi più sofisticati che rilasciano i lock in modo graduale (rilassano la condizione STRICT), ma a quel punto si rischia un DEADLOCK (in cui due oggetti sono necessari per il prosieguo delle transazioni X e Y ma sono bloccati dall'altra transazione), situazione che richiede il riavvio di una delle due transazioni.\n","x":4392,"y":3248,"width":1052,"height":931},
		{"id":"c257b123a2436672","type":"text","text":"# Caratteristiche di un DBMS\n\n- Gestisce collezioni di dati\n\t- Grandi: autoesplicativo;\n\t- Persistenti: i dati sono la risorsa più stabile (rispetto ai metodi, gli algoritmi e simili, che possono cambiare). Il DBMS gestisce processi di BACKUP e RECOVERY per minimizzare il rischio di perderli;\n\t- Condivise: accessibili ad altri sistemi e ad utenti. Questo porta a complicazioni nel momento in cui molti utenti accedono contemporaneamente al DBMS, il quale attua il CONTROLLO DI CONCORRENZA.\n\n- Garantisce (o dovrebbe garantire)\n\t- Privacy: il DBMS fa accedere ai dati (o a loro porzioni) solo gli utenti autorizzati. Gli admin possono accedere a tutti i dati in r/w. Ci sono definizioni molto dettagliate di cosa l'utente può o non può fare, tipicamente specificate al momento della richiesta;\n\t- Affidabilità: il DBMS fornisce risultati corretti;\n\t- Efficienza: i risultati vengono restituiti in un tempo ragionevole.\n\nEsempi di DMBS sono:\n\n- DB2, di IBM, per grandissime quantità di dati e grandi organizzazioni;\n- Oracle, il più diffuso poiché flessibile rispetto al piano tariffario;\n- SQLServer, di Microsoft, simile a Oracle ma \"un po' peggio\";\n- MySQL, MicrosoftAccess, DBMS \"giocattolo\";\n- PostgreSQL, non basato sulla logica relazionale.","x":5746,"y":4134,"width":680,"height":740},
		{"id":"d870b420ba88c947","type":"text","text":"# IL LOG\nEsempio: Ritiro al bancomat, ma poco prima che eroghi i soldi salta la luce. Ho perso i soldi?\nPur essendo ogni transazione costituita da molte micro-operazioni, in un DBMS viene trattata come unica entità, seguendo un principio di \"o tutto o niente\". Come faccio ad esserne certo? Intanto non succede sempre. Può essere ABORTITA per qualche motivo (deadlock o banalmente mancanza di elettricità). Allora come riparo? Annullo le operazioni parziali fatte. La transazione deve arrivare a dare il comando di COMMIT per non essere annullata. Ma in pratica fare recovery in qualsiasi momento richiederebbe un backup in tempo reale, idea inverosimile. Allora, invece di scrivere nel DB scrivo nel LOG delle transazioni sia il vecchio che il nuovo valore per ogni micro-operazione, e ogni tot aggiorno il DB. In questo modo il DB resta sempre consistente (è in uno STATO LEGALE), e se una transazione si interrompe nel log è sufficiente riavviare il log. In pratica il log è il foglio di brutta e il DB è la bella.","x":4546,"y":2767,"width":697,"height":453},
		{"id":"4010dbf8b74b33c3","type":"text","text":"# Perché serve un DBMS?\n\nIn assenza di un DBMS, dovrei costruire un DB a partire da un *filesystem* come *Excel*, o addirittura un semplice *file.txt*.\n\nChiaramente non ho garanzia di evitare **_duplicati_** o **_inconsistenze_**. Più ci si affida all'intervento umano e a diversi DB contenenti informazioni simili che non si parlano, più aumenta il rischio di duplicazione e inconsistenze, da cui rischio di estrarre dati e informazioni false.\n\nIn un DBMS, il tipo di dato può essere molto semplice (alfanumerico) o molto pesante (video). Il DB può essere grande sia in senso di numero di dati sia in senso di quanto occupa il singolo dato. Ma dove li metto tutti questi dati? La memoria centrale non basta, serve memoria secondaria. Il DBMS deve quindi trovare il dato sulla memoria secondaria e caricarlo in centrale. Uno dei problemi degli ultimi 30 anni è come velocizzare questo processo. Nessuno vuole aspettare 3 minuti per comprare un biglietto!","x":4240,"y":4274,"width":686,"height":600,"color":"3"},
		{"id":"1559942f272c8467","x":5083,"y":4274,"width":447,"height":680,"type":"text","text":"# Come opera un DBMS \n\nil so apre un canale di comunicazione con il dbms che risponde su un certo socket (porta). I dati del DB hanno una codifica proprietaria, e sono decodificati solo tramite il dbms (leggi: se li apro con l'editor vedo roba insensata) che si occupa di virtualizzarli per l'utente.\n\n"},
		{"id":"15b9e5cae2616389","type":"text","text":"# Sicurezza","x":319,"y":6059,"width":211,"height":50,"color":"6"},
		{"id":"b07c9a0115988648","type":"text","text":"# PRO e contro\n\n- I dati sono condivisi, unificati, privi di ridondanze e incoerenze;\n- Protezione da crash dei sistemi;\n- Ottimizzazione dell'accesso concorrente;\n- Facilità di interfacciamento con applicazioni esterne.\n\n#### CONTRO\n- Prodotto complesso e costoso;\n- Se il DB è piccolo, il gioco non vale la candela.","x":-3110,"y":-460,"width":770,"height":720},
		{"id":"9ac131662f9a9040","type":"text","text":"##### circa le dipendenze funzionali\na --> b = se le tuple sono uguali su a devono esserlo anche su b. se ho valori diversi su a non mi interesso di b.","x":1214,"y":4181,"width":420,"height":400},
		{"id":"e0ca754560103232","type":"text","text":"# Come si interagisce con un RDBMS?\n\nIl *linguaggio di interrogazione* *ad-hoc* per i DBMS relazionali è **_SQL (Structured Query Language)._** Si può accedere anche con i linguaggi canonici (C, Java, ...) se al loro interno includono i comandi di SQL. Questo si distingue in due linguaggi formali:\n\n- **_DDL (Data Definition Language):_** Definisce gli schemi del DBMS. Serve nella fase di progettazione.\n- **_DML (Data Manipulation Language):_** Gestisce le richieste sui dati (**_query_**);\n\n\nIl potere espressivo (ovvero ciò che posso calcolare con un linguaggio) è dato dalla classe di query calcolabili, ed è diverso da quello di un normale linguaggio Touring-completo. I motivi per la scrittura ad hoc di un linguaggio di interrogazione rispetto a uno classico sono \n\t- Maggiore semplicità di utilizzo per il compito specifico;\n\t- Costante ottimizzazione per le interrogazioni.\n\nTra un'operazione ottimizzata e una non ottimizzata ci possono essere differenze di svariati ordini di grandezza. Poi moltiplica per il numero di operazioni e il disastro è compiuto. Dentro SQL ci sono due linguaggi equivalenti:\n\n - Algebra relazionale: linguaggio procedurale (fornisce la procedura per ottenere il risultato);\n- Calcolo relazionale (che non si studia, ma alcune cose di SQL si basano su di esso): linguaggio dichiarativo, descrivo in modo formale le caratteristiche del risultato che voglio senza darne la procedura.\n\nCi focalizziamo sull'algebra. Costituita da\n\n- Operandi: tabelle relazionali;\n- Operatori: unari o binari su operandi.\n\nE' chiusa rispetto al risultato e gode di tutte le proprietà delle algebre (associativa, commutativa, ...). Seguono gli operatori ad hoc per operare sulle tabelle:\n\n- Insiemistici\n\t- Unione\n\t- Intersezione\n\t- Differenza (presenti nella prima ma non nella seconda), non simmetrica.\n\t\n- Ridenominazione, puramente sintattico, forma P(R(F), E) dove\n\t- P è l'operatore Ridenominazione;\n\t- R è il risultato;\n\t- F è la LISTA DI RIDENOMINAZIONE nella forma (vecchio nome -> nuovo nome; posizione -> nuovo nome; ...);\n\t- E è l'istanza di input.\n\n- Prodotto cartesiano, che invero è insiemistico vabb. Permette di creare nuove tuple modificando quelle esistenti. Se faccio RxS ottengo tutte le possibili combinazioni delle tuple di R con tutte quelle di S. Quindi se R ha campi ABC e S DE RxS ha ABCDE. Molto importante ottimizzare questa operazione perché il risultato esplode. Raramente, infatti, lo si usa. Si usa il JOIN. Se unisco tabelle aventi campi con lo stesso nome, nel risultato NON avranno nome, le devo rinominare con la posizione.\n\t\n- Selezione, la condizione è booleana. Taglia le righe.\n\n- Proiezioni, taglia le colonne, nuova tabella contiene colonne specificate nella condizione. Le tuple sono <= (= se prendo la chiave, se \tnon la prendo non è detto che sia strettamente minore). Bisogna stare attenti alle chiavi. Non c'è l'oggetto tupla, ma solo i valori\n\t\tche contiene. In genere è l'ultimo operatore applicato, seppure l'algebra sia commutativa. Questo perché prima costruisco il risultato senza rischiare di tagliare fuori le chiavi (e quindi far collassare tuple diverse nella stessa tupla, e quindi perdere informazione);\n\nPoi operatori derivati, ma un paio sono così utilizzati che vale la pena menzionarli\n\n- Join (o theta-join): perno delle query, prodotto cartesiano + selezione. Costruisce solo le tuple utili del prodotto cartesiano. Il DBMS implementa i Join, non il cartesiano. I più interessanti sono con condizione di uguaglianza (EQUI-JOIN) con campi di cui uno\n\t\tdei due è chiave, l'altro è foreign key. Perché?\n\t\n- Join Naturale, ovvero equi-join in cui specifico una condizione per ogni attributo comune alle due tabelle;\n\n- Divisione, introdotta per cose del tipo \"dimmi gli studenti che hanno fatto tutti gli esami\". Sia A una relazione con due campi, x e y. Sia B una relazione con il solo campo y. A/B contiene i valori x in A associati a tutti gli elementi y che compaiono in B. Concettualmente, si opera trovando tutti i valori x che NON vanno bene e si sottraggono.\n\nLa compatibilità delle interrogazioni è puramente sintattica (e non semantica). Sta a chi scrive assicurarsi che abbiano senso concettuale. Per convenzione, se unisco due tabelle i nomi delle colonne sono quelli della prima tabella. E qui entra in gioco Ridenominazione.\n\nIn algebra relazionale (e quindi in SQL) non ho modo di confrontare tuple diverse. Se devo fare un confronto, mi servono i valori da confrontare scritti nella stessa tupla. Non ci sono variabili, blocchi condizionali o cicli.\n\n- Se ad esempio devo trovare un minimo di una colonna, piuttosto che confrontarli elimino a coppie quelli più grandi.\n\nIn generale succede sempre così quando mi servirebbe un ciclo. In algebra relazionale non si possono ricostruire catene di riferimenti o alberi genealogici. Se facendo operazioni incontro un valore NULL, il sistema non lo includerà nel risultato se non diversamente specificato.\n\n","x":2080,"y":3063,"width":1200,"height":1620},
		{"id":"9f75da23c1fde580","type":"text","text":"# Glossario illogico del Modello Relazionale II\n\n- Vincoli d'Integrità \n- dipendenze funzionali - vincoli in scritti in matematichese su attributi definiti all'inizio, e.g. prescrive che se una coppia di tuple ha un certo valore uguale allora deve avere altri valori uguali (e.g. se ho stesso CF avrò anche stesso nome e cognome). vale sia su coppie di attributi sia su coppie di insiemi di attributi. si definisce sullo schema. a --> b si legge \"a determina b\". Una tupla che viene inserita in un'istanza (un insieme di tuple) deve rispettare le dipendenze funzionali (di quell'istanza? o generali?)\n- chiusure (degli insiemi di attributi e degli insiemi di dipendenze funzionali)","x":424,"y":4078,"width":686,"height":605},
		{"id":"23afcf5b45f8bffc","type":"text","text":"# Algebra Relazionale","x":280,"y":2746,"width":360,"height":50,"color":"6"},
		{"id":"b1a5285caeae4130","type":"text","text":"# Modello Relazionale\n","x":-460,"y":2078,"width":360,"height":50,"color":"6"},
		{"id":"3aec0d0f14f7cf5c","type":"text","text":"# Zona Sicurezza\n\n\n\nin una bdd è possibile centralizzare i dati e poi dividere in moduli a seconda dei privilegi di accesso e/o simili --> evito ridondanze e anomalie (e.g. se faccio database di tutte info docenti, gli studenti possono accedere solo ad alcune info, senza fare due bdd diverse)\n\ncontrollo della consistenza via controllo della concorrenza --> sincronizzazione\n\n\n\n#### rischio inconsistenze\n\nridondanza era bestia nera delle bdd, rischi inconsistenze (altra cosa è il mirroring, che ogni tot fa un backup dei dati e ci sono master e slave)\n\n- ridondanza (si risolve con buona progettazione)\n- concorrenza (si risolve con meccanismi di sincronizzazione, che però stanno al DBMS esattamente come stanno al Kernel nel SO)\n\n","x":-526,"y":5646,"width":811,"height":726},
		{"id":"8fc1cdfff9089b77","type":"text","text":"# Perché il Modello Relazionale è \"rivoluzionario\"?\n\nAnzitutto perché non ci sono riferimenti espliciti (puntatori a memoria), ed è pertanto **_indipendente dalla memorizzazione fisica dei dati_**. Questo di fatto risolve tutti i problemi di portabilità e semplifica di molto il lavoro dei programmatori, che non dovendo preoccuparsi della struttura sottostante possono manipolare il DB in modo logico (il che ovviamente porta a un'accelerazione nello sviluppo dell'intero campo).\n\nCiò accade perché sia dati che relazioni sono rappresentati come valori (**_riferimento per valore_**), e l'intero modello si basa sulla possibilità di costruire dei valori speciale (**_chiavi_**) che identificano univocamente le tuple nelle istanze.\n\nIn questo senso possiamo definire (FORSE!!!!!!!)\n\n- tutte e sole le informazioni rilevanti rispetto al problema - **Attributi**;\n- i vincoli che legano tra loro le informazioni - **Relazioni (Relationships)** QUI DA CAPIRE SE E' VERO;\n- un modo univoco per risalire a una certa informazione - **Chiavi**.\n","x":-2320,"y":1421,"width":880,"height":438,"color":"3"},
		{"id":"9d076c174e423d23","type":"text","text":"# Elementi del Modello Relazionale (Tabelle)\n\nDato un certo oggetto che si vuole rappresentare, si sceglie un sottoinsieme appropriato di attributi, li si dispongono in modo ordinato e gli si assegnano dei valori, realizzando una **tupla** (o **record**).\n\nTuple omogenee sono raggruppate in **istanze**, anche dette **relazioni (relations)**, realizzate al livello implementativo tramite tabelle.\n\nLe tuple possono rappresentare tanto **entità**, e quindi dati, quanto **relazioni (relationships)**, quindi correlazioni tra dati. Questo implica che le tabelle (anche dette *relazioni* nel senso di *istanze*) possono rappresentare sia entità che relazioni tra entità (*relationships*). Per niente convoluto, vero?\n\nDopo questo piccolo delirio di nomenclatura siamo arrivati alla faticosa conclusione che l'intero modello relazionale ha come **_unica struttura dati_** le **_tabelle_**.","x":-2320,"y":1901,"width":880,"height":404,"color":"4"},
		{"id":"72567ad0e9b60184","x":-2992,"y":1421,"width":616,"height":438,"type":"text","text":"# Vantaggi\n\n- multiuso\n- indipendenza dei dati dalle strutture fisiche\n- controllo centralizzato (DBMS)\n- ogni dato ha una sola rappresentazione (unico punto di accesso) a prescindere da quanti schemi esterni lo usano\n- minima ridondanza, se non assente\n- integrità, non devo preoccuparmi di modificare dati sensibili perché ho i vincoli di integrità\n- sicurezza, posso definire dei permessi"},
		{"id":"96639327a802451a","x":-2944,"y":1901,"width":520,"height":404,"type":"text","text":"# Dati\n\nLa stragrande maggioranza dei DBMS usa il MODELLO RELAZIONALE. In pratica, tabelle con intestazione, attributi e record (dati). Servono quindi nome e struttura per la tabella, e tutti i dati devono essere omogenei a livello di struttura. Distinguo quindi\n\n- Aspetto INTENSIONALE, nomi e strutture delle tabelle (che non si modificano);\n- Aspetto ESTENISONALE, i dati che memorizzo nelle tabelle (parte dinamica).\n"},
		{"id":"757ece01c4e7854b","type":"text","text":"# tabelle\n\n\nservono file aggiuntivi ausiliari (indici) che permettono di accedere velocemente al file principale\nsu ogni tabella posso costruire più indici (magari su campi diversi)\n\nindici sono contenuti in altri file\n\nil linguaggio mette a disposizione dei tipi e delle operazioni sui tipi, ad esempio il tipo data ha metodi per estrarre giorno, mese e ora\n\nun'istanza vuota non può violare alcuna dipendenza funzionale, quindi è sempre \"buona\". per poter violare una regola deve contenere almeno due tuple! infatti molte dimostrazioni di BDD si mettono nel caso non restrittivo di istanza a due tuple. se rispetto tutte le dipendenze funzionali mi chiamo istanza LEGALE.\n","x":-3840,"y":1931,"width":816,"height":395},
		{"id":"d978bd83e81a4684","type":"text","text":"# Glossario illogico del Modello Relazionale I\n\nIl modello relazionale fa casino con i nomi. Vediamo di capirci qualcosa.\n\n- **_Entità_** - Schematizzazione logica dell'oggetto di interesse da memorizzare;\n- **_Attributi_** - Caratteristiche che definiscono l'entità, sono associati a un **_dominio_** di valori che gli possono essere assegnati (e.g. gli attributi `colore`, `marca` e `modello` possono essere attributi che definiscono l'entità `macchina`, e non posso scegliere il valore `15` per l'attributo `colore` perché sono fuori dal suo dominio);\n- **_Campo_** - A volte usato come sinonimo di attributo, può riferirsi allo specifico  valore assegnatogli (e.g. il campo dell'attributo `colore` può essere `rosso`);\n- **_Record (Tupla)_** - Un set di campi $\\Rightarrow$ uno specifico set di valori assegnati agli attributi che in pratica definisce un'entita o una relazione (*relationship*);\n- **_Istanza ($r$)_** - Un insieme di tuple omogenee ($\\Rightarrow$ aventi tutte gli stessi attributi) a cui è associato un nome (e.g. `nome = studente` e tuple i cui campi sono i valori di `nome`, `cognome` e `matricola`). Usato talvolta per indicare una singola tupla (e.g. un'istanza specifica all'interno di una tabella);\n- **_Tabella_** - Implementazione effettiva delle istanze: le istanze sono rappresentate mediante tabelle;\n- **_Relazione_** - Termine in cui collassano due distinti termini inglesi:\n\t- **_Relation_** - Usato come sinonimo di Istanza e Tabella;\n\t- **_Relationship_** - Si riferisce a una connessione logica tra tabelle (e.g. se due tabelle rappresentano le entità `studenti` e `corsi`, `esame` è una *relationship* che associa un elemento `studente` a un elemento `corso`, potenzialmente aggiungendo l'informazione `voto`). Il guaio è che una *relationship* è a sua volta una *relation* (perché poi ovviamente questa informazione viene implementata come tabella), quindi in italiano si usa *relazione* dando per scontato tutto questo buco nero di significati.\n- **_Schema ($R$)_** - L'inseme di tutti e soli gli attributi e del nome della relazione (e.g. `nome = studente` e attributi `nome`, `cognome` e `matricola` sono lo schema della relazione). Si può dire che un'istanza è una tabella riempita secondo il suo schema. A rigore nello schema rientrano anche i tipi e i domini degli attributi (e.g. `matricola` è un intero positivo), nonché le **_chiavi_**, i _**vincoli d'integrità**_, ... \n","x":-2320,"y":2386,"width":880,"height":767,"color":"4"},
		{"id":"eba6d491c9cfc3d3","type":"text","text":"# MODELLO RELAZIONALE\n\nSi basa sul concetto di matematico di relazione e sui valori (niente oggetti, niente puntatori).\nUna RELAZIONE è un insieme di tuple omogenee, cioè definite sugli stessi attributi.\nDati n domini D_n (che possono essere interi, reali, date, stringhe, ore, personalizzato, ... spesso si usano tipi di dato astratti\npersonalizzati per mettere un vincolo sui possibili valori di quel campo), il loro prodotto cartesiano è ogni possibile tupla in cui\nd_i \\in D_i.\n\nESEMPIO\nSe D_1 = {a, b} e D_2 = {x, y, z} posso avere solo 6 tuple distinte. Un DB è un INSIEME, quindi ogni tupla compare una e una sola volta.\n\nUna relazione è un sottoinsieme del prodotto cartesiano dei domini.\n\n\t- Il GRADO di una relazione è il numero di domini (#colonne nella tabella);\n\t- La CARDINALITA' è il numero di tuple realizzabili (#righe nella tabella).\n\nRispetto alle tuple matematiche, le colonne delle tabelle hanno le ETICHETTE, quindi non devo rispettare per forza l'ordine\n(d_1, d_2, ...). Non ho più la relazione POSIZIONALE. L'etichetta dà la SEMANTICA al dato. Tutte le altre proprietà sono rispettate.\n\nTramite i valori definisco i collegamenti tra le tabelle. Se ad esempio ho una tabella con i codici dei corsi, non posso avere una\ntabella con i voti degli esami in cui compare un codice di corso non presente nell'altra tabella. Questo concetto prende il nome di\nVINCOLO DI INTEGRITA' REFERENZIALE. Si noti che differisce da un modello a puntatori, che farebbe direttamente riferimento al valore\ninserito nella prima tabella.\n\nSe devo inserire una riga, quanto mi costa la verifica che non ci sia già? O(n), ma posso migliorarlo? Sì, in due modi:\n\n\t- Introduco colonne privilegiate su cui effettuare i controlli. L'idea è che queste identifichino l'intera riga in modo univoco.\n\t\tAd esempio, in una tabella di studenti contenente nome, cognome, data di nascita e numero di matricola sarà sufficiente\n\t\tcontrollare quest'ultima. In una tabella con matricola, esame e voto sarà necessario prendere le colonne matricola e corso,\n\t\tin quanto non è possibile avere due voti positivi allo stesso esame;\n\n\t- Introduco un ordinamento, e quindi faccio ricerca binaria.\n\nSe non conosco un dato è possibile far inserire al DBMS il valore NULL. Con questa cosa bisogna stare molto attenti:\n\n\t- Se il dato che non conosco appartiene a una colonna privilegiata, non è ammissibile;\n\t- Se non appartiene a una colonna privilegiata, posso decidere in fase di progettazione se consentire o meno il NULL.\n\nNel momento in cui inserisco NULL, però, non so se quel dato non è stato inserito perché\n\n\t- non lo conosco al momento, ma potrei conoscerlo in futuro;\n\t- non esiste, e quindi non potrò mai conoscerlo;\n\nDa un lato, se non permettessi di inserire dati parziali risulterei troppo rigido. Dall'altro, ogni NULL abbassa la qualità del DB.\nInoltre, ogni vincolo di integrità introdotto corrisponde a un costo di ricerca e verifica su una enorme mole di dati.\n\nI vincoli possono essere\n\n\t- INTRARELAZIONALI, ovvero interni alla stessa tabella, e si distinguono in\n\n\t\t- Vincoli di Tupla, che verificano l'intera riga. Possono essere sia verifiche sul singolo campo (es: un voto deve essere\n\t\t\tcompreso tra 0 e 30) sia tra campi diversi (es: il campo lode può assumere solo valori vero/falso, ma può essere vero\n\t\t\tsolo se voto è uguale a 30);\n\n\t\t- Vincoli di Chiave, che verificano solo le colonne privilegiate. Se una tabella è grande, fare avanti e indietro tra RAM\n\t\t\te HDD è scomodo. Allora posso costruire una tabella più snella costituita dalle sole chiavi. Una SUPERCHIAVE è un\n\t\t\tinsieme di attributi al cui interno c'è una chiave. Segue che una chiave è una superchiave minimale. Non è detto che\n\t\t\tla chiave sia unica. Il MAX è il numero di attributi. In definitiva, il Vincolo di Chiave è un'asserzione che specifica\n\t\t\tche un insieme di attributi forma una chiave per una relazione. Se ho una relazione R(A, B, C, D), dichiarare un Vincolo\n\t\t\tdi Chiave su {A, B} significa dire che in R non possono esistere due tuple che coincidano negli attributi A e B.\n\t\t\tInoltre, incidentalmente, sto anche dicendo che nessun sottoinsieme di {A, B} è una chiave. Si noti che la tupla di per\n\t\t\tsé sarebbe una chiave (essendo un insieme), ma a livello pratico risulta un po' troppo lunga. Ogni tabella ha una e una\n\t\t\tsola CHIAVE PRIMARIA, per la quale non ha senso ammettere valori nulli (in tabella, si indica sottolineando l'intestazione\n\t\t\tdel campo), e poi opzionalmente N chiavi secondarie. L'importante, comunque, è che la tupla sia identificabile: vieto valori\n\t\t\tnulli in almeno una chiave (la primaria).\n\n\t- INTERRELAZIONALI, tra tabelle diverse\n\n\t\t- Vincoli di Integrità Referenziale (o di Foreign Key), lavora sulla chiave primaria di una tabella di riferimento. In particolare,\n\t\t\tdata la tabella R_1 e il suo campo X non chiave, il Vincolo di Integrità Refernziale impone che ogni valore che compare in X\n\t\t\tcompaia anche nel campo chiave Y della tabella R_2. Detta in modo diverso, l'insieme dei valori del campo REFERENZIANTE sono\n\t\t\tun sottoinsieme dell'insieme dei valori del campo REFERENZIATO.\n\nE'importante notare che è sempre meglio evitare campi ridondanti. Segue esempio.\n\n\tR_1 è una tabella di infrazioni stradali. I campi sono codice infrazione, data, matricola vigile, provincia, numero verbale. C'è\n\tun vincolo di foreign key sulla tabella dei vigili, R_2, che contiene matricola vigile (chiave primaria, quindi campo referenziato\n\tdall'omonimo referenziante di R_1), cognome e nome. Se nella tabella infrazioni volessi inserire il cognome del vigile (quindi un'\n\tinformazione ridondante) potrei effettuare un altro controllo di tipo foreign key sul cognome di R_2, ma è importante notare che\n\ti due vincoli sono indipendenti. Di conseguenza, potrei inserire in input di R_1 lo stesso codice vigile associato a due cognomi\n\tdiversi, e per i vincoli andrebbe bene. Porterebbe chiaramente a un'inconsistenza del DB.\n\n\t\t- Per ovviare al problema volendo mantenere il cognome dovrei usare la coppia, ma tecnicamente è più difficile da implementare.\n\t\t- In generale nella stessa tabella possono esserci più referenzianti.\n\nUn'istanza che rispetta tutti i vincoli è detta LEGALE. Un modo per assicurarsi che l'utente immetta in input una stringa corretta,\nè impostare una GUI per farlo scegliere tra i valori ammissibili piuttosto che lasciarlo libero di scrivere. Ad esempio, se voglio\nprenotare un aereo non è l'utente a immettere la data, ma sceglie dal calendario. Meglio prevenire che verificare.\n\nCosa succede se ho R con Squadra1 Squadra2 e Risultato? Qual è la chiave primaria? Squadra1 Squadra2. E se possono incontrarsi un\nnumero indefinito di volte? Ho diverse opzioni:\n\n\t- Aggiungo un attributo che funge da chiave primaria, come un codice partita;\n\t- Aggiungo un attributo che unito alla vecchia chiave primaria mi dia la nuova chiave primaria. Se ad esempio so che nella stessa\n\t\tdata due squadre si possono incontrare solo una volta, Sq1 Sq2 Data è la chiave primaria.\n\nNULL è un valore compatibile col foreign key. Mettere troppi vincoli può portare all'impossibilità di trovare una tupla che li\nsoddisfi tutti. Oltretutto, ognuno di essi introduce rallentamenti. Infine, se elimino una tupla referenziata potrebbero succedere\ndisastri. Vedremo dopo come ovviare a questi problemi.\n\n\nIn SQL NON ESISTE L'IF!! Devo gestirmela solo con la logica booleana. Questo potrebbe rendere particolarmente inefficienti alcuni\ntipi di verifiche, così come ","x":-3180,"y":3600,"width":1275,"height":2520},
		{"id":"8c9fae17850cb60e","type":"text","text":"# Vincoli Relazionali","x":1184,"y":3688,"width":336,"height":50,"color":"6"},
		{"id":"21febace8b459e12","type":"text","text":"# DBMS Relazionali (RDBMS)","x":792,"y":2078,"width":456,"height":50,"color":"6"},
		{"id":"9988826790f856a8","type":"text","text":"# Come è fatto un RDBMS?\n\nIl DBMS si struttura tipicamente a più livelli.\n\n- **_Livello dei Dati (Schema Interno):_** livello a cui opera il DBMS in senso stretto. Include\n\t- gestione dello spazio su HDD e RAM. All'avvio il DBMS occupa una certa porzione di memoria (stabilita come stima massimale da chi lo ha progettato) che diventa inaccessibile per qualsiasi altra applicazione;\n\t- Gestione dei buffer, ovvero spostamento dei dati tra RAM e HDD;\n\t- Accesso ai dati fisici;\n\t- Operatori relazionali e di ottimizzazione ed esecuzione delle interrogazioni, *layer* che rendono le richieste quanto più veloci possibile;\n- **_Livello della Logica dell'Applicazione (Schema Logico):_** livello a cui operano le applicazioni utilizzate dagli utenti. Scambia dati con il DB e riceve input dall'interfaccia utente. Questi appunti sono riferiti allo Schema Logico del DBMS;\n- **_Livello della Presentazione (Schema Esterno):_** Spesso una certa categoria di utenti può accedere solo a uno schema esterno del DB, ovvero una rappresentazione del DB indipendente dal DB, senza sapere che esistono altri schemi e dati. Questo garantisce anche un layer di sicurezza. Si dice **_vista_** degli utenti, e se ne possono implementare molteplici, a seconda degli utenti a cui è destinata (e.g. se sono uno studente non vedrò gli stessi dati che vede un professore, ma il DB a cui facciamo riferimento è lo stesso). Spesso la vista è generata con delle query (e.g. *join*) che partono quando viene fatta richiesta dall'utente. Le tabelle visualizzate in questo livello possono quindi non rispettare la Terza Forma Normale, ma va tutto bene perché sono figlie di manipolazioni esterne al DB.\n\n\n","x":1634,"y":1759,"width":760,"height":688,"color":"3"},
		{"id":"0570e36ad1c1366b","type":"text","text":"# SQL","x":1634,"y":2746,"width":140,"height":50,"color":"6"},
		{"id":"a2b5fda883cdac87","type":"text","text":"# Algebra Relazionale\n\nnon ha primitive di definizione e inizializzazione perché è un linguaggio astratto e non concreto (...)\n\nsql esistono i comandi perché è la sua implementazione","x":32,"y":3380,"width":497,"height":333},
		{"id":"1fe2b64d43eb657f","type":"text","text":"qui si fanno solo vincoli intrarelazionali, ovvero dentro la stessa relazione, non interrelazionali\n\n\nlei specifica \n\n- uno studente risiede in una sola città (dipendenze funzionali)\n- la matricola identifica univocamente uno studente (vincoli di chiave)\n- un voto è un intero positivo compreso tra 18 e 30 (vincoli di dominio)\n- lo straordinario di un impiegato è dato dal prodotto del numero di ore per la paga oraria; lo stipendio di un impiegato non può diminuire (vincoli dinamici cioè del mio sistema specifico)","x":-1820,"y":4860,"width":600,"height":600},
		{"id":"e0feb6d8be39ba85","x":1520,"y":5160,"width":3163,"height":1490,"color":"1","type":"text","text":"# Resume L 3 M 50"}
	],
	"edges":[
		{"id":"8244132c0918415c","fromNode":"a5db58697c7e9975","fromSide":"bottom","toNode":"b1a5285caeae4130","toSide":"top"},
		{"id":"53615e184984119f","fromNode":"9af72174f7185470","fromSide":"right","toNode":"26a4c1c0b1aebc3f","toSide":"left"},
		{"id":"04199cd57310519f","fromNode":"a5db58697c7e9975","fromSide":"right","toNode":"186012183c3f3ecd","toSide":"left"},
		{"id":"605a908ff8a064ac","fromNode":"a5db58697c7e9975","fromSide":"right","toNode":"110d5abbb0f74fea","toSide":"left"},
		{"id":"00164a5b40b396d1","fromNode":"50686229090c1bd0","fromSide":"right","toNode":"a5db58697c7e9975","toSide":"left"},
		{"id":"1d0c6513134fc948","fromNode":"a5db58697c7e9975","fromSide":"left","toNode":"50686229090c1bd0","toSide":"right"},
		{"id":"dfc5c734b7cb48f2","fromNode":"9f75da23c1fde580","fromSide":"right","toNode":"9ac131662f9a9040","toSide":"left"},
		{"id":"9b0d1ead3aa7310b","fromNode":"b1a5285caeae4130","fromSide":"left","toNode":"8fc1cdfff9089b77","toSide":"right"},
		{"id":"48f8f73bdfd86030","fromNode":"b1a5285caeae4130","fromSide":"left","toNode":"9d076c174e423d23","toSide":"right"},
		{"id":"19e88f46a476f090","fromNode":"26a4c1c0b1aebc3f","fromSide":"bottom","toNode":"50686229090c1bd0","toSide":"top"},
		{"id":"229eb5d723375f71","fromNode":"8fc1cdfff9089b77","fromSide":"bottom","toNode":"9d076c174e423d23","toSide":"top"},
		{"id":"8baeaf8c4952ce52","fromNode":"50686229090c1bd0","fromSide":"bottom","toNode":"b1a5285caeae4130","toSide":"top"},
		{"id":"f9b645531807fe60","fromNode":"50686229090c1bd0","fromSide":"left","toNode":"e62ff9ade2624375","toSide":"right"},
		{"id":"91bacaaa988bdc03","fromNode":"8fc1cdfff9089b77","fromSide":"top","toNode":"e62ff9ade2624375","toSide":"bottom"},
		{"id":"e1f50179b1ccf9c5","fromNode":"26a4c1c0b1aebc3f","fromSide":"right","toNode":"a5db58697c7e9975","toSide":"top"},
		{"id":"b366dee568d9bd2e","fromNode":"21febace8b459e12","fromSide":"right","toNode":"9988826790f856a8","toSide":"left"},
		{"id":"f3aee058f7397368","fromNode":"9d076c174e423d23","fromSide":"left","toNode":"96639327a802451a","toSide":"right"},
		{"id":"b4d5cb3dff300167","fromNode":"0570e36ad1c1366b","fromSide":"right","toNode":"e0ca754560103232","toSide":"left"},
		{"id":"422282514c311e0a","fromNode":"23afcf5b45f8bffc","fromSide":"right","toNode":"21febace8b459e12","toSide":"bottom"},
		{"id":"461f990d862f1ac8","fromNode":"b1a5285caeae4130","fromSide":"right","toNode":"23afcf5b45f8bffc","toSide":"top"},
		{"id":"4d3ee1e2315cd110","fromNode":"b1a5285caeae4130","fromSide":"left","toNode":"d978bd83e81a4684","toSide":"right"},
		{"id":"89dad3d121d78a11","fromNode":"9d076c174e423d23","fromSide":"bottom","toNode":"d978bd83e81a4684","toSide":"top"},
		{"id":"59f9bd3afb208faf","fromNode":"21febace8b459e12","fromSide":"bottom","toNode":"0570e36ad1c1366b","toSide":"left"}
	]
}